
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model auditoria
 * 
 */
export type auditoria = {
  action: string | null
  usuario: number | null
  data: Date | null
  modulo: string | null
  id: number
}

/**
 * Model bordero
 * 
 */
export type bordero = {
  id: number
  carteira_id: number
}

/**
 * Model carteira
 * 
 */
export type carteira = {
  id: number
  fiduc_fundo_id: number
}

/**
 * Model cedente
 * 
 */
export type cedente = {
  id: number
  pessoa_id: number
  razao_social: string
  nome_fantasia: string | null
  abertura: Date | null
  cnpj: string | null
  endereco: string | null
  numero: string | null
  cep: string | null
  bairro: string | null
  cidade: string | null
  uf: string | null
  telefone: string | null
}

/**
 * Model cedente_analise
 * 
 */
export type cedente_analise = {
  id: number
  status: string | null
  cedente: number | null
}

/**
 * Model cedente_n_sacados
 * 
 */
export type cedente_n_sacados = {
  id: number
  cedente: number | null
  sacado: number | null
}

/**
 * Model checagem
 * 
 */
export type checagem = {
  id: number
  nf: string | null
  status: string | null
  usuario: number | null
  titulos: string | null
}

/**
 * Model fidic_fundo
 * 
 */
export type fidic_fundo = {
  id: number
  pessoa_id: number
  razao_social: string
  nome_fantasia: string | null
  abertura: Date | null
  cnpj: string | null
}

/**
 * Model fidic_fundo_carteira_n_cedentes
 * 
 */
export type fidic_fundo_carteira_n_cedentes = {
  id: number
}

/**
 * Model fidic_fundo_x_usuario
 * 
 */
export type fidic_fundo_x_usuario = {
  id: number
  usuario: number | null
  fidic: number
}

/**
 * Model organograma
 * 
 */
export type organograma = {
  id: number
}

/**
 * Model organograma_tipo
 * 
 */
export type organograma_tipo = {
  id: number
  nome: string
}

/**
 * Model organograma_x_regiao
 * 
 */
export type organograma_x_regiao = {
  id: number
  organograma_id: number
  regiao_id: number
}

/**
 * Model organograma_x_regiao_atuacao
 * 
 */
export type organograma_x_regiao_atuacao = {
  id: number
  organograma_id: number
  regiao_id: number
}

/**
 * Model pessoa
 * 
 */
export type pessoa = {
  id: number
  nome: string
  sobrenome: string
  sexo: string | null
  nascimento: Date | null
  cpf: string | null
  rg: string | null
}

/**
 * Model plataforma
 * 
 */
export type plataforma = {
  id: number
  nome: string | null
}

/**
 * Model plataforma_n_borderos
 * 
 */
export type plataforma_n_borderos = {
  id: number
}

/**
 * Model plataforma_papel_tipo
 * 
 */
export type plataforma_papel_tipo = {
  id: number
}

/**
 * Model plataforma_papel_x_pessoa
 * 
 */
export type plataforma_papel_x_pessoa = {
  id: number
}

/**
 * Model plataforma_x_regiao_atuacao
 * 
 */
export type plataforma_x_regiao_atuacao = {
  id: number
}

/**
 * Model regiao_atuacao
 * 
 */
export type regiao_atuacao = {
  id: number
  nome: string
}

/**
 * Model regiao_atuacao_tipo
 * 
 */
export type regiao_atuacao_tipo = {
  id: number
  nome: string
}

/**
 * Model sacado
 * 
 */
export type sacado = {
  id: number
  pessoa_id: number
  razao_social: string
  nome_fantasia: string | null
  abertura: Date | null
  cnpj: string | null
}

/**
 * Model titulo
 * 
 */
export type titulo = {
  id: number
  titulo_tipo_id: number
  bordero_id: number
  nf: string | null
  valor: number | null
  vencimento: Date | null
  numero: string | null
  emissao: Date | null
  parcela: string | null
}

/**
 * Model titulo_tipo
 * 
 */
export type titulo_tipo = {
  id: number
  nome: string | null
}

/**
 * Model titulo_x_cedente
 * 
 */
export type titulo_x_cedente = {
  id: number
  cedente: number
}

/**
 * Model titulo_x_empresa
 * 
 */
export type titulo_x_empresa = {
  id: number
}

/**
 * Model titulo_x_plataforma
 * 
 */
export type titulo_x_plataforma = {
  id: number
}

/**
 * Model titulos_x_usuario
 * 
 */
export type titulos_x_usuario = {
  id: number
  usuario: number | null
  bordero: number | null
  status: string | null
}

/**
 * Model usuario
 * 
 */
export type usuario = {
  id: number
  email: string
  senha: string
  pessoa_id: number
  status: string | null
  primeiro_acesso: boolean | null
  confirmou_cadastro: boolean | null
  codigo_confirma_cadastro: string | null
  codigo_reset_senha: string | null
  codigo_data_expiracao: Date | null
  created_at: Date
  updated_at: Date | null
}

/**
 * Model usuario__pessoa
 * 
 */
export type usuario__pessoa = {
  id: number
}

/**
 * Model usuario_n_borderos
 * 
 */
export type usuario_n_borderos = {
  id: number
}

/**
 * Model usuario_perfil_tipo
 * 
 */
export type usuario_perfil_tipo = {
  id: number
  nome: string
}

/**
 * Model usuario_x_perfil
 * 
 */
export type usuario_x_perfil = {
  id: number
  senha: string
  usuario_id: number
  usuario_perfil_id: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Auditorias
 * const auditorias = await prisma.auditoria.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Auditorias
   * const auditorias = await prisma.auditoria.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.auditoria`: Exposes CRUD operations for the **auditoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auditorias
    * const auditorias = await prisma.auditoria.findMany()
    * ```
    */
  get auditoria(): Prisma.auditoriaDelegate<GlobalReject>;

  /**
   * `prisma.bordero`: Exposes CRUD operations for the **bordero** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Borderos
    * const borderos = await prisma.bordero.findMany()
    * ```
    */
  get bordero(): Prisma.borderoDelegate<GlobalReject>;

  /**
   * `prisma.carteira`: Exposes CRUD operations for the **carteira** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carteiras
    * const carteiras = await prisma.carteira.findMany()
    * ```
    */
  get carteira(): Prisma.carteiraDelegate<GlobalReject>;

  /**
   * `prisma.cedente`: Exposes CRUD operations for the **cedente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cedentes
    * const cedentes = await prisma.cedente.findMany()
    * ```
    */
  get cedente(): Prisma.cedenteDelegate<GlobalReject>;

  /**
   * `prisma.cedente_analise`: Exposes CRUD operations for the **cedente_analise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cedente_analises
    * const cedente_analises = await prisma.cedente_analise.findMany()
    * ```
    */
  get cedente_analise(): Prisma.cedente_analiseDelegate<GlobalReject>;

  /**
   * `prisma.cedente_n_sacados`: Exposes CRUD operations for the **cedente_n_sacados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cedente_n_sacados
    * const cedente_n_sacados = await prisma.cedente_n_sacados.findMany()
    * ```
    */
  get cedente_n_sacados(): Prisma.cedente_n_sacadosDelegate<GlobalReject>;

  /**
   * `prisma.checagem`: Exposes CRUD operations for the **checagem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Checagems
    * const checagems = await prisma.checagem.findMany()
    * ```
    */
  get checagem(): Prisma.checagemDelegate<GlobalReject>;

  /**
   * `prisma.fidic_fundo`: Exposes CRUD operations for the **fidic_fundo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fidic_fundos
    * const fidic_fundos = await prisma.fidic_fundo.findMany()
    * ```
    */
  get fidic_fundo(): Prisma.fidic_fundoDelegate<GlobalReject>;

  /**
   * `prisma.fidic_fundo_carteira_n_cedentes`: Exposes CRUD operations for the **fidic_fundo_carteira_n_cedentes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fidic_fundo_carteira_n_cedentes
    * const fidic_fundo_carteira_n_cedentes = await prisma.fidic_fundo_carteira_n_cedentes.findMany()
    * ```
    */
  get fidic_fundo_carteira_n_cedentes(): Prisma.fidic_fundo_carteira_n_cedentesDelegate<GlobalReject>;

  /**
   * `prisma.fidic_fundo_x_usuario`: Exposes CRUD operations for the **fidic_fundo_x_usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fidic_fundo_x_usuarios
    * const fidic_fundo_x_usuarios = await prisma.fidic_fundo_x_usuario.findMany()
    * ```
    */
  get fidic_fundo_x_usuario(): Prisma.fidic_fundo_x_usuarioDelegate<GlobalReject>;

  /**
   * `prisma.organograma`: Exposes CRUD operations for the **organograma** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organogramas
    * const organogramas = await prisma.organograma.findMany()
    * ```
    */
  get organograma(): Prisma.organogramaDelegate<GlobalReject>;

  /**
   * `prisma.organograma_tipo`: Exposes CRUD operations for the **organograma_tipo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organograma_tipos
    * const organograma_tipos = await prisma.organograma_tipo.findMany()
    * ```
    */
  get organograma_tipo(): Prisma.organograma_tipoDelegate<GlobalReject>;

  /**
   * `prisma.organograma_x_regiao`: Exposes CRUD operations for the **organograma_x_regiao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organograma_x_regiaos
    * const organograma_x_regiaos = await prisma.organograma_x_regiao.findMany()
    * ```
    */
  get organograma_x_regiao(): Prisma.organograma_x_regiaoDelegate<GlobalReject>;

  /**
   * `prisma.organograma_x_regiao_atuacao`: Exposes CRUD operations for the **organograma_x_regiao_atuacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organograma_x_regiao_atuacaos
    * const organograma_x_regiao_atuacaos = await prisma.organograma_x_regiao_atuacao.findMany()
    * ```
    */
  get organograma_x_regiao_atuacao(): Prisma.organograma_x_regiao_atuacaoDelegate<GlobalReject>;

  /**
   * `prisma.pessoa`: Exposes CRUD operations for the **pessoa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pessoas
    * const pessoas = await prisma.pessoa.findMany()
    * ```
    */
  get pessoa(): Prisma.pessoaDelegate<GlobalReject>;

  /**
   * `prisma.plataforma`: Exposes CRUD operations for the **plataforma** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plataformas
    * const plataformas = await prisma.plataforma.findMany()
    * ```
    */
  get plataforma(): Prisma.plataformaDelegate<GlobalReject>;

  /**
   * `prisma.plataforma_n_borderos`: Exposes CRUD operations for the **plataforma_n_borderos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plataforma_n_borderos
    * const plataforma_n_borderos = await prisma.plataforma_n_borderos.findMany()
    * ```
    */
  get plataforma_n_borderos(): Prisma.plataforma_n_borderosDelegate<GlobalReject>;

  /**
   * `prisma.plataforma_papel_tipo`: Exposes CRUD operations for the **plataforma_papel_tipo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plataforma_papel_tipos
    * const plataforma_papel_tipos = await prisma.plataforma_papel_tipo.findMany()
    * ```
    */
  get plataforma_papel_tipo(): Prisma.plataforma_papel_tipoDelegate<GlobalReject>;

  /**
   * `prisma.plataforma_papel_x_pessoa`: Exposes CRUD operations for the **plataforma_papel_x_pessoa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plataforma_papel_x_pessoas
    * const plataforma_papel_x_pessoas = await prisma.plataforma_papel_x_pessoa.findMany()
    * ```
    */
  get plataforma_papel_x_pessoa(): Prisma.plataforma_papel_x_pessoaDelegate<GlobalReject>;

  /**
   * `prisma.plataforma_x_regiao_atuacao`: Exposes CRUD operations for the **plataforma_x_regiao_atuacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plataforma_x_regiao_atuacaos
    * const plataforma_x_regiao_atuacaos = await prisma.plataforma_x_regiao_atuacao.findMany()
    * ```
    */
  get plataforma_x_regiao_atuacao(): Prisma.plataforma_x_regiao_atuacaoDelegate<GlobalReject>;

  /**
   * `prisma.regiao_atuacao`: Exposes CRUD operations for the **regiao_atuacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regiao_atuacaos
    * const regiao_atuacaos = await prisma.regiao_atuacao.findMany()
    * ```
    */
  get regiao_atuacao(): Prisma.regiao_atuacaoDelegate<GlobalReject>;

  /**
   * `prisma.regiao_atuacao_tipo`: Exposes CRUD operations for the **regiao_atuacao_tipo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regiao_atuacao_tipos
    * const regiao_atuacao_tipos = await prisma.regiao_atuacao_tipo.findMany()
    * ```
    */
  get regiao_atuacao_tipo(): Prisma.regiao_atuacao_tipoDelegate<GlobalReject>;

  /**
   * `prisma.sacado`: Exposes CRUD operations for the **sacado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sacados
    * const sacados = await prisma.sacado.findMany()
    * ```
    */
  get sacado(): Prisma.sacadoDelegate<GlobalReject>;

  /**
   * `prisma.titulo`: Exposes CRUD operations for the **titulo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Titulos
    * const titulos = await prisma.titulo.findMany()
    * ```
    */
  get titulo(): Prisma.tituloDelegate<GlobalReject>;

  /**
   * `prisma.titulo_tipo`: Exposes CRUD operations for the **titulo_tipo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Titulo_tipos
    * const titulo_tipos = await prisma.titulo_tipo.findMany()
    * ```
    */
  get titulo_tipo(): Prisma.titulo_tipoDelegate<GlobalReject>;

  /**
   * `prisma.titulo_x_cedente`: Exposes CRUD operations for the **titulo_x_cedente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Titulo_x_cedentes
    * const titulo_x_cedentes = await prisma.titulo_x_cedente.findMany()
    * ```
    */
  get titulo_x_cedente(): Prisma.titulo_x_cedenteDelegate<GlobalReject>;

  /**
   * `prisma.titulo_x_empresa`: Exposes CRUD operations for the **titulo_x_empresa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Titulo_x_empresas
    * const titulo_x_empresas = await prisma.titulo_x_empresa.findMany()
    * ```
    */
  get titulo_x_empresa(): Prisma.titulo_x_empresaDelegate<GlobalReject>;

  /**
   * `prisma.titulo_x_plataforma`: Exposes CRUD operations for the **titulo_x_plataforma** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Titulo_x_plataformas
    * const titulo_x_plataformas = await prisma.titulo_x_plataforma.findMany()
    * ```
    */
  get titulo_x_plataforma(): Prisma.titulo_x_plataformaDelegate<GlobalReject>;

  /**
   * `prisma.titulos_x_usuario`: Exposes CRUD operations for the **titulos_x_usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Titulos_x_usuarios
    * const titulos_x_usuarios = await prisma.titulos_x_usuario.findMany()
    * ```
    */
  get titulos_x_usuario(): Prisma.titulos_x_usuarioDelegate<GlobalReject>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.usuarioDelegate<GlobalReject>;

  /**
   * `prisma.usuario__pessoa`: Exposes CRUD operations for the **usuario__pessoa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuario__pessoas
    * const usuario__pessoas = await prisma.usuario__pessoa.findMany()
    * ```
    */
  get usuario__pessoa(): Prisma.usuario__pessoaDelegate<GlobalReject>;

  /**
   * `prisma.usuario_n_borderos`: Exposes CRUD operations for the **usuario_n_borderos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuario_n_borderos
    * const usuario_n_borderos = await prisma.usuario_n_borderos.findMany()
    * ```
    */
  get usuario_n_borderos(): Prisma.usuario_n_borderosDelegate<GlobalReject>;

  /**
   * `prisma.usuario_perfil_tipo`: Exposes CRUD operations for the **usuario_perfil_tipo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuario_perfil_tipos
    * const usuario_perfil_tipos = await prisma.usuario_perfil_tipo.findMany()
    * ```
    */
  get usuario_perfil_tipo(): Prisma.usuario_perfil_tipoDelegate<GlobalReject>;

  /**
   * `prisma.usuario_x_perfil`: Exposes CRUD operations for the **usuario_x_perfil** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuario_x_perfils
    * const usuario_x_perfils = await prisma.usuario_x_perfil.findMany()
    * ```
    */
  get usuario_x_perfil(): Prisma.usuario_x_perfilDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.6.1
   * Query Engine version: 272861e07ab64f234d3ffc4094e32bd61775599c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    auditoria: 'auditoria',
    bordero: 'bordero',
    carteira: 'carteira',
    cedente: 'cedente',
    cedente_analise: 'cedente_analise',
    cedente_n_sacados: 'cedente_n_sacados',
    checagem: 'checagem',
    fidic_fundo: 'fidic_fundo',
    fidic_fundo_carteira_n_cedentes: 'fidic_fundo_carteira_n_cedentes',
    fidic_fundo_x_usuario: 'fidic_fundo_x_usuario',
    organograma: 'organograma',
    organograma_tipo: 'organograma_tipo',
    organograma_x_regiao: 'organograma_x_regiao',
    organograma_x_regiao_atuacao: 'organograma_x_regiao_atuacao',
    pessoa: 'pessoa',
    plataforma: 'plataforma',
    plataforma_n_borderos: 'plataforma_n_borderos',
    plataforma_papel_tipo: 'plataforma_papel_tipo',
    plataforma_papel_x_pessoa: 'plataforma_papel_x_pessoa',
    plataforma_x_regiao_atuacao: 'plataforma_x_regiao_atuacao',
    regiao_atuacao: 'regiao_atuacao',
    regiao_atuacao_tipo: 'regiao_atuacao_tipo',
    sacado: 'sacado',
    titulo: 'titulo',
    titulo_tipo: 'titulo_tipo',
    titulo_x_cedente: 'titulo_x_cedente',
    titulo_x_empresa: 'titulo_x_empresa',
    titulo_x_plataforma: 'titulo_x_plataforma',
    titulos_x_usuario: 'titulos_x_usuario',
    usuario: 'usuario',
    usuario__pessoa: 'usuario__pessoa',
    usuario_n_borderos: 'usuario_n_borderos',
    usuario_perfil_tipo: 'usuario_perfil_tipo',
    usuario_x_perfil: 'usuario_x_perfil'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BorderoCountOutputType
   */


  export type BorderoCountOutputType = {
    titulo: number
    titulos_x_usuario: number
  }

  export type BorderoCountOutputTypeSelect = {
    titulo?: boolean
    titulos_x_usuario?: boolean
  }

  export type BorderoCountOutputTypeGetPayload<S extends boolean | null | undefined | BorderoCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BorderoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BorderoCountOutputTypeArgs)
    ? BorderoCountOutputType 
    : S extends { select: any } & (BorderoCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof BorderoCountOutputType ? BorderoCountOutputType[P] : never
  } 
      : BorderoCountOutputType




  // Custom InputTypes

  /**
   * BorderoCountOutputType without action
   */
  export type BorderoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BorderoCountOutputType
     * 
    **/
    select?: BorderoCountOutputTypeSelect | null
  }



  /**
   * Count Type CedenteCountOutputType
   */


  export type CedenteCountOutputType = {
    cedente_analise: number
    cedente_n_sacados: number
    titulo_x_cedente: number
  }

  export type CedenteCountOutputTypeSelect = {
    cedente_analise?: boolean
    cedente_n_sacados?: boolean
    titulo_x_cedente?: boolean
  }

  export type CedenteCountOutputTypeGetPayload<S extends boolean | null | undefined | CedenteCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CedenteCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CedenteCountOutputTypeArgs)
    ? CedenteCountOutputType 
    : S extends { select: any } & (CedenteCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CedenteCountOutputType ? CedenteCountOutputType[P] : never
  } 
      : CedenteCountOutputType




  // Custom InputTypes

  /**
   * CedenteCountOutputType without action
   */
  export type CedenteCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CedenteCountOutputType
     * 
    **/
    select?: CedenteCountOutputTypeSelect | null
  }



  /**
   * Count Type Fidic_fundoCountOutputType
   */


  export type Fidic_fundoCountOutputType = {
    carteira: number
    fidic_fundo_x_usuario: number
  }

  export type Fidic_fundoCountOutputTypeSelect = {
    carteira?: boolean
    fidic_fundo_x_usuario?: boolean
  }

  export type Fidic_fundoCountOutputTypeGetPayload<S extends boolean | null | undefined | Fidic_fundoCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Fidic_fundoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Fidic_fundoCountOutputTypeArgs)
    ? Fidic_fundoCountOutputType 
    : S extends { select: any } & (Fidic_fundoCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Fidic_fundoCountOutputType ? Fidic_fundoCountOutputType[P] : never
  } 
      : Fidic_fundoCountOutputType




  // Custom InputTypes

  /**
   * Fidic_fundoCountOutputType without action
   */
  export type Fidic_fundoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Fidic_fundoCountOutputType
     * 
    **/
    select?: Fidic_fundoCountOutputTypeSelect | null
  }



  /**
   * Count Type PessoaCountOutputType
   */


  export type PessoaCountOutputType = {
    usuario: number
  }

  export type PessoaCountOutputTypeSelect = {
    usuario?: boolean
  }

  export type PessoaCountOutputTypeGetPayload<S extends boolean | null | undefined | PessoaCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PessoaCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PessoaCountOutputTypeArgs)
    ? PessoaCountOutputType 
    : S extends { select: any } & (PessoaCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PessoaCountOutputType ? PessoaCountOutputType[P] : never
  } 
      : PessoaCountOutputType




  // Custom InputTypes

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PessoaCountOutputType
     * 
    **/
    select?: PessoaCountOutputTypeSelect | null
  }



  /**
   * Count Type SacadoCountOutputType
   */


  export type SacadoCountOutputType = {
    cedente_n_sacados: number
  }

  export type SacadoCountOutputTypeSelect = {
    cedente_n_sacados?: boolean
  }

  export type SacadoCountOutputTypeGetPayload<S extends boolean | null | undefined | SacadoCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SacadoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SacadoCountOutputTypeArgs)
    ? SacadoCountOutputType 
    : S extends { select: any } & (SacadoCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SacadoCountOutputType ? SacadoCountOutputType[P] : never
  } 
      : SacadoCountOutputType




  // Custom InputTypes

  /**
   * SacadoCountOutputType without action
   */
  export type SacadoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SacadoCountOutputType
     * 
    **/
    select?: SacadoCountOutputTypeSelect | null
  }



  /**
   * Count Type Titulo_tipoCountOutputType
   */


  export type Titulo_tipoCountOutputType = {
    titulo: number
  }

  export type Titulo_tipoCountOutputTypeSelect = {
    titulo?: boolean
  }

  export type Titulo_tipoCountOutputTypeGetPayload<S extends boolean | null | undefined | Titulo_tipoCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Titulo_tipoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Titulo_tipoCountOutputTypeArgs)
    ? Titulo_tipoCountOutputType 
    : S extends { select: any } & (Titulo_tipoCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Titulo_tipoCountOutputType ? Titulo_tipoCountOutputType[P] : never
  } 
      : Titulo_tipoCountOutputType




  // Custom InputTypes

  /**
   * Titulo_tipoCountOutputType without action
   */
  export type Titulo_tipoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Titulo_tipoCountOutputType
     * 
    **/
    select?: Titulo_tipoCountOutputTypeSelect | null
  }



  /**
   * Count Type UsuarioCountOutputType
   */


  export type UsuarioCountOutputType = {
    auditoria: number
    checagem: number
    fidic_fundo_x_usuario: number
    titulos_x_usuario: number
    usuario_x_perfil: number
  }

  export type UsuarioCountOutputTypeSelect = {
    auditoria?: boolean
    checagem?: boolean
    fidic_fundo_x_usuario?: boolean
    titulos_x_usuario?: boolean
    usuario_x_perfil?: boolean
  }

  export type UsuarioCountOutputTypeGetPayload<S extends boolean | null | undefined | UsuarioCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UsuarioCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UsuarioCountOutputTypeArgs)
    ? UsuarioCountOutputType 
    : S extends { select: any } & (UsuarioCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UsuarioCountOutputType ? UsuarioCountOutputType[P] : never
  } 
      : UsuarioCountOutputType




  // Custom InputTypes

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     * 
    **/
    select?: UsuarioCountOutputTypeSelect | null
  }



  /**
   * Count Type Usuario_perfil_tipoCountOutputType
   */


  export type Usuario_perfil_tipoCountOutputType = {
    usuario_x_perfil: number
  }

  export type Usuario_perfil_tipoCountOutputTypeSelect = {
    usuario_x_perfil?: boolean
  }

  export type Usuario_perfil_tipoCountOutputTypeGetPayload<S extends boolean | null | undefined | Usuario_perfil_tipoCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Usuario_perfil_tipoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Usuario_perfil_tipoCountOutputTypeArgs)
    ? Usuario_perfil_tipoCountOutputType 
    : S extends { select: any } & (Usuario_perfil_tipoCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Usuario_perfil_tipoCountOutputType ? Usuario_perfil_tipoCountOutputType[P] : never
  } 
      : Usuario_perfil_tipoCountOutputType




  // Custom InputTypes

  /**
   * Usuario_perfil_tipoCountOutputType without action
   */
  export type Usuario_perfil_tipoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Usuario_perfil_tipoCountOutputType
     * 
    **/
    select?: Usuario_perfil_tipoCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model auditoria
   */


  export type AggregateAuditoria = {
    _count: AuditoriaCountAggregateOutputType | null
    _avg: AuditoriaAvgAggregateOutputType | null
    _sum: AuditoriaSumAggregateOutputType | null
    _min: AuditoriaMinAggregateOutputType | null
    _max: AuditoriaMaxAggregateOutputType | null
  }

  export type AuditoriaAvgAggregateOutputType = {
    usuario: number | null
    id: number | null
  }

  export type AuditoriaSumAggregateOutputType = {
    usuario: number | null
    id: number | null
  }

  export type AuditoriaMinAggregateOutputType = {
    action: string | null
    usuario: number | null
    data: Date | null
    modulo: string | null
    id: number | null
  }

  export type AuditoriaMaxAggregateOutputType = {
    action: string | null
    usuario: number | null
    data: Date | null
    modulo: string | null
    id: number | null
  }

  export type AuditoriaCountAggregateOutputType = {
    action: number
    usuario: number
    data: number
    modulo: number
    id: number
    _all: number
  }


  export type AuditoriaAvgAggregateInputType = {
    usuario?: true
    id?: true
  }

  export type AuditoriaSumAggregateInputType = {
    usuario?: true
    id?: true
  }

  export type AuditoriaMinAggregateInputType = {
    action?: true
    usuario?: true
    data?: true
    modulo?: true
    id?: true
  }

  export type AuditoriaMaxAggregateInputType = {
    action?: true
    usuario?: true
    data?: true
    modulo?: true
    id?: true
  }

  export type AuditoriaCountAggregateInputType = {
    action?: true
    usuario?: true
    data?: true
    modulo?: true
    id?: true
    _all?: true
  }

  export type AuditoriaAggregateArgs = {
    /**
     * Filter which auditoria to aggregate.
     * 
    **/
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     * 
    **/
    orderBy?: Enumerable<auditoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auditorias
    **/
    _count?: true | AuditoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditoriaMaxAggregateInputType
  }

  export type GetAuditoriaAggregateType<T extends AuditoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditoria[P]>
      : GetScalarType<T[P], AggregateAuditoria[P]>
  }




  export type AuditoriaGroupByArgs = {
    where?: auditoriaWhereInput
    orderBy?: Enumerable<auditoriaOrderByWithAggregationInput>
    by: Array<AuditoriaScalarFieldEnum>
    having?: auditoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditoriaCountAggregateInputType | true
    _avg?: AuditoriaAvgAggregateInputType
    _sum?: AuditoriaSumAggregateInputType
    _min?: AuditoriaMinAggregateInputType
    _max?: AuditoriaMaxAggregateInputType
  }


  export type AuditoriaGroupByOutputType = {
    action: string | null
    usuario: number | null
    data: Date | null
    modulo: string | null
    id: number
    _count: AuditoriaCountAggregateOutputType | null
    _avg: AuditoriaAvgAggregateOutputType | null
    _sum: AuditoriaSumAggregateOutputType | null
    _min: AuditoriaMinAggregateOutputType | null
    _max: AuditoriaMaxAggregateOutputType | null
  }

  type GetAuditoriaGroupByPayload<T extends AuditoriaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AuditoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditoriaGroupByOutputType[P]>
            : GetScalarType<T[P], AuditoriaGroupByOutputType[P]>
        }
      >
    >


  export type auditoriaSelect = {
    action?: boolean
    usuario?: boolean
    data?: boolean
    modulo?: boolean
    id?: boolean
    usuario_auditoriaTousuario?: boolean | usuarioArgs
  }


  export type auditoriaInclude = {
    usuario_auditoriaTousuario?: boolean | usuarioArgs
  } 

  export type auditoriaGetPayload<S extends boolean | null | undefined | auditoriaArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? auditoria :
    S extends undefined ? never :
    S extends { include: any } & (auditoriaArgs | auditoriaFindManyArgs)
    ? auditoria  & {
    [P in TrueKeys<S['include']>]:
        P extends 'usuario_auditoriaTousuario' ? usuarioGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : S extends { select: any } & (auditoriaArgs | auditoriaFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'usuario_auditoriaTousuario' ? usuarioGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof auditoria ? auditoria[P] : never
  } 
      : auditoria


  type auditoriaCountArgs = Merge<
    Omit<auditoriaFindManyArgs, 'select' | 'include'> & {
      select?: AuditoriaCountAggregateInputType | true
    }
  >

  export interface auditoriaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Auditoria that matches the filter.
     * @param {auditoriaFindUniqueArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends auditoriaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, auditoriaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'auditoria'> extends True ? Prisma__auditoriaClient<auditoriaGetPayload<T>> : Prisma__auditoriaClient<auditoriaGetPayload<T> | null, null>

    /**
     * Find the first Auditoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaFindFirstArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends auditoriaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, auditoriaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'auditoria'> extends True ? Prisma__auditoriaClient<auditoriaGetPayload<T>> : Prisma__auditoriaClient<auditoriaGetPayload<T> | null, null>

    /**
     * Find zero or more Auditorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auditorias
     * const auditorias = await prisma.auditoria.findMany()
     * 
     * // Get first 10 Auditorias
     * const auditorias = await prisma.auditoria.findMany({ take: 10 })
     * 
     * // Only select the `action`
     * const auditoriaWithActionOnly = await prisma.auditoria.findMany({ select: { action: true } })
     * 
    **/
    findMany<T extends auditoriaFindManyArgs>(
      args?: SelectSubset<T, auditoriaFindManyArgs>
    ): PrismaPromise<Array<auditoriaGetPayload<T>>>

    /**
     * Create a Auditoria.
     * @param {auditoriaCreateArgs} args - Arguments to create a Auditoria.
     * @example
     * // Create one Auditoria
     * const Auditoria = await prisma.auditoria.create({
     *   data: {
     *     // ... data to create a Auditoria
     *   }
     * })
     * 
    **/
    create<T extends auditoriaCreateArgs>(
      args: SelectSubset<T, auditoriaCreateArgs>
    ): Prisma__auditoriaClient<auditoriaGetPayload<T>>

    /**
     * Create many Auditorias.
     *     @param {auditoriaCreateManyArgs} args - Arguments to create many Auditorias.
     *     @example
     *     // Create many Auditorias
     *     const auditoria = await prisma.auditoria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends auditoriaCreateManyArgs>(
      args?: SelectSubset<T, auditoriaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Auditoria.
     * @param {auditoriaDeleteArgs} args - Arguments to delete one Auditoria.
     * @example
     * // Delete one Auditoria
     * const Auditoria = await prisma.auditoria.delete({
     *   where: {
     *     // ... filter to delete one Auditoria
     *   }
     * })
     * 
    **/
    delete<T extends auditoriaDeleteArgs>(
      args: SelectSubset<T, auditoriaDeleteArgs>
    ): Prisma__auditoriaClient<auditoriaGetPayload<T>>

    /**
     * Update one Auditoria.
     * @param {auditoriaUpdateArgs} args - Arguments to update one Auditoria.
     * @example
     * // Update one Auditoria
     * const auditoria = await prisma.auditoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends auditoriaUpdateArgs>(
      args: SelectSubset<T, auditoriaUpdateArgs>
    ): Prisma__auditoriaClient<auditoriaGetPayload<T>>

    /**
     * Delete zero or more Auditorias.
     * @param {auditoriaDeleteManyArgs} args - Arguments to filter Auditorias to delete.
     * @example
     * // Delete a few Auditorias
     * const { count } = await prisma.auditoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends auditoriaDeleteManyArgs>(
      args?: SelectSubset<T, auditoriaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auditorias
     * const auditoria = await prisma.auditoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends auditoriaUpdateManyArgs>(
      args: SelectSubset<T, auditoriaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Auditoria.
     * @param {auditoriaUpsertArgs} args - Arguments to update or create a Auditoria.
     * @example
     * // Update or create a Auditoria
     * const auditoria = await prisma.auditoria.upsert({
     *   create: {
     *     // ... data to create a Auditoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auditoria we want to update
     *   }
     * })
    **/
    upsert<T extends auditoriaUpsertArgs>(
      args: SelectSubset<T, auditoriaUpsertArgs>
    ): Prisma__auditoriaClient<auditoriaGetPayload<T>>

    /**
     * Find one Auditoria that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {auditoriaFindUniqueOrThrowArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends auditoriaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, auditoriaFindUniqueOrThrowArgs>
    ): Prisma__auditoriaClient<auditoriaGetPayload<T>>

    /**
     * Find the first Auditoria that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaFindFirstOrThrowArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends auditoriaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, auditoriaFindFirstOrThrowArgs>
    ): Prisma__auditoriaClient<auditoriaGetPayload<T>>

    /**
     * Count the number of Auditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaCountArgs} args - Arguments to filter Auditorias to count.
     * @example
     * // Count the number of Auditorias
     * const count = await prisma.auditoria.count({
     *   where: {
     *     // ... the filter for the Auditorias we want to count
     *   }
     * })
    **/
    count<T extends auditoriaCountArgs>(
      args?: Subset<T, auditoriaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditoriaAggregateArgs>(args: Subset<T, AuditoriaAggregateArgs>): PrismaPromise<GetAuditoriaAggregateType<T>>

    /**
     * Group by Auditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditoriaGroupByArgs['orderBy'] }
        : { orderBy?: AuditoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditoriaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for auditoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__auditoriaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    usuario_auditoriaTousuario<T extends usuarioArgs= {}>(args?: Subset<T, usuarioArgs>): Prisma__usuarioClient<usuarioGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * auditoria base type for findUnique actions
   */
  export type auditoriaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the auditoria
     * 
    **/
    select?: auditoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: auditoriaInclude | null
    /**
     * Filter, which auditoria to fetch.
     * 
    **/
    where: auditoriaWhereUniqueInput
  }

  /**
   * auditoria: findUnique
   */
  export interface auditoriaFindUniqueArgs extends auditoriaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auditoria base type for findFirst actions
   */
  export type auditoriaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the auditoria
     * 
    **/
    select?: auditoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: auditoriaInclude | null
    /**
     * Filter, which auditoria to fetch.
     * 
    **/
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     * 
    **/
    orderBy?: Enumerable<auditoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditorias.
     * 
    **/
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditorias.
     * 
    **/
    distinct?: Enumerable<AuditoriaScalarFieldEnum>
  }

  /**
   * auditoria: findFirst
   */
  export interface auditoriaFindFirstArgs extends auditoriaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auditoria findMany
   */
  export type auditoriaFindManyArgs = {
    /**
     * Select specific fields to fetch from the auditoria
     * 
    **/
    select?: auditoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: auditoriaInclude | null
    /**
     * Filter, which auditorias to fetch.
     * 
    **/
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     * 
    **/
    orderBy?: Enumerable<auditoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auditorias.
     * 
    **/
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AuditoriaScalarFieldEnum>
  }


  /**
   * auditoria create
   */
  export type auditoriaCreateArgs = {
    /**
     * Select specific fields to fetch from the auditoria
     * 
    **/
    select?: auditoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: auditoriaInclude | null
    /**
     * The data needed to create a auditoria.
     * 
    **/
    data: XOR<auditoriaCreateInput, auditoriaUncheckedCreateInput>
  }


  /**
   * auditoria createMany
   */
  export type auditoriaCreateManyArgs = {
    /**
     * The data used to create many auditorias.
     * 
    **/
    data: Enumerable<auditoriaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * auditoria update
   */
  export type auditoriaUpdateArgs = {
    /**
     * Select specific fields to fetch from the auditoria
     * 
    **/
    select?: auditoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: auditoriaInclude | null
    /**
     * The data needed to update a auditoria.
     * 
    **/
    data: XOR<auditoriaUpdateInput, auditoriaUncheckedUpdateInput>
    /**
     * Choose, which auditoria to update.
     * 
    **/
    where: auditoriaWhereUniqueInput
  }


  /**
   * auditoria updateMany
   */
  export type auditoriaUpdateManyArgs = {
    /**
     * The data used to update auditorias.
     * 
    **/
    data: XOR<auditoriaUpdateManyMutationInput, auditoriaUncheckedUpdateManyInput>
    /**
     * Filter which auditorias to update
     * 
    **/
    where?: auditoriaWhereInput
  }


  /**
   * auditoria upsert
   */
  export type auditoriaUpsertArgs = {
    /**
     * Select specific fields to fetch from the auditoria
     * 
    **/
    select?: auditoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: auditoriaInclude | null
    /**
     * The filter to search for the auditoria to update in case it exists.
     * 
    **/
    where: auditoriaWhereUniqueInput
    /**
     * In case the auditoria found by the `where` argument doesn't exist, create a new auditoria with this data.
     * 
    **/
    create: XOR<auditoriaCreateInput, auditoriaUncheckedCreateInput>
    /**
     * In case the auditoria was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<auditoriaUpdateInput, auditoriaUncheckedUpdateInput>
  }


  /**
   * auditoria delete
   */
  export type auditoriaDeleteArgs = {
    /**
     * Select specific fields to fetch from the auditoria
     * 
    **/
    select?: auditoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: auditoriaInclude | null
    /**
     * Filter which auditoria to delete.
     * 
    **/
    where: auditoriaWhereUniqueInput
  }


  /**
   * auditoria deleteMany
   */
  export type auditoriaDeleteManyArgs = {
    /**
     * Filter which auditorias to delete
     * 
    **/
    where?: auditoriaWhereInput
  }


  /**
   * auditoria: findUniqueOrThrow
   */
  export type auditoriaFindUniqueOrThrowArgs = auditoriaFindUniqueArgsBase
      

  /**
   * auditoria: findFirstOrThrow
   */
  export type auditoriaFindFirstOrThrowArgs = auditoriaFindFirstArgsBase
      

  /**
   * auditoria without action
   */
  export type auditoriaArgs = {
    /**
     * Select specific fields to fetch from the auditoria
     * 
    **/
    select?: auditoriaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: auditoriaInclude | null
  }



  /**
   * Model bordero
   */


  export type AggregateBordero = {
    _count: BorderoCountAggregateOutputType | null
    _avg: BorderoAvgAggregateOutputType | null
    _sum: BorderoSumAggregateOutputType | null
    _min: BorderoMinAggregateOutputType | null
    _max: BorderoMaxAggregateOutputType | null
  }

  export type BorderoAvgAggregateOutputType = {
    id: number | null
    carteira_id: number | null
  }

  export type BorderoSumAggregateOutputType = {
    id: number | null
    carteira_id: number | null
  }

  export type BorderoMinAggregateOutputType = {
    id: number | null
    carteira_id: number | null
  }

  export type BorderoMaxAggregateOutputType = {
    id: number | null
    carteira_id: number | null
  }

  export type BorderoCountAggregateOutputType = {
    id: number
    carteira_id: number
    _all: number
  }


  export type BorderoAvgAggregateInputType = {
    id?: true
    carteira_id?: true
  }

  export type BorderoSumAggregateInputType = {
    id?: true
    carteira_id?: true
  }

  export type BorderoMinAggregateInputType = {
    id?: true
    carteira_id?: true
  }

  export type BorderoMaxAggregateInputType = {
    id?: true
    carteira_id?: true
  }

  export type BorderoCountAggregateInputType = {
    id?: true
    carteira_id?: true
    _all?: true
  }

  export type BorderoAggregateArgs = {
    /**
     * Filter which bordero to aggregate.
     * 
    **/
    where?: borderoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of borderos to fetch.
     * 
    **/
    orderBy?: Enumerable<borderoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: borderoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` borderos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` borderos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned borderos
    **/
    _count?: true | BorderoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BorderoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BorderoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BorderoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BorderoMaxAggregateInputType
  }

  export type GetBorderoAggregateType<T extends BorderoAggregateArgs> = {
        [P in keyof T & keyof AggregateBordero]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBordero[P]>
      : GetScalarType<T[P], AggregateBordero[P]>
  }




  export type BorderoGroupByArgs = {
    where?: borderoWhereInput
    orderBy?: Enumerable<borderoOrderByWithAggregationInput>
    by: Array<BorderoScalarFieldEnum>
    having?: borderoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BorderoCountAggregateInputType | true
    _avg?: BorderoAvgAggregateInputType
    _sum?: BorderoSumAggregateInputType
    _min?: BorderoMinAggregateInputType
    _max?: BorderoMaxAggregateInputType
  }


  export type BorderoGroupByOutputType = {
    id: number
    carteira_id: number
    _count: BorderoCountAggregateOutputType | null
    _avg: BorderoAvgAggregateOutputType | null
    _sum: BorderoSumAggregateOutputType | null
    _min: BorderoMinAggregateOutputType | null
    _max: BorderoMaxAggregateOutputType | null
  }

  type GetBorderoGroupByPayload<T extends BorderoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BorderoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BorderoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BorderoGroupByOutputType[P]>
            : GetScalarType<T[P], BorderoGroupByOutputType[P]>
        }
      >
    >


  export type borderoSelect = {
    id?: boolean
    carteira_id?: boolean
    titulo?: boolean | tituloFindManyArgs
    titulos_x_usuario?: boolean | titulos_x_usuarioFindManyArgs
    _count?: boolean | BorderoCountOutputTypeArgs
  }


  export type borderoInclude = {
    titulo?: boolean | tituloFindManyArgs
    titulos_x_usuario?: boolean | titulos_x_usuarioFindManyArgs
    _count?: boolean | BorderoCountOutputTypeArgs
  } 

  export type borderoGetPayload<S extends boolean | null | undefined | borderoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? bordero :
    S extends undefined ? never :
    S extends { include: any } & (borderoArgs | borderoFindManyArgs)
    ? bordero  & {
    [P in TrueKeys<S['include']>]:
        P extends 'titulo' ? Array < tituloGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'titulos_x_usuario' ? Array < titulos_x_usuarioGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? BorderoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (borderoArgs | borderoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'titulo' ? Array < tituloGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'titulos_x_usuario' ? Array < titulos_x_usuarioGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? BorderoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof bordero ? bordero[P] : never
  } 
      : bordero


  type borderoCountArgs = Merge<
    Omit<borderoFindManyArgs, 'select' | 'include'> & {
      select?: BorderoCountAggregateInputType | true
    }
  >

  export interface borderoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Bordero that matches the filter.
     * @param {borderoFindUniqueArgs} args - Arguments to find a Bordero
     * @example
     * // Get one Bordero
     * const bordero = await prisma.bordero.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends borderoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, borderoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'bordero'> extends True ? Prisma__borderoClient<borderoGetPayload<T>> : Prisma__borderoClient<borderoGetPayload<T> | null, null>

    /**
     * Find the first Bordero that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {borderoFindFirstArgs} args - Arguments to find a Bordero
     * @example
     * // Get one Bordero
     * const bordero = await prisma.bordero.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends borderoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, borderoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'bordero'> extends True ? Prisma__borderoClient<borderoGetPayload<T>> : Prisma__borderoClient<borderoGetPayload<T> | null, null>

    /**
     * Find zero or more Borderos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {borderoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Borderos
     * const borderos = await prisma.bordero.findMany()
     * 
     * // Get first 10 Borderos
     * const borderos = await prisma.bordero.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const borderoWithIdOnly = await prisma.bordero.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends borderoFindManyArgs>(
      args?: SelectSubset<T, borderoFindManyArgs>
    ): PrismaPromise<Array<borderoGetPayload<T>>>

    /**
     * Create a Bordero.
     * @param {borderoCreateArgs} args - Arguments to create a Bordero.
     * @example
     * // Create one Bordero
     * const Bordero = await prisma.bordero.create({
     *   data: {
     *     // ... data to create a Bordero
     *   }
     * })
     * 
    **/
    create<T extends borderoCreateArgs>(
      args: SelectSubset<T, borderoCreateArgs>
    ): Prisma__borderoClient<borderoGetPayload<T>>

    /**
     * Create many Borderos.
     *     @param {borderoCreateManyArgs} args - Arguments to create many Borderos.
     *     @example
     *     // Create many Borderos
     *     const bordero = await prisma.bordero.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends borderoCreateManyArgs>(
      args?: SelectSubset<T, borderoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Bordero.
     * @param {borderoDeleteArgs} args - Arguments to delete one Bordero.
     * @example
     * // Delete one Bordero
     * const Bordero = await prisma.bordero.delete({
     *   where: {
     *     // ... filter to delete one Bordero
     *   }
     * })
     * 
    **/
    delete<T extends borderoDeleteArgs>(
      args: SelectSubset<T, borderoDeleteArgs>
    ): Prisma__borderoClient<borderoGetPayload<T>>

    /**
     * Update one Bordero.
     * @param {borderoUpdateArgs} args - Arguments to update one Bordero.
     * @example
     * // Update one Bordero
     * const bordero = await prisma.bordero.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends borderoUpdateArgs>(
      args: SelectSubset<T, borderoUpdateArgs>
    ): Prisma__borderoClient<borderoGetPayload<T>>

    /**
     * Delete zero or more Borderos.
     * @param {borderoDeleteManyArgs} args - Arguments to filter Borderos to delete.
     * @example
     * // Delete a few Borderos
     * const { count } = await prisma.bordero.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends borderoDeleteManyArgs>(
      args?: SelectSubset<T, borderoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Borderos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {borderoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Borderos
     * const bordero = await prisma.bordero.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends borderoUpdateManyArgs>(
      args: SelectSubset<T, borderoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Bordero.
     * @param {borderoUpsertArgs} args - Arguments to update or create a Bordero.
     * @example
     * // Update or create a Bordero
     * const bordero = await prisma.bordero.upsert({
     *   create: {
     *     // ... data to create a Bordero
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bordero we want to update
     *   }
     * })
    **/
    upsert<T extends borderoUpsertArgs>(
      args: SelectSubset<T, borderoUpsertArgs>
    ): Prisma__borderoClient<borderoGetPayload<T>>

    /**
     * Find one Bordero that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {borderoFindUniqueOrThrowArgs} args - Arguments to find a Bordero
     * @example
     * // Get one Bordero
     * const bordero = await prisma.bordero.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends borderoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, borderoFindUniqueOrThrowArgs>
    ): Prisma__borderoClient<borderoGetPayload<T>>

    /**
     * Find the first Bordero that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {borderoFindFirstOrThrowArgs} args - Arguments to find a Bordero
     * @example
     * // Get one Bordero
     * const bordero = await prisma.bordero.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends borderoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, borderoFindFirstOrThrowArgs>
    ): Prisma__borderoClient<borderoGetPayload<T>>

    /**
     * Count the number of Borderos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {borderoCountArgs} args - Arguments to filter Borderos to count.
     * @example
     * // Count the number of Borderos
     * const count = await prisma.bordero.count({
     *   where: {
     *     // ... the filter for the Borderos we want to count
     *   }
     * })
    **/
    count<T extends borderoCountArgs>(
      args?: Subset<T, borderoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BorderoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bordero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorderoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BorderoAggregateArgs>(args: Subset<T, BorderoAggregateArgs>): PrismaPromise<GetBorderoAggregateType<T>>

    /**
     * Group by Bordero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorderoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BorderoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BorderoGroupByArgs['orderBy'] }
        : { orderBy?: BorderoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BorderoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBorderoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for bordero.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__borderoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    titulo<T extends tituloFindManyArgs= {}>(args?: Subset<T, tituloFindManyArgs>): PrismaPromise<Array<tituloGetPayload<T>>| Null>;

    titulos_x_usuario<T extends titulos_x_usuarioFindManyArgs= {}>(args?: Subset<T, titulos_x_usuarioFindManyArgs>): PrismaPromise<Array<titulos_x_usuarioGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * bordero base type for findUnique actions
   */
  export type borderoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the bordero
     * 
    **/
    select?: borderoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: borderoInclude | null
    /**
     * Filter, which bordero to fetch.
     * 
    **/
    where: borderoWhereUniqueInput
  }

  /**
   * bordero: findUnique
   */
  export interface borderoFindUniqueArgs extends borderoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * bordero base type for findFirst actions
   */
  export type borderoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the bordero
     * 
    **/
    select?: borderoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: borderoInclude | null
    /**
     * Filter, which bordero to fetch.
     * 
    **/
    where?: borderoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of borderos to fetch.
     * 
    **/
    orderBy?: Enumerable<borderoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for borderos.
     * 
    **/
    cursor?: borderoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` borderos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` borderos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of borderos.
     * 
    **/
    distinct?: Enumerable<BorderoScalarFieldEnum>
  }

  /**
   * bordero: findFirst
   */
  export interface borderoFindFirstArgs extends borderoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * bordero findMany
   */
  export type borderoFindManyArgs = {
    /**
     * Select specific fields to fetch from the bordero
     * 
    **/
    select?: borderoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: borderoInclude | null
    /**
     * Filter, which borderos to fetch.
     * 
    **/
    where?: borderoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of borderos to fetch.
     * 
    **/
    orderBy?: Enumerable<borderoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing borderos.
     * 
    **/
    cursor?: borderoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` borderos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` borderos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BorderoScalarFieldEnum>
  }


  /**
   * bordero create
   */
  export type borderoCreateArgs = {
    /**
     * Select specific fields to fetch from the bordero
     * 
    **/
    select?: borderoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: borderoInclude | null
    /**
     * The data needed to create a bordero.
     * 
    **/
    data: XOR<borderoCreateInput, borderoUncheckedCreateInput>
  }


  /**
   * bordero createMany
   */
  export type borderoCreateManyArgs = {
    /**
     * The data used to create many borderos.
     * 
    **/
    data: Enumerable<borderoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * bordero update
   */
  export type borderoUpdateArgs = {
    /**
     * Select specific fields to fetch from the bordero
     * 
    **/
    select?: borderoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: borderoInclude | null
    /**
     * The data needed to update a bordero.
     * 
    **/
    data: XOR<borderoUpdateInput, borderoUncheckedUpdateInput>
    /**
     * Choose, which bordero to update.
     * 
    **/
    where: borderoWhereUniqueInput
  }


  /**
   * bordero updateMany
   */
  export type borderoUpdateManyArgs = {
    /**
     * The data used to update borderos.
     * 
    **/
    data: XOR<borderoUpdateManyMutationInput, borderoUncheckedUpdateManyInput>
    /**
     * Filter which borderos to update
     * 
    **/
    where?: borderoWhereInput
  }


  /**
   * bordero upsert
   */
  export type borderoUpsertArgs = {
    /**
     * Select specific fields to fetch from the bordero
     * 
    **/
    select?: borderoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: borderoInclude | null
    /**
     * The filter to search for the bordero to update in case it exists.
     * 
    **/
    where: borderoWhereUniqueInput
    /**
     * In case the bordero found by the `where` argument doesn't exist, create a new bordero with this data.
     * 
    **/
    create: XOR<borderoCreateInput, borderoUncheckedCreateInput>
    /**
     * In case the bordero was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<borderoUpdateInput, borderoUncheckedUpdateInput>
  }


  /**
   * bordero delete
   */
  export type borderoDeleteArgs = {
    /**
     * Select specific fields to fetch from the bordero
     * 
    **/
    select?: borderoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: borderoInclude | null
    /**
     * Filter which bordero to delete.
     * 
    **/
    where: borderoWhereUniqueInput
  }


  /**
   * bordero deleteMany
   */
  export type borderoDeleteManyArgs = {
    /**
     * Filter which borderos to delete
     * 
    **/
    where?: borderoWhereInput
  }


  /**
   * bordero: findUniqueOrThrow
   */
  export type borderoFindUniqueOrThrowArgs = borderoFindUniqueArgsBase
      

  /**
   * bordero: findFirstOrThrow
   */
  export type borderoFindFirstOrThrowArgs = borderoFindFirstArgsBase
      

  /**
   * bordero without action
   */
  export type borderoArgs = {
    /**
     * Select specific fields to fetch from the bordero
     * 
    **/
    select?: borderoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: borderoInclude | null
  }



  /**
   * Model carteira
   */


  export type AggregateCarteira = {
    _count: CarteiraCountAggregateOutputType | null
    _avg: CarteiraAvgAggregateOutputType | null
    _sum: CarteiraSumAggregateOutputType | null
    _min: CarteiraMinAggregateOutputType | null
    _max: CarteiraMaxAggregateOutputType | null
  }

  export type CarteiraAvgAggregateOutputType = {
    id: number | null
    fiduc_fundo_id: number | null
  }

  export type CarteiraSumAggregateOutputType = {
    id: number | null
    fiduc_fundo_id: number | null
  }

  export type CarteiraMinAggregateOutputType = {
    id: number | null
    fiduc_fundo_id: number | null
  }

  export type CarteiraMaxAggregateOutputType = {
    id: number | null
    fiduc_fundo_id: number | null
  }

  export type CarteiraCountAggregateOutputType = {
    id: number
    fiduc_fundo_id: number
    _all: number
  }


  export type CarteiraAvgAggregateInputType = {
    id?: true
    fiduc_fundo_id?: true
  }

  export type CarteiraSumAggregateInputType = {
    id?: true
    fiduc_fundo_id?: true
  }

  export type CarteiraMinAggregateInputType = {
    id?: true
    fiduc_fundo_id?: true
  }

  export type CarteiraMaxAggregateInputType = {
    id?: true
    fiduc_fundo_id?: true
  }

  export type CarteiraCountAggregateInputType = {
    id?: true
    fiduc_fundo_id?: true
    _all?: true
  }

  export type CarteiraAggregateArgs = {
    /**
     * Filter which carteira to aggregate.
     * 
    **/
    where?: carteiraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteiras to fetch.
     * 
    **/
    orderBy?: Enumerable<carteiraOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: carteiraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteiras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteiras.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned carteiras
    **/
    _count?: true | CarteiraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarteiraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarteiraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarteiraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarteiraMaxAggregateInputType
  }

  export type GetCarteiraAggregateType<T extends CarteiraAggregateArgs> = {
        [P in keyof T & keyof AggregateCarteira]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarteira[P]>
      : GetScalarType<T[P], AggregateCarteira[P]>
  }




  export type CarteiraGroupByArgs = {
    where?: carteiraWhereInput
    orderBy?: Enumerable<carteiraOrderByWithAggregationInput>
    by: Array<CarteiraScalarFieldEnum>
    having?: carteiraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarteiraCountAggregateInputType | true
    _avg?: CarteiraAvgAggregateInputType
    _sum?: CarteiraSumAggregateInputType
    _min?: CarteiraMinAggregateInputType
    _max?: CarteiraMaxAggregateInputType
  }


  export type CarteiraGroupByOutputType = {
    id: number
    fiduc_fundo_id: number
    _count: CarteiraCountAggregateOutputType | null
    _avg: CarteiraAvgAggregateOutputType | null
    _sum: CarteiraSumAggregateOutputType | null
    _min: CarteiraMinAggregateOutputType | null
    _max: CarteiraMaxAggregateOutputType | null
  }

  type GetCarteiraGroupByPayload<T extends CarteiraGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CarteiraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarteiraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarteiraGroupByOutputType[P]>
            : GetScalarType<T[P], CarteiraGroupByOutputType[P]>
        }
      >
    >


  export type carteiraSelect = {
    id?: boolean
    fiduc_fundo_id?: boolean
    fidic_fundo?: boolean | fidic_fundoArgs
  }


  export type carteiraInclude = {
    fidic_fundo?: boolean | fidic_fundoArgs
  } 

  export type carteiraGetPayload<S extends boolean | null | undefined | carteiraArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? carteira :
    S extends undefined ? never :
    S extends { include: any } & (carteiraArgs | carteiraFindManyArgs)
    ? carteira  & {
    [P in TrueKeys<S['include']>]:
        P extends 'fidic_fundo' ? fidic_fundoGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (carteiraArgs | carteiraFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'fidic_fundo' ? fidic_fundoGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof carteira ? carteira[P] : never
  } 
      : carteira


  type carteiraCountArgs = Merge<
    Omit<carteiraFindManyArgs, 'select' | 'include'> & {
      select?: CarteiraCountAggregateInputType | true
    }
  >

  export interface carteiraDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Carteira that matches the filter.
     * @param {carteiraFindUniqueArgs} args - Arguments to find a Carteira
     * @example
     * // Get one Carteira
     * const carteira = await prisma.carteira.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends carteiraFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, carteiraFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'carteira'> extends True ? Prisma__carteiraClient<carteiraGetPayload<T>> : Prisma__carteiraClient<carteiraGetPayload<T> | null, null>

    /**
     * Find the first Carteira that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteiraFindFirstArgs} args - Arguments to find a Carteira
     * @example
     * // Get one Carteira
     * const carteira = await prisma.carteira.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends carteiraFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, carteiraFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'carteira'> extends True ? Prisma__carteiraClient<carteiraGetPayload<T>> : Prisma__carteiraClient<carteiraGetPayload<T> | null, null>

    /**
     * Find zero or more Carteiras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteiraFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carteiras
     * const carteiras = await prisma.carteira.findMany()
     * 
     * // Get first 10 Carteiras
     * const carteiras = await prisma.carteira.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carteiraWithIdOnly = await prisma.carteira.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends carteiraFindManyArgs>(
      args?: SelectSubset<T, carteiraFindManyArgs>
    ): PrismaPromise<Array<carteiraGetPayload<T>>>

    /**
     * Create a Carteira.
     * @param {carteiraCreateArgs} args - Arguments to create a Carteira.
     * @example
     * // Create one Carteira
     * const Carteira = await prisma.carteira.create({
     *   data: {
     *     // ... data to create a Carteira
     *   }
     * })
     * 
    **/
    create<T extends carteiraCreateArgs>(
      args: SelectSubset<T, carteiraCreateArgs>
    ): Prisma__carteiraClient<carteiraGetPayload<T>>

    /**
     * Create many Carteiras.
     *     @param {carteiraCreateManyArgs} args - Arguments to create many Carteiras.
     *     @example
     *     // Create many Carteiras
     *     const carteira = await prisma.carteira.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends carteiraCreateManyArgs>(
      args?: SelectSubset<T, carteiraCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Carteira.
     * @param {carteiraDeleteArgs} args - Arguments to delete one Carteira.
     * @example
     * // Delete one Carteira
     * const Carteira = await prisma.carteira.delete({
     *   where: {
     *     // ... filter to delete one Carteira
     *   }
     * })
     * 
    **/
    delete<T extends carteiraDeleteArgs>(
      args: SelectSubset<T, carteiraDeleteArgs>
    ): Prisma__carteiraClient<carteiraGetPayload<T>>

    /**
     * Update one Carteira.
     * @param {carteiraUpdateArgs} args - Arguments to update one Carteira.
     * @example
     * // Update one Carteira
     * const carteira = await prisma.carteira.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends carteiraUpdateArgs>(
      args: SelectSubset<T, carteiraUpdateArgs>
    ): Prisma__carteiraClient<carteiraGetPayload<T>>

    /**
     * Delete zero or more Carteiras.
     * @param {carteiraDeleteManyArgs} args - Arguments to filter Carteiras to delete.
     * @example
     * // Delete a few Carteiras
     * const { count } = await prisma.carteira.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends carteiraDeleteManyArgs>(
      args?: SelectSubset<T, carteiraDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carteiras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteiraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carteiras
     * const carteira = await prisma.carteira.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends carteiraUpdateManyArgs>(
      args: SelectSubset<T, carteiraUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Carteira.
     * @param {carteiraUpsertArgs} args - Arguments to update or create a Carteira.
     * @example
     * // Update or create a Carteira
     * const carteira = await prisma.carteira.upsert({
     *   create: {
     *     // ... data to create a Carteira
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carteira we want to update
     *   }
     * })
    **/
    upsert<T extends carteiraUpsertArgs>(
      args: SelectSubset<T, carteiraUpsertArgs>
    ): Prisma__carteiraClient<carteiraGetPayload<T>>

    /**
     * Find one Carteira that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {carteiraFindUniqueOrThrowArgs} args - Arguments to find a Carteira
     * @example
     * // Get one Carteira
     * const carteira = await prisma.carteira.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends carteiraFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, carteiraFindUniqueOrThrowArgs>
    ): Prisma__carteiraClient<carteiraGetPayload<T>>

    /**
     * Find the first Carteira that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteiraFindFirstOrThrowArgs} args - Arguments to find a Carteira
     * @example
     * // Get one Carteira
     * const carteira = await prisma.carteira.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends carteiraFindFirstOrThrowArgs>(
      args?: SelectSubset<T, carteiraFindFirstOrThrowArgs>
    ): Prisma__carteiraClient<carteiraGetPayload<T>>

    /**
     * Count the number of Carteiras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteiraCountArgs} args - Arguments to filter Carteiras to count.
     * @example
     * // Count the number of Carteiras
     * const count = await prisma.carteira.count({
     *   where: {
     *     // ... the filter for the Carteiras we want to count
     *   }
     * })
    **/
    count<T extends carteiraCountArgs>(
      args?: Subset<T, carteiraCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarteiraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Carteira.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteiraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarteiraAggregateArgs>(args: Subset<T, CarteiraAggregateArgs>): PrismaPromise<GetCarteiraAggregateType<T>>

    /**
     * Group by Carteira.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteiraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarteiraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarteiraGroupByArgs['orderBy'] }
        : { orderBy?: CarteiraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarteiraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarteiraGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for carteira.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__carteiraClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    fidic_fundo<T extends fidic_fundoArgs= {}>(args?: Subset<T, fidic_fundoArgs>): Prisma__fidic_fundoClient<fidic_fundoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * carteira base type for findUnique actions
   */
  export type carteiraFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the carteira
     * 
    **/
    select?: carteiraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteiraInclude | null
    /**
     * Filter, which carteira to fetch.
     * 
    **/
    where: carteiraWhereUniqueInput
  }

  /**
   * carteira: findUnique
   */
  export interface carteiraFindUniqueArgs extends carteiraFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * carteira base type for findFirst actions
   */
  export type carteiraFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the carteira
     * 
    **/
    select?: carteiraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteiraInclude | null
    /**
     * Filter, which carteira to fetch.
     * 
    **/
    where?: carteiraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteiras to fetch.
     * 
    **/
    orderBy?: Enumerable<carteiraOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for carteiras.
     * 
    **/
    cursor?: carteiraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteiras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteiras.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of carteiras.
     * 
    **/
    distinct?: Enumerable<CarteiraScalarFieldEnum>
  }

  /**
   * carteira: findFirst
   */
  export interface carteiraFindFirstArgs extends carteiraFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * carteira findMany
   */
  export type carteiraFindManyArgs = {
    /**
     * Select specific fields to fetch from the carteira
     * 
    **/
    select?: carteiraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteiraInclude | null
    /**
     * Filter, which carteiras to fetch.
     * 
    **/
    where?: carteiraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteiras to fetch.
     * 
    **/
    orderBy?: Enumerable<carteiraOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing carteiras.
     * 
    **/
    cursor?: carteiraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteiras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteiras.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CarteiraScalarFieldEnum>
  }


  /**
   * carteira create
   */
  export type carteiraCreateArgs = {
    /**
     * Select specific fields to fetch from the carteira
     * 
    **/
    select?: carteiraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteiraInclude | null
    /**
     * The data needed to create a carteira.
     * 
    **/
    data: XOR<carteiraCreateInput, carteiraUncheckedCreateInput>
  }


  /**
   * carteira createMany
   */
  export type carteiraCreateManyArgs = {
    /**
     * The data used to create many carteiras.
     * 
    **/
    data: Enumerable<carteiraCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * carteira update
   */
  export type carteiraUpdateArgs = {
    /**
     * Select specific fields to fetch from the carteira
     * 
    **/
    select?: carteiraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteiraInclude | null
    /**
     * The data needed to update a carteira.
     * 
    **/
    data: XOR<carteiraUpdateInput, carteiraUncheckedUpdateInput>
    /**
     * Choose, which carteira to update.
     * 
    **/
    where: carteiraWhereUniqueInput
  }


  /**
   * carteira updateMany
   */
  export type carteiraUpdateManyArgs = {
    /**
     * The data used to update carteiras.
     * 
    **/
    data: XOR<carteiraUpdateManyMutationInput, carteiraUncheckedUpdateManyInput>
    /**
     * Filter which carteiras to update
     * 
    **/
    where?: carteiraWhereInput
  }


  /**
   * carteira upsert
   */
  export type carteiraUpsertArgs = {
    /**
     * Select specific fields to fetch from the carteira
     * 
    **/
    select?: carteiraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteiraInclude | null
    /**
     * The filter to search for the carteira to update in case it exists.
     * 
    **/
    where: carteiraWhereUniqueInput
    /**
     * In case the carteira found by the `where` argument doesn't exist, create a new carteira with this data.
     * 
    **/
    create: XOR<carteiraCreateInput, carteiraUncheckedCreateInput>
    /**
     * In case the carteira was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<carteiraUpdateInput, carteiraUncheckedUpdateInput>
  }


  /**
   * carteira delete
   */
  export type carteiraDeleteArgs = {
    /**
     * Select specific fields to fetch from the carteira
     * 
    **/
    select?: carteiraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteiraInclude | null
    /**
     * Filter which carteira to delete.
     * 
    **/
    where: carteiraWhereUniqueInput
  }


  /**
   * carteira deleteMany
   */
  export type carteiraDeleteManyArgs = {
    /**
     * Filter which carteiras to delete
     * 
    **/
    where?: carteiraWhereInput
  }


  /**
   * carteira: findUniqueOrThrow
   */
  export type carteiraFindUniqueOrThrowArgs = carteiraFindUniqueArgsBase
      

  /**
   * carteira: findFirstOrThrow
   */
  export type carteiraFindFirstOrThrowArgs = carteiraFindFirstArgsBase
      

  /**
   * carteira without action
   */
  export type carteiraArgs = {
    /**
     * Select specific fields to fetch from the carteira
     * 
    **/
    select?: carteiraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteiraInclude | null
  }



  /**
   * Model cedente
   */


  export type AggregateCedente = {
    _count: CedenteCountAggregateOutputType | null
    _avg: CedenteAvgAggregateOutputType | null
    _sum: CedenteSumAggregateOutputType | null
    _min: CedenteMinAggregateOutputType | null
    _max: CedenteMaxAggregateOutputType | null
  }

  export type CedenteAvgAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
  }

  export type CedenteSumAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
  }

  export type CedenteMinAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
    razao_social: string | null
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
    endereco: string | null
    numero: string | null
    cep: string | null
    bairro: string | null
    cidade: string | null
    uf: string | null
    telefone: string | null
  }

  export type CedenteMaxAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
    razao_social: string | null
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
    endereco: string | null
    numero: string | null
    cep: string | null
    bairro: string | null
    cidade: string | null
    uf: string | null
    telefone: string | null
  }

  export type CedenteCountAggregateOutputType = {
    id: number
    pessoa_id: number
    razao_social: number
    nome_fantasia: number
    abertura: number
    cnpj: number
    endereco: number
    numero: number
    cep: number
    bairro: number
    cidade: number
    uf: number
    telefone: number
    _all: number
  }


  export type CedenteAvgAggregateInputType = {
    id?: true
    pessoa_id?: true
  }

  export type CedenteSumAggregateInputType = {
    id?: true
    pessoa_id?: true
  }

  export type CedenteMinAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
    endereco?: true
    numero?: true
    cep?: true
    bairro?: true
    cidade?: true
    uf?: true
    telefone?: true
  }

  export type CedenteMaxAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
    endereco?: true
    numero?: true
    cep?: true
    bairro?: true
    cidade?: true
    uf?: true
    telefone?: true
  }

  export type CedenteCountAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
    endereco?: true
    numero?: true
    cep?: true
    bairro?: true
    cidade?: true
    uf?: true
    telefone?: true
    _all?: true
  }

  export type CedenteAggregateArgs = {
    /**
     * Filter which cedente to aggregate.
     * 
    **/
    where?: cedenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedentes to fetch.
     * 
    **/
    orderBy?: Enumerable<cedenteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: cedenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedentes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedentes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cedentes
    **/
    _count?: true | CedenteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CedenteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CedenteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CedenteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CedenteMaxAggregateInputType
  }

  export type GetCedenteAggregateType<T extends CedenteAggregateArgs> = {
        [P in keyof T & keyof AggregateCedente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCedente[P]>
      : GetScalarType<T[P], AggregateCedente[P]>
  }




  export type CedenteGroupByArgs = {
    where?: cedenteWhereInput
    orderBy?: Enumerable<cedenteOrderByWithAggregationInput>
    by: Array<CedenteScalarFieldEnum>
    having?: cedenteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CedenteCountAggregateInputType | true
    _avg?: CedenteAvgAggregateInputType
    _sum?: CedenteSumAggregateInputType
    _min?: CedenteMinAggregateInputType
    _max?: CedenteMaxAggregateInputType
  }


  export type CedenteGroupByOutputType = {
    id: number
    pessoa_id: number
    razao_social: string
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
    endereco: string | null
    numero: string | null
    cep: string | null
    bairro: string | null
    cidade: string | null
    uf: string | null
    telefone: string | null
    _count: CedenteCountAggregateOutputType | null
    _avg: CedenteAvgAggregateOutputType | null
    _sum: CedenteSumAggregateOutputType | null
    _min: CedenteMinAggregateOutputType | null
    _max: CedenteMaxAggregateOutputType | null
  }

  type GetCedenteGroupByPayload<T extends CedenteGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CedenteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CedenteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CedenteGroupByOutputType[P]>
            : GetScalarType<T[P], CedenteGroupByOutputType[P]>
        }
      >
    >


  export type cedenteSelect = {
    id?: boolean
    pessoa_id?: boolean
    razao_social?: boolean
    nome_fantasia?: boolean
    abertura?: boolean
    cnpj?: boolean
    endereco?: boolean
    numero?: boolean
    cep?: boolean
    bairro?: boolean
    cidade?: boolean
    uf?: boolean
    telefone?: boolean
    cedente_analise?: boolean | cedente_analiseFindManyArgs
    cedente_n_sacados?: boolean | cedente_n_sacadosFindManyArgs
    titulo_x_cedente?: boolean | titulo_x_cedenteFindManyArgs
    _count?: boolean | CedenteCountOutputTypeArgs
  }


  export type cedenteInclude = {
    cedente_analise?: boolean | cedente_analiseFindManyArgs
    cedente_n_sacados?: boolean | cedente_n_sacadosFindManyArgs
    titulo_x_cedente?: boolean | titulo_x_cedenteFindManyArgs
    _count?: boolean | CedenteCountOutputTypeArgs
  } 

  export type cedenteGetPayload<S extends boolean | null | undefined | cedenteArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? cedente :
    S extends undefined ? never :
    S extends { include: any } & (cedenteArgs | cedenteFindManyArgs)
    ? cedente  & {
    [P in TrueKeys<S['include']>]:
        P extends 'cedente_analise' ? Array < cedente_analiseGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'cedente_n_sacados' ? Array < cedente_n_sacadosGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'titulo_x_cedente' ? Array < titulo_x_cedenteGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CedenteCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (cedenteArgs | cedenteFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'cedente_analise' ? Array < cedente_analiseGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'cedente_n_sacados' ? Array < cedente_n_sacadosGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'titulo_x_cedente' ? Array < titulo_x_cedenteGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CedenteCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof cedente ? cedente[P] : never
  } 
      : cedente


  type cedenteCountArgs = Merge<
    Omit<cedenteFindManyArgs, 'select' | 'include'> & {
      select?: CedenteCountAggregateInputType | true
    }
  >

  export interface cedenteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Cedente that matches the filter.
     * @param {cedenteFindUniqueArgs} args - Arguments to find a Cedente
     * @example
     * // Get one Cedente
     * const cedente = await prisma.cedente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cedenteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, cedenteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'cedente'> extends True ? Prisma__cedenteClient<cedenteGetPayload<T>> : Prisma__cedenteClient<cedenteGetPayload<T> | null, null>

    /**
     * Find the first Cedente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedenteFindFirstArgs} args - Arguments to find a Cedente
     * @example
     * // Get one Cedente
     * const cedente = await prisma.cedente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cedenteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, cedenteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'cedente'> extends True ? Prisma__cedenteClient<cedenteGetPayload<T>> : Prisma__cedenteClient<cedenteGetPayload<T> | null, null>

    /**
     * Find zero or more Cedentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedenteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cedentes
     * const cedentes = await prisma.cedente.findMany()
     * 
     * // Get first 10 Cedentes
     * const cedentes = await prisma.cedente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cedenteWithIdOnly = await prisma.cedente.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends cedenteFindManyArgs>(
      args?: SelectSubset<T, cedenteFindManyArgs>
    ): PrismaPromise<Array<cedenteGetPayload<T>>>

    /**
     * Create a Cedente.
     * @param {cedenteCreateArgs} args - Arguments to create a Cedente.
     * @example
     * // Create one Cedente
     * const Cedente = await prisma.cedente.create({
     *   data: {
     *     // ... data to create a Cedente
     *   }
     * })
     * 
    **/
    create<T extends cedenteCreateArgs>(
      args: SelectSubset<T, cedenteCreateArgs>
    ): Prisma__cedenteClient<cedenteGetPayload<T>>

    /**
     * Create many Cedentes.
     *     @param {cedenteCreateManyArgs} args - Arguments to create many Cedentes.
     *     @example
     *     // Create many Cedentes
     *     const cedente = await prisma.cedente.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cedenteCreateManyArgs>(
      args?: SelectSubset<T, cedenteCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Cedente.
     * @param {cedenteDeleteArgs} args - Arguments to delete one Cedente.
     * @example
     * // Delete one Cedente
     * const Cedente = await prisma.cedente.delete({
     *   where: {
     *     // ... filter to delete one Cedente
     *   }
     * })
     * 
    **/
    delete<T extends cedenteDeleteArgs>(
      args: SelectSubset<T, cedenteDeleteArgs>
    ): Prisma__cedenteClient<cedenteGetPayload<T>>

    /**
     * Update one Cedente.
     * @param {cedenteUpdateArgs} args - Arguments to update one Cedente.
     * @example
     * // Update one Cedente
     * const cedente = await prisma.cedente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cedenteUpdateArgs>(
      args: SelectSubset<T, cedenteUpdateArgs>
    ): Prisma__cedenteClient<cedenteGetPayload<T>>

    /**
     * Delete zero or more Cedentes.
     * @param {cedenteDeleteManyArgs} args - Arguments to filter Cedentes to delete.
     * @example
     * // Delete a few Cedentes
     * const { count } = await prisma.cedente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cedenteDeleteManyArgs>(
      args?: SelectSubset<T, cedenteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cedentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedenteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cedentes
     * const cedente = await prisma.cedente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cedenteUpdateManyArgs>(
      args: SelectSubset<T, cedenteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Cedente.
     * @param {cedenteUpsertArgs} args - Arguments to update or create a Cedente.
     * @example
     * // Update or create a Cedente
     * const cedente = await prisma.cedente.upsert({
     *   create: {
     *     // ... data to create a Cedente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cedente we want to update
     *   }
     * })
    **/
    upsert<T extends cedenteUpsertArgs>(
      args: SelectSubset<T, cedenteUpsertArgs>
    ): Prisma__cedenteClient<cedenteGetPayload<T>>

    /**
     * Find one Cedente that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {cedenteFindUniqueOrThrowArgs} args - Arguments to find a Cedente
     * @example
     * // Get one Cedente
     * const cedente = await prisma.cedente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cedenteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, cedenteFindUniqueOrThrowArgs>
    ): Prisma__cedenteClient<cedenteGetPayload<T>>

    /**
     * Find the first Cedente that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedenteFindFirstOrThrowArgs} args - Arguments to find a Cedente
     * @example
     * // Get one Cedente
     * const cedente = await prisma.cedente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cedenteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, cedenteFindFirstOrThrowArgs>
    ): Prisma__cedenteClient<cedenteGetPayload<T>>

    /**
     * Count the number of Cedentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedenteCountArgs} args - Arguments to filter Cedentes to count.
     * @example
     * // Count the number of Cedentes
     * const count = await prisma.cedente.count({
     *   where: {
     *     // ... the filter for the Cedentes we want to count
     *   }
     * })
    **/
    count<T extends cedenteCountArgs>(
      args?: Subset<T, cedenteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CedenteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cedente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CedenteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CedenteAggregateArgs>(args: Subset<T, CedenteAggregateArgs>): PrismaPromise<GetCedenteAggregateType<T>>

    /**
     * Group by Cedente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CedenteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CedenteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CedenteGroupByArgs['orderBy'] }
        : { orderBy?: CedenteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CedenteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCedenteGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for cedente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cedenteClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cedente_analise<T extends cedente_analiseFindManyArgs= {}>(args?: Subset<T, cedente_analiseFindManyArgs>): PrismaPromise<Array<cedente_analiseGetPayload<T>>| Null>;

    cedente_n_sacados<T extends cedente_n_sacadosFindManyArgs= {}>(args?: Subset<T, cedente_n_sacadosFindManyArgs>): PrismaPromise<Array<cedente_n_sacadosGetPayload<T>>| Null>;

    titulo_x_cedente<T extends titulo_x_cedenteFindManyArgs= {}>(args?: Subset<T, titulo_x_cedenteFindManyArgs>): PrismaPromise<Array<titulo_x_cedenteGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * cedente base type for findUnique actions
   */
  export type cedenteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the cedente
     * 
    **/
    select?: cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedenteInclude | null
    /**
     * Filter, which cedente to fetch.
     * 
    **/
    where: cedenteWhereUniqueInput
  }

  /**
   * cedente: findUnique
   */
  export interface cedenteFindUniqueArgs extends cedenteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cedente base type for findFirst actions
   */
  export type cedenteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the cedente
     * 
    **/
    select?: cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedenteInclude | null
    /**
     * Filter, which cedente to fetch.
     * 
    **/
    where?: cedenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedentes to fetch.
     * 
    **/
    orderBy?: Enumerable<cedenteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cedentes.
     * 
    **/
    cursor?: cedenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedentes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedentes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cedentes.
     * 
    **/
    distinct?: Enumerable<CedenteScalarFieldEnum>
  }

  /**
   * cedente: findFirst
   */
  export interface cedenteFindFirstArgs extends cedenteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cedente findMany
   */
  export type cedenteFindManyArgs = {
    /**
     * Select specific fields to fetch from the cedente
     * 
    **/
    select?: cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedenteInclude | null
    /**
     * Filter, which cedentes to fetch.
     * 
    **/
    where?: cedenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedentes to fetch.
     * 
    **/
    orderBy?: Enumerable<cedenteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cedentes.
     * 
    **/
    cursor?: cedenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedentes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedentes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CedenteScalarFieldEnum>
  }


  /**
   * cedente create
   */
  export type cedenteCreateArgs = {
    /**
     * Select specific fields to fetch from the cedente
     * 
    **/
    select?: cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedenteInclude | null
    /**
     * The data needed to create a cedente.
     * 
    **/
    data: XOR<cedenteCreateInput, cedenteUncheckedCreateInput>
  }


  /**
   * cedente createMany
   */
  export type cedenteCreateManyArgs = {
    /**
     * The data used to create many cedentes.
     * 
    **/
    data: Enumerable<cedenteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * cedente update
   */
  export type cedenteUpdateArgs = {
    /**
     * Select specific fields to fetch from the cedente
     * 
    **/
    select?: cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedenteInclude | null
    /**
     * The data needed to update a cedente.
     * 
    **/
    data: XOR<cedenteUpdateInput, cedenteUncheckedUpdateInput>
    /**
     * Choose, which cedente to update.
     * 
    **/
    where: cedenteWhereUniqueInput
  }


  /**
   * cedente updateMany
   */
  export type cedenteUpdateManyArgs = {
    /**
     * The data used to update cedentes.
     * 
    **/
    data: XOR<cedenteUpdateManyMutationInput, cedenteUncheckedUpdateManyInput>
    /**
     * Filter which cedentes to update
     * 
    **/
    where?: cedenteWhereInput
  }


  /**
   * cedente upsert
   */
  export type cedenteUpsertArgs = {
    /**
     * Select specific fields to fetch from the cedente
     * 
    **/
    select?: cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedenteInclude | null
    /**
     * The filter to search for the cedente to update in case it exists.
     * 
    **/
    where: cedenteWhereUniqueInput
    /**
     * In case the cedente found by the `where` argument doesn't exist, create a new cedente with this data.
     * 
    **/
    create: XOR<cedenteCreateInput, cedenteUncheckedCreateInput>
    /**
     * In case the cedente was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<cedenteUpdateInput, cedenteUncheckedUpdateInput>
  }


  /**
   * cedente delete
   */
  export type cedenteDeleteArgs = {
    /**
     * Select specific fields to fetch from the cedente
     * 
    **/
    select?: cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedenteInclude | null
    /**
     * Filter which cedente to delete.
     * 
    **/
    where: cedenteWhereUniqueInput
  }


  /**
   * cedente deleteMany
   */
  export type cedenteDeleteManyArgs = {
    /**
     * Filter which cedentes to delete
     * 
    **/
    where?: cedenteWhereInput
  }


  /**
   * cedente: findUniqueOrThrow
   */
  export type cedenteFindUniqueOrThrowArgs = cedenteFindUniqueArgsBase
      

  /**
   * cedente: findFirstOrThrow
   */
  export type cedenteFindFirstOrThrowArgs = cedenteFindFirstArgsBase
      

  /**
   * cedente without action
   */
  export type cedenteArgs = {
    /**
     * Select specific fields to fetch from the cedente
     * 
    **/
    select?: cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedenteInclude | null
  }



  /**
   * Model cedente_analise
   */


  export type AggregateCedente_analise = {
    _count: Cedente_analiseCountAggregateOutputType | null
    _avg: Cedente_analiseAvgAggregateOutputType | null
    _sum: Cedente_analiseSumAggregateOutputType | null
    _min: Cedente_analiseMinAggregateOutputType | null
    _max: Cedente_analiseMaxAggregateOutputType | null
  }

  export type Cedente_analiseAvgAggregateOutputType = {
    id: number | null
    cedente: number | null
  }

  export type Cedente_analiseSumAggregateOutputType = {
    id: number | null
    cedente: number | null
  }

  export type Cedente_analiseMinAggregateOutputType = {
    id: number | null
    status: string | null
    cedente: number | null
  }

  export type Cedente_analiseMaxAggregateOutputType = {
    id: number | null
    status: string | null
    cedente: number | null
  }

  export type Cedente_analiseCountAggregateOutputType = {
    id: number
    status: number
    cedente: number
    _all: number
  }


  export type Cedente_analiseAvgAggregateInputType = {
    id?: true
    cedente?: true
  }

  export type Cedente_analiseSumAggregateInputType = {
    id?: true
    cedente?: true
  }

  export type Cedente_analiseMinAggregateInputType = {
    id?: true
    status?: true
    cedente?: true
  }

  export type Cedente_analiseMaxAggregateInputType = {
    id?: true
    status?: true
    cedente?: true
  }

  export type Cedente_analiseCountAggregateInputType = {
    id?: true
    status?: true
    cedente?: true
    _all?: true
  }

  export type Cedente_analiseAggregateArgs = {
    /**
     * Filter which cedente_analise to aggregate.
     * 
    **/
    where?: cedente_analiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedente_analises to fetch.
     * 
    **/
    orderBy?: Enumerable<cedente_analiseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: cedente_analiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedente_analises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedente_analises.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cedente_analises
    **/
    _count?: true | Cedente_analiseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cedente_analiseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cedente_analiseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cedente_analiseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cedente_analiseMaxAggregateInputType
  }

  export type GetCedente_analiseAggregateType<T extends Cedente_analiseAggregateArgs> = {
        [P in keyof T & keyof AggregateCedente_analise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCedente_analise[P]>
      : GetScalarType<T[P], AggregateCedente_analise[P]>
  }




  export type Cedente_analiseGroupByArgs = {
    where?: cedente_analiseWhereInput
    orderBy?: Enumerable<cedente_analiseOrderByWithAggregationInput>
    by: Array<Cedente_analiseScalarFieldEnum>
    having?: cedente_analiseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cedente_analiseCountAggregateInputType | true
    _avg?: Cedente_analiseAvgAggregateInputType
    _sum?: Cedente_analiseSumAggregateInputType
    _min?: Cedente_analiseMinAggregateInputType
    _max?: Cedente_analiseMaxAggregateInputType
  }


  export type Cedente_analiseGroupByOutputType = {
    id: number
    status: string | null
    cedente: number | null
    _count: Cedente_analiseCountAggregateOutputType | null
    _avg: Cedente_analiseAvgAggregateOutputType | null
    _sum: Cedente_analiseSumAggregateOutputType | null
    _min: Cedente_analiseMinAggregateOutputType | null
    _max: Cedente_analiseMaxAggregateOutputType | null
  }

  type GetCedente_analiseGroupByPayload<T extends Cedente_analiseGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Cedente_analiseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cedente_analiseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cedente_analiseGroupByOutputType[P]>
            : GetScalarType<T[P], Cedente_analiseGroupByOutputType[P]>
        }
      >
    >


  export type cedente_analiseSelect = {
    id?: boolean
    status?: boolean
    cedente?: boolean
    cedente_cedenteTocedente_analise?: boolean | cedenteArgs
  }


  export type cedente_analiseInclude = {
    cedente_cedenteTocedente_analise?: boolean | cedenteArgs
  } 

  export type cedente_analiseGetPayload<S extends boolean | null | undefined | cedente_analiseArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? cedente_analise :
    S extends undefined ? never :
    S extends { include: any } & (cedente_analiseArgs | cedente_analiseFindManyArgs)
    ? cedente_analise  & {
    [P in TrueKeys<S['include']>]:
        P extends 'cedente_cedenteTocedente_analise' ? cedenteGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : S extends { select: any } & (cedente_analiseArgs | cedente_analiseFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'cedente_cedenteTocedente_analise' ? cedenteGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof cedente_analise ? cedente_analise[P] : never
  } 
      : cedente_analise


  type cedente_analiseCountArgs = Merge<
    Omit<cedente_analiseFindManyArgs, 'select' | 'include'> & {
      select?: Cedente_analiseCountAggregateInputType | true
    }
  >

  export interface cedente_analiseDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Cedente_analise that matches the filter.
     * @param {cedente_analiseFindUniqueArgs} args - Arguments to find a Cedente_analise
     * @example
     * // Get one Cedente_analise
     * const cedente_analise = await prisma.cedente_analise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cedente_analiseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, cedente_analiseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'cedente_analise'> extends True ? Prisma__cedente_analiseClient<cedente_analiseGetPayload<T>> : Prisma__cedente_analiseClient<cedente_analiseGetPayload<T> | null, null>

    /**
     * Find the first Cedente_analise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_analiseFindFirstArgs} args - Arguments to find a Cedente_analise
     * @example
     * // Get one Cedente_analise
     * const cedente_analise = await prisma.cedente_analise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cedente_analiseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, cedente_analiseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'cedente_analise'> extends True ? Prisma__cedente_analiseClient<cedente_analiseGetPayload<T>> : Prisma__cedente_analiseClient<cedente_analiseGetPayload<T> | null, null>

    /**
     * Find zero or more Cedente_analises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_analiseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cedente_analises
     * const cedente_analises = await prisma.cedente_analise.findMany()
     * 
     * // Get first 10 Cedente_analises
     * const cedente_analises = await prisma.cedente_analise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cedente_analiseWithIdOnly = await prisma.cedente_analise.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends cedente_analiseFindManyArgs>(
      args?: SelectSubset<T, cedente_analiseFindManyArgs>
    ): PrismaPromise<Array<cedente_analiseGetPayload<T>>>

    /**
     * Create a Cedente_analise.
     * @param {cedente_analiseCreateArgs} args - Arguments to create a Cedente_analise.
     * @example
     * // Create one Cedente_analise
     * const Cedente_analise = await prisma.cedente_analise.create({
     *   data: {
     *     // ... data to create a Cedente_analise
     *   }
     * })
     * 
    **/
    create<T extends cedente_analiseCreateArgs>(
      args: SelectSubset<T, cedente_analiseCreateArgs>
    ): Prisma__cedente_analiseClient<cedente_analiseGetPayload<T>>

    /**
     * Create many Cedente_analises.
     *     @param {cedente_analiseCreateManyArgs} args - Arguments to create many Cedente_analises.
     *     @example
     *     // Create many Cedente_analises
     *     const cedente_analise = await prisma.cedente_analise.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cedente_analiseCreateManyArgs>(
      args?: SelectSubset<T, cedente_analiseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Cedente_analise.
     * @param {cedente_analiseDeleteArgs} args - Arguments to delete one Cedente_analise.
     * @example
     * // Delete one Cedente_analise
     * const Cedente_analise = await prisma.cedente_analise.delete({
     *   where: {
     *     // ... filter to delete one Cedente_analise
     *   }
     * })
     * 
    **/
    delete<T extends cedente_analiseDeleteArgs>(
      args: SelectSubset<T, cedente_analiseDeleteArgs>
    ): Prisma__cedente_analiseClient<cedente_analiseGetPayload<T>>

    /**
     * Update one Cedente_analise.
     * @param {cedente_analiseUpdateArgs} args - Arguments to update one Cedente_analise.
     * @example
     * // Update one Cedente_analise
     * const cedente_analise = await prisma.cedente_analise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cedente_analiseUpdateArgs>(
      args: SelectSubset<T, cedente_analiseUpdateArgs>
    ): Prisma__cedente_analiseClient<cedente_analiseGetPayload<T>>

    /**
     * Delete zero or more Cedente_analises.
     * @param {cedente_analiseDeleteManyArgs} args - Arguments to filter Cedente_analises to delete.
     * @example
     * // Delete a few Cedente_analises
     * const { count } = await prisma.cedente_analise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cedente_analiseDeleteManyArgs>(
      args?: SelectSubset<T, cedente_analiseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cedente_analises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_analiseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cedente_analises
     * const cedente_analise = await prisma.cedente_analise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cedente_analiseUpdateManyArgs>(
      args: SelectSubset<T, cedente_analiseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Cedente_analise.
     * @param {cedente_analiseUpsertArgs} args - Arguments to update or create a Cedente_analise.
     * @example
     * // Update or create a Cedente_analise
     * const cedente_analise = await prisma.cedente_analise.upsert({
     *   create: {
     *     // ... data to create a Cedente_analise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cedente_analise we want to update
     *   }
     * })
    **/
    upsert<T extends cedente_analiseUpsertArgs>(
      args: SelectSubset<T, cedente_analiseUpsertArgs>
    ): Prisma__cedente_analiseClient<cedente_analiseGetPayload<T>>

    /**
     * Find one Cedente_analise that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {cedente_analiseFindUniqueOrThrowArgs} args - Arguments to find a Cedente_analise
     * @example
     * // Get one Cedente_analise
     * const cedente_analise = await prisma.cedente_analise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cedente_analiseFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, cedente_analiseFindUniqueOrThrowArgs>
    ): Prisma__cedente_analiseClient<cedente_analiseGetPayload<T>>

    /**
     * Find the first Cedente_analise that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_analiseFindFirstOrThrowArgs} args - Arguments to find a Cedente_analise
     * @example
     * // Get one Cedente_analise
     * const cedente_analise = await prisma.cedente_analise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cedente_analiseFindFirstOrThrowArgs>(
      args?: SelectSubset<T, cedente_analiseFindFirstOrThrowArgs>
    ): Prisma__cedente_analiseClient<cedente_analiseGetPayload<T>>

    /**
     * Count the number of Cedente_analises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_analiseCountArgs} args - Arguments to filter Cedente_analises to count.
     * @example
     * // Count the number of Cedente_analises
     * const count = await prisma.cedente_analise.count({
     *   where: {
     *     // ... the filter for the Cedente_analises we want to count
     *   }
     * })
    **/
    count<T extends cedente_analiseCountArgs>(
      args?: Subset<T, cedente_analiseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cedente_analiseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cedente_analise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cedente_analiseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cedente_analiseAggregateArgs>(args: Subset<T, Cedente_analiseAggregateArgs>): PrismaPromise<GetCedente_analiseAggregateType<T>>

    /**
     * Group by Cedente_analise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cedente_analiseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Cedente_analiseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Cedente_analiseGroupByArgs['orderBy'] }
        : { orderBy?: Cedente_analiseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Cedente_analiseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCedente_analiseGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for cedente_analise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cedente_analiseClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cedente_cedenteTocedente_analise<T extends cedenteArgs= {}>(args?: Subset<T, cedenteArgs>): Prisma__cedenteClient<cedenteGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * cedente_analise base type for findUnique actions
   */
  export type cedente_analiseFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the cedente_analise
     * 
    **/
    select?: cedente_analiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_analiseInclude | null
    /**
     * Filter, which cedente_analise to fetch.
     * 
    **/
    where: cedente_analiseWhereUniqueInput
  }

  /**
   * cedente_analise: findUnique
   */
  export interface cedente_analiseFindUniqueArgs extends cedente_analiseFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cedente_analise base type for findFirst actions
   */
  export type cedente_analiseFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the cedente_analise
     * 
    **/
    select?: cedente_analiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_analiseInclude | null
    /**
     * Filter, which cedente_analise to fetch.
     * 
    **/
    where?: cedente_analiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedente_analises to fetch.
     * 
    **/
    orderBy?: Enumerable<cedente_analiseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cedente_analises.
     * 
    **/
    cursor?: cedente_analiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedente_analises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedente_analises.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cedente_analises.
     * 
    **/
    distinct?: Enumerable<Cedente_analiseScalarFieldEnum>
  }

  /**
   * cedente_analise: findFirst
   */
  export interface cedente_analiseFindFirstArgs extends cedente_analiseFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cedente_analise findMany
   */
  export type cedente_analiseFindManyArgs = {
    /**
     * Select specific fields to fetch from the cedente_analise
     * 
    **/
    select?: cedente_analiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_analiseInclude | null
    /**
     * Filter, which cedente_analises to fetch.
     * 
    **/
    where?: cedente_analiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedente_analises to fetch.
     * 
    **/
    orderBy?: Enumerable<cedente_analiseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cedente_analises.
     * 
    **/
    cursor?: cedente_analiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedente_analises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedente_analises.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Cedente_analiseScalarFieldEnum>
  }


  /**
   * cedente_analise create
   */
  export type cedente_analiseCreateArgs = {
    /**
     * Select specific fields to fetch from the cedente_analise
     * 
    **/
    select?: cedente_analiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_analiseInclude | null
    /**
     * The data needed to create a cedente_analise.
     * 
    **/
    data: XOR<cedente_analiseCreateInput, cedente_analiseUncheckedCreateInput>
  }


  /**
   * cedente_analise createMany
   */
  export type cedente_analiseCreateManyArgs = {
    /**
     * The data used to create many cedente_analises.
     * 
    **/
    data: Enumerable<cedente_analiseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * cedente_analise update
   */
  export type cedente_analiseUpdateArgs = {
    /**
     * Select specific fields to fetch from the cedente_analise
     * 
    **/
    select?: cedente_analiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_analiseInclude | null
    /**
     * The data needed to update a cedente_analise.
     * 
    **/
    data: XOR<cedente_analiseUpdateInput, cedente_analiseUncheckedUpdateInput>
    /**
     * Choose, which cedente_analise to update.
     * 
    **/
    where: cedente_analiseWhereUniqueInput
  }


  /**
   * cedente_analise updateMany
   */
  export type cedente_analiseUpdateManyArgs = {
    /**
     * The data used to update cedente_analises.
     * 
    **/
    data: XOR<cedente_analiseUpdateManyMutationInput, cedente_analiseUncheckedUpdateManyInput>
    /**
     * Filter which cedente_analises to update
     * 
    **/
    where?: cedente_analiseWhereInput
  }


  /**
   * cedente_analise upsert
   */
  export type cedente_analiseUpsertArgs = {
    /**
     * Select specific fields to fetch from the cedente_analise
     * 
    **/
    select?: cedente_analiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_analiseInclude | null
    /**
     * The filter to search for the cedente_analise to update in case it exists.
     * 
    **/
    where: cedente_analiseWhereUniqueInput
    /**
     * In case the cedente_analise found by the `where` argument doesn't exist, create a new cedente_analise with this data.
     * 
    **/
    create: XOR<cedente_analiseCreateInput, cedente_analiseUncheckedCreateInput>
    /**
     * In case the cedente_analise was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<cedente_analiseUpdateInput, cedente_analiseUncheckedUpdateInput>
  }


  /**
   * cedente_analise delete
   */
  export type cedente_analiseDeleteArgs = {
    /**
     * Select specific fields to fetch from the cedente_analise
     * 
    **/
    select?: cedente_analiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_analiseInclude | null
    /**
     * Filter which cedente_analise to delete.
     * 
    **/
    where: cedente_analiseWhereUniqueInput
  }


  /**
   * cedente_analise deleteMany
   */
  export type cedente_analiseDeleteManyArgs = {
    /**
     * Filter which cedente_analises to delete
     * 
    **/
    where?: cedente_analiseWhereInput
  }


  /**
   * cedente_analise: findUniqueOrThrow
   */
  export type cedente_analiseFindUniqueOrThrowArgs = cedente_analiseFindUniqueArgsBase
      

  /**
   * cedente_analise: findFirstOrThrow
   */
  export type cedente_analiseFindFirstOrThrowArgs = cedente_analiseFindFirstArgsBase
      

  /**
   * cedente_analise without action
   */
  export type cedente_analiseArgs = {
    /**
     * Select specific fields to fetch from the cedente_analise
     * 
    **/
    select?: cedente_analiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_analiseInclude | null
  }



  /**
   * Model cedente_n_sacados
   */


  export type AggregateCedente_n_sacados = {
    _count: Cedente_n_sacadosCountAggregateOutputType | null
    _avg: Cedente_n_sacadosAvgAggregateOutputType | null
    _sum: Cedente_n_sacadosSumAggregateOutputType | null
    _min: Cedente_n_sacadosMinAggregateOutputType | null
    _max: Cedente_n_sacadosMaxAggregateOutputType | null
  }

  export type Cedente_n_sacadosAvgAggregateOutputType = {
    id: number | null
    cedente: number | null
    sacado: number | null
  }

  export type Cedente_n_sacadosSumAggregateOutputType = {
    id: number | null
    cedente: number | null
    sacado: number | null
  }

  export type Cedente_n_sacadosMinAggregateOutputType = {
    id: number | null
    cedente: number | null
    sacado: number | null
  }

  export type Cedente_n_sacadosMaxAggregateOutputType = {
    id: number | null
    cedente: number | null
    sacado: number | null
  }

  export type Cedente_n_sacadosCountAggregateOutputType = {
    id: number
    cedente: number
    sacado: number
    _all: number
  }


  export type Cedente_n_sacadosAvgAggregateInputType = {
    id?: true
    cedente?: true
    sacado?: true
  }

  export type Cedente_n_sacadosSumAggregateInputType = {
    id?: true
    cedente?: true
    sacado?: true
  }

  export type Cedente_n_sacadosMinAggregateInputType = {
    id?: true
    cedente?: true
    sacado?: true
  }

  export type Cedente_n_sacadosMaxAggregateInputType = {
    id?: true
    cedente?: true
    sacado?: true
  }

  export type Cedente_n_sacadosCountAggregateInputType = {
    id?: true
    cedente?: true
    sacado?: true
    _all?: true
  }

  export type Cedente_n_sacadosAggregateArgs = {
    /**
     * Filter which cedente_n_sacados to aggregate.
     * 
    **/
    where?: cedente_n_sacadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedente_n_sacados to fetch.
     * 
    **/
    orderBy?: Enumerable<cedente_n_sacadosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: cedente_n_sacadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedente_n_sacados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedente_n_sacados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cedente_n_sacados
    **/
    _count?: true | Cedente_n_sacadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cedente_n_sacadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cedente_n_sacadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cedente_n_sacadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cedente_n_sacadosMaxAggregateInputType
  }

  export type GetCedente_n_sacadosAggregateType<T extends Cedente_n_sacadosAggregateArgs> = {
        [P in keyof T & keyof AggregateCedente_n_sacados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCedente_n_sacados[P]>
      : GetScalarType<T[P], AggregateCedente_n_sacados[P]>
  }




  export type Cedente_n_sacadosGroupByArgs = {
    where?: cedente_n_sacadosWhereInput
    orderBy?: Enumerable<cedente_n_sacadosOrderByWithAggregationInput>
    by: Array<Cedente_n_sacadosScalarFieldEnum>
    having?: cedente_n_sacadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cedente_n_sacadosCountAggregateInputType | true
    _avg?: Cedente_n_sacadosAvgAggregateInputType
    _sum?: Cedente_n_sacadosSumAggregateInputType
    _min?: Cedente_n_sacadosMinAggregateInputType
    _max?: Cedente_n_sacadosMaxAggregateInputType
  }


  export type Cedente_n_sacadosGroupByOutputType = {
    id: number
    cedente: number | null
    sacado: number | null
    _count: Cedente_n_sacadosCountAggregateOutputType | null
    _avg: Cedente_n_sacadosAvgAggregateOutputType | null
    _sum: Cedente_n_sacadosSumAggregateOutputType | null
    _min: Cedente_n_sacadosMinAggregateOutputType | null
    _max: Cedente_n_sacadosMaxAggregateOutputType | null
  }

  type GetCedente_n_sacadosGroupByPayload<T extends Cedente_n_sacadosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Cedente_n_sacadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cedente_n_sacadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cedente_n_sacadosGroupByOutputType[P]>
            : GetScalarType<T[P], Cedente_n_sacadosGroupByOutputType[P]>
        }
      >
    >


  export type cedente_n_sacadosSelect = {
    id?: boolean
    cedente?: boolean
    sacado?: boolean
    cedente_cedenteTocedente_n_sacados?: boolean | cedenteArgs
    sacado_cedente_n_sacadosTosacado?: boolean | sacadoArgs
  }


  export type cedente_n_sacadosInclude = {
    cedente_cedenteTocedente_n_sacados?: boolean | cedenteArgs
    sacado_cedente_n_sacadosTosacado?: boolean | sacadoArgs
  } 

  export type cedente_n_sacadosGetPayload<S extends boolean | null | undefined | cedente_n_sacadosArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? cedente_n_sacados :
    S extends undefined ? never :
    S extends { include: any } & (cedente_n_sacadosArgs | cedente_n_sacadosFindManyArgs)
    ? cedente_n_sacados  & {
    [P in TrueKeys<S['include']>]:
        P extends 'cedente_cedenteTocedente_n_sacados' ? cedenteGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'sacado_cedente_n_sacadosTosacado' ? sacadoGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : S extends { select: any } & (cedente_n_sacadosArgs | cedente_n_sacadosFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'cedente_cedenteTocedente_n_sacados' ? cedenteGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'sacado_cedente_n_sacadosTosacado' ? sacadoGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof cedente_n_sacados ? cedente_n_sacados[P] : never
  } 
      : cedente_n_sacados


  type cedente_n_sacadosCountArgs = Merge<
    Omit<cedente_n_sacadosFindManyArgs, 'select' | 'include'> & {
      select?: Cedente_n_sacadosCountAggregateInputType | true
    }
  >

  export interface cedente_n_sacadosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Cedente_n_sacados that matches the filter.
     * @param {cedente_n_sacadosFindUniqueArgs} args - Arguments to find a Cedente_n_sacados
     * @example
     * // Get one Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cedente_n_sacadosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, cedente_n_sacadosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'cedente_n_sacados'> extends True ? Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T>> : Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T> | null, null>

    /**
     * Find the first Cedente_n_sacados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_n_sacadosFindFirstArgs} args - Arguments to find a Cedente_n_sacados
     * @example
     * // Get one Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cedente_n_sacadosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, cedente_n_sacadosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'cedente_n_sacados'> extends True ? Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T>> : Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T> | null, null>

    /**
     * Find zero or more Cedente_n_sacados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_n_sacadosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.findMany()
     * 
     * // Get first 10 Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cedente_n_sacadosWithIdOnly = await prisma.cedente_n_sacados.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends cedente_n_sacadosFindManyArgs>(
      args?: SelectSubset<T, cedente_n_sacadosFindManyArgs>
    ): PrismaPromise<Array<cedente_n_sacadosGetPayload<T>>>

    /**
     * Create a Cedente_n_sacados.
     * @param {cedente_n_sacadosCreateArgs} args - Arguments to create a Cedente_n_sacados.
     * @example
     * // Create one Cedente_n_sacados
     * const Cedente_n_sacados = await prisma.cedente_n_sacados.create({
     *   data: {
     *     // ... data to create a Cedente_n_sacados
     *   }
     * })
     * 
    **/
    create<T extends cedente_n_sacadosCreateArgs>(
      args: SelectSubset<T, cedente_n_sacadosCreateArgs>
    ): Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T>>

    /**
     * Create many Cedente_n_sacados.
     *     @param {cedente_n_sacadosCreateManyArgs} args - Arguments to create many Cedente_n_sacados.
     *     @example
     *     // Create many Cedente_n_sacados
     *     const cedente_n_sacados = await prisma.cedente_n_sacados.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cedente_n_sacadosCreateManyArgs>(
      args?: SelectSubset<T, cedente_n_sacadosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Cedente_n_sacados.
     * @param {cedente_n_sacadosDeleteArgs} args - Arguments to delete one Cedente_n_sacados.
     * @example
     * // Delete one Cedente_n_sacados
     * const Cedente_n_sacados = await prisma.cedente_n_sacados.delete({
     *   where: {
     *     // ... filter to delete one Cedente_n_sacados
     *   }
     * })
     * 
    **/
    delete<T extends cedente_n_sacadosDeleteArgs>(
      args: SelectSubset<T, cedente_n_sacadosDeleteArgs>
    ): Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T>>

    /**
     * Update one Cedente_n_sacados.
     * @param {cedente_n_sacadosUpdateArgs} args - Arguments to update one Cedente_n_sacados.
     * @example
     * // Update one Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cedente_n_sacadosUpdateArgs>(
      args: SelectSubset<T, cedente_n_sacadosUpdateArgs>
    ): Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T>>

    /**
     * Delete zero or more Cedente_n_sacados.
     * @param {cedente_n_sacadosDeleteManyArgs} args - Arguments to filter Cedente_n_sacados to delete.
     * @example
     * // Delete a few Cedente_n_sacados
     * const { count } = await prisma.cedente_n_sacados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cedente_n_sacadosDeleteManyArgs>(
      args?: SelectSubset<T, cedente_n_sacadosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cedente_n_sacados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_n_sacadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cedente_n_sacadosUpdateManyArgs>(
      args: SelectSubset<T, cedente_n_sacadosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Cedente_n_sacados.
     * @param {cedente_n_sacadosUpsertArgs} args - Arguments to update or create a Cedente_n_sacados.
     * @example
     * // Update or create a Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.upsert({
     *   create: {
     *     // ... data to create a Cedente_n_sacados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cedente_n_sacados we want to update
     *   }
     * })
    **/
    upsert<T extends cedente_n_sacadosUpsertArgs>(
      args: SelectSubset<T, cedente_n_sacadosUpsertArgs>
    ): Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T>>

    /**
     * Find one Cedente_n_sacados that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {cedente_n_sacadosFindUniqueOrThrowArgs} args - Arguments to find a Cedente_n_sacados
     * @example
     * // Get one Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cedente_n_sacadosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, cedente_n_sacadosFindUniqueOrThrowArgs>
    ): Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T>>

    /**
     * Find the first Cedente_n_sacados that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_n_sacadosFindFirstOrThrowArgs} args - Arguments to find a Cedente_n_sacados
     * @example
     * // Get one Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cedente_n_sacadosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, cedente_n_sacadosFindFirstOrThrowArgs>
    ): Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T>>

    /**
     * Count the number of Cedente_n_sacados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_n_sacadosCountArgs} args - Arguments to filter Cedente_n_sacados to count.
     * @example
     * // Count the number of Cedente_n_sacados
     * const count = await prisma.cedente_n_sacados.count({
     *   where: {
     *     // ... the filter for the Cedente_n_sacados we want to count
     *   }
     * })
    **/
    count<T extends cedente_n_sacadosCountArgs>(
      args?: Subset<T, cedente_n_sacadosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cedente_n_sacadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cedente_n_sacados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cedente_n_sacadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cedente_n_sacadosAggregateArgs>(args: Subset<T, Cedente_n_sacadosAggregateArgs>): PrismaPromise<GetCedente_n_sacadosAggregateType<T>>

    /**
     * Group by Cedente_n_sacados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cedente_n_sacadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Cedente_n_sacadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Cedente_n_sacadosGroupByArgs['orderBy'] }
        : { orderBy?: Cedente_n_sacadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Cedente_n_sacadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCedente_n_sacadosGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for cedente_n_sacados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cedente_n_sacadosClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cedente_cedenteTocedente_n_sacados<T extends cedenteArgs= {}>(args?: Subset<T, cedenteArgs>): Prisma__cedenteClient<cedenteGetPayload<T> | Null>;

    sacado_cedente_n_sacadosTosacado<T extends sacadoArgs= {}>(args?: Subset<T, sacadoArgs>): Prisma__sacadoClient<sacadoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * cedente_n_sacados base type for findUnique actions
   */
  export type cedente_n_sacadosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the cedente_n_sacados
     * 
    **/
    select?: cedente_n_sacadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_n_sacadosInclude | null
    /**
     * Filter, which cedente_n_sacados to fetch.
     * 
    **/
    where: cedente_n_sacadosWhereUniqueInput
  }

  /**
   * cedente_n_sacados: findUnique
   */
  export interface cedente_n_sacadosFindUniqueArgs extends cedente_n_sacadosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cedente_n_sacados base type for findFirst actions
   */
  export type cedente_n_sacadosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the cedente_n_sacados
     * 
    **/
    select?: cedente_n_sacadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_n_sacadosInclude | null
    /**
     * Filter, which cedente_n_sacados to fetch.
     * 
    **/
    where?: cedente_n_sacadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedente_n_sacados to fetch.
     * 
    **/
    orderBy?: Enumerable<cedente_n_sacadosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cedente_n_sacados.
     * 
    **/
    cursor?: cedente_n_sacadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedente_n_sacados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedente_n_sacados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cedente_n_sacados.
     * 
    **/
    distinct?: Enumerable<Cedente_n_sacadosScalarFieldEnum>
  }

  /**
   * cedente_n_sacados: findFirst
   */
  export interface cedente_n_sacadosFindFirstArgs extends cedente_n_sacadosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cedente_n_sacados findMany
   */
  export type cedente_n_sacadosFindManyArgs = {
    /**
     * Select specific fields to fetch from the cedente_n_sacados
     * 
    **/
    select?: cedente_n_sacadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_n_sacadosInclude | null
    /**
     * Filter, which cedente_n_sacados to fetch.
     * 
    **/
    where?: cedente_n_sacadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedente_n_sacados to fetch.
     * 
    **/
    orderBy?: Enumerable<cedente_n_sacadosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cedente_n_sacados.
     * 
    **/
    cursor?: cedente_n_sacadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedente_n_sacados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedente_n_sacados.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Cedente_n_sacadosScalarFieldEnum>
  }


  /**
   * cedente_n_sacados create
   */
  export type cedente_n_sacadosCreateArgs = {
    /**
     * Select specific fields to fetch from the cedente_n_sacados
     * 
    **/
    select?: cedente_n_sacadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_n_sacadosInclude | null
    /**
     * The data needed to create a cedente_n_sacados.
     * 
    **/
    data: XOR<cedente_n_sacadosCreateInput, cedente_n_sacadosUncheckedCreateInput>
  }


  /**
   * cedente_n_sacados createMany
   */
  export type cedente_n_sacadosCreateManyArgs = {
    /**
     * The data used to create many cedente_n_sacados.
     * 
    **/
    data: Enumerable<cedente_n_sacadosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * cedente_n_sacados update
   */
  export type cedente_n_sacadosUpdateArgs = {
    /**
     * Select specific fields to fetch from the cedente_n_sacados
     * 
    **/
    select?: cedente_n_sacadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_n_sacadosInclude | null
    /**
     * The data needed to update a cedente_n_sacados.
     * 
    **/
    data: XOR<cedente_n_sacadosUpdateInput, cedente_n_sacadosUncheckedUpdateInput>
    /**
     * Choose, which cedente_n_sacados to update.
     * 
    **/
    where: cedente_n_sacadosWhereUniqueInput
  }


  /**
   * cedente_n_sacados updateMany
   */
  export type cedente_n_sacadosUpdateManyArgs = {
    /**
     * The data used to update cedente_n_sacados.
     * 
    **/
    data: XOR<cedente_n_sacadosUpdateManyMutationInput, cedente_n_sacadosUncheckedUpdateManyInput>
    /**
     * Filter which cedente_n_sacados to update
     * 
    **/
    where?: cedente_n_sacadosWhereInput
  }


  /**
   * cedente_n_sacados upsert
   */
  export type cedente_n_sacadosUpsertArgs = {
    /**
     * Select specific fields to fetch from the cedente_n_sacados
     * 
    **/
    select?: cedente_n_sacadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_n_sacadosInclude | null
    /**
     * The filter to search for the cedente_n_sacados to update in case it exists.
     * 
    **/
    where: cedente_n_sacadosWhereUniqueInput
    /**
     * In case the cedente_n_sacados found by the `where` argument doesn't exist, create a new cedente_n_sacados with this data.
     * 
    **/
    create: XOR<cedente_n_sacadosCreateInput, cedente_n_sacadosUncheckedCreateInput>
    /**
     * In case the cedente_n_sacados was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<cedente_n_sacadosUpdateInput, cedente_n_sacadosUncheckedUpdateInput>
  }


  /**
   * cedente_n_sacados delete
   */
  export type cedente_n_sacadosDeleteArgs = {
    /**
     * Select specific fields to fetch from the cedente_n_sacados
     * 
    **/
    select?: cedente_n_sacadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_n_sacadosInclude | null
    /**
     * Filter which cedente_n_sacados to delete.
     * 
    **/
    where: cedente_n_sacadosWhereUniqueInput
  }


  /**
   * cedente_n_sacados deleteMany
   */
  export type cedente_n_sacadosDeleteManyArgs = {
    /**
     * Filter which cedente_n_sacados to delete
     * 
    **/
    where?: cedente_n_sacadosWhereInput
  }


  /**
   * cedente_n_sacados: findUniqueOrThrow
   */
  export type cedente_n_sacadosFindUniqueOrThrowArgs = cedente_n_sacadosFindUniqueArgsBase
      

  /**
   * cedente_n_sacados: findFirstOrThrow
   */
  export type cedente_n_sacadosFindFirstOrThrowArgs = cedente_n_sacadosFindFirstArgsBase
      

  /**
   * cedente_n_sacados without action
   */
  export type cedente_n_sacadosArgs = {
    /**
     * Select specific fields to fetch from the cedente_n_sacados
     * 
    **/
    select?: cedente_n_sacadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_n_sacadosInclude | null
  }



  /**
   * Model checagem
   */


  export type AggregateChecagem = {
    _count: ChecagemCountAggregateOutputType | null
    _avg: ChecagemAvgAggregateOutputType | null
    _sum: ChecagemSumAggregateOutputType | null
    _min: ChecagemMinAggregateOutputType | null
    _max: ChecagemMaxAggregateOutputType | null
  }

  export type ChecagemAvgAggregateOutputType = {
    id: number | null
    usuario: number | null
  }

  export type ChecagemSumAggregateOutputType = {
    id: number | null
    usuario: number | null
  }

  export type ChecagemMinAggregateOutputType = {
    id: number | null
    nf: string | null
    status: string | null
    usuario: number | null
    titulos: string | null
  }

  export type ChecagemMaxAggregateOutputType = {
    id: number | null
    nf: string | null
    status: string | null
    usuario: number | null
    titulos: string | null
  }

  export type ChecagemCountAggregateOutputType = {
    id: number
    nf: number
    status: number
    usuario: number
    titulos: number
    _all: number
  }


  export type ChecagemAvgAggregateInputType = {
    id?: true
    usuario?: true
  }

  export type ChecagemSumAggregateInputType = {
    id?: true
    usuario?: true
  }

  export type ChecagemMinAggregateInputType = {
    id?: true
    nf?: true
    status?: true
    usuario?: true
    titulos?: true
  }

  export type ChecagemMaxAggregateInputType = {
    id?: true
    nf?: true
    status?: true
    usuario?: true
    titulos?: true
  }

  export type ChecagemCountAggregateInputType = {
    id?: true
    nf?: true
    status?: true
    usuario?: true
    titulos?: true
    _all?: true
  }

  export type ChecagemAggregateArgs = {
    /**
     * Filter which checagem to aggregate.
     * 
    **/
    where?: checagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checagems to fetch.
     * 
    **/
    orderBy?: Enumerable<checagemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: checagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checagems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checagems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned checagems
    **/
    _count?: true | ChecagemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChecagemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChecagemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChecagemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChecagemMaxAggregateInputType
  }

  export type GetChecagemAggregateType<T extends ChecagemAggregateArgs> = {
        [P in keyof T & keyof AggregateChecagem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChecagem[P]>
      : GetScalarType<T[P], AggregateChecagem[P]>
  }




  export type ChecagemGroupByArgs = {
    where?: checagemWhereInput
    orderBy?: Enumerable<checagemOrderByWithAggregationInput>
    by: Array<ChecagemScalarFieldEnum>
    having?: checagemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChecagemCountAggregateInputType | true
    _avg?: ChecagemAvgAggregateInputType
    _sum?: ChecagemSumAggregateInputType
    _min?: ChecagemMinAggregateInputType
    _max?: ChecagemMaxAggregateInputType
  }


  export type ChecagemGroupByOutputType = {
    id: number
    nf: string | null
    status: string | null
    usuario: number | null
    titulos: string | null
    _count: ChecagemCountAggregateOutputType | null
    _avg: ChecagemAvgAggregateOutputType | null
    _sum: ChecagemSumAggregateOutputType | null
    _min: ChecagemMinAggregateOutputType | null
    _max: ChecagemMaxAggregateOutputType | null
  }

  type GetChecagemGroupByPayload<T extends ChecagemGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ChecagemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChecagemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChecagemGroupByOutputType[P]>
            : GetScalarType<T[P], ChecagemGroupByOutputType[P]>
        }
      >
    >


  export type checagemSelect = {
    id?: boolean
    nf?: boolean
    status?: boolean
    usuario?: boolean
    titulos?: boolean
    usuario_checagemTousuario?: boolean | usuarioArgs
  }


  export type checagemInclude = {
    usuario_checagemTousuario?: boolean | usuarioArgs
  } 

  export type checagemGetPayload<S extends boolean | null | undefined | checagemArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? checagem :
    S extends undefined ? never :
    S extends { include: any } & (checagemArgs | checagemFindManyArgs)
    ? checagem  & {
    [P in TrueKeys<S['include']>]:
        P extends 'usuario_checagemTousuario' ? usuarioGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : S extends { select: any } & (checagemArgs | checagemFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'usuario_checagemTousuario' ? usuarioGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof checagem ? checagem[P] : never
  } 
      : checagem


  type checagemCountArgs = Merge<
    Omit<checagemFindManyArgs, 'select' | 'include'> & {
      select?: ChecagemCountAggregateInputType | true
    }
  >

  export interface checagemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Checagem that matches the filter.
     * @param {checagemFindUniqueArgs} args - Arguments to find a Checagem
     * @example
     * // Get one Checagem
     * const checagem = await prisma.checagem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends checagemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, checagemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'checagem'> extends True ? Prisma__checagemClient<checagemGetPayload<T>> : Prisma__checagemClient<checagemGetPayload<T> | null, null>

    /**
     * Find the first Checagem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checagemFindFirstArgs} args - Arguments to find a Checagem
     * @example
     * // Get one Checagem
     * const checagem = await prisma.checagem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends checagemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, checagemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'checagem'> extends True ? Prisma__checagemClient<checagemGetPayload<T>> : Prisma__checagemClient<checagemGetPayload<T> | null, null>

    /**
     * Find zero or more Checagems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checagemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Checagems
     * const checagems = await prisma.checagem.findMany()
     * 
     * // Get first 10 Checagems
     * const checagems = await prisma.checagem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checagemWithIdOnly = await prisma.checagem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends checagemFindManyArgs>(
      args?: SelectSubset<T, checagemFindManyArgs>
    ): PrismaPromise<Array<checagemGetPayload<T>>>

    /**
     * Create a Checagem.
     * @param {checagemCreateArgs} args - Arguments to create a Checagem.
     * @example
     * // Create one Checagem
     * const Checagem = await prisma.checagem.create({
     *   data: {
     *     // ... data to create a Checagem
     *   }
     * })
     * 
    **/
    create<T extends checagemCreateArgs>(
      args: SelectSubset<T, checagemCreateArgs>
    ): Prisma__checagemClient<checagemGetPayload<T>>

    /**
     * Create many Checagems.
     *     @param {checagemCreateManyArgs} args - Arguments to create many Checagems.
     *     @example
     *     // Create many Checagems
     *     const checagem = await prisma.checagem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends checagemCreateManyArgs>(
      args?: SelectSubset<T, checagemCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Checagem.
     * @param {checagemDeleteArgs} args - Arguments to delete one Checagem.
     * @example
     * // Delete one Checagem
     * const Checagem = await prisma.checagem.delete({
     *   where: {
     *     // ... filter to delete one Checagem
     *   }
     * })
     * 
    **/
    delete<T extends checagemDeleteArgs>(
      args: SelectSubset<T, checagemDeleteArgs>
    ): Prisma__checagemClient<checagemGetPayload<T>>

    /**
     * Update one Checagem.
     * @param {checagemUpdateArgs} args - Arguments to update one Checagem.
     * @example
     * // Update one Checagem
     * const checagem = await prisma.checagem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends checagemUpdateArgs>(
      args: SelectSubset<T, checagemUpdateArgs>
    ): Prisma__checagemClient<checagemGetPayload<T>>

    /**
     * Delete zero or more Checagems.
     * @param {checagemDeleteManyArgs} args - Arguments to filter Checagems to delete.
     * @example
     * // Delete a few Checagems
     * const { count } = await prisma.checagem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends checagemDeleteManyArgs>(
      args?: SelectSubset<T, checagemDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checagems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checagemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Checagems
     * const checagem = await prisma.checagem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends checagemUpdateManyArgs>(
      args: SelectSubset<T, checagemUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Checagem.
     * @param {checagemUpsertArgs} args - Arguments to update or create a Checagem.
     * @example
     * // Update or create a Checagem
     * const checagem = await prisma.checagem.upsert({
     *   create: {
     *     // ... data to create a Checagem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Checagem we want to update
     *   }
     * })
    **/
    upsert<T extends checagemUpsertArgs>(
      args: SelectSubset<T, checagemUpsertArgs>
    ): Prisma__checagemClient<checagemGetPayload<T>>

    /**
     * Find one Checagem that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {checagemFindUniqueOrThrowArgs} args - Arguments to find a Checagem
     * @example
     * // Get one Checagem
     * const checagem = await prisma.checagem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends checagemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, checagemFindUniqueOrThrowArgs>
    ): Prisma__checagemClient<checagemGetPayload<T>>

    /**
     * Find the first Checagem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checagemFindFirstOrThrowArgs} args - Arguments to find a Checagem
     * @example
     * // Get one Checagem
     * const checagem = await prisma.checagem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends checagemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, checagemFindFirstOrThrowArgs>
    ): Prisma__checagemClient<checagemGetPayload<T>>

    /**
     * Count the number of Checagems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checagemCountArgs} args - Arguments to filter Checagems to count.
     * @example
     * // Count the number of Checagems
     * const count = await prisma.checagem.count({
     *   where: {
     *     // ... the filter for the Checagems we want to count
     *   }
     * })
    **/
    count<T extends checagemCountArgs>(
      args?: Subset<T, checagemCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChecagemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Checagem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecagemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChecagemAggregateArgs>(args: Subset<T, ChecagemAggregateArgs>): PrismaPromise<GetChecagemAggregateType<T>>

    /**
     * Group by Checagem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecagemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChecagemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChecagemGroupByArgs['orderBy'] }
        : { orderBy?: ChecagemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChecagemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChecagemGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for checagem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__checagemClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    usuario_checagemTousuario<T extends usuarioArgs= {}>(args?: Subset<T, usuarioArgs>): Prisma__usuarioClient<usuarioGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * checagem base type for findUnique actions
   */
  export type checagemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the checagem
     * 
    **/
    select?: checagemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: checagemInclude | null
    /**
     * Filter, which checagem to fetch.
     * 
    **/
    where: checagemWhereUniqueInput
  }

  /**
   * checagem: findUnique
   */
  export interface checagemFindUniqueArgs extends checagemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * checagem base type for findFirst actions
   */
  export type checagemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the checagem
     * 
    **/
    select?: checagemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: checagemInclude | null
    /**
     * Filter, which checagem to fetch.
     * 
    **/
    where?: checagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checagems to fetch.
     * 
    **/
    orderBy?: Enumerable<checagemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for checagems.
     * 
    **/
    cursor?: checagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checagems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checagems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of checagems.
     * 
    **/
    distinct?: Enumerable<ChecagemScalarFieldEnum>
  }

  /**
   * checagem: findFirst
   */
  export interface checagemFindFirstArgs extends checagemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * checagem findMany
   */
  export type checagemFindManyArgs = {
    /**
     * Select specific fields to fetch from the checagem
     * 
    **/
    select?: checagemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: checagemInclude | null
    /**
     * Filter, which checagems to fetch.
     * 
    **/
    where?: checagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checagems to fetch.
     * 
    **/
    orderBy?: Enumerable<checagemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing checagems.
     * 
    **/
    cursor?: checagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checagems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checagems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ChecagemScalarFieldEnum>
  }


  /**
   * checagem create
   */
  export type checagemCreateArgs = {
    /**
     * Select specific fields to fetch from the checagem
     * 
    **/
    select?: checagemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: checagemInclude | null
    /**
     * The data needed to create a checagem.
     * 
    **/
    data: XOR<checagemCreateInput, checagemUncheckedCreateInput>
  }


  /**
   * checagem createMany
   */
  export type checagemCreateManyArgs = {
    /**
     * The data used to create many checagems.
     * 
    **/
    data: Enumerable<checagemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * checagem update
   */
  export type checagemUpdateArgs = {
    /**
     * Select specific fields to fetch from the checagem
     * 
    **/
    select?: checagemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: checagemInclude | null
    /**
     * The data needed to update a checagem.
     * 
    **/
    data: XOR<checagemUpdateInput, checagemUncheckedUpdateInput>
    /**
     * Choose, which checagem to update.
     * 
    **/
    where: checagemWhereUniqueInput
  }


  /**
   * checagem updateMany
   */
  export type checagemUpdateManyArgs = {
    /**
     * The data used to update checagems.
     * 
    **/
    data: XOR<checagemUpdateManyMutationInput, checagemUncheckedUpdateManyInput>
    /**
     * Filter which checagems to update
     * 
    **/
    where?: checagemWhereInput
  }


  /**
   * checagem upsert
   */
  export type checagemUpsertArgs = {
    /**
     * Select specific fields to fetch from the checagem
     * 
    **/
    select?: checagemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: checagemInclude | null
    /**
     * The filter to search for the checagem to update in case it exists.
     * 
    **/
    where: checagemWhereUniqueInput
    /**
     * In case the checagem found by the `where` argument doesn't exist, create a new checagem with this data.
     * 
    **/
    create: XOR<checagemCreateInput, checagemUncheckedCreateInput>
    /**
     * In case the checagem was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<checagemUpdateInput, checagemUncheckedUpdateInput>
  }


  /**
   * checagem delete
   */
  export type checagemDeleteArgs = {
    /**
     * Select specific fields to fetch from the checagem
     * 
    **/
    select?: checagemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: checagemInclude | null
    /**
     * Filter which checagem to delete.
     * 
    **/
    where: checagemWhereUniqueInput
  }


  /**
   * checagem deleteMany
   */
  export type checagemDeleteManyArgs = {
    /**
     * Filter which checagems to delete
     * 
    **/
    where?: checagemWhereInput
  }


  /**
   * checagem: findUniqueOrThrow
   */
  export type checagemFindUniqueOrThrowArgs = checagemFindUniqueArgsBase
      

  /**
   * checagem: findFirstOrThrow
   */
  export type checagemFindFirstOrThrowArgs = checagemFindFirstArgsBase
      

  /**
   * checagem without action
   */
  export type checagemArgs = {
    /**
     * Select specific fields to fetch from the checagem
     * 
    **/
    select?: checagemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: checagemInclude | null
  }



  /**
   * Model fidic_fundo
   */


  export type AggregateFidic_fundo = {
    _count: Fidic_fundoCountAggregateOutputType | null
    _avg: Fidic_fundoAvgAggregateOutputType | null
    _sum: Fidic_fundoSumAggregateOutputType | null
    _min: Fidic_fundoMinAggregateOutputType | null
    _max: Fidic_fundoMaxAggregateOutputType | null
  }

  export type Fidic_fundoAvgAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
  }

  export type Fidic_fundoSumAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
  }

  export type Fidic_fundoMinAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
    razao_social: string | null
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
  }

  export type Fidic_fundoMaxAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
    razao_social: string | null
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
  }

  export type Fidic_fundoCountAggregateOutputType = {
    id: number
    pessoa_id: number
    razao_social: number
    nome_fantasia: number
    abertura: number
    cnpj: number
    _all: number
  }


  export type Fidic_fundoAvgAggregateInputType = {
    id?: true
    pessoa_id?: true
  }

  export type Fidic_fundoSumAggregateInputType = {
    id?: true
    pessoa_id?: true
  }

  export type Fidic_fundoMinAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
  }

  export type Fidic_fundoMaxAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
  }

  export type Fidic_fundoCountAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
    _all?: true
  }

  export type Fidic_fundoAggregateArgs = {
    /**
     * Filter which fidic_fundo to aggregate.
     * 
    **/
    where?: fidic_fundoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fidic_fundos to fetch.
     * 
    **/
    orderBy?: Enumerable<fidic_fundoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: fidic_fundoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fidic_fundos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fidic_fundos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fidic_fundos
    **/
    _count?: true | Fidic_fundoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fidic_fundoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fidic_fundoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fidic_fundoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fidic_fundoMaxAggregateInputType
  }

  export type GetFidic_fundoAggregateType<T extends Fidic_fundoAggregateArgs> = {
        [P in keyof T & keyof AggregateFidic_fundo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFidic_fundo[P]>
      : GetScalarType<T[P], AggregateFidic_fundo[P]>
  }




  export type Fidic_fundoGroupByArgs = {
    where?: fidic_fundoWhereInput
    orderBy?: Enumerable<fidic_fundoOrderByWithAggregationInput>
    by: Array<Fidic_fundoScalarFieldEnum>
    having?: fidic_fundoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fidic_fundoCountAggregateInputType | true
    _avg?: Fidic_fundoAvgAggregateInputType
    _sum?: Fidic_fundoSumAggregateInputType
    _min?: Fidic_fundoMinAggregateInputType
    _max?: Fidic_fundoMaxAggregateInputType
  }


  export type Fidic_fundoGroupByOutputType = {
    id: number
    pessoa_id: number
    razao_social: string
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
    _count: Fidic_fundoCountAggregateOutputType | null
    _avg: Fidic_fundoAvgAggregateOutputType | null
    _sum: Fidic_fundoSumAggregateOutputType | null
    _min: Fidic_fundoMinAggregateOutputType | null
    _max: Fidic_fundoMaxAggregateOutputType | null
  }

  type GetFidic_fundoGroupByPayload<T extends Fidic_fundoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Fidic_fundoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fidic_fundoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fidic_fundoGroupByOutputType[P]>
            : GetScalarType<T[P], Fidic_fundoGroupByOutputType[P]>
        }
      >
    >


  export type fidic_fundoSelect = {
    id?: boolean
    pessoa_id?: boolean
    razao_social?: boolean
    nome_fantasia?: boolean
    abertura?: boolean
    cnpj?: boolean
    carteira?: boolean | carteiraFindManyArgs
    fidic_fundo_x_usuario?: boolean | fidic_fundo_x_usuarioFindManyArgs
    _count?: boolean | Fidic_fundoCountOutputTypeArgs
  }


  export type fidic_fundoInclude = {
    carteira?: boolean | carteiraFindManyArgs
    fidic_fundo_x_usuario?: boolean | fidic_fundo_x_usuarioFindManyArgs
    _count?: boolean | Fidic_fundoCountOutputTypeArgs
  } 

  export type fidic_fundoGetPayload<S extends boolean | null | undefined | fidic_fundoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? fidic_fundo :
    S extends undefined ? never :
    S extends { include: any } & (fidic_fundoArgs | fidic_fundoFindManyArgs)
    ? fidic_fundo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'carteira' ? Array < carteiraGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'fidic_fundo_x_usuario' ? Array < fidic_fundo_x_usuarioGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Fidic_fundoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (fidic_fundoArgs | fidic_fundoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'carteira' ? Array < carteiraGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'fidic_fundo_x_usuario' ? Array < fidic_fundo_x_usuarioGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Fidic_fundoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof fidic_fundo ? fidic_fundo[P] : never
  } 
      : fidic_fundo


  type fidic_fundoCountArgs = Merge<
    Omit<fidic_fundoFindManyArgs, 'select' | 'include'> & {
      select?: Fidic_fundoCountAggregateInputType | true
    }
  >

  export interface fidic_fundoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Fidic_fundo that matches the filter.
     * @param {fidic_fundoFindUniqueArgs} args - Arguments to find a Fidic_fundo
     * @example
     * // Get one Fidic_fundo
     * const fidic_fundo = await prisma.fidic_fundo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fidic_fundoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fidic_fundoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fidic_fundo'> extends True ? Prisma__fidic_fundoClient<fidic_fundoGetPayload<T>> : Prisma__fidic_fundoClient<fidic_fundoGetPayload<T> | null, null>

    /**
     * Find the first Fidic_fundo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundoFindFirstArgs} args - Arguments to find a Fidic_fundo
     * @example
     * // Get one Fidic_fundo
     * const fidic_fundo = await prisma.fidic_fundo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fidic_fundoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fidic_fundoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fidic_fundo'> extends True ? Prisma__fidic_fundoClient<fidic_fundoGetPayload<T>> : Prisma__fidic_fundoClient<fidic_fundoGetPayload<T> | null, null>

    /**
     * Find zero or more Fidic_fundos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fidic_fundos
     * const fidic_fundos = await prisma.fidic_fundo.findMany()
     * 
     * // Get first 10 Fidic_fundos
     * const fidic_fundos = await prisma.fidic_fundo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fidic_fundoWithIdOnly = await prisma.fidic_fundo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fidic_fundoFindManyArgs>(
      args?: SelectSubset<T, fidic_fundoFindManyArgs>
    ): PrismaPromise<Array<fidic_fundoGetPayload<T>>>

    /**
     * Create a Fidic_fundo.
     * @param {fidic_fundoCreateArgs} args - Arguments to create a Fidic_fundo.
     * @example
     * // Create one Fidic_fundo
     * const Fidic_fundo = await prisma.fidic_fundo.create({
     *   data: {
     *     // ... data to create a Fidic_fundo
     *   }
     * })
     * 
    **/
    create<T extends fidic_fundoCreateArgs>(
      args: SelectSubset<T, fidic_fundoCreateArgs>
    ): Prisma__fidic_fundoClient<fidic_fundoGetPayload<T>>

    /**
     * Create many Fidic_fundos.
     *     @param {fidic_fundoCreateManyArgs} args - Arguments to create many Fidic_fundos.
     *     @example
     *     // Create many Fidic_fundos
     *     const fidic_fundo = await prisma.fidic_fundo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fidic_fundoCreateManyArgs>(
      args?: SelectSubset<T, fidic_fundoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Fidic_fundo.
     * @param {fidic_fundoDeleteArgs} args - Arguments to delete one Fidic_fundo.
     * @example
     * // Delete one Fidic_fundo
     * const Fidic_fundo = await prisma.fidic_fundo.delete({
     *   where: {
     *     // ... filter to delete one Fidic_fundo
     *   }
     * })
     * 
    **/
    delete<T extends fidic_fundoDeleteArgs>(
      args: SelectSubset<T, fidic_fundoDeleteArgs>
    ): Prisma__fidic_fundoClient<fidic_fundoGetPayload<T>>

    /**
     * Update one Fidic_fundo.
     * @param {fidic_fundoUpdateArgs} args - Arguments to update one Fidic_fundo.
     * @example
     * // Update one Fidic_fundo
     * const fidic_fundo = await prisma.fidic_fundo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fidic_fundoUpdateArgs>(
      args: SelectSubset<T, fidic_fundoUpdateArgs>
    ): Prisma__fidic_fundoClient<fidic_fundoGetPayload<T>>

    /**
     * Delete zero or more Fidic_fundos.
     * @param {fidic_fundoDeleteManyArgs} args - Arguments to filter Fidic_fundos to delete.
     * @example
     * // Delete a few Fidic_fundos
     * const { count } = await prisma.fidic_fundo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fidic_fundoDeleteManyArgs>(
      args?: SelectSubset<T, fidic_fundoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fidic_fundos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fidic_fundos
     * const fidic_fundo = await prisma.fidic_fundo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fidic_fundoUpdateManyArgs>(
      args: SelectSubset<T, fidic_fundoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Fidic_fundo.
     * @param {fidic_fundoUpsertArgs} args - Arguments to update or create a Fidic_fundo.
     * @example
     * // Update or create a Fidic_fundo
     * const fidic_fundo = await prisma.fidic_fundo.upsert({
     *   create: {
     *     // ... data to create a Fidic_fundo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fidic_fundo we want to update
     *   }
     * })
    **/
    upsert<T extends fidic_fundoUpsertArgs>(
      args: SelectSubset<T, fidic_fundoUpsertArgs>
    ): Prisma__fidic_fundoClient<fidic_fundoGetPayload<T>>

    /**
     * Find one Fidic_fundo that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {fidic_fundoFindUniqueOrThrowArgs} args - Arguments to find a Fidic_fundo
     * @example
     * // Get one Fidic_fundo
     * const fidic_fundo = await prisma.fidic_fundo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fidic_fundoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, fidic_fundoFindUniqueOrThrowArgs>
    ): Prisma__fidic_fundoClient<fidic_fundoGetPayload<T>>

    /**
     * Find the first Fidic_fundo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundoFindFirstOrThrowArgs} args - Arguments to find a Fidic_fundo
     * @example
     * // Get one Fidic_fundo
     * const fidic_fundo = await prisma.fidic_fundo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fidic_fundoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, fidic_fundoFindFirstOrThrowArgs>
    ): Prisma__fidic_fundoClient<fidic_fundoGetPayload<T>>

    /**
     * Count the number of Fidic_fundos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundoCountArgs} args - Arguments to filter Fidic_fundos to count.
     * @example
     * // Count the number of Fidic_fundos
     * const count = await prisma.fidic_fundo.count({
     *   where: {
     *     // ... the filter for the Fidic_fundos we want to count
     *   }
     * })
    **/
    count<T extends fidic_fundoCountArgs>(
      args?: Subset<T, fidic_fundoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fidic_fundoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fidic_fundo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fidic_fundoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fidic_fundoAggregateArgs>(args: Subset<T, Fidic_fundoAggregateArgs>): PrismaPromise<GetFidic_fundoAggregateType<T>>

    /**
     * Group by Fidic_fundo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fidic_fundoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Fidic_fundoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Fidic_fundoGroupByArgs['orderBy'] }
        : { orderBy?: Fidic_fundoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Fidic_fundoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFidic_fundoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fidic_fundo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fidic_fundoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    carteira<T extends carteiraFindManyArgs= {}>(args?: Subset<T, carteiraFindManyArgs>): PrismaPromise<Array<carteiraGetPayload<T>>| Null>;

    fidic_fundo_x_usuario<T extends fidic_fundo_x_usuarioFindManyArgs= {}>(args?: Subset<T, fidic_fundo_x_usuarioFindManyArgs>): PrismaPromise<Array<fidic_fundo_x_usuarioGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fidic_fundo base type for findUnique actions
   */
  export type fidic_fundoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the fidic_fundo
     * 
    **/
    select?: fidic_fundoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundoInclude | null
    /**
     * Filter, which fidic_fundo to fetch.
     * 
    **/
    where: fidic_fundoWhereUniqueInput
  }

  /**
   * fidic_fundo: findUnique
   */
  export interface fidic_fundoFindUniqueArgs extends fidic_fundoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fidic_fundo base type for findFirst actions
   */
  export type fidic_fundoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the fidic_fundo
     * 
    **/
    select?: fidic_fundoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundoInclude | null
    /**
     * Filter, which fidic_fundo to fetch.
     * 
    **/
    where?: fidic_fundoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fidic_fundos to fetch.
     * 
    **/
    orderBy?: Enumerable<fidic_fundoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fidic_fundos.
     * 
    **/
    cursor?: fidic_fundoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fidic_fundos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fidic_fundos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fidic_fundos.
     * 
    **/
    distinct?: Enumerable<Fidic_fundoScalarFieldEnum>
  }

  /**
   * fidic_fundo: findFirst
   */
  export interface fidic_fundoFindFirstArgs extends fidic_fundoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fidic_fundo findMany
   */
  export type fidic_fundoFindManyArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo
     * 
    **/
    select?: fidic_fundoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundoInclude | null
    /**
     * Filter, which fidic_fundos to fetch.
     * 
    **/
    where?: fidic_fundoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fidic_fundos to fetch.
     * 
    **/
    orderBy?: Enumerable<fidic_fundoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fidic_fundos.
     * 
    **/
    cursor?: fidic_fundoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fidic_fundos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fidic_fundos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Fidic_fundoScalarFieldEnum>
  }


  /**
   * fidic_fundo create
   */
  export type fidic_fundoCreateArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo
     * 
    **/
    select?: fidic_fundoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundoInclude | null
    /**
     * The data needed to create a fidic_fundo.
     * 
    **/
    data: XOR<fidic_fundoCreateInput, fidic_fundoUncheckedCreateInput>
  }


  /**
   * fidic_fundo createMany
   */
  export type fidic_fundoCreateManyArgs = {
    /**
     * The data used to create many fidic_fundos.
     * 
    **/
    data: Enumerable<fidic_fundoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * fidic_fundo update
   */
  export type fidic_fundoUpdateArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo
     * 
    **/
    select?: fidic_fundoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundoInclude | null
    /**
     * The data needed to update a fidic_fundo.
     * 
    **/
    data: XOR<fidic_fundoUpdateInput, fidic_fundoUncheckedUpdateInput>
    /**
     * Choose, which fidic_fundo to update.
     * 
    **/
    where: fidic_fundoWhereUniqueInput
  }


  /**
   * fidic_fundo updateMany
   */
  export type fidic_fundoUpdateManyArgs = {
    /**
     * The data used to update fidic_fundos.
     * 
    **/
    data: XOR<fidic_fundoUpdateManyMutationInput, fidic_fundoUncheckedUpdateManyInput>
    /**
     * Filter which fidic_fundos to update
     * 
    **/
    where?: fidic_fundoWhereInput
  }


  /**
   * fidic_fundo upsert
   */
  export type fidic_fundoUpsertArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo
     * 
    **/
    select?: fidic_fundoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundoInclude | null
    /**
     * The filter to search for the fidic_fundo to update in case it exists.
     * 
    **/
    where: fidic_fundoWhereUniqueInput
    /**
     * In case the fidic_fundo found by the `where` argument doesn't exist, create a new fidic_fundo with this data.
     * 
    **/
    create: XOR<fidic_fundoCreateInput, fidic_fundoUncheckedCreateInput>
    /**
     * In case the fidic_fundo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<fidic_fundoUpdateInput, fidic_fundoUncheckedUpdateInput>
  }


  /**
   * fidic_fundo delete
   */
  export type fidic_fundoDeleteArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo
     * 
    **/
    select?: fidic_fundoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundoInclude | null
    /**
     * Filter which fidic_fundo to delete.
     * 
    **/
    where: fidic_fundoWhereUniqueInput
  }


  /**
   * fidic_fundo deleteMany
   */
  export type fidic_fundoDeleteManyArgs = {
    /**
     * Filter which fidic_fundos to delete
     * 
    **/
    where?: fidic_fundoWhereInput
  }


  /**
   * fidic_fundo: findUniqueOrThrow
   */
  export type fidic_fundoFindUniqueOrThrowArgs = fidic_fundoFindUniqueArgsBase
      

  /**
   * fidic_fundo: findFirstOrThrow
   */
  export type fidic_fundoFindFirstOrThrowArgs = fidic_fundoFindFirstArgsBase
      

  /**
   * fidic_fundo without action
   */
  export type fidic_fundoArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo
     * 
    **/
    select?: fidic_fundoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundoInclude | null
  }



  /**
   * Model fidic_fundo_carteira_n_cedentes
   */


  export type AggregateFidic_fundo_carteira_n_cedentes = {
    _count: Fidic_fundo_carteira_n_cedentesCountAggregateOutputType | null
    _avg: Fidic_fundo_carteira_n_cedentesAvgAggregateOutputType | null
    _sum: Fidic_fundo_carteira_n_cedentesSumAggregateOutputType | null
    _min: Fidic_fundo_carteira_n_cedentesMinAggregateOutputType | null
    _max: Fidic_fundo_carteira_n_cedentesMaxAggregateOutputType | null
  }

  export type Fidic_fundo_carteira_n_cedentesAvgAggregateOutputType = {
    id: number | null
  }

  export type Fidic_fundo_carteira_n_cedentesSumAggregateOutputType = {
    id: number | null
  }

  export type Fidic_fundo_carteira_n_cedentesMinAggregateOutputType = {
    id: number | null
  }

  export type Fidic_fundo_carteira_n_cedentesMaxAggregateOutputType = {
    id: number | null
  }

  export type Fidic_fundo_carteira_n_cedentesCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type Fidic_fundo_carteira_n_cedentesAvgAggregateInputType = {
    id?: true
  }

  export type Fidic_fundo_carteira_n_cedentesSumAggregateInputType = {
    id?: true
  }

  export type Fidic_fundo_carteira_n_cedentesMinAggregateInputType = {
    id?: true
  }

  export type Fidic_fundo_carteira_n_cedentesMaxAggregateInputType = {
    id?: true
  }

  export type Fidic_fundo_carteira_n_cedentesCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type Fidic_fundo_carteira_n_cedentesAggregateArgs = {
    /**
     * Filter which fidic_fundo_carteira_n_cedentes to aggregate.
     * 
    **/
    where?: fidic_fundo_carteira_n_cedentesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fidic_fundo_carteira_n_cedentes to fetch.
     * 
    **/
    orderBy?: Enumerable<fidic_fundo_carteira_n_cedentesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: fidic_fundo_carteira_n_cedentesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fidic_fundo_carteira_n_cedentes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fidic_fundo_carteira_n_cedentes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fidic_fundo_carteira_n_cedentes
    **/
    _count?: true | Fidic_fundo_carteira_n_cedentesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fidic_fundo_carteira_n_cedentesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fidic_fundo_carteira_n_cedentesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fidic_fundo_carteira_n_cedentesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fidic_fundo_carteira_n_cedentesMaxAggregateInputType
  }

  export type GetFidic_fundo_carteira_n_cedentesAggregateType<T extends Fidic_fundo_carteira_n_cedentesAggregateArgs> = {
        [P in keyof T & keyof AggregateFidic_fundo_carteira_n_cedentes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFidic_fundo_carteira_n_cedentes[P]>
      : GetScalarType<T[P], AggregateFidic_fundo_carteira_n_cedentes[P]>
  }




  export type Fidic_fundo_carteira_n_cedentesGroupByArgs = {
    where?: fidic_fundo_carteira_n_cedentesWhereInput
    orderBy?: Enumerable<fidic_fundo_carteira_n_cedentesOrderByWithAggregationInput>
    by: Array<Fidic_fundo_carteira_n_cedentesScalarFieldEnum>
    having?: fidic_fundo_carteira_n_cedentesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fidic_fundo_carteira_n_cedentesCountAggregateInputType | true
    _avg?: Fidic_fundo_carteira_n_cedentesAvgAggregateInputType
    _sum?: Fidic_fundo_carteira_n_cedentesSumAggregateInputType
    _min?: Fidic_fundo_carteira_n_cedentesMinAggregateInputType
    _max?: Fidic_fundo_carteira_n_cedentesMaxAggregateInputType
  }


  export type Fidic_fundo_carteira_n_cedentesGroupByOutputType = {
    id: number
    _count: Fidic_fundo_carteira_n_cedentesCountAggregateOutputType | null
    _avg: Fidic_fundo_carteira_n_cedentesAvgAggregateOutputType | null
    _sum: Fidic_fundo_carteira_n_cedentesSumAggregateOutputType | null
    _min: Fidic_fundo_carteira_n_cedentesMinAggregateOutputType | null
    _max: Fidic_fundo_carteira_n_cedentesMaxAggregateOutputType | null
  }

  type GetFidic_fundo_carteira_n_cedentesGroupByPayload<T extends Fidic_fundo_carteira_n_cedentesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Fidic_fundo_carteira_n_cedentesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fidic_fundo_carteira_n_cedentesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fidic_fundo_carteira_n_cedentesGroupByOutputType[P]>
            : GetScalarType<T[P], Fidic_fundo_carteira_n_cedentesGroupByOutputType[P]>
        }
      >
    >


  export type fidic_fundo_carteira_n_cedentesSelect = {
    id?: boolean
  }


  export type fidic_fundo_carteira_n_cedentesGetPayload<S extends boolean | null | undefined | fidic_fundo_carteira_n_cedentesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? fidic_fundo_carteira_n_cedentes :
    S extends undefined ? never :
    S extends { include: any } & (fidic_fundo_carteira_n_cedentesArgs | fidic_fundo_carteira_n_cedentesFindManyArgs)
    ? fidic_fundo_carteira_n_cedentes 
    : S extends { select: any } & (fidic_fundo_carteira_n_cedentesArgs | fidic_fundo_carteira_n_cedentesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof fidic_fundo_carteira_n_cedentes ? fidic_fundo_carteira_n_cedentes[P] : never
  } 
      : fidic_fundo_carteira_n_cedentes


  type fidic_fundo_carteira_n_cedentesCountArgs = Merge<
    Omit<fidic_fundo_carteira_n_cedentesFindManyArgs, 'select' | 'include'> & {
      select?: Fidic_fundo_carteira_n_cedentesCountAggregateInputType | true
    }
  >

  export interface fidic_fundo_carteira_n_cedentesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Fidic_fundo_carteira_n_cedentes that matches the filter.
     * @param {fidic_fundo_carteira_n_cedentesFindUniqueArgs} args - Arguments to find a Fidic_fundo_carteira_n_cedentes
     * @example
     * // Get one Fidic_fundo_carteira_n_cedentes
     * const fidic_fundo_carteira_n_cedentes = await prisma.fidic_fundo_carteira_n_cedentes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fidic_fundo_carteira_n_cedentesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fidic_fundo_carteira_n_cedentesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fidic_fundo_carteira_n_cedentes'> extends True ? Prisma__fidic_fundo_carteira_n_cedentesClient<fidic_fundo_carteira_n_cedentesGetPayload<T>> : Prisma__fidic_fundo_carteira_n_cedentesClient<fidic_fundo_carteira_n_cedentesGetPayload<T> | null, null>

    /**
     * Find the first Fidic_fundo_carteira_n_cedentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundo_carteira_n_cedentesFindFirstArgs} args - Arguments to find a Fidic_fundo_carteira_n_cedentes
     * @example
     * // Get one Fidic_fundo_carteira_n_cedentes
     * const fidic_fundo_carteira_n_cedentes = await prisma.fidic_fundo_carteira_n_cedentes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fidic_fundo_carteira_n_cedentesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fidic_fundo_carteira_n_cedentesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fidic_fundo_carteira_n_cedentes'> extends True ? Prisma__fidic_fundo_carteira_n_cedentesClient<fidic_fundo_carteira_n_cedentesGetPayload<T>> : Prisma__fidic_fundo_carteira_n_cedentesClient<fidic_fundo_carteira_n_cedentesGetPayload<T> | null, null>

    /**
     * Find zero or more Fidic_fundo_carteira_n_cedentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundo_carteira_n_cedentesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fidic_fundo_carteira_n_cedentes
     * const fidic_fundo_carteira_n_cedentes = await prisma.fidic_fundo_carteira_n_cedentes.findMany()
     * 
     * // Get first 10 Fidic_fundo_carteira_n_cedentes
     * const fidic_fundo_carteira_n_cedentes = await prisma.fidic_fundo_carteira_n_cedentes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fidic_fundo_carteira_n_cedentesWithIdOnly = await prisma.fidic_fundo_carteira_n_cedentes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fidic_fundo_carteira_n_cedentesFindManyArgs>(
      args?: SelectSubset<T, fidic_fundo_carteira_n_cedentesFindManyArgs>
    ): PrismaPromise<Array<fidic_fundo_carteira_n_cedentesGetPayload<T>>>

    /**
     * Create a Fidic_fundo_carteira_n_cedentes.
     * @param {fidic_fundo_carteira_n_cedentesCreateArgs} args - Arguments to create a Fidic_fundo_carteira_n_cedentes.
     * @example
     * // Create one Fidic_fundo_carteira_n_cedentes
     * const Fidic_fundo_carteira_n_cedentes = await prisma.fidic_fundo_carteira_n_cedentes.create({
     *   data: {
     *     // ... data to create a Fidic_fundo_carteira_n_cedentes
     *   }
     * })
     * 
    **/
    create<T extends fidic_fundo_carteira_n_cedentesCreateArgs>(
      args: SelectSubset<T, fidic_fundo_carteira_n_cedentesCreateArgs>
    ): Prisma__fidic_fundo_carteira_n_cedentesClient<fidic_fundo_carteira_n_cedentesGetPayload<T>>

    /**
     * Create many Fidic_fundo_carteira_n_cedentes.
     *     @param {fidic_fundo_carteira_n_cedentesCreateManyArgs} args - Arguments to create many Fidic_fundo_carteira_n_cedentes.
     *     @example
     *     // Create many Fidic_fundo_carteira_n_cedentes
     *     const fidic_fundo_carteira_n_cedentes = await prisma.fidic_fundo_carteira_n_cedentes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fidic_fundo_carteira_n_cedentesCreateManyArgs>(
      args?: SelectSubset<T, fidic_fundo_carteira_n_cedentesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Fidic_fundo_carteira_n_cedentes.
     * @param {fidic_fundo_carteira_n_cedentesDeleteArgs} args - Arguments to delete one Fidic_fundo_carteira_n_cedentes.
     * @example
     * // Delete one Fidic_fundo_carteira_n_cedentes
     * const Fidic_fundo_carteira_n_cedentes = await prisma.fidic_fundo_carteira_n_cedentes.delete({
     *   where: {
     *     // ... filter to delete one Fidic_fundo_carteira_n_cedentes
     *   }
     * })
     * 
    **/
    delete<T extends fidic_fundo_carteira_n_cedentesDeleteArgs>(
      args: SelectSubset<T, fidic_fundo_carteira_n_cedentesDeleteArgs>
    ): Prisma__fidic_fundo_carteira_n_cedentesClient<fidic_fundo_carteira_n_cedentesGetPayload<T>>

    /**
     * Update one Fidic_fundo_carteira_n_cedentes.
     * @param {fidic_fundo_carteira_n_cedentesUpdateArgs} args - Arguments to update one Fidic_fundo_carteira_n_cedentes.
     * @example
     * // Update one Fidic_fundo_carteira_n_cedentes
     * const fidic_fundo_carteira_n_cedentes = await prisma.fidic_fundo_carteira_n_cedentes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fidic_fundo_carteira_n_cedentesUpdateArgs>(
      args: SelectSubset<T, fidic_fundo_carteira_n_cedentesUpdateArgs>
    ): Prisma__fidic_fundo_carteira_n_cedentesClient<fidic_fundo_carteira_n_cedentesGetPayload<T>>

    /**
     * Delete zero or more Fidic_fundo_carteira_n_cedentes.
     * @param {fidic_fundo_carteira_n_cedentesDeleteManyArgs} args - Arguments to filter Fidic_fundo_carteira_n_cedentes to delete.
     * @example
     * // Delete a few Fidic_fundo_carteira_n_cedentes
     * const { count } = await prisma.fidic_fundo_carteira_n_cedentes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fidic_fundo_carteira_n_cedentesDeleteManyArgs>(
      args?: SelectSubset<T, fidic_fundo_carteira_n_cedentesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fidic_fundo_carteira_n_cedentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundo_carteira_n_cedentesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fidic_fundo_carteira_n_cedentes
     * const fidic_fundo_carteira_n_cedentes = await prisma.fidic_fundo_carteira_n_cedentes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fidic_fundo_carteira_n_cedentesUpdateManyArgs>(
      args: SelectSubset<T, fidic_fundo_carteira_n_cedentesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Fidic_fundo_carteira_n_cedentes.
     * @param {fidic_fundo_carteira_n_cedentesUpsertArgs} args - Arguments to update or create a Fidic_fundo_carteira_n_cedentes.
     * @example
     * // Update or create a Fidic_fundo_carteira_n_cedentes
     * const fidic_fundo_carteira_n_cedentes = await prisma.fidic_fundo_carteira_n_cedentes.upsert({
     *   create: {
     *     // ... data to create a Fidic_fundo_carteira_n_cedentes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fidic_fundo_carteira_n_cedentes we want to update
     *   }
     * })
    **/
    upsert<T extends fidic_fundo_carteira_n_cedentesUpsertArgs>(
      args: SelectSubset<T, fidic_fundo_carteira_n_cedentesUpsertArgs>
    ): Prisma__fidic_fundo_carteira_n_cedentesClient<fidic_fundo_carteira_n_cedentesGetPayload<T>>

    /**
     * Find one Fidic_fundo_carteira_n_cedentes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {fidic_fundo_carteira_n_cedentesFindUniqueOrThrowArgs} args - Arguments to find a Fidic_fundo_carteira_n_cedentes
     * @example
     * // Get one Fidic_fundo_carteira_n_cedentes
     * const fidic_fundo_carteira_n_cedentes = await prisma.fidic_fundo_carteira_n_cedentes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fidic_fundo_carteira_n_cedentesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, fidic_fundo_carteira_n_cedentesFindUniqueOrThrowArgs>
    ): Prisma__fidic_fundo_carteira_n_cedentesClient<fidic_fundo_carteira_n_cedentesGetPayload<T>>

    /**
     * Find the first Fidic_fundo_carteira_n_cedentes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundo_carteira_n_cedentesFindFirstOrThrowArgs} args - Arguments to find a Fidic_fundo_carteira_n_cedentes
     * @example
     * // Get one Fidic_fundo_carteira_n_cedentes
     * const fidic_fundo_carteira_n_cedentes = await prisma.fidic_fundo_carteira_n_cedentes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fidic_fundo_carteira_n_cedentesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, fidic_fundo_carteira_n_cedentesFindFirstOrThrowArgs>
    ): Prisma__fidic_fundo_carteira_n_cedentesClient<fidic_fundo_carteira_n_cedentesGetPayload<T>>

    /**
     * Count the number of Fidic_fundo_carteira_n_cedentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundo_carteira_n_cedentesCountArgs} args - Arguments to filter Fidic_fundo_carteira_n_cedentes to count.
     * @example
     * // Count the number of Fidic_fundo_carteira_n_cedentes
     * const count = await prisma.fidic_fundo_carteira_n_cedentes.count({
     *   where: {
     *     // ... the filter for the Fidic_fundo_carteira_n_cedentes we want to count
     *   }
     * })
    **/
    count<T extends fidic_fundo_carteira_n_cedentesCountArgs>(
      args?: Subset<T, fidic_fundo_carteira_n_cedentesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fidic_fundo_carteira_n_cedentesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fidic_fundo_carteira_n_cedentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fidic_fundo_carteira_n_cedentesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fidic_fundo_carteira_n_cedentesAggregateArgs>(args: Subset<T, Fidic_fundo_carteira_n_cedentesAggregateArgs>): PrismaPromise<GetFidic_fundo_carteira_n_cedentesAggregateType<T>>

    /**
     * Group by Fidic_fundo_carteira_n_cedentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fidic_fundo_carteira_n_cedentesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Fidic_fundo_carteira_n_cedentesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Fidic_fundo_carteira_n_cedentesGroupByArgs['orderBy'] }
        : { orderBy?: Fidic_fundo_carteira_n_cedentesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Fidic_fundo_carteira_n_cedentesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFidic_fundo_carteira_n_cedentesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fidic_fundo_carteira_n_cedentes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fidic_fundo_carteira_n_cedentesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fidic_fundo_carteira_n_cedentes base type for findUnique actions
   */
  export type fidic_fundo_carteira_n_cedentesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the fidic_fundo_carteira_n_cedentes
     * 
    **/
    select?: fidic_fundo_carteira_n_cedentesSelect | null
    /**
     * Filter, which fidic_fundo_carteira_n_cedentes to fetch.
     * 
    **/
    where: fidic_fundo_carteira_n_cedentesWhereUniqueInput
  }

  /**
   * fidic_fundo_carteira_n_cedentes: findUnique
   */
  export interface fidic_fundo_carteira_n_cedentesFindUniqueArgs extends fidic_fundo_carteira_n_cedentesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fidic_fundo_carteira_n_cedentes base type for findFirst actions
   */
  export type fidic_fundo_carteira_n_cedentesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the fidic_fundo_carteira_n_cedentes
     * 
    **/
    select?: fidic_fundo_carteira_n_cedentesSelect | null
    /**
     * Filter, which fidic_fundo_carteira_n_cedentes to fetch.
     * 
    **/
    where?: fidic_fundo_carteira_n_cedentesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fidic_fundo_carteira_n_cedentes to fetch.
     * 
    **/
    orderBy?: Enumerable<fidic_fundo_carteira_n_cedentesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fidic_fundo_carteira_n_cedentes.
     * 
    **/
    cursor?: fidic_fundo_carteira_n_cedentesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fidic_fundo_carteira_n_cedentes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fidic_fundo_carteira_n_cedentes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fidic_fundo_carteira_n_cedentes.
     * 
    **/
    distinct?: Enumerable<Fidic_fundo_carteira_n_cedentesScalarFieldEnum>
  }

  /**
   * fidic_fundo_carteira_n_cedentes: findFirst
   */
  export interface fidic_fundo_carteira_n_cedentesFindFirstArgs extends fidic_fundo_carteira_n_cedentesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fidic_fundo_carteira_n_cedentes findMany
   */
  export type fidic_fundo_carteira_n_cedentesFindManyArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_carteira_n_cedentes
     * 
    **/
    select?: fidic_fundo_carteira_n_cedentesSelect | null
    /**
     * Filter, which fidic_fundo_carteira_n_cedentes to fetch.
     * 
    **/
    where?: fidic_fundo_carteira_n_cedentesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fidic_fundo_carteira_n_cedentes to fetch.
     * 
    **/
    orderBy?: Enumerable<fidic_fundo_carteira_n_cedentesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fidic_fundo_carteira_n_cedentes.
     * 
    **/
    cursor?: fidic_fundo_carteira_n_cedentesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fidic_fundo_carteira_n_cedentes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fidic_fundo_carteira_n_cedentes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Fidic_fundo_carteira_n_cedentesScalarFieldEnum>
  }


  /**
   * fidic_fundo_carteira_n_cedentes create
   */
  export type fidic_fundo_carteira_n_cedentesCreateArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_carteira_n_cedentes
     * 
    **/
    select?: fidic_fundo_carteira_n_cedentesSelect | null
    /**
     * The data needed to create a fidic_fundo_carteira_n_cedentes.
     * 
    **/
    data?: XOR<fidic_fundo_carteira_n_cedentesCreateInput, fidic_fundo_carteira_n_cedentesUncheckedCreateInput>
  }


  /**
   * fidic_fundo_carteira_n_cedentes createMany
   */
  export type fidic_fundo_carteira_n_cedentesCreateManyArgs = {
    /**
     * The data used to create many fidic_fundo_carteira_n_cedentes.
     * 
    **/
    data: Enumerable<fidic_fundo_carteira_n_cedentesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * fidic_fundo_carteira_n_cedentes update
   */
  export type fidic_fundo_carteira_n_cedentesUpdateArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_carteira_n_cedentes
     * 
    **/
    select?: fidic_fundo_carteira_n_cedentesSelect | null
    /**
     * The data needed to update a fidic_fundo_carteira_n_cedentes.
     * 
    **/
    data: XOR<fidic_fundo_carteira_n_cedentesUpdateInput, fidic_fundo_carteira_n_cedentesUncheckedUpdateInput>
    /**
     * Choose, which fidic_fundo_carteira_n_cedentes to update.
     * 
    **/
    where: fidic_fundo_carteira_n_cedentesWhereUniqueInput
  }


  /**
   * fidic_fundo_carteira_n_cedentes updateMany
   */
  export type fidic_fundo_carteira_n_cedentesUpdateManyArgs = {
    /**
     * The data used to update fidic_fundo_carteira_n_cedentes.
     * 
    **/
    data: XOR<fidic_fundo_carteira_n_cedentesUpdateManyMutationInput, fidic_fundo_carteira_n_cedentesUncheckedUpdateManyInput>
    /**
     * Filter which fidic_fundo_carteira_n_cedentes to update
     * 
    **/
    where?: fidic_fundo_carteira_n_cedentesWhereInput
  }


  /**
   * fidic_fundo_carteira_n_cedentes upsert
   */
  export type fidic_fundo_carteira_n_cedentesUpsertArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_carteira_n_cedentes
     * 
    **/
    select?: fidic_fundo_carteira_n_cedentesSelect | null
    /**
     * The filter to search for the fidic_fundo_carteira_n_cedentes to update in case it exists.
     * 
    **/
    where: fidic_fundo_carteira_n_cedentesWhereUniqueInput
    /**
     * In case the fidic_fundo_carteira_n_cedentes found by the `where` argument doesn't exist, create a new fidic_fundo_carteira_n_cedentes with this data.
     * 
    **/
    create: XOR<fidic_fundo_carteira_n_cedentesCreateInput, fidic_fundo_carteira_n_cedentesUncheckedCreateInput>
    /**
     * In case the fidic_fundo_carteira_n_cedentes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<fidic_fundo_carteira_n_cedentesUpdateInput, fidic_fundo_carteira_n_cedentesUncheckedUpdateInput>
  }


  /**
   * fidic_fundo_carteira_n_cedentes delete
   */
  export type fidic_fundo_carteira_n_cedentesDeleteArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_carteira_n_cedentes
     * 
    **/
    select?: fidic_fundo_carteira_n_cedentesSelect | null
    /**
     * Filter which fidic_fundo_carteira_n_cedentes to delete.
     * 
    **/
    where: fidic_fundo_carteira_n_cedentesWhereUniqueInput
  }


  /**
   * fidic_fundo_carteira_n_cedentes deleteMany
   */
  export type fidic_fundo_carteira_n_cedentesDeleteManyArgs = {
    /**
     * Filter which fidic_fundo_carteira_n_cedentes to delete
     * 
    **/
    where?: fidic_fundo_carteira_n_cedentesWhereInput
  }


  /**
   * fidic_fundo_carteira_n_cedentes: findUniqueOrThrow
   */
  export type fidic_fundo_carteira_n_cedentesFindUniqueOrThrowArgs = fidic_fundo_carteira_n_cedentesFindUniqueArgsBase
      

  /**
   * fidic_fundo_carteira_n_cedentes: findFirstOrThrow
   */
  export type fidic_fundo_carteira_n_cedentesFindFirstOrThrowArgs = fidic_fundo_carteira_n_cedentesFindFirstArgsBase
      

  /**
   * fidic_fundo_carteira_n_cedentes without action
   */
  export type fidic_fundo_carteira_n_cedentesArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_carteira_n_cedentes
     * 
    **/
    select?: fidic_fundo_carteira_n_cedentesSelect | null
  }



  /**
   * Model fidic_fundo_x_usuario
   */


  export type AggregateFidic_fundo_x_usuario = {
    _count: Fidic_fundo_x_usuarioCountAggregateOutputType | null
    _avg: Fidic_fundo_x_usuarioAvgAggregateOutputType | null
    _sum: Fidic_fundo_x_usuarioSumAggregateOutputType | null
    _min: Fidic_fundo_x_usuarioMinAggregateOutputType | null
    _max: Fidic_fundo_x_usuarioMaxAggregateOutputType | null
  }

  export type Fidic_fundo_x_usuarioAvgAggregateOutputType = {
    id: number | null
    usuario: number | null
    fidic: number | null
  }

  export type Fidic_fundo_x_usuarioSumAggregateOutputType = {
    id: number | null
    usuario: number | null
    fidic: number | null
  }

  export type Fidic_fundo_x_usuarioMinAggregateOutputType = {
    id: number | null
    usuario: number | null
    fidic: number | null
  }

  export type Fidic_fundo_x_usuarioMaxAggregateOutputType = {
    id: number | null
    usuario: number | null
    fidic: number | null
  }

  export type Fidic_fundo_x_usuarioCountAggregateOutputType = {
    id: number
    usuario: number
    fidic: number
    _all: number
  }


  export type Fidic_fundo_x_usuarioAvgAggregateInputType = {
    id?: true
    usuario?: true
    fidic?: true
  }

  export type Fidic_fundo_x_usuarioSumAggregateInputType = {
    id?: true
    usuario?: true
    fidic?: true
  }

  export type Fidic_fundo_x_usuarioMinAggregateInputType = {
    id?: true
    usuario?: true
    fidic?: true
  }

  export type Fidic_fundo_x_usuarioMaxAggregateInputType = {
    id?: true
    usuario?: true
    fidic?: true
  }

  export type Fidic_fundo_x_usuarioCountAggregateInputType = {
    id?: true
    usuario?: true
    fidic?: true
    _all?: true
  }

  export type Fidic_fundo_x_usuarioAggregateArgs = {
    /**
     * Filter which fidic_fundo_x_usuario to aggregate.
     * 
    **/
    where?: fidic_fundo_x_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fidic_fundo_x_usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<fidic_fundo_x_usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: fidic_fundo_x_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fidic_fundo_x_usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fidic_fundo_x_usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fidic_fundo_x_usuarios
    **/
    _count?: true | Fidic_fundo_x_usuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fidic_fundo_x_usuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fidic_fundo_x_usuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fidic_fundo_x_usuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fidic_fundo_x_usuarioMaxAggregateInputType
  }

  export type GetFidic_fundo_x_usuarioAggregateType<T extends Fidic_fundo_x_usuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateFidic_fundo_x_usuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFidic_fundo_x_usuario[P]>
      : GetScalarType<T[P], AggregateFidic_fundo_x_usuario[P]>
  }




  export type Fidic_fundo_x_usuarioGroupByArgs = {
    where?: fidic_fundo_x_usuarioWhereInput
    orderBy?: Enumerable<fidic_fundo_x_usuarioOrderByWithAggregationInput>
    by: Array<Fidic_fundo_x_usuarioScalarFieldEnum>
    having?: fidic_fundo_x_usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fidic_fundo_x_usuarioCountAggregateInputType | true
    _avg?: Fidic_fundo_x_usuarioAvgAggregateInputType
    _sum?: Fidic_fundo_x_usuarioSumAggregateInputType
    _min?: Fidic_fundo_x_usuarioMinAggregateInputType
    _max?: Fidic_fundo_x_usuarioMaxAggregateInputType
  }


  export type Fidic_fundo_x_usuarioGroupByOutputType = {
    id: number
    usuario: number | null
    fidic: number
    _count: Fidic_fundo_x_usuarioCountAggregateOutputType | null
    _avg: Fidic_fundo_x_usuarioAvgAggregateOutputType | null
    _sum: Fidic_fundo_x_usuarioSumAggregateOutputType | null
    _min: Fidic_fundo_x_usuarioMinAggregateOutputType | null
    _max: Fidic_fundo_x_usuarioMaxAggregateOutputType | null
  }

  type GetFidic_fundo_x_usuarioGroupByPayload<T extends Fidic_fundo_x_usuarioGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Fidic_fundo_x_usuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fidic_fundo_x_usuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fidic_fundo_x_usuarioGroupByOutputType[P]>
            : GetScalarType<T[P], Fidic_fundo_x_usuarioGroupByOutputType[P]>
        }
      >
    >


  export type fidic_fundo_x_usuarioSelect = {
    id?: boolean
    usuario?: boolean
    fidic?: boolean
    fidic_fundo?: boolean | fidic_fundoArgs
    usuario_fidic_fundo_x_usuarioTousuario?: boolean | usuarioArgs
  }


  export type fidic_fundo_x_usuarioInclude = {
    fidic_fundo?: boolean | fidic_fundoArgs
    usuario_fidic_fundo_x_usuarioTousuario?: boolean | usuarioArgs
  } 

  export type fidic_fundo_x_usuarioGetPayload<S extends boolean | null | undefined | fidic_fundo_x_usuarioArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? fidic_fundo_x_usuario :
    S extends undefined ? never :
    S extends { include: any } & (fidic_fundo_x_usuarioArgs | fidic_fundo_x_usuarioFindManyArgs)
    ? fidic_fundo_x_usuario  & {
    [P in TrueKeys<S['include']>]:
        P extends 'fidic_fundo' ? fidic_fundoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'usuario_fidic_fundo_x_usuarioTousuario' ? usuarioGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : S extends { select: any } & (fidic_fundo_x_usuarioArgs | fidic_fundo_x_usuarioFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'fidic_fundo' ? fidic_fundoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'usuario_fidic_fundo_x_usuarioTousuario' ? usuarioGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof fidic_fundo_x_usuario ? fidic_fundo_x_usuario[P] : never
  } 
      : fidic_fundo_x_usuario


  type fidic_fundo_x_usuarioCountArgs = Merge<
    Omit<fidic_fundo_x_usuarioFindManyArgs, 'select' | 'include'> & {
      select?: Fidic_fundo_x_usuarioCountAggregateInputType | true
    }
  >

  export interface fidic_fundo_x_usuarioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Fidic_fundo_x_usuario that matches the filter.
     * @param {fidic_fundo_x_usuarioFindUniqueArgs} args - Arguments to find a Fidic_fundo_x_usuario
     * @example
     * // Get one Fidic_fundo_x_usuario
     * const fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fidic_fundo_x_usuarioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fidic_fundo_x_usuarioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fidic_fundo_x_usuario'> extends True ? Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T>> : Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T> | null, null>

    /**
     * Find the first Fidic_fundo_x_usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundo_x_usuarioFindFirstArgs} args - Arguments to find a Fidic_fundo_x_usuario
     * @example
     * // Get one Fidic_fundo_x_usuario
     * const fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fidic_fundo_x_usuarioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fidic_fundo_x_usuarioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fidic_fundo_x_usuario'> extends True ? Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T>> : Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T> | null, null>

    /**
     * Find zero or more Fidic_fundo_x_usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundo_x_usuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fidic_fundo_x_usuarios
     * const fidic_fundo_x_usuarios = await prisma.fidic_fundo_x_usuario.findMany()
     * 
     * // Get first 10 Fidic_fundo_x_usuarios
     * const fidic_fundo_x_usuarios = await prisma.fidic_fundo_x_usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fidic_fundo_x_usuarioWithIdOnly = await prisma.fidic_fundo_x_usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fidic_fundo_x_usuarioFindManyArgs>(
      args?: SelectSubset<T, fidic_fundo_x_usuarioFindManyArgs>
    ): PrismaPromise<Array<fidic_fundo_x_usuarioGetPayload<T>>>

    /**
     * Create a Fidic_fundo_x_usuario.
     * @param {fidic_fundo_x_usuarioCreateArgs} args - Arguments to create a Fidic_fundo_x_usuario.
     * @example
     * // Create one Fidic_fundo_x_usuario
     * const Fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.create({
     *   data: {
     *     // ... data to create a Fidic_fundo_x_usuario
     *   }
     * })
     * 
    **/
    create<T extends fidic_fundo_x_usuarioCreateArgs>(
      args: SelectSubset<T, fidic_fundo_x_usuarioCreateArgs>
    ): Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T>>

    /**
     * Create many Fidic_fundo_x_usuarios.
     *     @param {fidic_fundo_x_usuarioCreateManyArgs} args - Arguments to create many Fidic_fundo_x_usuarios.
     *     @example
     *     // Create many Fidic_fundo_x_usuarios
     *     const fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fidic_fundo_x_usuarioCreateManyArgs>(
      args?: SelectSubset<T, fidic_fundo_x_usuarioCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Fidic_fundo_x_usuario.
     * @param {fidic_fundo_x_usuarioDeleteArgs} args - Arguments to delete one Fidic_fundo_x_usuario.
     * @example
     * // Delete one Fidic_fundo_x_usuario
     * const Fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.delete({
     *   where: {
     *     // ... filter to delete one Fidic_fundo_x_usuario
     *   }
     * })
     * 
    **/
    delete<T extends fidic_fundo_x_usuarioDeleteArgs>(
      args: SelectSubset<T, fidic_fundo_x_usuarioDeleteArgs>
    ): Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T>>

    /**
     * Update one Fidic_fundo_x_usuario.
     * @param {fidic_fundo_x_usuarioUpdateArgs} args - Arguments to update one Fidic_fundo_x_usuario.
     * @example
     * // Update one Fidic_fundo_x_usuario
     * const fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fidic_fundo_x_usuarioUpdateArgs>(
      args: SelectSubset<T, fidic_fundo_x_usuarioUpdateArgs>
    ): Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T>>

    /**
     * Delete zero or more Fidic_fundo_x_usuarios.
     * @param {fidic_fundo_x_usuarioDeleteManyArgs} args - Arguments to filter Fidic_fundo_x_usuarios to delete.
     * @example
     * // Delete a few Fidic_fundo_x_usuarios
     * const { count } = await prisma.fidic_fundo_x_usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fidic_fundo_x_usuarioDeleteManyArgs>(
      args?: SelectSubset<T, fidic_fundo_x_usuarioDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fidic_fundo_x_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundo_x_usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fidic_fundo_x_usuarios
     * const fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fidic_fundo_x_usuarioUpdateManyArgs>(
      args: SelectSubset<T, fidic_fundo_x_usuarioUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Fidic_fundo_x_usuario.
     * @param {fidic_fundo_x_usuarioUpsertArgs} args - Arguments to update or create a Fidic_fundo_x_usuario.
     * @example
     * // Update or create a Fidic_fundo_x_usuario
     * const fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.upsert({
     *   create: {
     *     // ... data to create a Fidic_fundo_x_usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fidic_fundo_x_usuario we want to update
     *   }
     * })
    **/
    upsert<T extends fidic_fundo_x_usuarioUpsertArgs>(
      args: SelectSubset<T, fidic_fundo_x_usuarioUpsertArgs>
    ): Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T>>

    /**
     * Find one Fidic_fundo_x_usuario that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {fidic_fundo_x_usuarioFindUniqueOrThrowArgs} args - Arguments to find a Fidic_fundo_x_usuario
     * @example
     * // Get one Fidic_fundo_x_usuario
     * const fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fidic_fundo_x_usuarioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, fidic_fundo_x_usuarioFindUniqueOrThrowArgs>
    ): Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T>>

    /**
     * Find the first Fidic_fundo_x_usuario that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundo_x_usuarioFindFirstOrThrowArgs} args - Arguments to find a Fidic_fundo_x_usuario
     * @example
     * // Get one Fidic_fundo_x_usuario
     * const fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fidic_fundo_x_usuarioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, fidic_fundo_x_usuarioFindFirstOrThrowArgs>
    ): Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T>>

    /**
     * Count the number of Fidic_fundo_x_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundo_x_usuarioCountArgs} args - Arguments to filter Fidic_fundo_x_usuarios to count.
     * @example
     * // Count the number of Fidic_fundo_x_usuarios
     * const count = await prisma.fidic_fundo_x_usuario.count({
     *   where: {
     *     // ... the filter for the Fidic_fundo_x_usuarios we want to count
     *   }
     * })
    **/
    count<T extends fidic_fundo_x_usuarioCountArgs>(
      args?: Subset<T, fidic_fundo_x_usuarioCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fidic_fundo_x_usuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fidic_fundo_x_usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fidic_fundo_x_usuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fidic_fundo_x_usuarioAggregateArgs>(args: Subset<T, Fidic_fundo_x_usuarioAggregateArgs>): PrismaPromise<GetFidic_fundo_x_usuarioAggregateType<T>>

    /**
     * Group by Fidic_fundo_x_usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fidic_fundo_x_usuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Fidic_fundo_x_usuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Fidic_fundo_x_usuarioGroupByArgs['orderBy'] }
        : { orderBy?: Fidic_fundo_x_usuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Fidic_fundo_x_usuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFidic_fundo_x_usuarioGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fidic_fundo_x_usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fidic_fundo_x_usuarioClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    fidic_fundo<T extends fidic_fundoArgs= {}>(args?: Subset<T, fidic_fundoArgs>): Prisma__fidic_fundoClient<fidic_fundoGetPayload<T> | Null>;

    usuario_fidic_fundo_x_usuarioTousuario<T extends usuarioArgs= {}>(args?: Subset<T, usuarioArgs>): Prisma__usuarioClient<usuarioGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fidic_fundo_x_usuario base type for findUnique actions
   */
  export type fidic_fundo_x_usuarioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the fidic_fundo_x_usuario
     * 
    **/
    select?: fidic_fundo_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundo_x_usuarioInclude | null
    /**
     * Filter, which fidic_fundo_x_usuario to fetch.
     * 
    **/
    where: fidic_fundo_x_usuarioWhereUniqueInput
  }

  /**
   * fidic_fundo_x_usuario: findUnique
   */
  export interface fidic_fundo_x_usuarioFindUniqueArgs extends fidic_fundo_x_usuarioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fidic_fundo_x_usuario base type for findFirst actions
   */
  export type fidic_fundo_x_usuarioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the fidic_fundo_x_usuario
     * 
    **/
    select?: fidic_fundo_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundo_x_usuarioInclude | null
    /**
     * Filter, which fidic_fundo_x_usuario to fetch.
     * 
    **/
    where?: fidic_fundo_x_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fidic_fundo_x_usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<fidic_fundo_x_usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fidic_fundo_x_usuarios.
     * 
    **/
    cursor?: fidic_fundo_x_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fidic_fundo_x_usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fidic_fundo_x_usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fidic_fundo_x_usuarios.
     * 
    **/
    distinct?: Enumerable<Fidic_fundo_x_usuarioScalarFieldEnum>
  }

  /**
   * fidic_fundo_x_usuario: findFirst
   */
  export interface fidic_fundo_x_usuarioFindFirstArgs extends fidic_fundo_x_usuarioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fidic_fundo_x_usuario findMany
   */
  export type fidic_fundo_x_usuarioFindManyArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_x_usuario
     * 
    **/
    select?: fidic_fundo_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundo_x_usuarioInclude | null
    /**
     * Filter, which fidic_fundo_x_usuarios to fetch.
     * 
    **/
    where?: fidic_fundo_x_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fidic_fundo_x_usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<fidic_fundo_x_usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fidic_fundo_x_usuarios.
     * 
    **/
    cursor?: fidic_fundo_x_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fidic_fundo_x_usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fidic_fundo_x_usuarios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Fidic_fundo_x_usuarioScalarFieldEnum>
  }


  /**
   * fidic_fundo_x_usuario create
   */
  export type fidic_fundo_x_usuarioCreateArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_x_usuario
     * 
    **/
    select?: fidic_fundo_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundo_x_usuarioInclude | null
    /**
     * The data needed to create a fidic_fundo_x_usuario.
     * 
    **/
    data: XOR<fidic_fundo_x_usuarioCreateInput, fidic_fundo_x_usuarioUncheckedCreateInput>
  }


  /**
   * fidic_fundo_x_usuario createMany
   */
  export type fidic_fundo_x_usuarioCreateManyArgs = {
    /**
     * The data used to create many fidic_fundo_x_usuarios.
     * 
    **/
    data: Enumerable<fidic_fundo_x_usuarioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * fidic_fundo_x_usuario update
   */
  export type fidic_fundo_x_usuarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_x_usuario
     * 
    **/
    select?: fidic_fundo_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundo_x_usuarioInclude | null
    /**
     * The data needed to update a fidic_fundo_x_usuario.
     * 
    **/
    data: XOR<fidic_fundo_x_usuarioUpdateInput, fidic_fundo_x_usuarioUncheckedUpdateInput>
    /**
     * Choose, which fidic_fundo_x_usuario to update.
     * 
    **/
    where: fidic_fundo_x_usuarioWhereUniqueInput
  }


  /**
   * fidic_fundo_x_usuario updateMany
   */
  export type fidic_fundo_x_usuarioUpdateManyArgs = {
    /**
     * The data used to update fidic_fundo_x_usuarios.
     * 
    **/
    data: XOR<fidic_fundo_x_usuarioUpdateManyMutationInput, fidic_fundo_x_usuarioUncheckedUpdateManyInput>
    /**
     * Filter which fidic_fundo_x_usuarios to update
     * 
    **/
    where?: fidic_fundo_x_usuarioWhereInput
  }


  /**
   * fidic_fundo_x_usuario upsert
   */
  export type fidic_fundo_x_usuarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_x_usuario
     * 
    **/
    select?: fidic_fundo_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundo_x_usuarioInclude | null
    /**
     * The filter to search for the fidic_fundo_x_usuario to update in case it exists.
     * 
    **/
    where: fidic_fundo_x_usuarioWhereUniqueInput
    /**
     * In case the fidic_fundo_x_usuario found by the `where` argument doesn't exist, create a new fidic_fundo_x_usuario with this data.
     * 
    **/
    create: XOR<fidic_fundo_x_usuarioCreateInput, fidic_fundo_x_usuarioUncheckedCreateInput>
    /**
     * In case the fidic_fundo_x_usuario was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<fidic_fundo_x_usuarioUpdateInput, fidic_fundo_x_usuarioUncheckedUpdateInput>
  }


  /**
   * fidic_fundo_x_usuario delete
   */
  export type fidic_fundo_x_usuarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_x_usuario
     * 
    **/
    select?: fidic_fundo_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundo_x_usuarioInclude | null
    /**
     * Filter which fidic_fundo_x_usuario to delete.
     * 
    **/
    where: fidic_fundo_x_usuarioWhereUniqueInput
  }


  /**
   * fidic_fundo_x_usuario deleteMany
   */
  export type fidic_fundo_x_usuarioDeleteManyArgs = {
    /**
     * Filter which fidic_fundo_x_usuarios to delete
     * 
    **/
    where?: fidic_fundo_x_usuarioWhereInput
  }


  /**
   * fidic_fundo_x_usuario: findUniqueOrThrow
   */
  export type fidic_fundo_x_usuarioFindUniqueOrThrowArgs = fidic_fundo_x_usuarioFindUniqueArgsBase
      

  /**
   * fidic_fundo_x_usuario: findFirstOrThrow
   */
  export type fidic_fundo_x_usuarioFindFirstOrThrowArgs = fidic_fundo_x_usuarioFindFirstArgsBase
      

  /**
   * fidic_fundo_x_usuario without action
   */
  export type fidic_fundo_x_usuarioArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_x_usuario
     * 
    **/
    select?: fidic_fundo_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundo_x_usuarioInclude | null
  }



  /**
   * Model organograma
   */


  export type AggregateOrganograma = {
    _count: OrganogramaCountAggregateOutputType | null
    _avg: OrganogramaAvgAggregateOutputType | null
    _sum: OrganogramaSumAggregateOutputType | null
    _min: OrganogramaMinAggregateOutputType | null
    _max: OrganogramaMaxAggregateOutputType | null
  }

  export type OrganogramaAvgAggregateOutputType = {
    id: number | null
  }

  export type OrganogramaSumAggregateOutputType = {
    id: number | null
  }

  export type OrganogramaMinAggregateOutputType = {
    id: number | null
  }

  export type OrganogramaMaxAggregateOutputType = {
    id: number | null
  }

  export type OrganogramaCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type OrganogramaAvgAggregateInputType = {
    id?: true
  }

  export type OrganogramaSumAggregateInputType = {
    id?: true
  }

  export type OrganogramaMinAggregateInputType = {
    id?: true
  }

  export type OrganogramaMaxAggregateInputType = {
    id?: true
  }

  export type OrganogramaCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type OrganogramaAggregateArgs = {
    /**
     * Filter which organograma to aggregate.
     * 
    **/
    where?: organogramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organogramas to fetch.
     * 
    **/
    orderBy?: Enumerable<organogramaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: organogramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organogramas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organogramas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organogramas
    **/
    _count?: true | OrganogramaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganogramaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganogramaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganogramaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganogramaMaxAggregateInputType
  }

  export type GetOrganogramaAggregateType<T extends OrganogramaAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganograma]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganograma[P]>
      : GetScalarType<T[P], AggregateOrganograma[P]>
  }




  export type OrganogramaGroupByArgs = {
    where?: organogramaWhereInput
    orderBy?: Enumerable<organogramaOrderByWithAggregationInput>
    by: Array<OrganogramaScalarFieldEnum>
    having?: organogramaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganogramaCountAggregateInputType | true
    _avg?: OrganogramaAvgAggregateInputType
    _sum?: OrganogramaSumAggregateInputType
    _min?: OrganogramaMinAggregateInputType
    _max?: OrganogramaMaxAggregateInputType
  }


  export type OrganogramaGroupByOutputType = {
    id: number
    _count: OrganogramaCountAggregateOutputType | null
    _avg: OrganogramaAvgAggregateOutputType | null
    _sum: OrganogramaSumAggregateOutputType | null
    _min: OrganogramaMinAggregateOutputType | null
    _max: OrganogramaMaxAggregateOutputType | null
  }

  type GetOrganogramaGroupByPayload<T extends OrganogramaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrganogramaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganogramaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganogramaGroupByOutputType[P]>
            : GetScalarType<T[P], OrganogramaGroupByOutputType[P]>
        }
      >
    >


  export type organogramaSelect = {
    id?: boolean
  }


  export type organogramaGetPayload<S extends boolean | null | undefined | organogramaArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? organograma :
    S extends undefined ? never :
    S extends { include: any } & (organogramaArgs | organogramaFindManyArgs)
    ? organograma 
    : S extends { select: any } & (organogramaArgs | organogramaFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof organograma ? organograma[P] : never
  } 
      : organograma


  type organogramaCountArgs = Merge<
    Omit<organogramaFindManyArgs, 'select' | 'include'> & {
      select?: OrganogramaCountAggregateInputType | true
    }
  >

  export interface organogramaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Organograma that matches the filter.
     * @param {organogramaFindUniqueArgs} args - Arguments to find a Organograma
     * @example
     * // Get one Organograma
     * const organograma = await prisma.organograma.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends organogramaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, organogramaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'organograma'> extends True ? Prisma__organogramaClient<organogramaGetPayload<T>> : Prisma__organogramaClient<organogramaGetPayload<T> | null, null>

    /**
     * Find the first Organograma that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organogramaFindFirstArgs} args - Arguments to find a Organograma
     * @example
     * // Get one Organograma
     * const organograma = await prisma.organograma.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends organogramaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, organogramaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'organograma'> extends True ? Prisma__organogramaClient<organogramaGetPayload<T>> : Prisma__organogramaClient<organogramaGetPayload<T> | null, null>

    /**
     * Find zero or more Organogramas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organogramaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organogramas
     * const organogramas = await prisma.organograma.findMany()
     * 
     * // Get first 10 Organogramas
     * const organogramas = await prisma.organograma.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organogramaWithIdOnly = await prisma.organograma.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends organogramaFindManyArgs>(
      args?: SelectSubset<T, organogramaFindManyArgs>
    ): PrismaPromise<Array<organogramaGetPayload<T>>>

    /**
     * Create a Organograma.
     * @param {organogramaCreateArgs} args - Arguments to create a Organograma.
     * @example
     * // Create one Organograma
     * const Organograma = await prisma.organograma.create({
     *   data: {
     *     // ... data to create a Organograma
     *   }
     * })
     * 
    **/
    create<T extends organogramaCreateArgs>(
      args: SelectSubset<T, organogramaCreateArgs>
    ): Prisma__organogramaClient<organogramaGetPayload<T>>

    /**
     * Create many Organogramas.
     *     @param {organogramaCreateManyArgs} args - Arguments to create many Organogramas.
     *     @example
     *     // Create many Organogramas
     *     const organograma = await prisma.organograma.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends organogramaCreateManyArgs>(
      args?: SelectSubset<T, organogramaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Organograma.
     * @param {organogramaDeleteArgs} args - Arguments to delete one Organograma.
     * @example
     * // Delete one Organograma
     * const Organograma = await prisma.organograma.delete({
     *   where: {
     *     // ... filter to delete one Organograma
     *   }
     * })
     * 
    **/
    delete<T extends organogramaDeleteArgs>(
      args: SelectSubset<T, organogramaDeleteArgs>
    ): Prisma__organogramaClient<organogramaGetPayload<T>>

    /**
     * Update one Organograma.
     * @param {organogramaUpdateArgs} args - Arguments to update one Organograma.
     * @example
     * // Update one Organograma
     * const organograma = await prisma.organograma.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends organogramaUpdateArgs>(
      args: SelectSubset<T, organogramaUpdateArgs>
    ): Prisma__organogramaClient<organogramaGetPayload<T>>

    /**
     * Delete zero or more Organogramas.
     * @param {organogramaDeleteManyArgs} args - Arguments to filter Organogramas to delete.
     * @example
     * // Delete a few Organogramas
     * const { count } = await prisma.organograma.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends organogramaDeleteManyArgs>(
      args?: SelectSubset<T, organogramaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organogramas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organogramaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organogramas
     * const organograma = await prisma.organograma.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends organogramaUpdateManyArgs>(
      args: SelectSubset<T, organogramaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Organograma.
     * @param {organogramaUpsertArgs} args - Arguments to update or create a Organograma.
     * @example
     * // Update or create a Organograma
     * const organograma = await prisma.organograma.upsert({
     *   create: {
     *     // ... data to create a Organograma
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organograma we want to update
     *   }
     * })
    **/
    upsert<T extends organogramaUpsertArgs>(
      args: SelectSubset<T, organogramaUpsertArgs>
    ): Prisma__organogramaClient<organogramaGetPayload<T>>

    /**
     * Find one Organograma that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {organogramaFindUniqueOrThrowArgs} args - Arguments to find a Organograma
     * @example
     * // Get one Organograma
     * const organograma = await prisma.organograma.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends organogramaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, organogramaFindUniqueOrThrowArgs>
    ): Prisma__organogramaClient<organogramaGetPayload<T>>

    /**
     * Find the first Organograma that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organogramaFindFirstOrThrowArgs} args - Arguments to find a Organograma
     * @example
     * // Get one Organograma
     * const organograma = await prisma.organograma.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends organogramaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, organogramaFindFirstOrThrowArgs>
    ): Prisma__organogramaClient<organogramaGetPayload<T>>

    /**
     * Count the number of Organogramas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organogramaCountArgs} args - Arguments to filter Organogramas to count.
     * @example
     * // Count the number of Organogramas
     * const count = await prisma.organograma.count({
     *   where: {
     *     // ... the filter for the Organogramas we want to count
     *   }
     * })
    **/
    count<T extends organogramaCountArgs>(
      args?: Subset<T, organogramaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganogramaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organograma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganogramaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganogramaAggregateArgs>(args: Subset<T, OrganogramaAggregateArgs>): PrismaPromise<GetOrganogramaAggregateType<T>>

    /**
     * Group by Organograma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganogramaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganogramaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganogramaGroupByArgs['orderBy'] }
        : { orderBy?: OrganogramaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganogramaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganogramaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for organograma.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__organogramaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * organograma base type for findUnique actions
   */
  export type organogramaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the organograma
     * 
    **/
    select?: organogramaSelect | null
    /**
     * Filter, which organograma to fetch.
     * 
    **/
    where: organogramaWhereUniqueInput
  }

  /**
   * organograma: findUnique
   */
  export interface organogramaFindUniqueArgs extends organogramaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organograma base type for findFirst actions
   */
  export type organogramaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the organograma
     * 
    **/
    select?: organogramaSelect | null
    /**
     * Filter, which organograma to fetch.
     * 
    **/
    where?: organogramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organogramas to fetch.
     * 
    **/
    orderBy?: Enumerable<organogramaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organogramas.
     * 
    **/
    cursor?: organogramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organogramas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organogramas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organogramas.
     * 
    **/
    distinct?: Enumerable<OrganogramaScalarFieldEnum>
  }

  /**
   * organograma: findFirst
   */
  export interface organogramaFindFirstArgs extends organogramaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organograma findMany
   */
  export type organogramaFindManyArgs = {
    /**
     * Select specific fields to fetch from the organograma
     * 
    **/
    select?: organogramaSelect | null
    /**
     * Filter, which organogramas to fetch.
     * 
    **/
    where?: organogramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organogramas to fetch.
     * 
    **/
    orderBy?: Enumerable<organogramaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organogramas.
     * 
    **/
    cursor?: organogramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organogramas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organogramas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrganogramaScalarFieldEnum>
  }


  /**
   * organograma create
   */
  export type organogramaCreateArgs = {
    /**
     * Select specific fields to fetch from the organograma
     * 
    **/
    select?: organogramaSelect | null
    /**
     * The data needed to create a organograma.
     * 
    **/
    data?: XOR<organogramaCreateInput, organogramaUncheckedCreateInput>
  }


  /**
   * organograma createMany
   */
  export type organogramaCreateManyArgs = {
    /**
     * The data used to create many organogramas.
     * 
    **/
    data: Enumerable<organogramaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * organograma update
   */
  export type organogramaUpdateArgs = {
    /**
     * Select specific fields to fetch from the organograma
     * 
    **/
    select?: organogramaSelect | null
    /**
     * The data needed to update a organograma.
     * 
    **/
    data: XOR<organogramaUpdateInput, organogramaUncheckedUpdateInput>
    /**
     * Choose, which organograma to update.
     * 
    **/
    where: organogramaWhereUniqueInput
  }


  /**
   * organograma updateMany
   */
  export type organogramaUpdateManyArgs = {
    /**
     * The data used to update organogramas.
     * 
    **/
    data: XOR<organogramaUpdateManyMutationInput, organogramaUncheckedUpdateManyInput>
    /**
     * Filter which organogramas to update
     * 
    **/
    where?: organogramaWhereInput
  }


  /**
   * organograma upsert
   */
  export type organogramaUpsertArgs = {
    /**
     * Select specific fields to fetch from the organograma
     * 
    **/
    select?: organogramaSelect | null
    /**
     * The filter to search for the organograma to update in case it exists.
     * 
    **/
    where: organogramaWhereUniqueInput
    /**
     * In case the organograma found by the `where` argument doesn't exist, create a new organograma with this data.
     * 
    **/
    create: XOR<organogramaCreateInput, organogramaUncheckedCreateInput>
    /**
     * In case the organograma was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<organogramaUpdateInput, organogramaUncheckedUpdateInput>
  }


  /**
   * organograma delete
   */
  export type organogramaDeleteArgs = {
    /**
     * Select specific fields to fetch from the organograma
     * 
    **/
    select?: organogramaSelect | null
    /**
     * Filter which organograma to delete.
     * 
    **/
    where: organogramaWhereUniqueInput
  }


  /**
   * organograma deleteMany
   */
  export type organogramaDeleteManyArgs = {
    /**
     * Filter which organogramas to delete
     * 
    **/
    where?: organogramaWhereInput
  }


  /**
   * organograma: findUniqueOrThrow
   */
  export type organogramaFindUniqueOrThrowArgs = organogramaFindUniqueArgsBase
      

  /**
   * organograma: findFirstOrThrow
   */
  export type organogramaFindFirstOrThrowArgs = organogramaFindFirstArgsBase
      

  /**
   * organograma without action
   */
  export type organogramaArgs = {
    /**
     * Select specific fields to fetch from the organograma
     * 
    **/
    select?: organogramaSelect | null
  }



  /**
   * Model organograma_tipo
   */


  export type AggregateOrganograma_tipo = {
    _count: Organograma_tipoCountAggregateOutputType | null
    _avg: Organograma_tipoAvgAggregateOutputType | null
    _sum: Organograma_tipoSumAggregateOutputType | null
    _min: Organograma_tipoMinAggregateOutputType | null
    _max: Organograma_tipoMaxAggregateOutputType | null
  }

  export type Organograma_tipoAvgAggregateOutputType = {
    id: number | null
  }

  export type Organograma_tipoSumAggregateOutputType = {
    id: number | null
  }

  export type Organograma_tipoMinAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Organograma_tipoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Organograma_tipoCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type Organograma_tipoAvgAggregateInputType = {
    id?: true
  }

  export type Organograma_tipoSumAggregateInputType = {
    id?: true
  }

  export type Organograma_tipoMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Organograma_tipoMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Organograma_tipoCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type Organograma_tipoAggregateArgs = {
    /**
     * Filter which organograma_tipo to aggregate.
     * 
    **/
    where?: organograma_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: organograma_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organograma_tipos
    **/
    _count?: true | Organograma_tipoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Organograma_tipoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Organograma_tipoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Organograma_tipoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Organograma_tipoMaxAggregateInputType
  }

  export type GetOrganograma_tipoAggregateType<T extends Organograma_tipoAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganograma_tipo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganograma_tipo[P]>
      : GetScalarType<T[P], AggregateOrganograma_tipo[P]>
  }




  export type Organograma_tipoGroupByArgs = {
    where?: organograma_tipoWhereInput
    orderBy?: Enumerable<organograma_tipoOrderByWithAggregationInput>
    by: Array<Organograma_tipoScalarFieldEnum>
    having?: organograma_tipoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Organograma_tipoCountAggregateInputType | true
    _avg?: Organograma_tipoAvgAggregateInputType
    _sum?: Organograma_tipoSumAggregateInputType
    _min?: Organograma_tipoMinAggregateInputType
    _max?: Organograma_tipoMaxAggregateInputType
  }


  export type Organograma_tipoGroupByOutputType = {
    id: number
    nome: string
    _count: Organograma_tipoCountAggregateOutputType | null
    _avg: Organograma_tipoAvgAggregateOutputType | null
    _sum: Organograma_tipoSumAggregateOutputType | null
    _min: Organograma_tipoMinAggregateOutputType | null
    _max: Organograma_tipoMaxAggregateOutputType | null
  }

  type GetOrganograma_tipoGroupByPayload<T extends Organograma_tipoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Organograma_tipoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Organograma_tipoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Organograma_tipoGroupByOutputType[P]>
            : GetScalarType<T[P], Organograma_tipoGroupByOutputType[P]>
        }
      >
    >


  export type organograma_tipoSelect = {
    id?: boolean
    nome?: boolean
  }


  export type organograma_tipoGetPayload<S extends boolean | null | undefined | organograma_tipoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? organograma_tipo :
    S extends undefined ? never :
    S extends { include: any } & (organograma_tipoArgs | organograma_tipoFindManyArgs)
    ? organograma_tipo 
    : S extends { select: any } & (organograma_tipoArgs | organograma_tipoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof organograma_tipo ? organograma_tipo[P] : never
  } 
      : organograma_tipo


  type organograma_tipoCountArgs = Merge<
    Omit<organograma_tipoFindManyArgs, 'select' | 'include'> & {
      select?: Organograma_tipoCountAggregateInputType | true
    }
  >

  export interface organograma_tipoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Organograma_tipo that matches the filter.
     * @param {organograma_tipoFindUniqueArgs} args - Arguments to find a Organograma_tipo
     * @example
     * // Get one Organograma_tipo
     * const organograma_tipo = await prisma.organograma_tipo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends organograma_tipoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, organograma_tipoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'organograma_tipo'> extends True ? Prisma__organograma_tipoClient<organograma_tipoGetPayload<T>> : Prisma__organograma_tipoClient<organograma_tipoGetPayload<T> | null, null>

    /**
     * Find the first Organograma_tipo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_tipoFindFirstArgs} args - Arguments to find a Organograma_tipo
     * @example
     * // Get one Organograma_tipo
     * const organograma_tipo = await prisma.organograma_tipo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends organograma_tipoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, organograma_tipoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'organograma_tipo'> extends True ? Prisma__organograma_tipoClient<organograma_tipoGetPayload<T>> : Prisma__organograma_tipoClient<organograma_tipoGetPayload<T> | null, null>

    /**
     * Find zero or more Organograma_tipos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_tipoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organograma_tipos
     * const organograma_tipos = await prisma.organograma_tipo.findMany()
     * 
     * // Get first 10 Organograma_tipos
     * const organograma_tipos = await prisma.organograma_tipo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organograma_tipoWithIdOnly = await prisma.organograma_tipo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends organograma_tipoFindManyArgs>(
      args?: SelectSubset<T, organograma_tipoFindManyArgs>
    ): PrismaPromise<Array<organograma_tipoGetPayload<T>>>

    /**
     * Create a Organograma_tipo.
     * @param {organograma_tipoCreateArgs} args - Arguments to create a Organograma_tipo.
     * @example
     * // Create one Organograma_tipo
     * const Organograma_tipo = await prisma.organograma_tipo.create({
     *   data: {
     *     // ... data to create a Organograma_tipo
     *   }
     * })
     * 
    **/
    create<T extends organograma_tipoCreateArgs>(
      args: SelectSubset<T, organograma_tipoCreateArgs>
    ): Prisma__organograma_tipoClient<organograma_tipoGetPayload<T>>

    /**
     * Create many Organograma_tipos.
     *     @param {organograma_tipoCreateManyArgs} args - Arguments to create many Organograma_tipos.
     *     @example
     *     // Create many Organograma_tipos
     *     const organograma_tipo = await prisma.organograma_tipo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends organograma_tipoCreateManyArgs>(
      args?: SelectSubset<T, organograma_tipoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Organograma_tipo.
     * @param {organograma_tipoDeleteArgs} args - Arguments to delete one Organograma_tipo.
     * @example
     * // Delete one Organograma_tipo
     * const Organograma_tipo = await prisma.organograma_tipo.delete({
     *   where: {
     *     // ... filter to delete one Organograma_tipo
     *   }
     * })
     * 
    **/
    delete<T extends organograma_tipoDeleteArgs>(
      args: SelectSubset<T, organograma_tipoDeleteArgs>
    ): Prisma__organograma_tipoClient<organograma_tipoGetPayload<T>>

    /**
     * Update one Organograma_tipo.
     * @param {organograma_tipoUpdateArgs} args - Arguments to update one Organograma_tipo.
     * @example
     * // Update one Organograma_tipo
     * const organograma_tipo = await prisma.organograma_tipo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends organograma_tipoUpdateArgs>(
      args: SelectSubset<T, organograma_tipoUpdateArgs>
    ): Prisma__organograma_tipoClient<organograma_tipoGetPayload<T>>

    /**
     * Delete zero or more Organograma_tipos.
     * @param {organograma_tipoDeleteManyArgs} args - Arguments to filter Organograma_tipos to delete.
     * @example
     * // Delete a few Organograma_tipos
     * const { count } = await prisma.organograma_tipo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends organograma_tipoDeleteManyArgs>(
      args?: SelectSubset<T, organograma_tipoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organograma_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_tipoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organograma_tipos
     * const organograma_tipo = await prisma.organograma_tipo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends organograma_tipoUpdateManyArgs>(
      args: SelectSubset<T, organograma_tipoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Organograma_tipo.
     * @param {organograma_tipoUpsertArgs} args - Arguments to update or create a Organograma_tipo.
     * @example
     * // Update or create a Organograma_tipo
     * const organograma_tipo = await prisma.organograma_tipo.upsert({
     *   create: {
     *     // ... data to create a Organograma_tipo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organograma_tipo we want to update
     *   }
     * })
    **/
    upsert<T extends organograma_tipoUpsertArgs>(
      args: SelectSubset<T, organograma_tipoUpsertArgs>
    ): Prisma__organograma_tipoClient<organograma_tipoGetPayload<T>>

    /**
     * Find one Organograma_tipo that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {organograma_tipoFindUniqueOrThrowArgs} args - Arguments to find a Organograma_tipo
     * @example
     * // Get one Organograma_tipo
     * const organograma_tipo = await prisma.organograma_tipo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends organograma_tipoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, organograma_tipoFindUniqueOrThrowArgs>
    ): Prisma__organograma_tipoClient<organograma_tipoGetPayload<T>>

    /**
     * Find the first Organograma_tipo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_tipoFindFirstOrThrowArgs} args - Arguments to find a Organograma_tipo
     * @example
     * // Get one Organograma_tipo
     * const organograma_tipo = await prisma.organograma_tipo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends organograma_tipoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, organograma_tipoFindFirstOrThrowArgs>
    ): Prisma__organograma_tipoClient<organograma_tipoGetPayload<T>>

    /**
     * Count the number of Organograma_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_tipoCountArgs} args - Arguments to filter Organograma_tipos to count.
     * @example
     * // Count the number of Organograma_tipos
     * const count = await prisma.organograma_tipo.count({
     *   where: {
     *     // ... the filter for the Organograma_tipos we want to count
     *   }
     * })
    **/
    count<T extends organograma_tipoCountArgs>(
      args?: Subset<T, organograma_tipoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Organograma_tipoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organograma_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Organograma_tipoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Organograma_tipoAggregateArgs>(args: Subset<T, Organograma_tipoAggregateArgs>): PrismaPromise<GetOrganograma_tipoAggregateType<T>>

    /**
     * Group by Organograma_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Organograma_tipoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Organograma_tipoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Organograma_tipoGroupByArgs['orderBy'] }
        : { orderBy?: Organograma_tipoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Organograma_tipoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganograma_tipoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for organograma_tipo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__organograma_tipoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * organograma_tipo base type for findUnique actions
   */
  export type organograma_tipoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the organograma_tipo
     * 
    **/
    select?: organograma_tipoSelect | null
    /**
     * Filter, which organograma_tipo to fetch.
     * 
    **/
    where: organograma_tipoWhereUniqueInput
  }

  /**
   * organograma_tipo: findUnique
   */
  export interface organograma_tipoFindUniqueArgs extends organograma_tipoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organograma_tipo base type for findFirst actions
   */
  export type organograma_tipoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the organograma_tipo
     * 
    **/
    select?: organograma_tipoSelect | null
    /**
     * Filter, which organograma_tipo to fetch.
     * 
    **/
    where?: organograma_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organograma_tipos.
     * 
    **/
    cursor?: organograma_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organograma_tipos.
     * 
    **/
    distinct?: Enumerable<Organograma_tipoScalarFieldEnum>
  }

  /**
   * organograma_tipo: findFirst
   */
  export interface organograma_tipoFindFirstArgs extends organograma_tipoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organograma_tipo findMany
   */
  export type organograma_tipoFindManyArgs = {
    /**
     * Select specific fields to fetch from the organograma_tipo
     * 
    **/
    select?: organograma_tipoSelect | null
    /**
     * Filter, which organograma_tipos to fetch.
     * 
    **/
    where?: organograma_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organograma_tipos.
     * 
    **/
    cursor?: organograma_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_tipos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Organograma_tipoScalarFieldEnum>
  }


  /**
   * organograma_tipo create
   */
  export type organograma_tipoCreateArgs = {
    /**
     * Select specific fields to fetch from the organograma_tipo
     * 
    **/
    select?: organograma_tipoSelect | null
    /**
     * The data needed to create a organograma_tipo.
     * 
    **/
    data: XOR<organograma_tipoCreateInput, organograma_tipoUncheckedCreateInput>
  }


  /**
   * organograma_tipo createMany
   */
  export type organograma_tipoCreateManyArgs = {
    /**
     * The data used to create many organograma_tipos.
     * 
    **/
    data: Enumerable<organograma_tipoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * organograma_tipo update
   */
  export type organograma_tipoUpdateArgs = {
    /**
     * Select specific fields to fetch from the organograma_tipo
     * 
    **/
    select?: organograma_tipoSelect | null
    /**
     * The data needed to update a organograma_tipo.
     * 
    **/
    data: XOR<organograma_tipoUpdateInput, organograma_tipoUncheckedUpdateInput>
    /**
     * Choose, which organograma_tipo to update.
     * 
    **/
    where: organograma_tipoWhereUniqueInput
  }


  /**
   * organograma_tipo updateMany
   */
  export type organograma_tipoUpdateManyArgs = {
    /**
     * The data used to update organograma_tipos.
     * 
    **/
    data: XOR<organograma_tipoUpdateManyMutationInput, organograma_tipoUncheckedUpdateManyInput>
    /**
     * Filter which organograma_tipos to update
     * 
    **/
    where?: organograma_tipoWhereInput
  }


  /**
   * organograma_tipo upsert
   */
  export type organograma_tipoUpsertArgs = {
    /**
     * Select specific fields to fetch from the organograma_tipo
     * 
    **/
    select?: organograma_tipoSelect | null
    /**
     * The filter to search for the organograma_tipo to update in case it exists.
     * 
    **/
    where: organograma_tipoWhereUniqueInput
    /**
     * In case the organograma_tipo found by the `where` argument doesn't exist, create a new organograma_tipo with this data.
     * 
    **/
    create: XOR<organograma_tipoCreateInput, organograma_tipoUncheckedCreateInput>
    /**
     * In case the organograma_tipo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<organograma_tipoUpdateInput, organograma_tipoUncheckedUpdateInput>
  }


  /**
   * organograma_tipo delete
   */
  export type organograma_tipoDeleteArgs = {
    /**
     * Select specific fields to fetch from the organograma_tipo
     * 
    **/
    select?: organograma_tipoSelect | null
    /**
     * Filter which organograma_tipo to delete.
     * 
    **/
    where: organograma_tipoWhereUniqueInput
  }


  /**
   * organograma_tipo deleteMany
   */
  export type organograma_tipoDeleteManyArgs = {
    /**
     * Filter which organograma_tipos to delete
     * 
    **/
    where?: organograma_tipoWhereInput
  }


  /**
   * organograma_tipo: findUniqueOrThrow
   */
  export type organograma_tipoFindUniqueOrThrowArgs = organograma_tipoFindUniqueArgsBase
      

  /**
   * organograma_tipo: findFirstOrThrow
   */
  export type organograma_tipoFindFirstOrThrowArgs = organograma_tipoFindFirstArgsBase
      

  /**
   * organograma_tipo without action
   */
  export type organograma_tipoArgs = {
    /**
     * Select specific fields to fetch from the organograma_tipo
     * 
    **/
    select?: organograma_tipoSelect | null
  }



  /**
   * Model organograma_x_regiao
   */


  export type AggregateOrganograma_x_regiao = {
    _count: Organograma_x_regiaoCountAggregateOutputType | null
    _avg: Organograma_x_regiaoAvgAggregateOutputType | null
    _sum: Organograma_x_regiaoSumAggregateOutputType | null
    _min: Organograma_x_regiaoMinAggregateOutputType | null
    _max: Organograma_x_regiaoMaxAggregateOutputType | null
  }

  export type Organograma_x_regiaoAvgAggregateOutputType = {
    id: number | null
    organograma_id: number | null
    regiao_id: number | null
  }

  export type Organograma_x_regiaoSumAggregateOutputType = {
    id: number | null
    organograma_id: number | null
    regiao_id: number | null
  }

  export type Organograma_x_regiaoMinAggregateOutputType = {
    id: number | null
    organograma_id: number | null
    regiao_id: number | null
  }

  export type Organograma_x_regiaoMaxAggregateOutputType = {
    id: number | null
    organograma_id: number | null
    regiao_id: number | null
  }

  export type Organograma_x_regiaoCountAggregateOutputType = {
    id: number
    organograma_id: number
    regiao_id: number
    _all: number
  }


  export type Organograma_x_regiaoAvgAggregateInputType = {
    id?: true
    organograma_id?: true
    regiao_id?: true
  }

  export type Organograma_x_regiaoSumAggregateInputType = {
    id?: true
    organograma_id?: true
    regiao_id?: true
  }

  export type Organograma_x_regiaoMinAggregateInputType = {
    id?: true
    organograma_id?: true
    regiao_id?: true
  }

  export type Organograma_x_regiaoMaxAggregateInputType = {
    id?: true
    organograma_id?: true
    regiao_id?: true
  }

  export type Organograma_x_regiaoCountAggregateInputType = {
    id?: true
    organograma_id?: true
    regiao_id?: true
    _all?: true
  }

  export type Organograma_x_regiaoAggregateArgs = {
    /**
     * Filter which organograma_x_regiao to aggregate.
     * 
    **/
    where?: organograma_x_regiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_x_regiaos to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_x_regiaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: organograma_x_regiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_x_regiaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_x_regiaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organograma_x_regiaos
    **/
    _count?: true | Organograma_x_regiaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Organograma_x_regiaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Organograma_x_regiaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Organograma_x_regiaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Organograma_x_regiaoMaxAggregateInputType
  }

  export type GetOrganograma_x_regiaoAggregateType<T extends Organograma_x_regiaoAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganograma_x_regiao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganograma_x_regiao[P]>
      : GetScalarType<T[P], AggregateOrganograma_x_regiao[P]>
  }




  export type Organograma_x_regiaoGroupByArgs = {
    where?: organograma_x_regiaoWhereInput
    orderBy?: Enumerable<organograma_x_regiaoOrderByWithAggregationInput>
    by: Array<Organograma_x_regiaoScalarFieldEnum>
    having?: organograma_x_regiaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Organograma_x_regiaoCountAggregateInputType | true
    _avg?: Organograma_x_regiaoAvgAggregateInputType
    _sum?: Organograma_x_regiaoSumAggregateInputType
    _min?: Organograma_x_regiaoMinAggregateInputType
    _max?: Organograma_x_regiaoMaxAggregateInputType
  }


  export type Organograma_x_regiaoGroupByOutputType = {
    id: number
    organograma_id: number
    regiao_id: number
    _count: Organograma_x_regiaoCountAggregateOutputType | null
    _avg: Organograma_x_regiaoAvgAggregateOutputType | null
    _sum: Organograma_x_regiaoSumAggregateOutputType | null
    _min: Organograma_x_regiaoMinAggregateOutputType | null
    _max: Organograma_x_regiaoMaxAggregateOutputType | null
  }

  type GetOrganograma_x_regiaoGroupByPayload<T extends Organograma_x_regiaoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Organograma_x_regiaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Organograma_x_regiaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Organograma_x_regiaoGroupByOutputType[P]>
            : GetScalarType<T[P], Organograma_x_regiaoGroupByOutputType[P]>
        }
      >
    >


  export type organograma_x_regiaoSelect = {
    id?: boolean
    organograma_id?: boolean
    regiao_id?: boolean
  }


  export type organograma_x_regiaoGetPayload<S extends boolean | null | undefined | organograma_x_regiaoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? organograma_x_regiao :
    S extends undefined ? never :
    S extends { include: any } & (organograma_x_regiaoArgs | organograma_x_regiaoFindManyArgs)
    ? organograma_x_regiao 
    : S extends { select: any } & (organograma_x_regiaoArgs | organograma_x_regiaoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof organograma_x_regiao ? organograma_x_regiao[P] : never
  } 
      : organograma_x_regiao


  type organograma_x_regiaoCountArgs = Merge<
    Omit<organograma_x_regiaoFindManyArgs, 'select' | 'include'> & {
      select?: Organograma_x_regiaoCountAggregateInputType | true
    }
  >

  export interface organograma_x_regiaoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Organograma_x_regiao that matches the filter.
     * @param {organograma_x_regiaoFindUniqueArgs} args - Arguments to find a Organograma_x_regiao
     * @example
     * // Get one Organograma_x_regiao
     * const organograma_x_regiao = await prisma.organograma_x_regiao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends organograma_x_regiaoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, organograma_x_regiaoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'organograma_x_regiao'> extends True ? Prisma__organograma_x_regiaoClient<organograma_x_regiaoGetPayload<T>> : Prisma__organograma_x_regiaoClient<organograma_x_regiaoGetPayload<T> | null, null>

    /**
     * Find the first Organograma_x_regiao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_regiaoFindFirstArgs} args - Arguments to find a Organograma_x_regiao
     * @example
     * // Get one Organograma_x_regiao
     * const organograma_x_regiao = await prisma.organograma_x_regiao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends organograma_x_regiaoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, organograma_x_regiaoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'organograma_x_regiao'> extends True ? Prisma__organograma_x_regiaoClient<organograma_x_regiaoGetPayload<T>> : Prisma__organograma_x_regiaoClient<organograma_x_regiaoGetPayload<T> | null, null>

    /**
     * Find zero or more Organograma_x_regiaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_regiaoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organograma_x_regiaos
     * const organograma_x_regiaos = await prisma.organograma_x_regiao.findMany()
     * 
     * // Get first 10 Organograma_x_regiaos
     * const organograma_x_regiaos = await prisma.organograma_x_regiao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organograma_x_regiaoWithIdOnly = await prisma.organograma_x_regiao.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends organograma_x_regiaoFindManyArgs>(
      args?: SelectSubset<T, organograma_x_regiaoFindManyArgs>
    ): PrismaPromise<Array<organograma_x_regiaoGetPayload<T>>>

    /**
     * Create a Organograma_x_regiao.
     * @param {organograma_x_regiaoCreateArgs} args - Arguments to create a Organograma_x_regiao.
     * @example
     * // Create one Organograma_x_regiao
     * const Organograma_x_regiao = await prisma.organograma_x_regiao.create({
     *   data: {
     *     // ... data to create a Organograma_x_regiao
     *   }
     * })
     * 
    **/
    create<T extends organograma_x_regiaoCreateArgs>(
      args: SelectSubset<T, organograma_x_regiaoCreateArgs>
    ): Prisma__organograma_x_regiaoClient<organograma_x_regiaoGetPayload<T>>

    /**
     * Create many Organograma_x_regiaos.
     *     @param {organograma_x_regiaoCreateManyArgs} args - Arguments to create many Organograma_x_regiaos.
     *     @example
     *     // Create many Organograma_x_regiaos
     *     const organograma_x_regiao = await prisma.organograma_x_regiao.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends organograma_x_regiaoCreateManyArgs>(
      args?: SelectSubset<T, organograma_x_regiaoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Organograma_x_regiao.
     * @param {organograma_x_regiaoDeleteArgs} args - Arguments to delete one Organograma_x_regiao.
     * @example
     * // Delete one Organograma_x_regiao
     * const Organograma_x_regiao = await prisma.organograma_x_regiao.delete({
     *   where: {
     *     // ... filter to delete one Organograma_x_regiao
     *   }
     * })
     * 
    **/
    delete<T extends organograma_x_regiaoDeleteArgs>(
      args: SelectSubset<T, organograma_x_regiaoDeleteArgs>
    ): Prisma__organograma_x_regiaoClient<organograma_x_regiaoGetPayload<T>>

    /**
     * Update one Organograma_x_regiao.
     * @param {organograma_x_regiaoUpdateArgs} args - Arguments to update one Organograma_x_regiao.
     * @example
     * // Update one Organograma_x_regiao
     * const organograma_x_regiao = await prisma.organograma_x_regiao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends organograma_x_regiaoUpdateArgs>(
      args: SelectSubset<T, organograma_x_regiaoUpdateArgs>
    ): Prisma__organograma_x_regiaoClient<organograma_x_regiaoGetPayload<T>>

    /**
     * Delete zero or more Organograma_x_regiaos.
     * @param {organograma_x_regiaoDeleteManyArgs} args - Arguments to filter Organograma_x_regiaos to delete.
     * @example
     * // Delete a few Organograma_x_regiaos
     * const { count } = await prisma.organograma_x_regiao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends organograma_x_regiaoDeleteManyArgs>(
      args?: SelectSubset<T, organograma_x_regiaoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organograma_x_regiaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_regiaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organograma_x_regiaos
     * const organograma_x_regiao = await prisma.organograma_x_regiao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends organograma_x_regiaoUpdateManyArgs>(
      args: SelectSubset<T, organograma_x_regiaoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Organograma_x_regiao.
     * @param {organograma_x_regiaoUpsertArgs} args - Arguments to update or create a Organograma_x_regiao.
     * @example
     * // Update or create a Organograma_x_regiao
     * const organograma_x_regiao = await prisma.organograma_x_regiao.upsert({
     *   create: {
     *     // ... data to create a Organograma_x_regiao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organograma_x_regiao we want to update
     *   }
     * })
    **/
    upsert<T extends organograma_x_regiaoUpsertArgs>(
      args: SelectSubset<T, organograma_x_regiaoUpsertArgs>
    ): Prisma__organograma_x_regiaoClient<organograma_x_regiaoGetPayload<T>>

    /**
     * Find one Organograma_x_regiao that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {organograma_x_regiaoFindUniqueOrThrowArgs} args - Arguments to find a Organograma_x_regiao
     * @example
     * // Get one Organograma_x_regiao
     * const organograma_x_regiao = await prisma.organograma_x_regiao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends organograma_x_regiaoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, organograma_x_regiaoFindUniqueOrThrowArgs>
    ): Prisma__organograma_x_regiaoClient<organograma_x_regiaoGetPayload<T>>

    /**
     * Find the first Organograma_x_regiao that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_regiaoFindFirstOrThrowArgs} args - Arguments to find a Organograma_x_regiao
     * @example
     * // Get one Organograma_x_regiao
     * const organograma_x_regiao = await prisma.organograma_x_regiao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends organograma_x_regiaoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, organograma_x_regiaoFindFirstOrThrowArgs>
    ): Prisma__organograma_x_regiaoClient<organograma_x_regiaoGetPayload<T>>

    /**
     * Count the number of Organograma_x_regiaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_regiaoCountArgs} args - Arguments to filter Organograma_x_regiaos to count.
     * @example
     * // Count the number of Organograma_x_regiaos
     * const count = await prisma.organograma_x_regiao.count({
     *   where: {
     *     // ... the filter for the Organograma_x_regiaos we want to count
     *   }
     * })
    **/
    count<T extends organograma_x_regiaoCountArgs>(
      args?: Subset<T, organograma_x_regiaoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Organograma_x_regiaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organograma_x_regiao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Organograma_x_regiaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Organograma_x_regiaoAggregateArgs>(args: Subset<T, Organograma_x_regiaoAggregateArgs>): PrismaPromise<GetOrganograma_x_regiaoAggregateType<T>>

    /**
     * Group by Organograma_x_regiao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Organograma_x_regiaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Organograma_x_regiaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Organograma_x_regiaoGroupByArgs['orderBy'] }
        : { orderBy?: Organograma_x_regiaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Organograma_x_regiaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganograma_x_regiaoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for organograma_x_regiao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__organograma_x_regiaoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * organograma_x_regiao base type for findUnique actions
   */
  export type organograma_x_regiaoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao
     * 
    **/
    select?: organograma_x_regiaoSelect | null
    /**
     * Filter, which organograma_x_regiao to fetch.
     * 
    **/
    where: organograma_x_regiaoWhereUniqueInput
  }

  /**
   * organograma_x_regiao: findUnique
   */
  export interface organograma_x_regiaoFindUniqueArgs extends organograma_x_regiaoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organograma_x_regiao base type for findFirst actions
   */
  export type organograma_x_regiaoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao
     * 
    **/
    select?: organograma_x_regiaoSelect | null
    /**
     * Filter, which organograma_x_regiao to fetch.
     * 
    **/
    where?: organograma_x_regiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_x_regiaos to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_x_regiaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organograma_x_regiaos.
     * 
    **/
    cursor?: organograma_x_regiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_x_regiaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_x_regiaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organograma_x_regiaos.
     * 
    **/
    distinct?: Enumerable<Organograma_x_regiaoScalarFieldEnum>
  }

  /**
   * organograma_x_regiao: findFirst
   */
  export interface organograma_x_regiaoFindFirstArgs extends organograma_x_regiaoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organograma_x_regiao findMany
   */
  export type organograma_x_regiaoFindManyArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao
     * 
    **/
    select?: organograma_x_regiaoSelect | null
    /**
     * Filter, which organograma_x_regiaos to fetch.
     * 
    **/
    where?: organograma_x_regiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_x_regiaos to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_x_regiaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organograma_x_regiaos.
     * 
    **/
    cursor?: organograma_x_regiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_x_regiaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_x_regiaos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Organograma_x_regiaoScalarFieldEnum>
  }


  /**
   * organograma_x_regiao create
   */
  export type organograma_x_regiaoCreateArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao
     * 
    **/
    select?: organograma_x_regiaoSelect | null
    /**
     * The data needed to create a organograma_x_regiao.
     * 
    **/
    data: XOR<organograma_x_regiaoCreateInput, organograma_x_regiaoUncheckedCreateInput>
  }


  /**
   * organograma_x_regiao createMany
   */
  export type organograma_x_regiaoCreateManyArgs = {
    /**
     * The data used to create many organograma_x_regiaos.
     * 
    **/
    data: Enumerable<organograma_x_regiaoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * organograma_x_regiao update
   */
  export type organograma_x_regiaoUpdateArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao
     * 
    **/
    select?: organograma_x_regiaoSelect | null
    /**
     * The data needed to update a organograma_x_regiao.
     * 
    **/
    data: XOR<organograma_x_regiaoUpdateInput, organograma_x_regiaoUncheckedUpdateInput>
    /**
     * Choose, which organograma_x_regiao to update.
     * 
    **/
    where: organograma_x_regiaoWhereUniqueInput
  }


  /**
   * organograma_x_regiao updateMany
   */
  export type organograma_x_regiaoUpdateManyArgs = {
    /**
     * The data used to update organograma_x_regiaos.
     * 
    **/
    data: XOR<organograma_x_regiaoUpdateManyMutationInput, organograma_x_regiaoUncheckedUpdateManyInput>
    /**
     * Filter which organograma_x_regiaos to update
     * 
    **/
    where?: organograma_x_regiaoWhereInput
  }


  /**
   * organograma_x_regiao upsert
   */
  export type organograma_x_regiaoUpsertArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao
     * 
    **/
    select?: organograma_x_regiaoSelect | null
    /**
     * The filter to search for the organograma_x_regiao to update in case it exists.
     * 
    **/
    where: organograma_x_regiaoWhereUniqueInput
    /**
     * In case the organograma_x_regiao found by the `where` argument doesn't exist, create a new organograma_x_regiao with this data.
     * 
    **/
    create: XOR<organograma_x_regiaoCreateInput, organograma_x_regiaoUncheckedCreateInput>
    /**
     * In case the organograma_x_regiao was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<organograma_x_regiaoUpdateInput, organograma_x_regiaoUncheckedUpdateInput>
  }


  /**
   * organograma_x_regiao delete
   */
  export type organograma_x_regiaoDeleteArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao
     * 
    **/
    select?: organograma_x_regiaoSelect | null
    /**
     * Filter which organograma_x_regiao to delete.
     * 
    **/
    where: organograma_x_regiaoWhereUniqueInput
  }


  /**
   * organograma_x_regiao deleteMany
   */
  export type organograma_x_regiaoDeleteManyArgs = {
    /**
     * Filter which organograma_x_regiaos to delete
     * 
    **/
    where?: organograma_x_regiaoWhereInput
  }


  /**
   * organograma_x_regiao: findUniqueOrThrow
   */
  export type organograma_x_regiaoFindUniqueOrThrowArgs = organograma_x_regiaoFindUniqueArgsBase
      

  /**
   * organograma_x_regiao: findFirstOrThrow
   */
  export type organograma_x_regiaoFindFirstOrThrowArgs = organograma_x_regiaoFindFirstArgsBase
      

  /**
   * organograma_x_regiao without action
   */
  export type organograma_x_regiaoArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao
     * 
    **/
    select?: organograma_x_regiaoSelect | null
  }



  /**
   * Model organograma_x_regiao_atuacao
   */


  export type AggregateOrganograma_x_regiao_atuacao = {
    _count: Organograma_x_regiao_atuacaoCountAggregateOutputType | null
    _avg: Organograma_x_regiao_atuacaoAvgAggregateOutputType | null
    _sum: Organograma_x_regiao_atuacaoSumAggregateOutputType | null
    _min: Organograma_x_regiao_atuacaoMinAggregateOutputType | null
    _max: Organograma_x_regiao_atuacaoMaxAggregateOutputType | null
  }

  export type Organograma_x_regiao_atuacaoAvgAggregateOutputType = {
    id: number | null
    organograma_id: number | null
    regiao_id: number | null
  }

  export type Organograma_x_regiao_atuacaoSumAggregateOutputType = {
    id: number | null
    organograma_id: number | null
    regiao_id: number | null
  }

  export type Organograma_x_regiao_atuacaoMinAggregateOutputType = {
    id: number | null
    organograma_id: number | null
    regiao_id: number | null
  }

  export type Organograma_x_regiao_atuacaoMaxAggregateOutputType = {
    id: number | null
    organograma_id: number | null
    regiao_id: number | null
  }

  export type Organograma_x_regiao_atuacaoCountAggregateOutputType = {
    id: number
    organograma_id: number
    regiao_id: number
    _all: number
  }


  export type Organograma_x_regiao_atuacaoAvgAggregateInputType = {
    id?: true
    organograma_id?: true
    regiao_id?: true
  }

  export type Organograma_x_regiao_atuacaoSumAggregateInputType = {
    id?: true
    organograma_id?: true
    regiao_id?: true
  }

  export type Organograma_x_regiao_atuacaoMinAggregateInputType = {
    id?: true
    organograma_id?: true
    regiao_id?: true
  }

  export type Organograma_x_regiao_atuacaoMaxAggregateInputType = {
    id?: true
    organograma_id?: true
    regiao_id?: true
  }

  export type Organograma_x_regiao_atuacaoCountAggregateInputType = {
    id?: true
    organograma_id?: true
    regiao_id?: true
    _all?: true
  }

  export type Organograma_x_regiao_atuacaoAggregateArgs = {
    /**
     * Filter which organograma_x_regiao_atuacao to aggregate.
     * 
    **/
    where?: organograma_x_regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_x_regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_x_regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: organograma_x_regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_x_regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_x_regiao_atuacaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organograma_x_regiao_atuacaos
    **/
    _count?: true | Organograma_x_regiao_atuacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Organograma_x_regiao_atuacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Organograma_x_regiao_atuacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Organograma_x_regiao_atuacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Organograma_x_regiao_atuacaoMaxAggregateInputType
  }

  export type GetOrganograma_x_regiao_atuacaoAggregateType<T extends Organograma_x_regiao_atuacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganograma_x_regiao_atuacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganograma_x_regiao_atuacao[P]>
      : GetScalarType<T[P], AggregateOrganograma_x_regiao_atuacao[P]>
  }




  export type Organograma_x_regiao_atuacaoGroupByArgs = {
    where?: organograma_x_regiao_atuacaoWhereInput
    orderBy?: Enumerable<organograma_x_regiao_atuacaoOrderByWithAggregationInput>
    by: Array<Organograma_x_regiao_atuacaoScalarFieldEnum>
    having?: organograma_x_regiao_atuacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Organograma_x_regiao_atuacaoCountAggregateInputType | true
    _avg?: Organograma_x_regiao_atuacaoAvgAggregateInputType
    _sum?: Organograma_x_regiao_atuacaoSumAggregateInputType
    _min?: Organograma_x_regiao_atuacaoMinAggregateInputType
    _max?: Organograma_x_regiao_atuacaoMaxAggregateInputType
  }


  export type Organograma_x_regiao_atuacaoGroupByOutputType = {
    id: number
    organograma_id: number
    regiao_id: number
    _count: Organograma_x_regiao_atuacaoCountAggregateOutputType | null
    _avg: Organograma_x_regiao_atuacaoAvgAggregateOutputType | null
    _sum: Organograma_x_regiao_atuacaoSumAggregateOutputType | null
    _min: Organograma_x_regiao_atuacaoMinAggregateOutputType | null
    _max: Organograma_x_regiao_atuacaoMaxAggregateOutputType | null
  }

  type GetOrganograma_x_regiao_atuacaoGroupByPayload<T extends Organograma_x_regiao_atuacaoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Organograma_x_regiao_atuacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Organograma_x_regiao_atuacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Organograma_x_regiao_atuacaoGroupByOutputType[P]>
            : GetScalarType<T[P], Organograma_x_regiao_atuacaoGroupByOutputType[P]>
        }
      >
    >


  export type organograma_x_regiao_atuacaoSelect = {
    id?: boolean
    organograma_id?: boolean
    regiao_id?: boolean
  }


  export type organograma_x_regiao_atuacaoGetPayload<S extends boolean | null | undefined | organograma_x_regiao_atuacaoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? organograma_x_regiao_atuacao :
    S extends undefined ? never :
    S extends { include: any } & (organograma_x_regiao_atuacaoArgs | organograma_x_regiao_atuacaoFindManyArgs)
    ? organograma_x_regiao_atuacao 
    : S extends { select: any } & (organograma_x_regiao_atuacaoArgs | organograma_x_regiao_atuacaoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof organograma_x_regiao_atuacao ? organograma_x_regiao_atuacao[P] : never
  } 
      : organograma_x_regiao_atuacao


  type organograma_x_regiao_atuacaoCountArgs = Merge<
    Omit<organograma_x_regiao_atuacaoFindManyArgs, 'select' | 'include'> & {
      select?: Organograma_x_regiao_atuacaoCountAggregateInputType | true
    }
  >

  export interface organograma_x_regiao_atuacaoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Organograma_x_regiao_atuacao that matches the filter.
     * @param {organograma_x_regiao_atuacaoFindUniqueArgs} args - Arguments to find a Organograma_x_regiao_atuacao
     * @example
     * // Get one Organograma_x_regiao_atuacao
     * const organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends organograma_x_regiao_atuacaoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, organograma_x_regiao_atuacaoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'organograma_x_regiao_atuacao'> extends True ? Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T>> : Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T> | null, null>

    /**
     * Find the first Organograma_x_regiao_atuacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_regiao_atuacaoFindFirstArgs} args - Arguments to find a Organograma_x_regiao_atuacao
     * @example
     * // Get one Organograma_x_regiao_atuacao
     * const organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends organograma_x_regiao_atuacaoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, organograma_x_regiao_atuacaoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'organograma_x_regiao_atuacao'> extends True ? Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T>> : Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T> | null, null>

    /**
     * Find zero or more Organograma_x_regiao_atuacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_regiao_atuacaoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organograma_x_regiao_atuacaos
     * const organograma_x_regiao_atuacaos = await prisma.organograma_x_regiao_atuacao.findMany()
     * 
     * // Get first 10 Organograma_x_regiao_atuacaos
     * const organograma_x_regiao_atuacaos = await prisma.organograma_x_regiao_atuacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organograma_x_regiao_atuacaoWithIdOnly = await prisma.organograma_x_regiao_atuacao.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends organograma_x_regiao_atuacaoFindManyArgs>(
      args?: SelectSubset<T, organograma_x_regiao_atuacaoFindManyArgs>
    ): PrismaPromise<Array<organograma_x_regiao_atuacaoGetPayload<T>>>

    /**
     * Create a Organograma_x_regiao_atuacao.
     * @param {organograma_x_regiao_atuacaoCreateArgs} args - Arguments to create a Organograma_x_regiao_atuacao.
     * @example
     * // Create one Organograma_x_regiao_atuacao
     * const Organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.create({
     *   data: {
     *     // ... data to create a Organograma_x_regiao_atuacao
     *   }
     * })
     * 
    **/
    create<T extends organograma_x_regiao_atuacaoCreateArgs>(
      args: SelectSubset<T, organograma_x_regiao_atuacaoCreateArgs>
    ): Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Create many Organograma_x_regiao_atuacaos.
     *     @param {organograma_x_regiao_atuacaoCreateManyArgs} args - Arguments to create many Organograma_x_regiao_atuacaos.
     *     @example
     *     // Create many Organograma_x_regiao_atuacaos
     *     const organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends organograma_x_regiao_atuacaoCreateManyArgs>(
      args?: SelectSubset<T, organograma_x_regiao_atuacaoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Organograma_x_regiao_atuacao.
     * @param {organograma_x_regiao_atuacaoDeleteArgs} args - Arguments to delete one Organograma_x_regiao_atuacao.
     * @example
     * // Delete one Organograma_x_regiao_atuacao
     * const Organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.delete({
     *   where: {
     *     // ... filter to delete one Organograma_x_regiao_atuacao
     *   }
     * })
     * 
    **/
    delete<T extends organograma_x_regiao_atuacaoDeleteArgs>(
      args: SelectSubset<T, organograma_x_regiao_atuacaoDeleteArgs>
    ): Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Update one Organograma_x_regiao_atuacao.
     * @param {organograma_x_regiao_atuacaoUpdateArgs} args - Arguments to update one Organograma_x_regiao_atuacao.
     * @example
     * // Update one Organograma_x_regiao_atuacao
     * const organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends organograma_x_regiao_atuacaoUpdateArgs>(
      args: SelectSubset<T, organograma_x_regiao_atuacaoUpdateArgs>
    ): Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Delete zero or more Organograma_x_regiao_atuacaos.
     * @param {organograma_x_regiao_atuacaoDeleteManyArgs} args - Arguments to filter Organograma_x_regiao_atuacaos to delete.
     * @example
     * // Delete a few Organograma_x_regiao_atuacaos
     * const { count } = await prisma.organograma_x_regiao_atuacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends organograma_x_regiao_atuacaoDeleteManyArgs>(
      args?: SelectSubset<T, organograma_x_regiao_atuacaoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organograma_x_regiao_atuacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_regiao_atuacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organograma_x_regiao_atuacaos
     * const organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends organograma_x_regiao_atuacaoUpdateManyArgs>(
      args: SelectSubset<T, organograma_x_regiao_atuacaoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Organograma_x_regiao_atuacao.
     * @param {organograma_x_regiao_atuacaoUpsertArgs} args - Arguments to update or create a Organograma_x_regiao_atuacao.
     * @example
     * // Update or create a Organograma_x_regiao_atuacao
     * const organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.upsert({
     *   create: {
     *     // ... data to create a Organograma_x_regiao_atuacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organograma_x_regiao_atuacao we want to update
     *   }
     * })
    **/
    upsert<T extends organograma_x_regiao_atuacaoUpsertArgs>(
      args: SelectSubset<T, organograma_x_regiao_atuacaoUpsertArgs>
    ): Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Find one Organograma_x_regiao_atuacao that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {organograma_x_regiao_atuacaoFindUniqueOrThrowArgs} args - Arguments to find a Organograma_x_regiao_atuacao
     * @example
     * // Get one Organograma_x_regiao_atuacao
     * const organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends organograma_x_regiao_atuacaoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, organograma_x_regiao_atuacaoFindUniqueOrThrowArgs>
    ): Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Find the first Organograma_x_regiao_atuacao that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_regiao_atuacaoFindFirstOrThrowArgs} args - Arguments to find a Organograma_x_regiao_atuacao
     * @example
     * // Get one Organograma_x_regiao_atuacao
     * const organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends organograma_x_regiao_atuacaoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, organograma_x_regiao_atuacaoFindFirstOrThrowArgs>
    ): Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Count the number of Organograma_x_regiao_atuacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_regiao_atuacaoCountArgs} args - Arguments to filter Organograma_x_regiao_atuacaos to count.
     * @example
     * // Count the number of Organograma_x_regiao_atuacaos
     * const count = await prisma.organograma_x_regiao_atuacao.count({
     *   where: {
     *     // ... the filter for the Organograma_x_regiao_atuacaos we want to count
     *   }
     * })
    **/
    count<T extends organograma_x_regiao_atuacaoCountArgs>(
      args?: Subset<T, organograma_x_regiao_atuacaoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Organograma_x_regiao_atuacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organograma_x_regiao_atuacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Organograma_x_regiao_atuacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Organograma_x_regiao_atuacaoAggregateArgs>(args: Subset<T, Organograma_x_regiao_atuacaoAggregateArgs>): PrismaPromise<GetOrganograma_x_regiao_atuacaoAggregateType<T>>

    /**
     * Group by Organograma_x_regiao_atuacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Organograma_x_regiao_atuacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Organograma_x_regiao_atuacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Organograma_x_regiao_atuacaoGroupByArgs['orderBy'] }
        : { orderBy?: Organograma_x_regiao_atuacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Organograma_x_regiao_atuacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganograma_x_regiao_atuacaoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for organograma_x_regiao_atuacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__organograma_x_regiao_atuacaoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * organograma_x_regiao_atuacao base type for findUnique actions
   */
  export type organograma_x_regiao_atuacaoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao_atuacao
     * 
    **/
    select?: organograma_x_regiao_atuacaoSelect | null
    /**
     * Filter, which organograma_x_regiao_atuacao to fetch.
     * 
    **/
    where: organograma_x_regiao_atuacaoWhereUniqueInput
  }

  /**
   * organograma_x_regiao_atuacao: findUnique
   */
  export interface organograma_x_regiao_atuacaoFindUniqueArgs extends organograma_x_regiao_atuacaoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organograma_x_regiao_atuacao base type for findFirst actions
   */
  export type organograma_x_regiao_atuacaoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao_atuacao
     * 
    **/
    select?: organograma_x_regiao_atuacaoSelect | null
    /**
     * Filter, which organograma_x_regiao_atuacao to fetch.
     * 
    **/
    where?: organograma_x_regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_x_regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_x_regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organograma_x_regiao_atuacaos.
     * 
    **/
    cursor?: organograma_x_regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_x_regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_x_regiao_atuacaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organograma_x_regiao_atuacaos.
     * 
    **/
    distinct?: Enumerable<Organograma_x_regiao_atuacaoScalarFieldEnum>
  }

  /**
   * organograma_x_regiao_atuacao: findFirst
   */
  export interface organograma_x_regiao_atuacaoFindFirstArgs extends organograma_x_regiao_atuacaoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organograma_x_regiao_atuacao findMany
   */
  export type organograma_x_regiao_atuacaoFindManyArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao_atuacao
     * 
    **/
    select?: organograma_x_regiao_atuacaoSelect | null
    /**
     * Filter, which organograma_x_regiao_atuacaos to fetch.
     * 
    **/
    where?: organograma_x_regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_x_regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_x_regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organograma_x_regiao_atuacaos.
     * 
    **/
    cursor?: organograma_x_regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_x_regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_x_regiao_atuacaos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Organograma_x_regiao_atuacaoScalarFieldEnum>
  }


  /**
   * organograma_x_regiao_atuacao create
   */
  export type organograma_x_regiao_atuacaoCreateArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao_atuacao
     * 
    **/
    select?: organograma_x_regiao_atuacaoSelect | null
    /**
     * The data needed to create a organograma_x_regiao_atuacao.
     * 
    **/
    data: XOR<organograma_x_regiao_atuacaoCreateInput, organograma_x_regiao_atuacaoUncheckedCreateInput>
  }


  /**
   * organograma_x_regiao_atuacao createMany
   */
  export type organograma_x_regiao_atuacaoCreateManyArgs = {
    /**
     * The data used to create many organograma_x_regiao_atuacaos.
     * 
    **/
    data: Enumerable<organograma_x_regiao_atuacaoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * organograma_x_regiao_atuacao update
   */
  export type organograma_x_regiao_atuacaoUpdateArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao_atuacao
     * 
    **/
    select?: organograma_x_regiao_atuacaoSelect | null
    /**
     * The data needed to update a organograma_x_regiao_atuacao.
     * 
    **/
    data: XOR<organograma_x_regiao_atuacaoUpdateInput, organograma_x_regiao_atuacaoUncheckedUpdateInput>
    /**
     * Choose, which organograma_x_regiao_atuacao to update.
     * 
    **/
    where: organograma_x_regiao_atuacaoWhereUniqueInput
  }


  /**
   * organograma_x_regiao_atuacao updateMany
   */
  export type organograma_x_regiao_atuacaoUpdateManyArgs = {
    /**
     * The data used to update organograma_x_regiao_atuacaos.
     * 
    **/
    data: XOR<organograma_x_regiao_atuacaoUpdateManyMutationInput, organograma_x_regiao_atuacaoUncheckedUpdateManyInput>
    /**
     * Filter which organograma_x_regiao_atuacaos to update
     * 
    **/
    where?: organograma_x_regiao_atuacaoWhereInput
  }


  /**
   * organograma_x_regiao_atuacao upsert
   */
  export type organograma_x_regiao_atuacaoUpsertArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao_atuacao
     * 
    **/
    select?: organograma_x_regiao_atuacaoSelect | null
    /**
     * The filter to search for the organograma_x_regiao_atuacao to update in case it exists.
     * 
    **/
    where: organograma_x_regiao_atuacaoWhereUniqueInput
    /**
     * In case the organograma_x_regiao_atuacao found by the `where` argument doesn't exist, create a new organograma_x_regiao_atuacao with this data.
     * 
    **/
    create: XOR<organograma_x_regiao_atuacaoCreateInput, organograma_x_regiao_atuacaoUncheckedCreateInput>
    /**
     * In case the organograma_x_regiao_atuacao was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<organograma_x_regiao_atuacaoUpdateInput, organograma_x_regiao_atuacaoUncheckedUpdateInput>
  }


  /**
   * organograma_x_regiao_atuacao delete
   */
  export type organograma_x_regiao_atuacaoDeleteArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao_atuacao
     * 
    **/
    select?: organograma_x_regiao_atuacaoSelect | null
    /**
     * Filter which organograma_x_regiao_atuacao to delete.
     * 
    **/
    where: organograma_x_regiao_atuacaoWhereUniqueInput
  }


  /**
   * organograma_x_regiao_atuacao deleteMany
   */
  export type organograma_x_regiao_atuacaoDeleteManyArgs = {
    /**
     * Filter which organograma_x_regiao_atuacaos to delete
     * 
    **/
    where?: organograma_x_regiao_atuacaoWhereInput
  }


  /**
   * organograma_x_regiao_atuacao: findUniqueOrThrow
   */
  export type organograma_x_regiao_atuacaoFindUniqueOrThrowArgs = organograma_x_regiao_atuacaoFindUniqueArgsBase
      

  /**
   * organograma_x_regiao_atuacao: findFirstOrThrow
   */
  export type organograma_x_regiao_atuacaoFindFirstOrThrowArgs = organograma_x_regiao_atuacaoFindFirstArgsBase
      

  /**
   * organograma_x_regiao_atuacao without action
   */
  export type organograma_x_regiao_atuacaoArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao_atuacao
     * 
    **/
    select?: organograma_x_regiao_atuacaoSelect | null
  }



  /**
   * Model pessoa
   */


  export type AggregatePessoa = {
    _count: PessoaCountAggregateOutputType | null
    _avg: PessoaAvgAggregateOutputType | null
    _sum: PessoaSumAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  export type PessoaAvgAggregateOutputType = {
    id: number | null
  }

  export type PessoaSumAggregateOutputType = {
    id: number | null
  }

  export type PessoaMinAggregateOutputType = {
    id: number | null
    nome: string | null
    sobrenome: string | null
    sexo: string | null
    nascimento: Date | null
    cpf: string | null
    rg: string | null
  }

  export type PessoaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    sobrenome: string | null
    sexo: string | null
    nascimento: Date | null
    cpf: string | null
    rg: string | null
  }

  export type PessoaCountAggregateOutputType = {
    id: number
    nome: number
    sobrenome: number
    sexo: number
    nascimento: number
    cpf: number
    rg: number
    _all: number
  }


  export type PessoaAvgAggregateInputType = {
    id?: true
  }

  export type PessoaSumAggregateInputType = {
    id?: true
  }

  export type PessoaMinAggregateInputType = {
    id?: true
    nome?: true
    sobrenome?: true
    sexo?: true
    nascimento?: true
    cpf?: true
    rg?: true
  }

  export type PessoaMaxAggregateInputType = {
    id?: true
    nome?: true
    sobrenome?: true
    sexo?: true
    nascimento?: true
    cpf?: true
    rg?: true
  }

  export type PessoaCountAggregateInputType = {
    id?: true
    nome?: true
    sobrenome?: true
    sexo?: true
    nascimento?: true
    cpf?: true
    rg?: true
    _all?: true
  }

  export type PessoaAggregateArgs = {
    /**
     * Filter which pessoa to aggregate.
     * 
    **/
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     * 
    **/
    orderBy?: Enumerable<pessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pessoas
    **/
    _count?: true | PessoaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PessoaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PessoaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PessoaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PessoaMaxAggregateInputType
  }

  export type GetPessoaAggregateType<T extends PessoaAggregateArgs> = {
        [P in keyof T & keyof AggregatePessoa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePessoa[P]>
      : GetScalarType<T[P], AggregatePessoa[P]>
  }




  export type PessoaGroupByArgs = {
    where?: pessoaWhereInput
    orderBy?: Enumerable<pessoaOrderByWithAggregationInput>
    by: Array<PessoaScalarFieldEnum>
    having?: pessoaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PessoaCountAggregateInputType | true
    _avg?: PessoaAvgAggregateInputType
    _sum?: PessoaSumAggregateInputType
    _min?: PessoaMinAggregateInputType
    _max?: PessoaMaxAggregateInputType
  }


  export type PessoaGroupByOutputType = {
    id: number
    nome: string
    sobrenome: string
    sexo: string | null
    nascimento: Date | null
    cpf: string | null
    rg: string | null
    _count: PessoaCountAggregateOutputType | null
    _avg: PessoaAvgAggregateOutputType | null
    _sum: PessoaSumAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  type GetPessoaGroupByPayload<T extends PessoaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PessoaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PessoaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PessoaGroupByOutputType[P]>
            : GetScalarType<T[P], PessoaGroupByOutputType[P]>
        }
      >
    >


  export type pessoaSelect = {
    id?: boolean
    nome?: boolean
    sobrenome?: boolean
    sexo?: boolean
    nascimento?: boolean
    cpf?: boolean
    rg?: boolean
    usuario?: boolean | usuarioFindManyArgs
    _count?: boolean | PessoaCountOutputTypeArgs
  }


  export type pessoaInclude = {
    usuario?: boolean | usuarioFindManyArgs
    _count?: boolean | PessoaCountOutputTypeArgs
  } 

  export type pessoaGetPayload<S extends boolean | null | undefined | pessoaArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? pessoa :
    S extends undefined ? never :
    S extends { include: any } & (pessoaArgs | pessoaFindManyArgs)
    ? pessoa  & {
    [P in TrueKeys<S['include']>]:
        P extends 'usuario' ? Array < usuarioGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? PessoaCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (pessoaArgs | pessoaFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'usuario' ? Array < usuarioGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? PessoaCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof pessoa ? pessoa[P] : never
  } 
      : pessoa


  type pessoaCountArgs = Merge<
    Omit<pessoaFindManyArgs, 'select' | 'include'> & {
      select?: PessoaCountAggregateInputType | true
    }
  >

  export interface pessoaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Pessoa that matches the filter.
     * @param {pessoaFindUniqueArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pessoaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pessoaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pessoa'> extends True ? Prisma__pessoaClient<pessoaGetPayload<T>> : Prisma__pessoaClient<pessoaGetPayload<T> | null, null>

    /**
     * Find the first Pessoa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaFindFirstArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pessoaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pessoaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pessoa'> extends True ? Prisma__pessoaClient<pessoaGetPayload<T>> : Prisma__pessoaClient<pessoaGetPayload<T> | null, null>

    /**
     * Find zero or more Pessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pessoas
     * const pessoas = await prisma.pessoa.findMany()
     * 
     * // Get first 10 Pessoas
     * const pessoas = await prisma.pessoa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pessoaWithIdOnly = await prisma.pessoa.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pessoaFindManyArgs>(
      args?: SelectSubset<T, pessoaFindManyArgs>
    ): PrismaPromise<Array<pessoaGetPayload<T>>>

    /**
     * Create a Pessoa.
     * @param {pessoaCreateArgs} args - Arguments to create a Pessoa.
     * @example
     * // Create one Pessoa
     * const Pessoa = await prisma.pessoa.create({
     *   data: {
     *     // ... data to create a Pessoa
     *   }
     * })
     * 
    **/
    create<T extends pessoaCreateArgs>(
      args: SelectSubset<T, pessoaCreateArgs>
    ): Prisma__pessoaClient<pessoaGetPayload<T>>

    /**
     * Create many Pessoas.
     *     @param {pessoaCreateManyArgs} args - Arguments to create many Pessoas.
     *     @example
     *     // Create many Pessoas
     *     const pessoa = await prisma.pessoa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pessoaCreateManyArgs>(
      args?: SelectSubset<T, pessoaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pessoa.
     * @param {pessoaDeleteArgs} args - Arguments to delete one Pessoa.
     * @example
     * // Delete one Pessoa
     * const Pessoa = await prisma.pessoa.delete({
     *   where: {
     *     // ... filter to delete one Pessoa
     *   }
     * })
     * 
    **/
    delete<T extends pessoaDeleteArgs>(
      args: SelectSubset<T, pessoaDeleteArgs>
    ): Prisma__pessoaClient<pessoaGetPayload<T>>

    /**
     * Update one Pessoa.
     * @param {pessoaUpdateArgs} args - Arguments to update one Pessoa.
     * @example
     * // Update one Pessoa
     * const pessoa = await prisma.pessoa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pessoaUpdateArgs>(
      args: SelectSubset<T, pessoaUpdateArgs>
    ): Prisma__pessoaClient<pessoaGetPayload<T>>

    /**
     * Delete zero or more Pessoas.
     * @param {pessoaDeleteManyArgs} args - Arguments to filter Pessoas to delete.
     * @example
     * // Delete a few Pessoas
     * const { count } = await prisma.pessoa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pessoaDeleteManyArgs>(
      args?: SelectSubset<T, pessoaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pessoas
     * const pessoa = await prisma.pessoa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pessoaUpdateManyArgs>(
      args: SelectSubset<T, pessoaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pessoa.
     * @param {pessoaUpsertArgs} args - Arguments to update or create a Pessoa.
     * @example
     * // Update or create a Pessoa
     * const pessoa = await prisma.pessoa.upsert({
     *   create: {
     *     // ... data to create a Pessoa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pessoa we want to update
     *   }
     * })
    **/
    upsert<T extends pessoaUpsertArgs>(
      args: SelectSubset<T, pessoaUpsertArgs>
    ): Prisma__pessoaClient<pessoaGetPayload<T>>

    /**
     * Find one Pessoa that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {pessoaFindUniqueOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pessoaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, pessoaFindUniqueOrThrowArgs>
    ): Prisma__pessoaClient<pessoaGetPayload<T>>

    /**
     * Find the first Pessoa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaFindFirstOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pessoaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, pessoaFindFirstOrThrowArgs>
    ): Prisma__pessoaClient<pessoaGetPayload<T>>

    /**
     * Count the number of Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCountArgs} args - Arguments to filter Pessoas to count.
     * @example
     * // Count the number of Pessoas
     * const count = await prisma.pessoa.count({
     *   where: {
     *     // ... the filter for the Pessoas we want to count
     *   }
     * })
    **/
    count<T extends pessoaCountArgs>(
      args?: Subset<T, pessoaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PessoaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PessoaAggregateArgs>(args: Subset<T, PessoaAggregateArgs>): PrismaPromise<GetPessoaAggregateType<T>>

    /**
     * Group by Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PessoaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PessoaGroupByArgs['orderBy'] }
        : { orderBy?: PessoaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PessoaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPessoaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for pessoa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pessoaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    usuario<T extends usuarioFindManyArgs= {}>(args?: Subset<T, usuarioFindManyArgs>): PrismaPromise<Array<usuarioGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * pessoa base type for findUnique actions
   */
  export type pessoaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the pessoa
     * 
    **/
    select?: pessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pessoaInclude | null
    /**
     * Filter, which pessoa to fetch.
     * 
    **/
    where: pessoaWhereUniqueInput
  }

  /**
   * pessoa: findUnique
   */
  export interface pessoaFindUniqueArgs extends pessoaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pessoa base type for findFirst actions
   */
  export type pessoaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the pessoa
     * 
    **/
    select?: pessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pessoaInclude | null
    /**
     * Filter, which pessoa to fetch.
     * 
    **/
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     * 
    **/
    orderBy?: Enumerable<pessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pessoas.
     * 
    **/
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pessoas.
     * 
    **/
    distinct?: Enumerable<PessoaScalarFieldEnum>
  }

  /**
   * pessoa: findFirst
   */
  export interface pessoaFindFirstArgs extends pessoaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pessoa findMany
   */
  export type pessoaFindManyArgs = {
    /**
     * Select specific fields to fetch from the pessoa
     * 
    **/
    select?: pessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pessoaInclude | null
    /**
     * Filter, which pessoas to fetch.
     * 
    **/
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     * 
    **/
    orderBy?: Enumerable<pessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pessoas.
     * 
    **/
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PessoaScalarFieldEnum>
  }


  /**
   * pessoa create
   */
  export type pessoaCreateArgs = {
    /**
     * Select specific fields to fetch from the pessoa
     * 
    **/
    select?: pessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pessoaInclude | null
    /**
     * The data needed to create a pessoa.
     * 
    **/
    data: XOR<pessoaCreateInput, pessoaUncheckedCreateInput>
  }


  /**
   * pessoa createMany
   */
  export type pessoaCreateManyArgs = {
    /**
     * The data used to create many pessoas.
     * 
    **/
    data: Enumerable<pessoaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pessoa update
   */
  export type pessoaUpdateArgs = {
    /**
     * Select specific fields to fetch from the pessoa
     * 
    **/
    select?: pessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pessoaInclude | null
    /**
     * The data needed to update a pessoa.
     * 
    **/
    data: XOR<pessoaUpdateInput, pessoaUncheckedUpdateInput>
    /**
     * Choose, which pessoa to update.
     * 
    **/
    where: pessoaWhereUniqueInput
  }


  /**
   * pessoa updateMany
   */
  export type pessoaUpdateManyArgs = {
    /**
     * The data used to update pessoas.
     * 
    **/
    data: XOR<pessoaUpdateManyMutationInput, pessoaUncheckedUpdateManyInput>
    /**
     * Filter which pessoas to update
     * 
    **/
    where?: pessoaWhereInput
  }


  /**
   * pessoa upsert
   */
  export type pessoaUpsertArgs = {
    /**
     * Select specific fields to fetch from the pessoa
     * 
    **/
    select?: pessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pessoaInclude | null
    /**
     * The filter to search for the pessoa to update in case it exists.
     * 
    **/
    where: pessoaWhereUniqueInput
    /**
     * In case the pessoa found by the `where` argument doesn't exist, create a new pessoa with this data.
     * 
    **/
    create: XOR<pessoaCreateInput, pessoaUncheckedCreateInput>
    /**
     * In case the pessoa was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<pessoaUpdateInput, pessoaUncheckedUpdateInput>
  }


  /**
   * pessoa delete
   */
  export type pessoaDeleteArgs = {
    /**
     * Select specific fields to fetch from the pessoa
     * 
    **/
    select?: pessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pessoaInclude | null
    /**
     * Filter which pessoa to delete.
     * 
    **/
    where: pessoaWhereUniqueInput
  }


  /**
   * pessoa deleteMany
   */
  export type pessoaDeleteManyArgs = {
    /**
     * Filter which pessoas to delete
     * 
    **/
    where?: pessoaWhereInput
  }


  /**
   * pessoa: findUniqueOrThrow
   */
  export type pessoaFindUniqueOrThrowArgs = pessoaFindUniqueArgsBase
      

  /**
   * pessoa: findFirstOrThrow
   */
  export type pessoaFindFirstOrThrowArgs = pessoaFindFirstArgsBase
      

  /**
   * pessoa without action
   */
  export type pessoaArgs = {
    /**
     * Select specific fields to fetch from the pessoa
     * 
    **/
    select?: pessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pessoaInclude | null
  }



  /**
   * Model plataforma
   */


  export type AggregatePlataforma = {
    _count: PlataformaCountAggregateOutputType | null
    _avg: PlataformaAvgAggregateOutputType | null
    _sum: PlataformaSumAggregateOutputType | null
    _min: PlataformaMinAggregateOutputType | null
    _max: PlataformaMaxAggregateOutputType | null
  }

  export type PlataformaAvgAggregateOutputType = {
    id: number | null
  }

  export type PlataformaSumAggregateOutputType = {
    id: number | null
  }

  export type PlataformaMinAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type PlataformaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type PlataformaCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type PlataformaAvgAggregateInputType = {
    id?: true
  }

  export type PlataformaSumAggregateInputType = {
    id?: true
  }

  export type PlataformaMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type PlataformaMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type PlataformaCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type PlataformaAggregateArgs = {
    /**
     * Filter which plataforma to aggregate.
     * 
    **/
    where?: plataformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataformas to fetch.
     * 
    **/
    orderBy?: Enumerable<plataformaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: plataformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataformas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataformas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plataformas
    **/
    _count?: true | PlataformaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlataformaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlataformaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlataformaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlataformaMaxAggregateInputType
  }

  export type GetPlataformaAggregateType<T extends PlataformaAggregateArgs> = {
        [P in keyof T & keyof AggregatePlataforma]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlataforma[P]>
      : GetScalarType<T[P], AggregatePlataforma[P]>
  }




  export type PlataformaGroupByArgs = {
    where?: plataformaWhereInput
    orderBy?: Enumerable<plataformaOrderByWithAggregationInput>
    by: Array<PlataformaScalarFieldEnum>
    having?: plataformaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlataformaCountAggregateInputType | true
    _avg?: PlataformaAvgAggregateInputType
    _sum?: PlataformaSumAggregateInputType
    _min?: PlataformaMinAggregateInputType
    _max?: PlataformaMaxAggregateInputType
  }


  export type PlataformaGroupByOutputType = {
    id: number
    nome: string | null
    _count: PlataformaCountAggregateOutputType | null
    _avg: PlataformaAvgAggregateOutputType | null
    _sum: PlataformaSumAggregateOutputType | null
    _min: PlataformaMinAggregateOutputType | null
    _max: PlataformaMaxAggregateOutputType | null
  }

  type GetPlataformaGroupByPayload<T extends PlataformaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlataformaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlataformaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlataformaGroupByOutputType[P]>
            : GetScalarType<T[P], PlataformaGroupByOutputType[P]>
        }
      >
    >


  export type plataformaSelect = {
    id?: boolean
    nome?: boolean
  }


  export type plataformaGetPayload<S extends boolean | null | undefined | plataformaArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? plataforma :
    S extends undefined ? never :
    S extends { include: any } & (plataformaArgs | plataformaFindManyArgs)
    ? plataforma 
    : S extends { select: any } & (plataformaArgs | plataformaFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof plataforma ? plataforma[P] : never
  } 
      : plataforma


  type plataformaCountArgs = Merge<
    Omit<plataformaFindManyArgs, 'select' | 'include'> & {
      select?: PlataformaCountAggregateInputType | true
    }
  >

  export interface plataformaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Plataforma that matches the filter.
     * @param {plataformaFindUniqueArgs} args - Arguments to find a Plataforma
     * @example
     * // Get one Plataforma
     * const plataforma = await prisma.plataforma.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends plataformaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, plataformaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'plataforma'> extends True ? Prisma__plataformaClient<plataformaGetPayload<T>> : Prisma__plataformaClient<plataformaGetPayload<T> | null, null>

    /**
     * Find the first Plataforma that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataformaFindFirstArgs} args - Arguments to find a Plataforma
     * @example
     * // Get one Plataforma
     * const plataforma = await prisma.plataforma.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends plataformaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, plataformaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'plataforma'> extends True ? Prisma__plataformaClient<plataformaGetPayload<T>> : Prisma__plataformaClient<plataformaGetPayload<T> | null, null>

    /**
     * Find zero or more Plataformas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataformaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plataformas
     * const plataformas = await prisma.plataforma.findMany()
     * 
     * // Get first 10 Plataformas
     * const plataformas = await prisma.plataforma.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plataformaWithIdOnly = await prisma.plataforma.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends plataformaFindManyArgs>(
      args?: SelectSubset<T, plataformaFindManyArgs>
    ): PrismaPromise<Array<plataformaGetPayload<T>>>

    /**
     * Create a Plataforma.
     * @param {plataformaCreateArgs} args - Arguments to create a Plataforma.
     * @example
     * // Create one Plataforma
     * const Plataforma = await prisma.plataforma.create({
     *   data: {
     *     // ... data to create a Plataforma
     *   }
     * })
     * 
    **/
    create<T extends plataformaCreateArgs>(
      args: SelectSubset<T, plataformaCreateArgs>
    ): Prisma__plataformaClient<plataformaGetPayload<T>>

    /**
     * Create many Plataformas.
     *     @param {plataformaCreateManyArgs} args - Arguments to create many Plataformas.
     *     @example
     *     // Create many Plataformas
     *     const plataforma = await prisma.plataforma.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends plataformaCreateManyArgs>(
      args?: SelectSubset<T, plataformaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Plataforma.
     * @param {plataformaDeleteArgs} args - Arguments to delete one Plataforma.
     * @example
     * // Delete one Plataforma
     * const Plataforma = await prisma.plataforma.delete({
     *   where: {
     *     // ... filter to delete one Plataforma
     *   }
     * })
     * 
    **/
    delete<T extends plataformaDeleteArgs>(
      args: SelectSubset<T, plataformaDeleteArgs>
    ): Prisma__plataformaClient<plataformaGetPayload<T>>

    /**
     * Update one Plataforma.
     * @param {plataformaUpdateArgs} args - Arguments to update one Plataforma.
     * @example
     * // Update one Plataforma
     * const plataforma = await prisma.plataforma.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends plataformaUpdateArgs>(
      args: SelectSubset<T, plataformaUpdateArgs>
    ): Prisma__plataformaClient<plataformaGetPayload<T>>

    /**
     * Delete zero or more Plataformas.
     * @param {plataformaDeleteManyArgs} args - Arguments to filter Plataformas to delete.
     * @example
     * // Delete a few Plataformas
     * const { count } = await prisma.plataforma.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends plataformaDeleteManyArgs>(
      args?: SelectSubset<T, plataformaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plataformas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataformaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plataformas
     * const plataforma = await prisma.plataforma.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends plataformaUpdateManyArgs>(
      args: SelectSubset<T, plataformaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Plataforma.
     * @param {plataformaUpsertArgs} args - Arguments to update or create a Plataforma.
     * @example
     * // Update or create a Plataforma
     * const plataforma = await prisma.plataforma.upsert({
     *   create: {
     *     // ... data to create a Plataforma
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plataforma we want to update
     *   }
     * })
    **/
    upsert<T extends plataformaUpsertArgs>(
      args: SelectSubset<T, plataformaUpsertArgs>
    ): Prisma__plataformaClient<plataformaGetPayload<T>>

    /**
     * Find one Plataforma that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {plataformaFindUniqueOrThrowArgs} args - Arguments to find a Plataforma
     * @example
     * // Get one Plataforma
     * const plataforma = await prisma.plataforma.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends plataformaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, plataformaFindUniqueOrThrowArgs>
    ): Prisma__plataformaClient<plataformaGetPayload<T>>

    /**
     * Find the first Plataforma that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataformaFindFirstOrThrowArgs} args - Arguments to find a Plataforma
     * @example
     * // Get one Plataforma
     * const plataforma = await prisma.plataforma.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends plataformaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, plataformaFindFirstOrThrowArgs>
    ): Prisma__plataformaClient<plataformaGetPayload<T>>

    /**
     * Count the number of Plataformas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataformaCountArgs} args - Arguments to filter Plataformas to count.
     * @example
     * // Count the number of Plataformas
     * const count = await prisma.plataforma.count({
     *   where: {
     *     // ... the filter for the Plataformas we want to count
     *   }
     * })
    **/
    count<T extends plataformaCountArgs>(
      args?: Subset<T, plataformaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlataformaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plataforma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlataformaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlataformaAggregateArgs>(args: Subset<T, PlataformaAggregateArgs>): PrismaPromise<GetPlataformaAggregateType<T>>

    /**
     * Group by Plataforma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlataformaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlataformaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlataformaGroupByArgs['orderBy'] }
        : { orderBy?: PlataformaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlataformaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlataformaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for plataforma.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__plataformaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * plataforma base type for findUnique actions
   */
  export type plataformaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma
     * 
    **/
    select?: plataformaSelect | null
    /**
     * Filter, which plataforma to fetch.
     * 
    **/
    where: plataformaWhereUniqueInput
  }

  /**
   * plataforma: findUnique
   */
  export interface plataformaFindUniqueArgs extends plataformaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma base type for findFirst actions
   */
  export type plataformaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma
     * 
    **/
    select?: plataformaSelect | null
    /**
     * Filter, which plataforma to fetch.
     * 
    **/
    where?: plataformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataformas to fetch.
     * 
    **/
    orderBy?: Enumerable<plataformaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plataformas.
     * 
    **/
    cursor?: plataformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataformas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataformas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plataformas.
     * 
    **/
    distinct?: Enumerable<PlataformaScalarFieldEnum>
  }

  /**
   * plataforma: findFirst
   */
  export interface plataformaFindFirstArgs extends plataformaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma findMany
   */
  export type plataformaFindManyArgs = {
    /**
     * Select specific fields to fetch from the plataforma
     * 
    **/
    select?: plataformaSelect | null
    /**
     * Filter, which plataformas to fetch.
     * 
    **/
    where?: plataformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataformas to fetch.
     * 
    **/
    orderBy?: Enumerable<plataformaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plataformas.
     * 
    **/
    cursor?: plataformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataformas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataformas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlataformaScalarFieldEnum>
  }


  /**
   * plataforma create
   */
  export type plataformaCreateArgs = {
    /**
     * Select specific fields to fetch from the plataforma
     * 
    **/
    select?: plataformaSelect | null
    /**
     * The data needed to create a plataforma.
     * 
    **/
    data: XOR<plataformaCreateInput, plataformaUncheckedCreateInput>
  }


  /**
   * plataforma createMany
   */
  export type plataformaCreateManyArgs = {
    /**
     * The data used to create many plataformas.
     * 
    **/
    data: Enumerable<plataformaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * plataforma update
   */
  export type plataformaUpdateArgs = {
    /**
     * Select specific fields to fetch from the plataforma
     * 
    **/
    select?: plataformaSelect | null
    /**
     * The data needed to update a plataforma.
     * 
    **/
    data: XOR<plataformaUpdateInput, plataformaUncheckedUpdateInput>
    /**
     * Choose, which plataforma to update.
     * 
    **/
    where: plataformaWhereUniqueInput
  }


  /**
   * plataforma updateMany
   */
  export type plataformaUpdateManyArgs = {
    /**
     * The data used to update plataformas.
     * 
    **/
    data: XOR<plataformaUpdateManyMutationInput, plataformaUncheckedUpdateManyInput>
    /**
     * Filter which plataformas to update
     * 
    **/
    where?: plataformaWhereInput
  }


  /**
   * plataforma upsert
   */
  export type plataformaUpsertArgs = {
    /**
     * Select specific fields to fetch from the plataforma
     * 
    **/
    select?: plataformaSelect | null
    /**
     * The filter to search for the plataforma to update in case it exists.
     * 
    **/
    where: plataformaWhereUniqueInput
    /**
     * In case the plataforma found by the `where` argument doesn't exist, create a new plataforma with this data.
     * 
    **/
    create: XOR<plataformaCreateInput, plataformaUncheckedCreateInput>
    /**
     * In case the plataforma was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<plataformaUpdateInput, plataformaUncheckedUpdateInput>
  }


  /**
   * plataforma delete
   */
  export type plataformaDeleteArgs = {
    /**
     * Select specific fields to fetch from the plataforma
     * 
    **/
    select?: plataformaSelect | null
    /**
     * Filter which plataforma to delete.
     * 
    **/
    where: plataformaWhereUniqueInput
  }


  /**
   * plataforma deleteMany
   */
  export type plataformaDeleteManyArgs = {
    /**
     * Filter which plataformas to delete
     * 
    **/
    where?: plataformaWhereInput
  }


  /**
   * plataforma: findUniqueOrThrow
   */
  export type plataformaFindUniqueOrThrowArgs = plataformaFindUniqueArgsBase
      

  /**
   * plataforma: findFirstOrThrow
   */
  export type plataformaFindFirstOrThrowArgs = plataformaFindFirstArgsBase
      

  /**
   * plataforma without action
   */
  export type plataformaArgs = {
    /**
     * Select specific fields to fetch from the plataforma
     * 
    **/
    select?: plataformaSelect | null
  }



  /**
   * Model plataforma_n_borderos
   */


  export type AggregatePlataforma_n_borderos = {
    _count: Plataforma_n_borderosCountAggregateOutputType | null
    _avg: Plataforma_n_borderosAvgAggregateOutputType | null
    _sum: Plataforma_n_borderosSumAggregateOutputType | null
    _min: Plataforma_n_borderosMinAggregateOutputType | null
    _max: Plataforma_n_borderosMaxAggregateOutputType | null
  }

  export type Plataforma_n_borderosAvgAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_n_borderosSumAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_n_borderosMinAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_n_borderosMaxAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_n_borderosCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type Plataforma_n_borderosAvgAggregateInputType = {
    id?: true
  }

  export type Plataforma_n_borderosSumAggregateInputType = {
    id?: true
  }

  export type Plataforma_n_borderosMinAggregateInputType = {
    id?: true
  }

  export type Plataforma_n_borderosMaxAggregateInputType = {
    id?: true
  }

  export type Plataforma_n_borderosCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type Plataforma_n_borderosAggregateArgs = {
    /**
     * Filter which plataforma_n_borderos to aggregate.
     * 
    **/
    where?: plataforma_n_borderosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_n_borderos to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_n_borderosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: plataforma_n_borderosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_n_borderos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_n_borderos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plataforma_n_borderos
    **/
    _count?: true | Plataforma_n_borderosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plataforma_n_borderosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plataforma_n_borderosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plataforma_n_borderosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plataforma_n_borderosMaxAggregateInputType
  }

  export type GetPlataforma_n_borderosAggregateType<T extends Plataforma_n_borderosAggregateArgs> = {
        [P in keyof T & keyof AggregatePlataforma_n_borderos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlataforma_n_borderos[P]>
      : GetScalarType<T[P], AggregatePlataforma_n_borderos[P]>
  }




  export type Plataforma_n_borderosGroupByArgs = {
    where?: plataforma_n_borderosWhereInput
    orderBy?: Enumerable<plataforma_n_borderosOrderByWithAggregationInput>
    by: Array<Plataforma_n_borderosScalarFieldEnum>
    having?: plataforma_n_borderosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plataforma_n_borderosCountAggregateInputType | true
    _avg?: Plataforma_n_borderosAvgAggregateInputType
    _sum?: Plataforma_n_borderosSumAggregateInputType
    _min?: Plataforma_n_borderosMinAggregateInputType
    _max?: Plataforma_n_borderosMaxAggregateInputType
  }


  export type Plataforma_n_borderosGroupByOutputType = {
    id: number
    _count: Plataforma_n_borderosCountAggregateOutputType | null
    _avg: Plataforma_n_borderosAvgAggregateOutputType | null
    _sum: Plataforma_n_borderosSumAggregateOutputType | null
    _min: Plataforma_n_borderosMinAggregateOutputType | null
    _max: Plataforma_n_borderosMaxAggregateOutputType | null
  }

  type GetPlataforma_n_borderosGroupByPayload<T extends Plataforma_n_borderosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Plataforma_n_borderosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plataforma_n_borderosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plataforma_n_borderosGroupByOutputType[P]>
            : GetScalarType<T[P], Plataforma_n_borderosGroupByOutputType[P]>
        }
      >
    >


  export type plataforma_n_borderosSelect = {
    id?: boolean
  }


  export type plataforma_n_borderosGetPayload<S extends boolean | null | undefined | plataforma_n_borderosArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? plataforma_n_borderos :
    S extends undefined ? never :
    S extends { include: any } & (plataforma_n_borderosArgs | plataforma_n_borderosFindManyArgs)
    ? plataforma_n_borderos 
    : S extends { select: any } & (plataforma_n_borderosArgs | plataforma_n_borderosFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof plataforma_n_borderos ? plataforma_n_borderos[P] : never
  } 
      : plataforma_n_borderos


  type plataforma_n_borderosCountArgs = Merge<
    Omit<plataforma_n_borderosFindManyArgs, 'select' | 'include'> & {
      select?: Plataforma_n_borderosCountAggregateInputType | true
    }
  >

  export interface plataforma_n_borderosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Plataforma_n_borderos that matches the filter.
     * @param {plataforma_n_borderosFindUniqueArgs} args - Arguments to find a Plataforma_n_borderos
     * @example
     * // Get one Plataforma_n_borderos
     * const plataforma_n_borderos = await prisma.plataforma_n_borderos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends plataforma_n_borderosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, plataforma_n_borderosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'plataforma_n_borderos'> extends True ? Prisma__plataforma_n_borderosClient<plataforma_n_borderosGetPayload<T>> : Prisma__plataforma_n_borderosClient<plataforma_n_borderosGetPayload<T> | null, null>

    /**
     * Find the first Plataforma_n_borderos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_n_borderosFindFirstArgs} args - Arguments to find a Plataforma_n_borderos
     * @example
     * // Get one Plataforma_n_borderos
     * const plataforma_n_borderos = await prisma.plataforma_n_borderos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends plataforma_n_borderosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, plataforma_n_borderosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'plataforma_n_borderos'> extends True ? Prisma__plataforma_n_borderosClient<plataforma_n_borderosGetPayload<T>> : Prisma__plataforma_n_borderosClient<plataforma_n_borderosGetPayload<T> | null, null>

    /**
     * Find zero or more Plataforma_n_borderos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_n_borderosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plataforma_n_borderos
     * const plataforma_n_borderos = await prisma.plataforma_n_borderos.findMany()
     * 
     * // Get first 10 Plataforma_n_borderos
     * const plataforma_n_borderos = await prisma.plataforma_n_borderos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plataforma_n_borderosWithIdOnly = await prisma.plataforma_n_borderos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends plataforma_n_borderosFindManyArgs>(
      args?: SelectSubset<T, plataforma_n_borderosFindManyArgs>
    ): PrismaPromise<Array<plataforma_n_borderosGetPayload<T>>>

    /**
     * Create a Plataforma_n_borderos.
     * @param {plataforma_n_borderosCreateArgs} args - Arguments to create a Plataforma_n_borderos.
     * @example
     * // Create one Plataforma_n_borderos
     * const Plataforma_n_borderos = await prisma.plataforma_n_borderos.create({
     *   data: {
     *     // ... data to create a Plataforma_n_borderos
     *   }
     * })
     * 
    **/
    create<T extends plataforma_n_borderosCreateArgs>(
      args: SelectSubset<T, plataforma_n_borderosCreateArgs>
    ): Prisma__plataforma_n_borderosClient<plataforma_n_borderosGetPayload<T>>

    /**
     * Create many Plataforma_n_borderos.
     *     @param {plataforma_n_borderosCreateManyArgs} args - Arguments to create many Plataforma_n_borderos.
     *     @example
     *     // Create many Plataforma_n_borderos
     *     const plataforma_n_borderos = await prisma.plataforma_n_borderos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends plataforma_n_borderosCreateManyArgs>(
      args?: SelectSubset<T, plataforma_n_borderosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Plataforma_n_borderos.
     * @param {plataforma_n_borderosDeleteArgs} args - Arguments to delete one Plataforma_n_borderos.
     * @example
     * // Delete one Plataforma_n_borderos
     * const Plataforma_n_borderos = await prisma.plataforma_n_borderos.delete({
     *   where: {
     *     // ... filter to delete one Plataforma_n_borderos
     *   }
     * })
     * 
    **/
    delete<T extends plataforma_n_borderosDeleteArgs>(
      args: SelectSubset<T, plataforma_n_borderosDeleteArgs>
    ): Prisma__plataforma_n_borderosClient<plataforma_n_borderosGetPayload<T>>

    /**
     * Update one Plataforma_n_borderos.
     * @param {plataforma_n_borderosUpdateArgs} args - Arguments to update one Plataforma_n_borderos.
     * @example
     * // Update one Plataforma_n_borderos
     * const plataforma_n_borderos = await prisma.plataforma_n_borderos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends plataforma_n_borderosUpdateArgs>(
      args: SelectSubset<T, plataforma_n_borderosUpdateArgs>
    ): Prisma__plataforma_n_borderosClient<plataforma_n_borderosGetPayload<T>>

    /**
     * Delete zero or more Plataforma_n_borderos.
     * @param {plataforma_n_borderosDeleteManyArgs} args - Arguments to filter Plataforma_n_borderos to delete.
     * @example
     * // Delete a few Plataforma_n_borderos
     * const { count } = await prisma.plataforma_n_borderos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends plataforma_n_borderosDeleteManyArgs>(
      args?: SelectSubset<T, plataforma_n_borderosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plataforma_n_borderos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_n_borderosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plataforma_n_borderos
     * const plataforma_n_borderos = await prisma.plataforma_n_borderos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends plataforma_n_borderosUpdateManyArgs>(
      args: SelectSubset<T, plataforma_n_borderosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Plataforma_n_borderos.
     * @param {plataforma_n_borderosUpsertArgs} args - Arguments to update or create a Plataforma_n_borderos.
     * @example
     * // Update or create a Plataforma_n_borderos
     * const plataforma_n_borderos = await prisma.plataforma_n_borderos.upsert({
     *   create: {
     *     // ... data to create a Plataforma_n_borderos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plataforma_n_borderos we want to update
     *   }
     * })
    **/
    upsert<T extends plataforma_n_borderosUpsertArgs>(
      args: SelectSubset<T, plataforma_n_borderosUpsertArgs>
    ): Prisma__plataforma_n_borderosClient<plataforma_n_borderosGetPayload<T>>

    /**
     * Find one Plataforma_n_borderos that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {plataforma_n_borderosFindUniqueOrThrowArgs} args - Arguments to find a Plataforma_n_borderos
     * @example
     * // Get one Plataforma_n_borderos
     * const plataforma_n_borderos = await prisma.plataforma_n_borderos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends plataforma_n_borderosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, plataforma_n_borderosFindUniqueOrThrowArgs>
    ): Prisma__plataforma_n_borderosClient<plataforma_n_borderosGetPayload<T>>

    /**
     * Find the first Plataforma_n_borderos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_n_borderosFindFirstOrThrowArgs} args - Arguments to find a Plataforma_n_borderos
     * @example
     * // Get one Plataforma_n_borderos
     * const plataforma_n_borderos = await prisma.plataforma_n_borderos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends plataforma_n_borderosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, plataforma_n_borderosFindFirstOrThrowArgs>
    ): Prisma__plataforma_n_borderosClient<plataforma_n_borderosGetPayload<T>>

    /**
     * Count the number of Plataforma_n_borderos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_n_borderosCountArgs} args - Arguments to filter Plataforma_n_borderos to count.
     * @example
     * // Count the number of Plataforma_n_borderos
     * const count = await prisma.plataforma_n_borderos.count({
     *   where: {
     *     // ... the filter for the Plataforma_n_borderos we want to count
     *   }
     * })
    **/
    count<T extends plataforma_n_borderosCountArgs>(
      args?: Subset<T, plataforma_n_borderosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plataforma_n_borderosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plataforma_n_borderos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plataforma_n_borderosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plataforma_n_borderosAggregateArgs>(args: Subset<T, Plataforma_n_borderosAggregateArgs>): PrismaPromise<GetPlataforma_n_borderosAggregateType<T>>

    /**
     * Group by Plataforma_n_borderos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plataforma_n_borderosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Plataforma_n_borderosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Plataforma_n_borderosGroupByArgs['orderBy'] }
        : { orderBy?: Plataforma_n_borderosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Plataforma_n_borderosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlataforma_n_borderosGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for plataforma_n_borderos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__plataforma_n_borderosClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * plataforma_n_borderos base type for findUnique actions
   */
  export type plataforma_n_borderosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma_n_borderos
     * 
    **/
    select?: plataforma_n_borderosSelect | null
    /**
     * Filter, which plataforma_n_borderos to fetch.
     * 
    **/
    where: plataforma_n_borderosWhereUniqueInput
  }

  /**
   * plataforma_n_borderos: findUnique
   */
  export interface plataforma_n_borderosFindUniqueArgs extends plataforma_n_borderosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma_n_borderos base type for findFirst actions
   */
  export type plataforma_n_borderosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma_n_borderos
     * 
    **/
    select?: plataforma_n_borderosSelect | null
    /**
     * Filter, which plataforma_n_borderos to fetch.
     * 
    **/
    where?: plataforma_n_borderosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_n_borderos to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_n_borderosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plataforma_n_borderos.
     * 
    **/
    cursor?: plataforma_n_borderosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_n_borderos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_n_borderos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plataforma_n_borderos.
     * 
    **/
    distinct?: Enumerable<Plataforma_n_borderosScalarFieldEnum>
  }

  /**
   * plataforma_n_borderos: findFirst
   */
  export interface plataforma_n_borderosFindFirstArgs extends plataforma_n_borderosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma_n_borderos findMany
   */
  export type plataforma_n_borderosFindManyArgs = {
    /**
     * Select specific fields to fetch from the plataforma_n_borderos
     * 
    **/
    select?: plataforma_n_borderosSelect | null
    /**
     * Filter, which plataforma_n_borderos to fetch.
     * 
    **/
    where?: plataforma_n_borderosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_n_borderos to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_n_borderosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plataforma_n_borderos.
     * 
    **/
    cursor?: plataforma_n_borderosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_n_borderos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_n_borderos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Plataforma_n_borderosScalarFieldEnum>
  }


  /**
   * plataforma_n_borderos create
   */
  export type plataforma_n_borderosCreateArgs = {
    /**
     * Select specific fields to fetch from the plataforma_n_borderos
     * 
    **/
    select?: plataforma_n_borderosSelect | null
    /**
     * The data needed to create a plataforma_n_borderos.
     * 
    **/
    data?: XOR<plataforma_n_borderosCreateInput, plataforma_n_borderosUncheckedCreateInput>
  }


  /**
   * plataforma_n_borderos createMany
   */
  export type plataforma_n_borderosCreateManyArgs = {
    /**
     * The data used to create many plataforma_n_borderos.
     * 
    **/
    data: Enumerable<plataforma_n_borderosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * plataforma_n_borderos update
   */
  export type plataforma_n_borderosUpdateArgs = {
    /**
     * Select specific fields to fetch from the plataforma_n_borderos
     * 
    **/
    select?: plataforma_n_borderosSelect | null
    /**
     * The data needed to update a plataforma_n_borderos.
     * 
    **/
    data: XOR<plataforma_n_borderosUpdateInput, plataforma_n_borderosUncheckedUpdateInput>
    /**
     * Choose, which plataforma_n_borderos to update.
     * 
    **/
    where: plataforma_n_borderosWhereUniqueInput
  }


  /**
   * plataforma_n_borderos updateMany
   */
  export type plataforma_n_borderosUpdateManyArgs = {
    /**
     * The data used to update plataforma_n_borderos.
     * 
    **/
    data: XOR<plataforma_n_borderosUpdateManyMutationInput, plataforma_n_borderosUncheckedUpdateManyInput>
    /**
     * Filter which plataforma_n_borderos to update
     * 
    **/
    where?: plataforma_n_borderosWhereInput
  }


  /**
   * plataforma_n_borderos upsert
   */
  export type plataforma_n_borderosUpsertArgs = {
    /**
     * Select specific fields to fetch from the plataforma_n_borderos
     * 
    **/
    select?: plataforma_n_borderosSelect | null
    /**
     * The filter to search for the plataforma_n_borderos to update in case it exists.
     * 
    **/
    where: plataforma_n_borderosWhereUniqueInput
    /**
     * In case the plataforma_n_borderos found by the `where` argument doesn't exist, create a new plataforma_n_borderos with this data.
     * 
    **/
    create: XOR<plataforma_n_borderosCreateInput, plataforma_n_borderosUncheckedCreateInput>
    /**
     * In case the plataforma_n_borderos was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<plataforma_n_borderosUpdateInput, plataforma_n_borderosUncheckedUpdateInput>
  }


  /**
   * plataforma_n_borderos delete
   */
  export type plataforma_n_borderosDeleteArgs = {
    /**
     * Select specific fields to fetch from the plataforma_n_borderos
     * 
    **/
    select?: plataforma_n_borderosSelect | null
    /**
     * Filter which plataforma_n_borderos to delete.
     * 
    **/
    where: plataforma_n_borderosWhereUniqueInput
  }


  /**
   * plataforma_n_borderos deleteMany
   */
  export type plataforma_n_borderosDeleteManyArgs = {
    /**
     * Filter which plataforma_n_borderos to delete
     * 
    **/
    where?: plataforma_n_borderosWhereInput
  }


  /**
   * plataforma_n_borderos: findUniqueOrThrow
   */
  export type plataforma_n_borderosFindUniqueOrThrowArgs = plataforma_n_borderosFindUniqueArgsBase
      

  /**
   * plataforma_n_borderos: findFirstOrThrow
   */
  export type plataforma_n_borderosFindFirstOrThrowArgs = plataforma_n_borderosFindFirstArgsBase
      

  /**
   * plataforma_n_borderos without action
   */
  export type plataforma_n_borderosArgs = {
    /**
     * Select specific fields to fetch from the plataforma_n_borderos
     * 
    **/
    select?: plataforma_n_borderosSelect | null
  }



  /**
   * Model plataforma_papel_tipo
   */


  export type AggregatePlataforma_papel_tipo = {
    _count: Plataforma_papel_tipoCountAggregateOutputType | null
    _avg: Plataforma_papel_tipoAvgAggregateOutputType | null
    _sum: Plataforma_papel_tipoSumAggregateOutputType | null
    _min: Plataforma_papel_tipoMinAggregateOutputType | null
    _max: Plataforma_papel_tipoMaxAggregateOutputType | null
  }

  export type Plataforma_papel_tipoAvgAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_papel_tipoSumAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_papel_tipoMinAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_papel_tipoMaxAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_papel_tipoCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type Plataforma_papel_tipoAvgAggregateInputType = {
    id?: true
  }

  export type Plataforma_papel_tipoSumAggregateInputType = {
    id?: true
  }

  export type Plataforma_papel_tipoMinAggregateInputType = {
    id?: true
  }

  export type Plataforma_papel_tipoMaxAggregateInputType = {
    id?: true
  }

  export type Plataforma_papel_tipoCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type Plataforma_papel_tipoAggregateArgs = {
    /**
     * Filter which plataforma_papel_tipo to aggregate.
     * 
    **/
    where?: plataforma_papel_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_papel_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_papel_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: plataforma_papel_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_papel_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_papel_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plataforma_papel_tipos
    **/
    _count?: true | Plataforma_papel_tipoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plataforma_papel_tipoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plataforma_papel_tipoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plataforma_papel_tipoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plataforma_papel_tipoMaxAggregateInputType
  }

  export type GetPlataforma_papel_tipoAggregateType<T extends Plataforma_papel_tipoAggregateArgs> = {
        [P in keyof T & keyof AggregatePlataforma_papel_tipo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlataforma_papel_tipo[P]>
      : GetScalarType<T[P], AggregatePlataforma_papel_tipo[P]>
  }




  export type Plataforma_papel_tipoGroupByArgs = {
    where?: plataforma_papel_tipoWhereInput
    orderBy?: Enumerable<plataforma_papel_tipoOrderByWithAggregationInput>
    by: Array<Plataforma_papel_tipoScalarFieldEnum>
    having?: plataforma_papel_tipoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plataforma_papel_tipoCountAggregateInputType | true
    _avg?: Plataforma_papel_tipoAvgAggregateInputType
    _sum?: Plataforma_papel_tipoSumAggregateInputType
    _min?: Plataforma_papel_tipoMinAggregateInputType
    _max?: Plataforma_papel_tipoMaxAggregateInputType
  }


  export type Plataforma_papel_tipoGroupByOutputType = {
    id: number
    _count: Plataforma_papel_tipoCountAggregateOutputType | null
    _avg: Plataforma_papel_tipoAvgAggregateOutputType | null
    _sum: Plataforma_papel_tipoSumAggregateOutputType | null
    _min: Plataforma_papel_tipoMinAggregateOutputType | null
    _max: Plataforma_papel_tipoMaxAggregateOutputType | null
  }

  type GetPlataforma_papel_tipoGroupByPayload<T extends Plataforma_papel_tipoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Plataforma_papel_tipoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plataforma_papel_tipoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plataforma_papel_tipoGroupByOutputType[P]>
            : GetScalarType<T[P], Plataforma_papel_tipoGroupByOutputType[P]>
        }
      >
    >


  export type plataforma_papel_tipoSelect = {
    id?: boolean
  }


  export type plataforma_papel_tipoGetPayload<S extends boolean | null | undefined | plataforma_papel_tipoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? plataforma_papel_tipo :
    S extends undefined ? never :
    S extends { include: any } & (plataforma_papel_tipoArgs | plataforma_papel_tipoFindManyArgs)
    ? plataforma_papel_tipo 
    : S extends { select: any } & (plataforma_papel_tipoArgs | plataforma_papel_tipoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof plataforma_papel_tipo ? plataforma_papel_tipo[P] : never
  } 
      : plataforma_papel_tipo


  type plataforma_papel_tipoCountArgs = Merge<
    Omit<plataforma_papel_tipoFindManyArgs, 'select' | 'include'> & {
      select?: Plataforma_papel_tipoCountAggregateInputType | true
    }
  >

  export interface plataforma_papel_tipoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Plataforma_papel_tipo that matches the filter.
     * @param {plataforma_papel_tipoFindUniqueArgs} args - Arguments to find a Plataforma_papel_tipo
     * @example
     * // Get one Plataforma_papel_tipo
     * const plataforma_papel_tipo = await prisma.plataforma_papel_tipo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends plataforma_papel_tipoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, plataforma_papel_tipoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'plataforma_papel_tipo'> extends True ? Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T>> : Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T> | null, null>

    /**
     * Find the first Plataforma_papel_tipo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_papel_tipoFindFirstArgs} args - Arguments to find a Plataforma_papel_tipo
     * @example
     * // Get one Plataforma_papel_tipo
     * const plataforma_papel_tipo = await prisma.plataforma_papel_tipo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends plataforma_papel_tipoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, plataforma_papel_tipoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'plataforma_papel_tipo'> extends True ? Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T>> : Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T> | null, null>

    /**
     * Find zero or more Plataforma_papel_tipos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_papel_tipoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plataforma_papel_tipos
     * const plataforma_papel_tipos = await prisma.plataforma_papel_tipo.findMany()
     * 
     * // Get first 10 Plataforma_papel_tipos
     * const plataforma_papel_tipos = await prisma.plataforma_papel_tipo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plataforma_papel_tipoWithIdOnly = await prisma.plataforma_papel_tipo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends plataforma_papel_tipoFindManyArgs>(
      args?: SelectSubset<T, plataforma_papel_tipoFindManyArgs>
    ): PrismaPromise<Array<plataforma_papel_tipoGetPayload<T>>>

    /**
     * Create a Plataforma_papel_tipo.
     * @param {plataforma_papel_tipoCreateArgs} args - Arguments to create a Plataforma_papel_tipo.
     * @example
     * // Create one Plataforma_papel_tipo
     * const Plataforma_papel_tipo = await prisma.plataforma_papel_tipo.create({
     *   data: {
     *     // ... data to create a Plataforma_papel_tipo
     *   }
     * })
     * 
    **/
    create<T extends plataforma_papel_tipoCreateArgs>(
      args: SelectSubset<T, plataforma_papel_tipoCreateArgs>
    ): Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T>>

    /**
     * Create many Plataforma_papel_tipos.
     *     @param {plataforma_papel_tipoCreateManyArgs} args - Arguments to create many Plataforma_papel_tipos.
     *     @example
     *     // Create many Plataforma_papel_tipos
     *     const plataforma_papel_tipo = await prisma.plataforma_papel_tipo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends plataforma_papel_tipoCreateManyArgs>(
      args?: SelectSubset<T, plataforma_papel_tipoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Plataforma_papel_tipo.
     * @param {plataforma_papel_tipoDeleteArgs} args - Arguments to delete one Plataforma_papel_tipo.
     * @example
     * // Delete one Plataforma_papel_tipo
     * const Plataforma_papel_tipo = await prisma.plataforma_papel_tipo.delete({
     *   where: {
     *     // ... filter to delete one Plataforma_papel_tipo
     *   }
     * })
     * 
    **/
    delete<T extends plataforma_papel_tipoDeleteArgs>(
      args: SelectSubset<T, plataforma_papel_tipoDeleteArgs>
    ): Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T>>

    /**
     * Update one Plataforma_papel_tipo.
     * @param {plataforma_papel_tipoUpdateArgs} args - Arguments to update one Plataforma_papel_tipo.
     * @example
     * // Update one Plataforma_papel_tipo
     * const plataforma_papel_tipo = await prisma.plataforma_papel_tipo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends plataforma_papel_tipoUpdateArgs>(
      args: SelectSubset<T, plataforma_papel_tipoUpdateArgs>
    ): Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T>>

    /**
     * Delete zero or more Plataforma_papel_tipos.
     * @param {plataforma_papel_tipoDeleteManyArgs} args - Arguments to filter Plataforma_papel_tipos to delete.
     * @example
     * // Delete a few Plataforma_papel_tipos
     * const { count } = await prisma.plataforma_papel_tipo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends plataforma_papel_tipoDeleteManyArgs>(
      args?: SelectSubset<T, plataforma_papel_tipoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plataforma_papel_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_papel_tipoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plataforma_papel_tipos
     * const plataforma_papel_tipo = await prisma.plataforma_papel_tipo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends plataforma_papel_tipoUpdateManyArgs>(
      args: SelectSubset<T, plataforma_papel_tipoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Plataforma_papel_tipo.
     * @param {plataforma_papel_tipoUpsertArgs} args - Arguments to update or create a Plataforma_papel_tipo.
     * @example
     * // Update or create a Plataforma_papel_tipo
     * const plataforma_papel_tipo = await prisma.plataforma_papel_tipo.upsert({
     *   create: {
     *     // ... data to create a Plataforma_papel_tipo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plataforma_papel_tipo we want to update
     *   }
     * })
    **/
    upsert<T extends plataforma_papel_tipoUpsertArgs>(
      args: SelectSubset<T, plataforma_papel_tipoUpsertArgs>
    ): Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T>>

    /**
     * Find one Plataforma_papel_tipo that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {plataforma_papel_tipoFindUniqueOrThrowArgs} args - Arguments to find a Plataforma_papel_tipo
     * @example
     * // Get one Plataforma_papel_tipo
     * const plataforma_papel_tipo = await prisma.plataforma_papel_tipo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends plataforma_papel_tipoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, plataforma_papel_tipoFindUniqueOrThrowArgs>
    ): Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T>>

    /**
     * Find the first Plataforma_papel_tipo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_papel_tipoFindFirstOrThrowArgs} args - Arguments to find a Plataforma_papel_tipo
     * @example
     * // Get one Plataforma_papel_tipo
     * const plataforma_papel_tipo = await prisma.plataforma_papel_tipo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends plataforma_papel_tipoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, plataforma_papel_tipoFindFirstOrThrowArgs>
    ): Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T>>

    /**
     * Count the number of Plataforma_papel_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_papel_tipoCountArgs} args - Arguments to filter Plataforma_papel_tipos to count.
     * @example
     * // Count the number of Plataforma_papel_tipos
     * const count = await prisma.plataforma_papel_tipo.count({
     *   where: {
     *     // ... the filter for the Plataforma_papel_tipos we want to count
     *   }
     * })
    **/
    count<T extends plataforma_papel_tipoCountArgs>(
      args?: Subset<T, plataforma_papel_tipoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plataforma_papel_tipoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plataforma_papel_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plataforma_papel_tipoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plataforma_papel_tipoAggregateArgs>(args: Subset<T, Plataforma_papel_tipoAggregateArgs>): PrismaPromise<GetPlataforma_papel_tipoAggregateType<T>>

    /**
     * Group by Plataforma_papel_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plataforma_papel_tipoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Plataforma_papel_tipoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Plataforma_papel_tipoGroupByArgs['orderBy'] }
        : { orderBy?: Plataforma_papel_tipoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Plataforma_papel_tipoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlataforma_papel_tipoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for plataforma_papel_tipo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__plataforma_papel_tipoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * plataforma_papel_tipo base type for findUnique actions
   */
  export type plataforma_papel_tipoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma_papel_tipo
     * 
    **/
    select?: plataforma_papel_tipoSelect | null
    /**
     * Filter, which plataforma_papel_tipo to fetch.
     * 
    **/
    where: plataforma_papel_tipoWhereUniqueInput
  }

  /**
   * plataforma_papel_tipo: findUnique
   */
  export interface plataforma_papel_tipoFindUniqueArgs extends plataforma_papel_tipoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma_papel_tipo base type for findFirst actions
   */
  export type plataforma_papel_tipoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma_papel_tipo
     * 
    **/
    select?: plataforma_papel_tipoSelect | null
    /**
     * Filter, which plataforma_papel_tipo to fetch.
     * 
    **/
    where?: plataforma_papel_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_papel_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_papel_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plataforma_papel_tipos.
     * 
    **/
    cursor?: plataforma_papel_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_papel_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_papel_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plataforma_papel_tipos.
     * 
    **/
    distinct?: Enumerable<Plataforma_papel_tipoScalarFieldEnum>
  }

  /**
   * plataforma_papel_tipo: findFirst
   */
  export interface plataforma_papel_tipoFindFirstArgs extends plataforma_papel_tipoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma_papel_tipo findMany
   */
  export type plataforma_papel_tipoFindManyArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_tipo
     * 
    **/
    select?: plataforma_papel_tipoSelect | null
    /**
     * Filter, which plataforma_papel_tipos to fetch.
     * 
    **/
    where?: plataforma_papel_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_papel_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_papel_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plataforma_papel_tipos.
     * 
    **/
    cursor?: plataforma_papel_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_papel_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_papel_tipos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Plataforma_papel_tipoScalarFieldEnum>
  }


  /**
   * plataforma_papel_tipo create
   */
  export type plataforma_papel_tipoCreateArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_tipo
     * 
    **/
    select?: plataforma_papel_tipoSelect | null
    /**
     * The data needed to create a plataforma_papel_tipo.
     * 
    **/
    data?: XOR<plataforma_papel_tipoCreateInput, plataforma_papel_tipoUncheckedCreateInput>
  }


  /**
   * plataforma_papel_tipo createMany
   */
  export type plataforma_papel_tipoCreateManyArgs = {
    /**
     * The data used to create many plataforma_papel_tipos.
     * 
    **/
    data: Enumerable<plataforma_papel_tipoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * plataforma_papel_tipo update
   */
  export type plataforma_papel_tipoUpdateArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_tipo
     * 
    **/
    select?: plataforma_papel_tipoSelect | null
    /**
     * The data needed to update a plataforma_papel_tipo.
     * 
    **/
    data: XOR<plataforma_papel_tipoUpdateInput, plataforma_papel_tipoUncheckedUpdateInput>
    /**
     * Choose, which plataforma_papel_tipo to update.
     * 
    **/
    where: plataforma_papel_tipoWhereUniqueInput
  }


  /**
   * plataforma_papel_tipo updateMany
   */
  export type plataforma_papel_tipoUpdateManyArgs = {
    /**
     * The data used to update plataforma_papel_tipos.
     * 
    **/
    data: XOR<plataforma_papel_tipoUpdateManyMutationInput, plataforma_papel_tipoUncheckedUpdateManyInput>
    /**
     * Filter which plataforma_papel_tipos to update
     * 
    **/
    where?: plataforma_papel_tipoWhereInput
  }


  /**
   * plataforma_papel_tipo upsert
   */
  export type plataforma_papel_tipoUpsertArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_tipo
     * 
    **/
    select?: plataforma_papel_tipoSelect | null
    /**
     * The filter to search for the plataforma_papel_tipo to update in case it exists.
     * 
    **/
    where: plataforma_papel_tipoWhereUniqueInput
    /**
     * In case the plataforma_papel_tipo found by the `where` argument doesn't exist, create a new plataforma_papel_tipo with this data.
     * 
    **/
    create: XOR<plataforma_papel_tipoCreateInput, plataforma_papel_tipoUncheckedCreateInput>
    /**
     * In case the plataforma_papel_tipo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<plataforma_papel_tipoUpdateInput, plataforma_papel_tipoUncheckedUpdateInput>
  }


  /**
   * plataforma_papel_tipo delete
   */
  export type plataforma_papel_tipoDeleteArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_tipo
     * 
    **/
    select?: plataforma_papel_tipoSelect | null
    /**
     * Filter which plataforma_papel_tipo to delete.
     * 
    **/
    where: plataforma_papel_tipoWhereUniqueInput
  }


  /**
   * plataforma_papel_tipo deleteMany
   */
  export type plataforma_papel_tipoDeleteManyArgs = {
    /**
     * Filter which plataforma_papel_tipos to delete
     * 
    **/
    where?: plataforma_papel_tipoWhereInput
  }


  /**
   * plataforma_papel_tipo: findUniqueOrThrow
   */
  export type plataforma_papel_tipoFindUniqueOrThrowArgs = plataforma_papel_tipoFindUniqueArgsBase
      

  /**
   * plataforma_papel_tipo: findFirstOrThrow
   */
  export type plataforma_papel_tipoFindFirstOrThrowArgs = plataforma_papel_tipoFindFirstArgsBase
      

  /**
   * plataforma_papel_tipo without action
   */
  export type plataforma_papel_tipoArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_tipo
     * 
    **/
    select?: plataforma_papel_tipoSelect | null
  }



  /**
   * Model plataforma_papel_x_pessoa
   */


  export type AggregatePlataforma_papel_x_pessoa = {
    _count: Plataforma_papel_x_pessoaCountAggregateOutputType | null
    _avg: Plataforma_papel_x_pessoaAvgAggregateOutputType | null
    _sum: Plataforma_papel_x_pessoaSumAggregateOutputType | null
    _min: Plataforma_papel_x_pessoaMinAggregateOutputType | null
    _max: Plataforma_papel_x_pessoaMaxAggregateOutputType | null
  }

  export type Plataforma_papel_x_pessoaAvgAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_papel_x_pessoaSumAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_papel_x_pessoaMinAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_papel_x_pessoaMaxAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_papel_x_pessoaCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type Plataforma_papel_x_pessoaAvgAggregateInputType = {
    id?: true
  }

  export type Plataforma_papel_x_pessoaSumAggregateInputType = {
    id?: true
  }

  export type Plataforma_papel_x_pessoaMinAggregateInputType = {
    id?: true
  }

  export type Plataforma_papel_x_pessoaMaxAggregateInputType = {
    id?: true
  }

  export type Plataforma_papel_x_pessoaCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type Plataforma_papel_x_pessoaAggregateArgs = {
    /**
     * Filter which plataforma_papel_x_pessoa to aggregate.
     * 
    **/
    where?: plataforma_papel_x_pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_papel_x_pessoas to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_papel_x_pessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: plataforma_papel_x_pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_papel_x_pessoas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_papel_x_pessoas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plataforma_papel_x_pessoas
    **/
    _count?: true | Plataforma_papel_x_pessoaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plataforma_papel_x_pessoaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plataforma_papel_x_pessoaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plataforma_papel_x_pessoaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plataforma_papel_x_pessoaMaxAggregateInputType
  }

  export type GetPlataforma_papel_x_pessoaAggregateType<T extends Plataforma_papel_x_pessoaAggregateArgs> = {
        [P in keyof T & keyof AggregatePlataforma_papel_x_pessoa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlataforma_papel_x_pessoa[P]>
      : GetScalarType<T[P], AggregatePlataforma_papel_x_pessoa[P]>
  }




  export type Plataforma_papel_x_pessoaGroupByArgs = {
    where?: plataforma_papel_x_pessoaWhereInput
    orderBy?: Enumerable<plataforma_papel_x_pessoaOrderByWithAggregationInput>
    by: Array<Plataforma_papel_x_pessoaScalarFieldEnum>
    having?: plataforma_papel_x_pessoaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plataforma_papel_x_pessoaCountAggregateInputType | true
    _avg?: Plataforma_papel_x_pessoaAvgAggregateInputType
    _sum?: Plataforma_papel_x_pessoaSumAggregateInputType
    _min?: Plataforma_papel_x_pessoaMinAggregateInputType
    _max?: Plataforma_papel_x_pessoaMaxAggregateInputType
  }


  export type Plataforma_papel_x_pessoaGroupByOutputType = {
    id: number
    _count: Plataforma_papel_x_pessoaCountAggregateOutputType | null
    _avg: Plataforma_papel_x_pessoaAvgAggregateOutputType | null
    _sum: Plataforma_papel_x_pessoaSumAggregateOutputType | null
    _min: Plataforma_papel_x_pessoaMinAggregateOutputType | null
    _max: Plataforma_papel_x_pessoaMaxAggregateOutputType | null
  }

  type GetPlataforma_papel_x_pessoaGroupByPayload<T extends Plataforma_papel_x_pessoaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Plataforma_papel_x_pessoaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plataforma_papel_x_pessoaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plataforma_papel_x_pessoaGroupByOutputType[P]>
            : GetScalarType<T[P], Plataforma_papel_x_pessoaGroupByOutputType[P]>
        }
      >
    >


  export type plataforma_papel_x_pessoaSelect = {
    id?: boolean
  }


  export type plataforma_papel_x_pessoaGetPayload<S extends boolean | null | undefined | plataforma_papel_x_pessoaArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? plataforma_papel_x_pessoa :
    S extends undefined ? never :
    S extends { include: any } & (plataforma_papel_x_pessoaArgs | plataforma_papel_x_pessoaFindManyArgs)
    ? plataforma_papel_x_pessoa 
    : S extends { select: any } & (plataforma_papel_x_pessoaArgs | plataforma_papel_x_pessoaFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof plataforma_papel_x_pessoa ? plataforma_papel_x_pessoa[P] : never
  } 
      : plataforma_papel_x_pessoa


  type plataforma_papel_x_pessoaCountArgs = Merge<
    Omit<plataforma_papel_x_pessoaFindManyArgs, 'select' | 'include'> & {
      select?: Plataforma_papel_x_pessoaCountAggregateInputType | true
    }
  >

  export interface plataforma_papel_x_pessoaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Plataforma_papel_x_pessoa that matches the filter.
     * @param {plataforma_papel_x_pessoaFindUniqueArgs} args - Arguments to find a Plataforma_papel_x_pessoa
     * @example
     * // Get one Plataforma_papel_x_pessoa
     * const plataforma_papel_x_pessoa = await prisma.plataforma_papel_x_pessoa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends plataforma_papel_x_pessoaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, plataforma_papel_x_pessoaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'plataforma_papel_x_pessoa'> extends True ? Prisma__plataforma_papel_x_pessoaClient<plataforma_papel_x_pessoaGetPayload<T>> : Prisma__plataforma_papel_x_pessoaClient<plataforma_papel_x_pessoaGetPayload<T> | null, null>

    /**
     * Find the first Plataforma_papel_x_pessoa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_papel_x_pessoaFindFirstArgs} args - Arguments to find a Plataforma_papel_x_pessoa
     * @example
     * // Get one Plataforma_papel_x_pessoa
     * const plataforma_papel_x_pessoa = await prisma.plataforma_papel_x_pessoa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends plataforma_papel_x_pessoaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, plataforma_papel_x_pessoaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'plataforma_papel_x_pessoa'> extends True ? Prisma__plataforma_papel_x_pessoaClient<plataforma_papel_x_pessoaGetPayload<T>> : Prisma__plataforma_papel_x_pessoaClient<plataforma_papel_x_pessoaGetPayload<T> | null, null>

    /**
     * Find zero or more Plataforma_papel_x_pessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_papel_x_pessoaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plataforma_papel_x_pessoas
     * const plataforma_papel_x_pessoas = await prisma.plataforma_papel_x_pessoa.findMany()
     * 
     * // Get first 10 Plataforma_papel_x_pessoas
     * const plataforma_papel_x_pessoas = await prisma.plataforma_papel_x_pessoa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plataforma_papel_x_pessoaWithIdOnly = await prisma.plataforma_papel_x_pessoa.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends plataforma_papel_x_pessoaFindManyArgs>(
      args?: SelectSubset<T, plataforma_papel_x_pessoaFindManyArgs>
    ): PrismaPromise<Array<plataforma_papel_x_pessoaGetPayload<T>>>

    /**
     * Create a Plataforma_papel_x_pessoa.
     * @param {plataforma_papel_x_pessoaCreateArgs} args - Arguments to create a Plataforma_papel_x_pessoa.
     * @example
     * // Create one Plataforma_papel_x_pessoa
     * const Plataforma_papel_x_pessoa = await prisma.plataforma_papel_x_pessoa.create({
     *   data: {
     *     // ... data to create a Plataforma_papel_x_pessoa
     *   }
     * })
     * 
    **/
    create<T extends plataforma_papel_x_pessoaCreateArgs>(
      args: SelectSubset<T, plataforma_papel_x_pessoaCreateArgs>
    ): Prisma__plataforma_papel_x_pessoaClient<plataforma_papel_x_pessoaGetPayload<T>>

    /**
     * Create many Plataforma_papel_x_pessoas.
     *     @param {plataforma_papel_x_pessoaCreateManyArgs} args - Arguments to create many Plataforma_papel_x_pessoas.
     *     @example
     *     // Create many Plataforma_papel_x_pessoas
     *     const plataforma_papel_x_pessoa = await prisma.plataforma_papel_x_pessoa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends plataforma_papel_x_pessoaCreateManyArgs>(
      args?: SelectSubset<T, plataforma_papel_x_pessoaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Plataforma_papel_x_pessoa.
     * @param {plataforma_papel_x_pessoaDeleteArgs} args - Arguments to delete one Plataforma_papel_x_pessoa.
     * @example
     * // Delete one Plataforma_papel_x_pessoa
     * const Plataforma_papel_x_pessoa = await prisma.plataforma_papel_x_pessoa.delete({
     *   where: {
     *     // ... filter to delete one Plataforma_papel_x_pessoa
     *   }
     * })
     * 
    **/
    delete<T extends plataforma_papel_x_pessoaDeleteArgs>(
      args: SelectSubset<T, plataforma_papel_x_pessoaDeleteArgs>
    ): Prisma__plataforma_papel_x_pessoaClient<plataforma_papel_x_pessoaGetPayload<T>>

    /**
     * Update one Plataforma_papel_x_pessoa.
     * @param {plataforma_papel_x_pessoaUpdateArgs} args - Arguments to update one Plataforma_papel_x_pessoa.
     * @example
     * // Update one Plataforma_papel_x_pessoa
     * const plataforma_papel_x_pessoa = await prisma.plataforma_papel_x_pessoa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends plataforma_papel_x_pessoaUpdateArgs>(
      args: SelectSubset<T, plataforma_papel_x_pessoaUpdateArgs>
    ): Prisma__plataforma_papel_x_pessoaClient<plataforma_papel_x_pessoaGetPayload<T>>

    /**
     * Delete zero or more Plataforma_papel_x_pessoas.
     * @param {plataforma_papel_x_pessoaDeleteManyArgs} args - Arguments to filter Plataforma_papel_x_pessoas to delete.
     * @example
     * // Delete a few Plataforma_papel_x_pessoas
     * const { count } = await prisma.plataforma_papel_x_pessoa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends plataforma_papel_x_pessoaDeleteManyArgs>(
      args?: SelectSubset<T, plataforma_papel_x_pessoaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plataforma_papel_x_pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_papel_x_pessoaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plataforma_papel_x_pessoas
     * const plataforma_papel_x_pessoa = await prisma.plataforma_papel_x_pessoa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends plataforma_papel_x_pessoaUpdateManyArgs>(
      args: SelectSubset<T, plataforma_papel_x_pessoaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Plataforma_papel_x_pessoa.
     * @param {plataforma_papel_x_pessoaUpsertArgs} args - Arguments to update or create a Plataforma_papel_x_pessoa.
     * @example
     * // Update or create a Plataforma_papel_x_pessoa
     * const plataforma_papel_x_pessoa = await prisma.plataforma_papel_x_pessoa.upsert({
     *   create: {
     *     // ... data to create a Plataforma_papel_x_pessoa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plataforma_papel_x_pessoa we want to update
     *   }
     * })
    **/
    upsert<T extends plataforma_papel_x_pessoaUpsertArgs>(
      args: SelectSubset<T, plataforma_papel_x_pessoaUpsertArgs>
    ): Prisma__plataforma_papel_x_pessoaClient<plataforma_papel_x_pessoaGetPayload<T>>

    /**
     * Find one Plataforma_papel_x_pessoa that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {plataforma_papel_x_pessoaFindUniqueOrThrowArgs} args - Arguments to find a Plataforma_papel_x_pessoa
     * @example
     * // Get one Plataforma_papel_x_pessoa
     * const plataforma_papel_x_pessoa = await prisma.plataforma_papel_x_pessoa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends plataforma_papel_x_pessoaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, plataforma_papel_x_pessoaFindUniqueOrThrowArgs>
    ): Prisma__plataforma_papel_x_pessoaClient<plataforma_papel_x_pessoaGetPayload<T>>

    /**
     * Find the first Plataforma_papel_x_pessoa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_papel_x_pessoaFindFirstOrThrowArgs} args - Arguments to find a Plataforma_papel_x_pessoa
     * @example
     * // Get one Plataforma_papel_x_pessoa
     * const plataforma_papel_x_pessoa = await prisma.plataforma_papel_x_pessoa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends plataforma_papel_x_pessoaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, plataforma_papel_x_pessoaFindFirstOrThrowArgs>
    ): Prisma__plataforma_papel_x_pessoaClient<plataforma_papel_x_pessoaGetPayload<T>>

    /**
     * Count the number of Plataforma_papel_x_pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_papel_x_pessoaCountArgs} args - Arguments to filter Plataforma_papel_x_pessoas to count.
     * @example
     * // Count the number of Plataforma_papel_x_pessoas
     * const count = await prisma.plataforma_papel_x_pessoa.count({
     *   where: {
     *     // ... the filter for the Plataforma_papel_x_pessoas we want to count
     *   }
     * })
    **/
    count<T extends plataforma_papel_x_pessoaCountArgs>(
      args?: Subset<T, plataforma_papel_x_pessoaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plataforma_papel_x_pessoaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plataforma_papel_x_pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plataforma_papel_x_pessoaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plataforma_papel_x_pessoaAggregateArgs>(args: Subset<T, Plataforma_papel_x_pessoaAggregateArgs>): PrismaPromise<GetPlataforma_papel_x_pessoaAggregateType<T>>

    /**
     * Group by Plataforma_papel_x_pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plataforma_papel_x_pessoaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Plataforma_papel_x_pessoaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Plataforma_papel_x_pessoaGroupByArgs['orderBy'] }
        : { orderBy?: Plataforma_papel_x_pessoaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Plataforma_papel_x_pessoaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlataforma_papel_x_pessoaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for plataforma_papel_x_pessoa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__plataforma_papel_x_pessoaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * plataforma_papel_x_pessoa base type for findUnique actions
   */
  export type plataforma_papel_x_pessoaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma_papel_x_pessoa
     * 
    **/
    select?: plataforma_papel_x_pessoaSelect | null
    /**
     * Filter, which plataforma_papel_x_pessoa to fetch.
     * 
    **/
    where: plataforma_papel_x_pessoaWhereUniqueInput
  }

  /**
   * plataforma_papel_x_pessoa: findUnique
   */
  export interface plataforma_papel_x_pessoaFindUniqueArgs extends plataforma_papel_x_pessoaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma_papel_x_pessoa base type for findFirst actions
   */
  export type plataforma_papel_x_pessoaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma_papel_x_pessoa
     * 
    **/
    select?: plataforma_papel_x_pessoaSelect | null
    /**
     * Filter, which plataforma_papel_x_pessoa to fetch.
     * 
    **/
    where?: plataforma_papel_x_pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_papel_x_pessoas to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_papel_x_pessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plataforma_papel_x_pessoas.
     * 
    **/
    cursor?: plataforma_papel_x_pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_papel_x_pessoas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_papel_x_pessoas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plataforma_papel_x_pessoas.
     * 
    **/
    distinct?: Enumerable<Plataforma_papel_x_pessoaScalarFieldEnum>
  }

  /**
   * plataforma_papel_x_pessoa: findFirst
   */
  export interface plataforma_papel_x_pessoaFindFirstArgs extends plataforma_papel_x_pessoaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma_papel_x_pessoa findMany
   */
  export type plataforma_papel_x_pessoaFindManyArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_x_pessoa
     * 
    **/
    select?: plataforma_papel_x_pessoaSelect | null
    /**
     * Filter, which plataforma_papel_x_pessoas to fetch.
     * 
    **/
    where?: plataforma_papel_x_pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_papel_x_pessoas to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_papel_x_pessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plataforma_papel_x_pessoas.
     * 
    **/
    cursor?: plataforma_papel_x_pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_papel_x_pessoas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_papel_x_pessoas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Plataforma_papel_x_pessoaScalarFieldEnum>
  }


  /**
   * plataforma_papel_x_pessoa create
   */
  export type plataforma_papel_x_pessoaCreateArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_x_pessoa
     * 
    **/
    select?: plataforma_papel_x_pessoaSelect | null
    /**
     * The data needed to create a plataforma_papel_x_pessoa.
     * 
    **/
    data?: XOR<plataforma_papel_x_pessoaCreateInput, plataforma_papel_x_pessoaUncheckedCreateInput>
  }


  /**
   * plataforma_papel_x_pessoa createMany
   */
  export type plataforma_papel_x_pessoaCreateManyArgs = {
    /**
     * The data used to create many plataforma_papel_x_pessoas.
     * 
    **/
    data: Enumerable<plataforma_papel_x_pessoaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * plataforma_papel_x_pessoa update
   */
  export type plataforma_papel_x_pessoaUpdateArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_x_pessoa
     * 
    **/
    select?: plataforma_papel_x_pessoaSelect | null
    /**
     * The data needed to update a plataforma_papel_x_pessoa.
     * 
    **/
    data: XOR<plataforma_papel_x_pessoaUpdateInput, plataforma_papel_x_pessoaUncheckedUpdateInput>
    /**
     * Choose, which plataforma_papel_x_pessoa to update.
     * 
    **/
    where: plataforma_papel_x_pessoaWhereUniqueInput
  }


  /**
   * plataforma_papel_x_pessoa updateMany
   */
  export type plataforma_papel_x_pessoaUpdateManyArgs = {
    /**
     * The data used to update plataforma_papel_x_pessoas.
     * 
    **/
    data: XOR<plataforma_papel_x_pessoaUpdateManyMutationInput, plataforma_papel_x_pessoaUncheckedUpdateManyInput>
    /**
     * Filter which plataforma_papel_x_pessoas to update
     * 
    **/
    where?: plataforma_papel_x_pessoaWhereInput
  }


  /**
   * plataforma_papel_x_pessoa upsert
   */
  export type plataforma_papel_x_pessoaUpsertArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_x_pessoa
     * 
    **/
    select?: plataforma_papel_x_pessoaSelect | null
    /**
     * The filter to search for the plataforma_papel_x_pessoa to update in case it exists.
     * 
    **/
    where: plataforma_papel_x_pessoaWhereUniqueInput
    /**
     * In case the plataforma_papel_x_pessoa found by the `where` argument doesn't exist, create a new plataforma_papel_x_pessoa with this data.
     * 
    **/
    create: XOR<plataforma_papel_x_pessoaCreateInput, plataforma_papel_x_pessoaUncheckedCreateInput>
    /**
     * In case the plataforma_papel_x_pessoa was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<plataforma_papel_x_pessoaUpdateInput, plataforma_papel_x_pessoaUncheckedUpdateInput>
  }


  /**
   * plataforma_papel_x_pessoa delete
   */
  export type plataforma_papel_x_pessoaDeleteArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_x_pessoa
     * 
    **/
    select?: plataforma_papel_x_pessoaSelect | null
    /**
     * Filter which plataforma_papel_x_pessoa to delete.
     * 
    **/
    where: plataforma_papel_x_pessoaWhereUniqueInput
  }


  /**
   * plataforma_papel_x_pessoa deleteMany
   */
  export type plataforma_papel_x_pessoaDeleteManyArgs = {
    /**
     * Filter which plataforma_papel_x_pessoas to delete
     * 
    **/
    where?: plataforma_papel_x_pessoaWhereInput
  }


  /**
   * plataforma_papel_x_pessoa: findUniqueOrThrow
   */
  export type plataforma_papel_x_pessoaFindUniqueOrThrowArgs = plataforma_papel_x_pessoaFindUniqueArgsBase
      

  /**
   * plataforma_papel_x_pessoa: findFirstOrThrow
   */
  export type plataforma_papel_x_pessoaFindFirstOrThrowArgs = plataforma_papel_x_pessoaFindFirstArgsBase
      

  /**
   * plataforma_papel_x_pessoa without action
   */
  export type plataforma_papel_x_pessoaArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_x_pessoa
     * 
    **/
    select?: plataforma_papel_x_pessoaSelect | null
  }



  /**
   * Model plataforma_x_regiao_atuacao
   */


  export type AggregatePlataforma_x_regiao_atuacao = {
    _count: Plataforma_x_regiao_atuacaoCountAggregateOutputType | null
    _avg: Plataforma_x_regiao_atuacaoAvgAggregateOutputType | null
    _sum: Plataforma_x_regiao_atuacaoSumAggregateOutputType | null
    _min: Plataforma_x_regiao_atuacaoMinAggregateOutputType | null
    _max: Plataforma_x_regiao_atuacaoMaxAggregateOutputType | null
  }

  export type Plataforma_x_regiao_atuacaoAvgAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_x_regiao_atuacaoSumAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_x_regiao_atuacaoMinAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_x_regiao_atuacaoMaxAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_x_regiao_atuacaoCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type Plataforma_x_regiao_atuacaoAvgAggregateInputType = {
    id?: true
  }

  export type Plataforma_x_regiao_atuacaoSumAggregateInputType = {
    id?: true
  }

  export type Plataforma_x_regiao_atuacaoMinAggregateInputType = {
    id?: true
  }

  export type Plataforma_x_regiao_atuacaoMaxAggregateInputType = {
    id?: true
  }

  export type Plataforma_x_regiao_atuacaoCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type Plataforma_x_regiao_atuacaoAggregateArgs = {
    /**
     * Filter which plataforma_x_regiao_atuacao to aggregate.
     * 
    **/
    where?: plataforma_x_regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_x_regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_x_regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: plataforma_x_regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_x_regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_x_regiao_atuacaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plataforma_x_regiao_atuacaos
    **/
    _count?: true | Plataforma_x_regiao_atuacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plataforma_x_regiao_atuacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plataforma_x_regiao_atuacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plataforma_x_regiao_atuacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plataforma_x_regiao_atuacaoMaxAggregateInputType
  }

  export type GetPlataforma_x_regiao_atuacaoAggregateType<T extends Plataforma_x_regiao_atuacaoAggregateArgs> = {
        [P in keyof T & keyof AggregatePlataforma_x_regiao_atuacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlataforma_x_regiao_atuacao[P]>
      : GetScalarType<T[P], AggregatePlataforma_x_regiao_atuacao[P]>
  }




  export type Plataforma_x_regiao_atuacaoGroupByArgs = {
    where?: plataforma_x_regiao_atuacaoWhereInput
    orderBy?: Enumerable<plataforma_x_regiao_atuacaoOrderByWithAggregationInput>
    by: Array<Plataforma_x_regiao_atuacaoScalarFieldEnum>
    having?: plataforma_x_regiao_atuacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plataforma_x_regiao_atuacaoCountAggregateInputType | true
    _avg?: Plataforma_x_regiao_atuacaoAvgAggregateInputType
    _sum?: Plataforma_x_regiao_atuacaoSumAggregateInputType
    _min?: Plataforma_x_regiao_atuacaoMinAggregateInputType
    _max?: Plataforma_x_regiao_atuacaoMaxAggregateInputType
  }


  export type Plataforma_x_regiao_atuacaoGroupByOutputType = {
    id: number
    _count: Plataforma_x_regiao_atuacaoCountAggregateOutputType | null
    _avg: Plataforma_x_regiao_atuacaoAvgAggregateOutputType | null
    _sum: Plataforma_x_regiao_atuacaoSumAggregateOutputType | null
    _min: Plataforma_x_regiao_atuacaoMinAggregateOutputType | null
    _max: Plataforma_x_regiao_atuacaoMaxAggregateOutputType | null
  }

  type GetPlataforma_x_regiao_atuacaoGroupByPayload<T extends Plataforma_x_regiao_atuacaoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Plataforma_x_regiao_atuacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plataforma_x_regiao_atuacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plataforma_x_regiao_atuacaoGroupByOutputType[P]>
            : GetScalarType<T[P], Plataforma_x_regiao_atuacaoGroupByOutputType[P]>
        }
      >
    >


  export type plataforma_x_regiao_atuacaoSelect = {
    id?: boolean
  }


  export type plataforma_x_regiao_atuacaoGetPayload<S extends boolean | null | undefined | plataforma_x_regiao_atuacaoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? plataforma_x_regiao_atuacao :
    S extends undefined ? never :
    S extends { include: any } & (plataforma_x_regiao_atuacaoArgs | plataforma_x_regiao_atuacaoFindManyArgs)
    ? plataforma_x_regiao_atuacao 
    : S extends { select: any } & (plataforma_x_regiao_atuacaoArgs | plataforma_x_regiao_atuacaoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof plataforma_x_regiao_atuacao ? plataforma_x_regiao_atuacao[P] : never
  } 
      : plataforma_x_regiao_atuacao


  type plataforma_x_regiao_atuacaoCountArgs = Merge<
    Omit<plataforma_x_regiao_atuacaoFindManyArgs, 'select' | 'include'> & {
      select?: Plataforma_x_regiao_atuacaoCountAggregateInputType | true
    }
  >

  export interface plataforma_x_regiao_atuacaoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Plataforma_x_regiao_atuacao that matches the filter.
     * @param {plataforma_x_regiao_atuacaoFindUniqueArgs} args - Arguments to find a Plataforma_x_regiao_atuacao
     * @example
     * // Get one Plataforma_x_regiao_atuacao
     * const plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends plataforma_x_regiao_atuacaoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, plataforma_x_regiao_atuacaoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'plataforma_x_regiao_atuacao'> extends True ? Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T>> : Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T> | null, null>

    /**
     * Find the first Plataforma_x_regiao_atuacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_x_regiao_atuacaoFindFirstArgs} args - Arguments to find a Plataforma_x_regiao_atuacao
     * @example
     * // Get one Plataforma_x_regiao_atuacao
     * const plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends plataforma_x_regiao_atuacaoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, plataforma_x_regiao_atuacaoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'plataforma_x_regiao_atuacao'> extends True ? Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T>> : Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T> | null, null>

    /**
     * Find zero or more Plataforma_x_regiao_atuacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_x_regiao_atuacaoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plataforma_x_regiao_atuacaos
     * const plataforma_x_regiao_atuacaos = await prisma.plataforma_x_regiao_atuacao.findMany()
     * 
     * // Get first 10 Plataforma_x_regiao_atuacaos
     * const plataforma_x_regiao_atuacaos = await prisma.plataforma_x_regiao_atuacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plataforma_x_regiao_atuacaoWithIdOnly = await prisma.plataforma_x_regiao_atuacao.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends plataforma_x_regiao_atuacaoFindManyArgs>(
      args?: SelectSubset<T, plataforma_x_regiao_atuacaoFindManyArgs>
    ): PrismaPromise<Array<plataforma_x_regiao_atuacaoGetPayload<T>>>

    /**
     * Create a Plataforma_x_regiao_atuacao.
     * @param {plataforma_x_regiao_atuacaoCreateArgs} args - Arguments to create a Plataforma_x_regiao_atuacao.
     * @example
     * // Create one Plataforma_x_regiao_atuacao
     * const Plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.create({
     *   data: {
     *     // ... data to create a Plataforma_x_regiao_atuacao
     *   }
     * })
     * 
    **/
    create<T extends plataforma_x_regiao_atuacaoCreateArgs>(
      args: SelectSubset<T, plataforma_x_regiao_atuacaoCreateArgs>
    ): Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Create many Plataforma_x_regiao_atuacaos.
     *     @param {plataforma_x_regiao_atuacaoCreateManyArgs} args - Arguments to create many Plataforma_x_regiao_atuacaos.
     *     @example
     *     // Create many Plataforma_x_regiao_atuacaos
     *     const plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends plataforma_x_regiao_atuacaoCreateManyArgs>(
      args?: SelectSubset<T, plataforma_x_regiao_atuacaoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Plataforma_x_regiao_atuacao.
     * @param {plataforma_x_regiao_atuacaoDeleteArgs} args - Arguments to delete one Plataforma_x_regiao_atuacao.
     * @example
     * // Delete one Plataforma_x_regiao_atuacao
     * const Plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.delete({
     *   where: {
     *     // ... filter to delete one Plataforma_x_regiao_atuacao
     *   }
     * })
     * 
    **/
    delete<T extends plataforma_x_regiao_atuacaoDeleteArgs>(
      args: SelectSubset<T, plataforma_x_regiao_atuacaoDeleteArgs>
    ): Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Update one Plataforma_x_regiao_atuacao.
     * @param {plataforma_x_regiao_atuacaoUpdateArgs} args - Arguments to update one Plataforma_x_regiao_atuacao.
     * @example
     * // Update one Plataforma_x_regiao_atuacao
     * const plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends plataforma_x_regiao_atuacaoUpdateArgs>(
      args: SelectSubset<T, plataforma_x_regiao_atuacaoUpdateArgs>
    ): Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Delete zero or more Plataforma_x_regiao_atuacaos.
     * @param {plataforma_x_regiao_atuacaoDeleteManyArgs} args - Arguments to filter Plataforma_x_regiao_atuacaos to delete.
     * @example
     * // Delete a few Plataforma_x_regiao_atuacaos
     * const { count } = await prisma.plataforma_x_regiao_atuacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends plataforma_x_regiao_atuacaoDeleteManyArgs>(
      args?: SelectSubset<T, plataforma_x_regiao_atuacaoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plataforma_x_regiao_atuacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_x_regiao_atuacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plataforma_x_regiao_atuacaos
     * const plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends plataforma_x_regiao_atuacaoUpdateManyArgs>(
      args: SelectSubset<T, plataforma_x_regiao_atuacaoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Plataforma_x_regiao_atuacao.
     * @param {plataforma_x_regiao_atuacaoUpsertArgs} args - Arguments to update or create a Plataforma_x_regiao_atuacao.
     * @example
     * // Update or create a Plataforma_x_regiao_atuacao
     * const plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.upsert({
     *   create: {
     *     // ... data to create a Plataforma_x_regiao_atuacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plataforma_x_regiao_atuacao we want to update
     *   }
     * })
    **/
    upsert<T extends plataforma_x_regiao_atuacaoUpsertArgs>(
      args: SelectSubset<T, plataforma_x_regiao_atuacaoUpsertArgs>
    ): Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Find one Plataforma_x_regiao_atuacao that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {plataforma_x_regiao_atuacaoFindUniqueOrThrowArgs} args - Arguments to find a Plataforma_x_regiao_atuacao
     * @example
     * // Get one Plataforma_x_regiao_atuacao
     * const plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends plataforma_x_regiao_atuacaoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, plataforma_x_regiao_atuacaoFindUniqueOrThrowArgs>
    ): Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Find the first Plataforma_x_regiao_atuacao that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_x_regiao_atuacaoFindFirstOrThrowArgs} args - Arguments to find a Plataforma_x_regiao_atuacao
     * @example
     * // Get one Plataforma_x_regiao_atuacao
     * const plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends plataforma_x_regiao_atuacaoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, plataforma_x_regiao_atuacaoFindFirstOrThrowArgs>
    ): Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Count the number of Plataforma_x_regiao_atuacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_x_regiao_atuacaoCountArgs} args - Arguments to filter Plataforma_x_regiao_atuacaos to count.
     * @example
     * // Count the number of Plataforma_x_regiao_atuacaos
     * const count = await prisma.plataforma_x_regiao_atuacao.count({
     *   where: {
     *     // ... the filter for the Plataforma_x_regiao_atuacaos we want to count
     *   }
     * })
    **/
    count<T extends plataforma_x_regiao_atuacaoCountArgs>(
      args?: Subset<T, plataforma_x_regiao_atuacaoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plataforma_x_regiao_atuacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plataforma_x_regiao_atuacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plataforma_x_regiao_atuacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plataforma_x_regiao_atuacaoAggregateArgs>(args: Subset<T, Plataforma_x_regiao_atuacaoAggregateArgs>): PrismaPromise<GetPlataforma_x_regiao_atuacaoAggregateType<T>>

    /**
     * Group by Plataforma_x_regiao_atuacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plataforma_x_regiao_atuacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Plataforma_x_regiao_atuacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Plataforma_x_regiao_atuacaoGroupByArgs['orderBy'] }
        : { orderBy?: Plataforma_x_regiao_atuacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Plataforma_x_regiao_atuacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlataforma_x_regiao_atuacaoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for plataforma_x_regiao_atuacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__plataforma_x_regiao_atuacaoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * plataforma_x_regiao_atuacao base type for findUnique actions
   */
  export type plataforma_x_regiao_atuacaoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma_x_regiao_atuacao
     * 
    **/
    select?: plataforma_x_regiao_atuacaoSelect | null
    /**
     * Filter, which plataforma_x_regiao_atuacao to fetch.
     * 
    **/
    where: plataforma_x_regiao_atuacaoWhereUniqueInput
  }

  /**
   * plataforma_x_regiao_atuacao: findUnique
   */
  export interface plataforma_x_regiao_atuacaoFindUniqueArgs extends plataforma_x_regiao_atuacaoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma_x_regiao_atuacao base type for findFirst actions
   */
  export type plataforma_x_regiao_atuacaoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma_x_regiao_atuacao
     * 
    **/
    select?: plataforma_x_regiao_atuacaoSelect | null
    /**
     * Filter, which plataforma_x_regiao_atuacao to fetch.
     * 
    **/
    where?: plataforma_x_regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_x_regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_x_regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plataforma_x_regiao_atuacaos.
     * 
    **/
    cursor?: plataforma_x_regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_x_regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_x_regiao_atuacaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plataforma_x_regiao_atuacaos.
     * 
    **/
    distinct?: Enumerable<Plataforma_x_regiao_atuacaoScalarFieldEnum>
  }

  /**
   * plataforma_x_regiao_atuacao: findFirst
   */
  export interface plataforma_x_regiao_atuacaoFindFirstArgs extends plataforma_x_regiao_atuacaoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma_x_regiao_atuacao findMany
   */
  export type plataforma_x_regiao_atuacaoFindManyArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_regiao_atuacao
     * 
    **/
    select?: plataforma_x_regiao_atuacaoSelect | null
    /**
     * Filter, which plataforma_x_regiao_atuacaos to fetch.
     * 
    **/
    where?: plataforma_x_regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_x_regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_x_regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plataforma_x_regiao_atuacaos.
     * 
    **/
    cursor?: plataforma_x_regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_x_regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_x_regiao_atuacaos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Plataforma_x_regiao_atuacaoScalarFieldEnum>
  }


  /**
   * plataforma_x_regiao_atuacao create
   */
  export type plataforma_x_regiao_atuacaoCreateArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_regiao_atuacao
     * 
    **/
    select?: plataforma_x_regiao_atuacaoSelect | null
    /**
     * The data needed to create a plataforma_x_regiao_atuacao.
     * 
    **/
    data?: XOR<plataforma_x_regiao_atuacaoCreateInput, plataforma_x_regiao_atuacaoUncheckedCreateInput>
  }


  /**
   * plataforma_x_regiao_atuacao createMany
   */
  export type plataforma_x_regiao_atuacaoCreateManyArgs = {
    /**
     * The data used to create many plataforma_x_regiao_atuacaos.
     * 
    **/
    data: Enumerable<plataforma_x_regiao_atuacaoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * plataforma_x_regiao_atuacao update
   */
  export type plataforma_x_regiao_atuacaoUpdateArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_regiao_atuacao
     * 
    **/
    select?: plataforma_x_regiao_atuacaoSelect | null
    /**
     * The data needed to update a plataforma_x_regiao_atuacao.
     * 
    **/
    data: XOR<plataforma_x_regiao_atuacaoUpdateInput, plataforma_x_regiao_atuacaoUncheckedUpdateInput>
    /**
     * Choose, which plataforma_x_regiao_atuacao to update.
     * 
    **/
    where: plataforma_x_regiao_atuacaoWhereUniqueInput
  }


  /**
   * plataforma_x_regiao_atuacao updateMany
   */
  export type plataforma_x_regiao_atuacaoUpdateManyArgs = {
    /**
     * The data used to update plataforma_x_regiao_atuacaos.
     * 
    **/
    data: XOR<plataforma_x_regiao_atuacaoUpdateManyMutationInput, plataforma_x_regiao_atuacaoUncheckedUpdateManyInput>
    /**
     * Filter which plataforma_x_regiao_atuacaos to update
     * 
    **/
    where?: plataforma_x_regiao_atuacaoWhereInput
  }


  /**
   * plataforma_x_regiao_atuacao upsert
   */
  export type plataforma_x_regiao_atuacaoUpsertArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_regiao_atuacao
     * 
    **/
    select?: plataforma_x_regiao_atuacaoSelect | null
    /**
     * The filter to search for the plataforma_x_regiao_atuacao to update in case it exists.
     * 
    **/
    where: plataforma_x_regiao_atuacaoWhereUniqueInput
    /**
     * In case the plataforma_x_regiao_atuacao found by the `where` argument doesn't exist, create a new plataforma_x_regiao_atuacao with this data.
     * 
    **/
    create: XOR<plataforma_x_regiao_atuacaoCreateInput, plataforma_x_regiao_atuacaoUncheckedCreateInput>
    /**
     * In case the plataforma_x_regiao_atuacao was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<plataforma_x_regiao_atuacaoUpdateInput, plataforma_x_regiao_atuacaoUncheckedUpdateInput>
  }


  /**
   * plataforma_x_regiao_atuacao delete
   */
  export type plataforma_x_regiao_atuacaoDeleteArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_regiao_atuacao
     * 
    **/
    select?: plataforma_x_regiao_atuacaoSelect | null
    /**
     * Filter which plataforma_x_regiao_atuacao to delete.
     * 
    **/
    where: plataforma_x_regiao_atuacaoWhereUniqueInput
  }


  /**
   * plataforma_x_regiao_atuacao deleteMany
   */
  export type plataforma_x_regiao_atuacaoDeleteManyArgs = {
    /**
     * Filter which plataforma_x_regiao_atuacaos to delete
     * 
    **/
    where?: plataforma_x_regiao_atuacaoWhereInput
  }


  /**
   * plataforma_x_regiao_atuacao: findUniqueOrThrow
   */
  export type plataforma_x_regiao_atuacaoFindUniqueOrThrowArgs = plataforma_x_regiao_atuacaoFindUniqueArgsBase
      

  /**
   * plataforma_x_regiao_atuacao: findFirstOrThrow
   */
  export type plataforma_x_regiao_atuacaoFindFirstOrThrowArgs = plataforma_x_regiao_atuacaoFindFirstArgsBase
      

  /**
   * plataforma_x_regiao_atuacao without action
   */
  export type plataforma_x_regiao_atuacaoArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_regiao_atuacao
     * 
    **/
    select?: plataforma_x_regiao_atuacaoSelect | null
  }



  /**
   * Model regiao_atuacao
   */


  export type AggregateRegiao_atuacao = {
    _count: Regiao_atuacaoCountAggregateOutputType | null
    _avg: Regiao_atuacaoAvgAggregateOutputType | null
    _sum: Regiao_atuacaoSumAggregateOutputType | null
    _min: Regiao_atuacaoMinAggregateOutputType | null
    _max: Regiao_atuacaoMaxAggregateOutputType | null
  }

  export type Regiao_atuacaoAvgAggregateOutputType = {
    id: number | null
  }

  export type Regiao_atuacaoSumAggregateOutputType = {
    id: number | null
  }

  export type Regiao_atuacaoMinAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Regiao_atuacaoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Regiao_atuacaoCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type Regiao_atuacaoAvgAggregateInputType = {
    id?: true
  }

  export type Regiao_atuacaoSumAggregateInputType = {
    id?: true
  }

  export type Regiao_atuacaoMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Regiao_atuacaoMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Regiao_atuacaoCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type Regiao_atuacaoAggregateArgs = {
    /**
     * Filter which regiao_atuacao to aggregate.
     * 
    **/
    where?: regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regiao_atuacaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned regiao_atuacaos
    **/
    _count?: true | Regiao_atuacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Regiao_atuacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Regiao_atuacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Regiao_atuacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Regiao_atuacaoMaxAggregateInputType
  }

  export type GetRegiao_atuacaoAggregateType<T extends Regiao_atuacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateRegiao_atuacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegiao_atuacao[P]>
      : GetScalarType<T[P], AggregateRegiao_atuacao[P]>
  }




  export type Regiao_atuacaoGroupByArgs = {
    where?: regiao_atuacaoWhereInput
    orderBy?: Enumerable<regiao_atuacaoOrderByWithAggregationInput>
    by: Array<Regiao_atuacaoScalarFieldEnum>
    having?: regiao_atuacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Regiao_atuacaoCountAggregateInputType | true
    _avg?: Regiao_atuacaoAvgAggregateInputType
    _sum?: Regiao_atuacaoSumAggregateInputType
    _min?: Regiao_atuacaoMinAggregateInputType
    _max?: Regiao_atuacaoMaxAggregateInputType
  }


  export type Regiao_atuacaoGroupByOutputType = {
    id: number
    nome: string
    _count: Regiao_atuacaoCountAggregateOutputType | null
    _avg: Regiao_atuacaoAvgAggregateOutputType | null
    _sum: Regiao_atuacaoSumAggregateOutputType | null
    _min: Regiao_atuacaoMinAggregateOutputType | null
    _max: Regiao_atuacaoMaxAggregateOutputType | null
  }

  type GetRegiao_atuacaoGroupByPayload<T extends Regiao_atuacaoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Regiao_atuacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Regiao_atuacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Regiao_atuacaoGroupByOutputType[P]>
            : GetScalarType<T[P], Regiao_atuacaoGroupByOutputType[P]>
        }
      >
    >


  export type regiao_atuacaoSelect = {
    id?: boolean
    nome?: boolean
  }


  export type regiao_atuacaoGetPayload<S extends boolean | null | undefined | regiao_atuacaoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? regiao_atuacao :
    S extends undefined ? never :
    S extends { include: any } & (regiao_atuacaoArgs | regiao_atuacaoFindManyArgs)
    ? regiao_atuacao 
    : S extends { select: any } & (regiao_atuacaoArgs | regiao_atuacaoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof regiao_atuacao ? regiao_atuacao[P] : never
  } 
      : regiao_atuacao


  type regiao_atuacaoCountArgs = Merge<
    Omit<regiao_atuacaoFindManyArgs, 'select' | 'include'> & {
      select?: Regiao_atuacaoCountAggregateInputType | true
    }
  >

  export interface regiao_atuacaoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Regiao_atuacao that matches the filter.
     * @param {regiao_atuacaoFindUniqueArgs} args - Arguments to find a Regiao_atuacao
     * @example
     * // Get one Regiao_atuacao
     * const regiao_atuacao = await prisma.regiao_atuacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends regiao_atuacaoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, regiao_atuacaoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'regiao_atuacao'> extends True ? Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T>> : Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T> | null, null>

    /**
     * Find the first Regiao_atuacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacaoFindFirstArgs} args - Arguments to find a Regiao_atuacao
     * @example
     * // Get one Regiao_atuacao
     * const regiao_atuacao = await prisma.regiao_atuacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends regiao_atuacaoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, regiao_atuacaoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'regiao_atuacao'> extends True ? Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T>> : Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T> | null, null>

    /**
     * Find zero or more Regiao_atuacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacaoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regiao_atuacaos
     * const regiao_atuacaos = await prisma.regiao_atuacao.findMany()
     * 
     * // Get first 10 Regiao_atuacaos
     * const regiao_atuacaos = await prisma.regiao_atuacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regiao_atuacaoWithIdOnly = await prisma.regiao_atuacao.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends regiao_atuacaoFindManyArgs>(
      args?: SelectSubset<T, regiao_atuacaoFindManyArgs>
    ): PrismaPromise<Array<regiao_atuacaoGetPayload<T>>>

    /**
     * Create a Regiao_atuacao.
     * @param {regiao_atuacaoCreateArgs} args - Arguments to create a Regiao_atuacao.
     * @example
     * // Create one Regiao_atuacao
     * const Regiao_atuacao = await prisma.regiao_atuacao.create({
     *   data: {
     *     // ... data to create a Regiao_atuacao
     *   }
     * })
     * 
    **/
    create<T extends regiao_atuacaoCreateArgs>(
      args: SelectSubset<T, regiao_atuacaoCreateArgs>
    ): Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T>>

    /**
     * Create many Regiao_atuacaos.
     *     @param {regiao_atuacaoCreateManyArgs} args - Arguments to create many Regiao_atuacaos.
     *     @example
     *     // Create many Regiao_atuacaos
     *     const regiao_atuacao = await prisma.regiao_atuacao.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends regiao_atuacaoCreateManyArgs>(
      args?: SelectSubset<T, regiao_atuacaoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Regiao_atuacao.
     * @param {regiao_atuacaoDeleteArgs} args - Arguments to delete one Regiao_atuacao.
     * @example
     * // Delete one Regiao_atuacao
     * const Regiao_atuacao = await prisma.regiao_atuacao.delete({
     *   where: {
     *     // ... filter to delete one Regiao_atuacao
     *   }
     * })
     * 
    **/
    delete<T extends regiao_atuacaoDeleteArgs>(
      args: SelectSubset<T, regiao_atuacaoDeleteArgs>
    ): Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T>>

    /**
     * Update one Regiao_atuacao.
     * @param {regiao_atuacaoUpdateArgs} args - Arguments to update one Regiao_atuacao.
     * @example
     * // Update one Regiao_atuacao
     * const regiao_atuacao = await prisma.regiao_atuacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends regiao_atuacaoUpdateArgs>(
      args: SelectSubset<T, regiao_atuacaoUpdateArgs>
    ): Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T>>

    /**
     * Delete zero or more Regiao_atuacaos.
     * @param {regiao_atuacaoDeleteManyArgs} args - Arguments to filter Regiao_atuacaos to delete.
     * @example
     * // Delete a few Regiao_atuacaos
     * const { count } = await prisma.regiao_atuacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends regiao_atuacaoDeleteManyArgs>(
      args?: SelectSubset<T, regiao_atuacaoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regiao_atuacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regiao_atuacaos
     * const regiao_atuacao = await prisma.regiao_atuacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends regiao_atuacaoUpdateManyArgs>(
      args: SelectSubset<T, regiao_atuacaoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Regiao_atuacao.
     * @param {regiao_atuacaoUpsertArgs} args - Arguments to update or create a Regiao_atuacao.
     * @example
     * // Update or create a Regiao_atuacao
     * const regiao_atuacao = await prisma.regiao_atuacao.upsert({
     *   create: {
     *     // ... data to create a Regiao_atuacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Regiao_atuacao we want to update
     *   }
     * })
    **/
    upsert<T extends regiao_atuacaoUpsertArgs>(
      args: SelectSubset<T, regiao_atuacaoUpsertArgs>
    ): Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T>>

    /**
     * Find one Regiao_atuacao that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {regiao_atuacaoFindUniqueOrThrowArgs} args - Arguments to find a Regiao_atuacao
     * @example
     * // Get one Regiao_atuacao
     * const regiao_atuacao = await prisma.regiao_atuacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends regiao_atuacaoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, regiao_atuacaoFindUniqueOrThrowArgs>
    ): Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T>>

    /**
     * Find the first Regiao_atuacao that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacaoFindFirstOrThrowArgs} args - Arguments to find a Regiao_atuacao
     * @example
     * // Get one Regiao_atuacao
     * const regiao_atuacao = await prisma.regiao_atuacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends regiao_atuacaoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, regiao_atuacaoFindFirstOrThrowArgs>
    ): Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T>>

    /**
     * Count the number of Regiao_atuacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacaoCountArgs} args - Arguments to filter Regiao_atuacaos to count.
     * @example
     * // Count the number of Regiao_atuacaos
     * const count = await prisma.regiao_atuacao.count({
     *   where: {
     *     // ... the filter for the Regiao_atuacaos we want to count
     *   }
     * })
    **/
    count<T extends regiao_atuacaoCountArgs>(
      args?: Subset<T, regiao_atuacaoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Regiao_atuacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Regiao_atuacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Regiao_atuacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Regiao_atuacaoAggregateArgs>(args: Subset<T, Regiao_atuacaoAggregateArgs>): PrismaPromise<GetRegiao_atuacaoAggregateType<T>>

    /**
     * Group by Regiao_atuacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Regiao_atuacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Regiao_atuacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Regiao_atuacaoGroupByArgs['orderBy'] }
        : { orderBy?: Regiao_atuacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Regiao_atuacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegiao_atuacaoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for regiao_atuacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__regiao_atuacaoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * regiao_atuacao base type for findUnique actions
   */
  export type regiao_atuacaoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the regiao_atuacao
     * 
    **/
    select?: regiao_atuacaoSelect | null
    /**
     * Filter, which regiao_atuacao to fetch.
     * 
    **/
    where: regiao_atuacaoWhereUniqueInput
  }

  /**
   * regiao_atuacao: findUnique
   */
  export interface regiao_atuacaoFindUniqueArgs extends regiao_atuacaoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * regiao_atuacao base type for findFirst actions
   */
  export type regiao_atuacaoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the regiao_atuacao
     * 
    **/
    select?: regiao_atuacaoSelect | null
    /**
     * Filter, which regiao_atuacao to fetch.
     * 
    **/
    where?: regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for regiao_atuacaos.
     * 
    **/
    cursor?: regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regiao_atuacaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of regiao_atuacaos.
     * 
    **/
    distinct?: Enumerable<Regiao_atuacaoScalarFieldEnum>
  }

  /**
   * regiao_atuacao: findFirst
   */
  export interface regiao_atuacaoFindFirstArgs extends regiao_atuacaoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * regiao_atuacao findMany
   */
  export type regiao_atuacaoFindManyArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao
     * 
    **/
    select?: regiao_atuacaoSelect | null
    /**
     * Filter, which regiao_atuacaos to fetch.
     * 
    **/
    where?: regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing regiao_atuacaos.
     * 
    **/
    cursor?: regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regiao_atuacaos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Regiao_atuacaoScalarFieldEnum>
  }


  /**
   * regiao_atuacao create
   */
  export type regiao_atuacaoCreateArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao
     * 
    **/
    select?: regiao_atuacaoSelect | null
    /**
     * The data needed to create a regiao_atuacao.
     * 
    **/
    data: XOR<regiao_atuacaoCreateInput, regiao_atuacaoUncheckedCreateInput>
  }


  /**
   * regiao_atuacao createMany
   */
  export type regiao_atuacaoCreateManyArgs = {
    /**
     * The data used to create many regiao_atuacaos.
     * 
    **/
    data: Enumerable<regiao_atuacaoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * regiao_atuacao update
   */
  export type regiao_atuacaoUpdateArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao
     * 
    **/
    select?: regiao_atuacaoSelect | null
    /**
     * The data needed to update a regiao_atuacao.
     * 
    **/
    data: XOR<regiao_atuacaoUpdateInput, regiao_atuacaoUncheckedUpdateInput>
    /**
     * Choose, which regiao_atuacao to update.
     * 
    **/
    where: regiao_atuacaoWhereUniqueInput
  }


  /**
   * regiao_atuacao updateMany
   */
  export type regiao_atuacaoUpdateManyArgs = {
    /**
     * The data used to update regiao_atuacaos.
     * 
    **/
    data: XOR<regiao_atuacaoUpdateManyMutationInput, regiao_atuacaoUncheckedUpdateManyInput>
    /**
     * Filter which regiao_atuacaos to update
     * 
    **/
    where?: regiao_atuacaoWhereInput
  }


  /**
   * regiao_atuacao upsert
   */
  export type regiao_atuacaoUpsertArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao
     * 
    **/
    select?: regiao_atuacaoSelect | null
    /**
     * The filter to search for the regiao_atuacao to update in case it exists.
     * 
    **/
    where: regiao_atuacaoWhereUniqueInput
    /**
     * In case the regiao_atuacao found by the `where` argument doesn't exist, create a new regiao_atuacao with this data.
     * 
    **/
    create: XOR<regiao_atuacaoCreateInput, regiao_atuacaoUncheckedCreateInput>
    /**
     * In case the regiao_atuacao was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<regiao_atuacaoUpdateInput, regiao_atuacaoUncheckedUpdateInput>
  }


  /**
   * regiao_atuacao delete
   */
  export type regiao_atuacaoDeleteArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao
     * 
    **/
    select?: regiao_atuacaoSelect | null
    /**
     * Filter which regiao_atuacao to delete.
     * 
    **/
    where: regiao_atuacaoWhereUniqueInput
  }


  /**
   * regiao_atuacao deleteMany
   */
  export type regiao_atuacaoDeleteManyArgs = {
    /**
     * Filter which regiao_atuacaos to delete
     * 
    **/
    where?: regiao_atuacaoWhereInput
  }


  /**
   * regiao_atuacao: findUniqueOrThrow
   */
  export type regiao_atuacaoFindUniqueOrThrowArgs = regiao_atuacaoFindUniqueArgsBase
      

  /**
   * regiao_atuacao: findFirstOrThrow
   */
  export type regiao_atuacaoFindFirstOrThrowArgs = regiao_atuacaoFindFirstArgsBase
      

  /**
   * regiao_atuacao without action
   */
  export type regiao_atuacaoArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao
     * 
    **/
    select?: regiao_atuacaoSelect | null
  }



  /**
   * Model regiao_atuacao_tipo
   */


  export type AggregateRegiao_atuacao_tipo = {
    _count: Regiao_atuacao_tipoCountAggregateOutputType | null
    _avg: Regiao_atuacao_tipoAvgAggregateOutputType | null
    _sum: Regiao_atuacao_tipoSumAggregateOutputType | null
    _min: Regiao_atuacao_tipoMinAggregateOutputType | null
    _max: Regiao_atuacao_tipoMaxAggregateOutputType | null
  }

  export type Regiao_atuacao_tipoAvgAggregateOutputType = {
    id: number | null
  }

  export type Regiao_atuacao_tipoSumAggregateOutputType = {
    id: number | null
  }

  export type Regiao_atuacao_tipoMinAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Regiao_atuacao_tipoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Regiao_atuacao_tipoCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type Regiao_atuacao_tipoAvgAggregateInputType = {
    id?: true
  }

  export type Regiao_atuacao_tipoSumAggregateInputType = {
    id?: true
  }

  export type Regiao_atuacao_tipoMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Regiao_atuacao_tipoMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Regiao_atuacao_tipoCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type Regiao_atuacao_tipoAggregateArgs = {
    /**
     * Filter which regiao_atuacao_tipo to aggregate.
     * 
    **/
    where?: regiao_atuacao_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regiao_atuacao_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<regiao_atuacao_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: regiao_atuacao_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regiao_atuacao_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regiao_atuacao_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned regiao_atuacao_tipos
    **/
    _count?: true | Regiao_atuacao_tipoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Regiao_atuacao_tipoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Regiao_atuacao_tipoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Regiao_atuacao_tipoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Regiao_atuacao_tipoMaxAggregateInputType
  }

  export type GetRegiao_atuacao_tipoAggregateType<T extends Regiao_atuacao_tipoAggregateArgs> = {
        [P in keyof T & keyof AggregateRegiao_atuacao_tipo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegiao_atuacao_tipo[P]>
      : GetScalarType<T[P], AggregateRegiao_atuacao_tipo[P]>
  }




  export type Regiao_atuacao_tipoGroupByArgs = {
    where?: regiao_atuacao_tipoWhereInput
    orderBy?: Enumerable<regiao_atuacao_tipoOrderByWithAggregationInput>
    by: Array<Regiao_atuacao_tipoScalarFieldEnum>
    having?: regiao_atuacao_tipoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Regiao_atuacao_tipoCountAggregateInputType | true
    _avg?: Regiao_atuacao_tipoAvgAggregateInputType
    _sum?: Regiao_atuacao_tipoSumAggregateInputType
    _min?: Regiao_atuacao_tipoMinAggregateInputType
    _max?: Regiao_atuacao_tipoMaxAggregateInputType
  }


  export type Regiao_atuacao_tipoGroupByOutputType = {
    id: number
    nome: string
    _count: Regiao_atuacao_tipoCountAggregateOutputType | null
    _avg: Regiao_atuacao_tipoAvgAggregateOutputType | null
    _sum: Regiao_atuacao_tipoSumAggregateOutputType | null
    _min: Regiao_atuacao_tipoMinAggregateOutputType | null
    _max: Regiao_atuacao_tipoMaxAggregateOutputType | null
  }

  type GetRegiao_atuacao_tipoGroupByPayload<T extends Regiao_atuacao_tipoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Regiao_atuacao_tipoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Regiao_atuacao_tipoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Regiao_atuacao_tipoGroupByOutputType[P]>
            : GetScalarType<T[P], Regiao_atuacao_tipoGroupByOutputType[P]>
        }
      >
    >


  export type regiao_atuacao_tipoSelect = {
    id?: boolean
    nome?: boolean
  }


  export type regiao_atuacao_tipoGetPayload<S extends boolean | null | undefined | regiao_atuacao_tipoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? regiao_atuacao_tipo :
    S extends undefined ? never :
    S extends { include: any } & (regiao_atuacao_tipoArgs | regiao_atuacao_tipoFindManyArgs)
    ? regiao_atuacao_tipo 
    : S extends { select: any } & (regiao_atuacao_tipoArgs | regiao_atuacao_tipoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof regiao_atuacao_tipo ? regiao_atuacao_tipo[P] : never
  } 
      : regiao_atuacao_tipo


  type regiao_atuacao_tipoCountArgs = Merge<
    Omit<regiao_atuacao_tipoFindManyArgs, 'select' | 'include'> & {
      select?: Regiao_atuacao_tipoCountAggregateInputType | true
    }
  >

  export interface regiao_atuacao_tipoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Regiao_atuacao_tipo that matches the filter.
     * @param {regiao_atuacao_tipoFindUniqueArgs} args - Arguments to find a Regiao_atuacao_tipo
     * @example
     * // Get one Regiao_atuacao_tipo
     * const regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends regiao_atuacao_tipoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, regiao_atuacao_tipoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'regiao_atuacao_tipo'> extends True ? Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T>> : Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T> | null, null>

    /**
     * Find the first Regiao_atuacao_tipo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacao_tipoFindFirstArgs} args - Arguments to find a Regiao_atuacao_tipo
     * @example
     * // Get one Regiao_atuacao_tipo
     * const regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends regiao_atuacao_tipoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, regiao_atuacao_tipoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'regiao_atuacao_tipo'> extends True ? Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T>> : Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T> | null, null>

    /**
     * Find zero or more Regiao_atuacao_tipos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacao_tipoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regiao_atuacao_tipos
     * const regiao_atuacao_tipos = await prisma.regiao_atuacao_tipo.findMany()
     * 
     * // Get first 10 Regiao_atuacao_tipos
     * const regiao_atuacao_tipos = await prisma.regiao_atuacao_tipo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regiao_atuacao_tipoWithIdOnly = await prisma.regiao_atuacao_tipo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends regiao_atuacao_tipoFindManyArgs>(
      args?: SelectSubset<T, regiao_atuacao_tipoFindManyArgs>
    ): PrismaPromise<Array<regiao_atuacao_tipoGetPayload<T>>>

    /**
     * Create a Regiao_atuacao_tipo.
     * @param {regiao_atuacao_tipoCreateArgs} args - Arguments to create a Regiao_atuacao_tipo.
     * @example
     * // Create one Regiao_atuacao_tipo
     * const Regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.create({
     *   data: {
     *     // ... data to create a Regiao_atuacao_tipo
     *   }
     * })
     * 
    **/
    create<T extends regiao_atuacao_tipoCreateArgs>(
      args: SelectSubset<T, regiao_atuacao_tipoCreateArgs>
    ): Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T>>

    /**
     * Create many Regiao_atuacao_tipos.
     *     @param {regiao_atuacao_tipoCreateManyArgs} args - Arguments to create many Regiao_atuacao_tipos.
     *     @example
     *     // Create many Regiao_atuacao_tipos
     *     const regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends regiao_atuacao_tipoCreateManyArgs>(
      args?: SelectSubset<T, regiao_atuacao_tipoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Regiao_atuacao_tipo.
     * @param {regiao_atuacao_tipoDeleteArgs} args - Arguments to delete one Regiao_atuacao_tipo.
     * @example
     * // Delete one Regiao_atuacao_tipo
     * const Regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.delete({
     *   where: {
     *     // ... filter to delete one Regiao_atuacao_tipo
     *   }
     * })
     * 
    **/
    delete<T extends regiao_atuacao_tipoDeleteArgs>(
      args: SelectSubset<T, regiao_atuacao_tipoDeleteArgs>
    ): Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T>>

    /**
     * Update one Regiao_atuacao_tipo.
     * @param {regiao_atuacao_tipoUpdateArgs} args - Arguments to update one Regiao_atuacao_tipo.
     * @example
     * // Update one Regiao_atuacao_tipo
     * const regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends regiao_atuacao_tipoUpdateArgs>(
      args: SelectSubset<T, regiao_atuacao_tipoUpdateArgs>
    ): Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T>>

    /**
     * Delete zero or more Regiao_atuacao_tipos.
     * @param {regiao_atuacao_tipoDeleteManyArgs} args - Arguments to filter Regiao_atuacao_tipos to delete.
     * @example
     * // Delete a few Regiao_atuacao_tipos
     * const { count } = await prisma.regiao_atuacao_tipo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends regiao_atuacao_tipoDeleteManyArgs>(
      args?: SelectSubset<T, regiao_atuacao_tipoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regiao_atuacao_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacao_tipoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regiao_atuacao_tipos
     * const regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends regiao_atuacao_tipoUpdateManyArgs>(
      args: SelectSubset<T, regiao_atuacao_tipoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Regiao_atuacao_tipo.
     * @param {regiao_atuacao_tipoUpsertArgs} args - Arguments to update or create a Regiao_atuacao_tipo.
     * @example
     * // Update or create a Regiao_atuacao_tipo
     * const regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.upsert({
     *   create: {
     *     // ... data to create a Regiao_atuacao_tipo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Regiao_atuacao_tipo we want to update
     *   }
     * })
    **/
    upsert<T extends regiao_atuacao_tipoUpsertArgs>(
      args: SelectSubset<T, regiao_atuacao_tipoUpsertArgs>
    ): Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T>>

    /**
     * Find one Regiao_atuacao_tipo that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {regiao_atuacao_tipoFindUniqueOrThrowArgs} args - Arguments to find a Regiao_atuacao_tipo
     * @example
     * // Get one Regiao_atuacao_tipo
     * const regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends regiao_atuacao_tipoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, regiao_atuacao_tipoFindUniqueOrThrowArgs>
    ): Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T>>

    /**
     * Find the first Regiao_atuacao_tipo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacao_tipoFindFirstOrThrowArgs} args - Arguments to find a Regiao_atuacao_tipo
     * @example
     * // Get one Regiao_atuacao_tipo
     * const regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends regiao_atuacao_tipoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, regiao_atuacao_tipoFindFirstOrThrowArgs>
    ): Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T>>

    /**
     * Count the number of Regiao_atuacao_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacao_tipoCountArgs} args - Arguments to filter Regiao_atuacao_tipos to count.
     * @example
     * // Count the number of Regiao_atuacao_tipos
     * const count = await prisma.regiao_atuacao_tipo.count({
     *   where: {
     *     // ... the filter for the Regiao_atuacao_tipos we want to count
     *   }
     * })
    **/
    count<T extends regiao_atuacao_tipoCountArgs>(
      args?: Subset<T, regiao_atuacao_tipoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Regiao_atuacao_tipoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Regiao_atuacao_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Regiao_atuacao_tipoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Regiao_atuacao_tipoAggregateArgs>(args: Subset<T, Regiao_atuacao_tipoAggregateArgs>): PrismaPromise<GetRegiao_atuacao_tipoAggregateType<T>>

    /**
     * Group by Regiao_atuacao_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Regiao_atuacao_tipoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Regiao_atuacao_tipoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Regiao_atuacao_tipoGroupByArgs['orderBy'] }
        : { orderBy?: Regiao_atuacao_tipoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Regiao_atuacao_tipoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegiao_atuacao_tipoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for regiao_atuacao_tipo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__regiao_atuacao_tipoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * regiao_atuacao_tipo base type for findUnique actions
   */
  export type regiao_atuacao_tipoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the regiao_atuacao_tipo
     * 
    **/
    select?: regiao_atuacao_tipoSelect | null
    /**
     * Filter, which regiao_atuacao_tipo to fetch.
     * 
    **/
    where: regiao_atuacao_tipoWhereUniqueInput
  }

  /**
   * regiao_atuacao_tipo: findUnique
   */
  export interface regiao_atuacao_tipoFindUniqueArgs extends regiao_atuacao_tipoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * regiao_atuacao_tipo base type for findFirst actions
   */
  export type regiao_atuacao_tipoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the regiao_atuacao_tipo
     * 
    **/
    select?: regiao_atuacao_tipoSelect | null
    /**
     * Filter, which regiao_atuacao_tipo to fetch.
     * 
    **/
    where?: regiao_atuacao_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regiao_atuacao_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<regiao_atuacao_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for regiao_atuacao_tipos.
     * 
    **/
    cursor?: regiao_atuacao_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regiao_atuacao_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regiao_atuacao_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of regiao_atuacao_tipos.
     * 
    **/
    distinct?: Enumerable<Regiao_atuacao_tipoScalarFieldEnum>
  }

  /**
   * regiao_atuacao_tipo: findFirst
   */
  export interface regiao_atuacao_tipoFindFirstArgs extends regiao_atuacao_tipoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * regiao_atuacao_tipo findMany
   */
  export type regiao_atuacao_tipoFindManyArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao_tipo
     * 
    **/
    select?: regiao_atuacao_tipoSelect | null
    /**
     * Filter, which regiao_atuacao_tipos to fetch.
     * 
    **/
    where?: regiao_atuacao_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regiao_atuacao_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<regiao_atuacao_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing regiao_atuacao_tipos.
     * 
    **/
    cursor?: regiao_atuacao_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regiao_atuacao_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regiao_atuacao_tipos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Regiao_atuacao_tipoScalarFieldEnum>
  }


  /**
   * regiao_atuacao_tipo create
   */
  export type regiao_atuacao_tipoCreateArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao_tipo
     * 
    **/
    select?: regiao_atuacao_tipoSelect | null
    /**
     * The data needed to create a regiao_atuacao_tipo.
     * 
    **/
    data: XOR<regiao_atuacao_tipoCreateInput, regiao_atuacao_tipoUncheckedCreateInput>
  }


  /**
   * regiao_atuacao_tipo createMany
   */
  export type regiao_atuacao_tipoCreateManyArgs = {
    /**
     * The data used to create many regiao_atuacao_tipos.
     * 
    **/
    data: Enumerable<regiao_atuacao_tipoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * regiao_atuacao_tipo update
   */
  export type regiao_atuacao_tipoUpdateArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao_tipo
     * 
    **/
    select?: regiao_atuacao_tipoSelect | null
    /**
     * The data needed to update a regiao_atuacao_tipo.
     * 
    **/
    data: XOR<regiao_atuacao_tipoUpdateInput, regiao_atuacao_tipoUncheckedUpdateInput>
    /**
     * Choose, which regiao_atuacao_tipo to update.
     * 
    **/
    where: regiao_atuacao_tipoWhereUniqueInput
  }


  /**
   * regiao_atuacao_tipo updateMany
   */
  export type regiao_atuacao_tipoUpdateManyArgs = {
    /**
     * The data used to update regiao_atuacao_tipos.
     * 
    **/
    data: XOR<regiao_atuacao_tipoUpdateManyMutationInput, regiao_atuacao_tipoUncheckedUpdateManyInput>
    /**
     * Filter which regiao_atuacao_tipos to update
     * 
    **/
    where?: regiao_atuacao_tipoWhereInput
  }


  /**
   * regiao_atuacao_tipo upsert
   */
  export type regiao_atuacao_tipoUpsertArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao_tipo
     * 
    **/
    select?: regiao_atuacao_tipoSelect | null
    /**
     * The filter to search for the regiao_atuacao_tipo to update in case it exists.
     * 
    **/
    where: regiao_atuacao_tipoWhereUniqueInput
    /**
     * In case the regiao_atuacao_tipo found by the `where` argument doesn't exist, create a new regiao_atuacao_tipo with this data.
     * 
    **/
    create: XOR<regiao_atuacao_tipoCreateInput, regiao_atuacao_tipoUncheckedCreateInput>
    /**
     * In case the regiao_atuacao_tipo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<regiao_atuacao_tipoUpdateInput, regiao_atuacao_tipoUncheckedUpdateInput>
  }


  /**
   * regiao_atuacao_tipo delete
   */
  export type regiao_atuacao_tipoDeleteArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao_tipo
     * 
    **/
    select?: regiao_atuacao_tipoSelect | null
    /**
     * Filter which regiao_atuacao_tipo to delete.
     * 
    **/
    where: regiao_atuacao_tipoWhereUniqueInput
  }


  /**
   * regiao_atuacao_tipo deleteMany
   */
  export type regiao_atuacao_tipoDeleteManyArgs = {
    /**
     * Filter which regiao_atuacao_tipos to delete
     * 
    **/
    where?: regiao_atuacao_tipoWhereInput
  }


  /**
   * regiao_atuacao_tipo: findUniqueOrThrow
   */
  export type regiao_atuacao_tipoFindUniqueOrThrowArgs = regiao_atuacao_tipoFindUniqueArgsBase
      

  /**
   * regiao_atuacao_tipo: findFirstOrThrow
   */
  export type regiao_atuacao_tipoFindFirstOrThrowArgs = regiao_atuacao_tipoFindFirstArgsBase
      

  /**
   * regiao_atuacao_tipo without action
   */
  export type regiao_atuacao_tipoArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao_tipo
     * 
    **/
    select?: regiao_atuacao_tipoSelect | null
  }



  /**
   * Model sacado
   */


  export type AggregateSacado = {
    _count: SacadoCountAggregateOutputType | null
    _avg: SacadoAvgAggregateOutputType | null
    _sum: SacadoSumAggregateOutputType | null
    _min: SacadoMinAggregateOutputType | null
    _max: SacadoMaxAggregateOutputType | null
  }

  export type SacadoAvgAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
  }

  export type SacadoSumAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
  }

  export type SacadoMinAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
    razao_social: string | null
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
  }

  export type SacadoMaxAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
    razao_social: string | null
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
  }

  export type SacadoCountAggregateOutputType = {
    id: number
    pessoa_id: number
    razao_social: number
    nome_fantasia: number
    abertura: number
    cnpj: number
    _all: number
  }


  export type SacadoAvgAggregateInputType = {
    id?: true
    pessoa_id?: true
  }

  export type SacadoSumAggregateInputType = {
    id?: true
    pessoa_id?: true
  }

  export type SacadoMinAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
  }

  export type SacadoMaxAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
  }

  export type SacadoCountAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
    _all?: true
  }

  export type SacadoAggregateArgs = {
    /**
     * Filter which sacado to aggregate.
     * 
    **/
    where?: sacadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sacados to fetch.
     * 
    **/
    orderBy?: Enumerable<sacadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: sacadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sacados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sacados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sacados
    **/
    _count?: true | SacadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SacadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SacadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SacadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SacadoMaxAggregateInputType
  }

  export type GetSacadoAggregateType<T extends SacadoAggregateArgs> = {
        [P in keyof T & keyof AggregateSacado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSacado[P]>
      : GetScalarType<T[P], AggregateSacado[P]>
  }




  export type SacadoGroupByArgs = {
    where?: sacadoWhereInput
    orderBy?: Enumerable<sacadoOrderByWithAggregationInput>
    by: Array<SacadoScalarFieldEnum>
    having?: sacadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SacadoCountAggregateInputType | true
    _avg?: SacadoAvgAggregateInputType
    _sum?: SacadoSumAggregateInputType
    _min?: SacadoMinAggregateInputType
    _max?: SacadoMaxAggregateInputType
  }


  export type SacadoGroupByOutputType = {
    id: number
    pessoa_id: number
    razao_social: string
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
    _count: SacadoCountAggregateOutputType | null
    _avg: SacadoAvgAggregateOutputType | null
    _sum: SacadoSumAggregateOutputType | null
    _min: SacadoMinAggregateOutputType | null
    _max: SacadoMaxAggregateOutputType | null
  }

  type GetSacadoGroupByPayload<T extends SacadoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SacadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SacadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SacadoGroupByOutputType[P]>
            : GetScalarType<T[P], SacadoGroupByOutputType[P]>
        }
      >
    >


  export type sacadoSelect = {
    id?: boolean
    pessoa_id?: boolean
    razao_social?: boolean
    nome_fantasia?: boolean
    abertura?: boolean
    cnpj?: boolean
    cedente_n_sacados?: boolean | cedente_n_sacadosFindManyArgs
    _count?: boolean | SacadoCountOutputTypeArgs
  }


  export type sacadoInclude = {
    cedente_n_sacados?: boolean | cedente_n_sacadosFindManyArgs
    _count?: boolean | SacadoCountOutputTypeArgs
  } 

  export type sacadoGetPayload<S extends boolean | null | undefined | sacadoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? sacado :
    S extends undefined ? never :
    S extends { include: any } & (sacadoArgs | sacadoFindManyArgs)
    ? sacado  & {
    [P in TrueKeys<S['include']>]:
        P extends 'cedente_n_sacados' ? Array < cedente_n_sacadosGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? SacadoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (sacadoArgs | sacadoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'cedente_n_sacados' ? Array < cedente_n_sacadosGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? SacadoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof sacado ? sacado[P] : never
  } 
      : sacado


  type sacadoCountArgs = Merge<
    Omit<sacadoFindManyArgs, 'select' | 'include'> & {
      select?: SacadoCountAggregateInputType | true
    }
  >

  export interface sacadoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Sacado that matches the filter.
     * @param {sacadoFindUniqueArgs} args - Arguments to find a Sacado
     * @example
     * // Get one Sacado
     * const sacado = await prisma.sacado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sacadoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sacadoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'sacado'> extends True ? Prisma__sacadoClient<sacadoGetPayload<T>> : Prisma__sacadoClient<sacadoGetPayload<T> | null, null>

    /**
     * Find the first Sacado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sacadoFindFirstArgs} args - Arguments to find a Sacado
     * @example
     * // Get one Sacado
     * const sacado = await prisma.sacado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sacadoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sacadoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'sacado'> extends True ? Prisma__sacadoClient<sacadoGetPayload<T>> : Prisma__sacadoClient<sacadoGetPayload<T> | null, null>

    /**
     * Find zero or more Sacados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sacadoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sacados
     * const sacados = await prisma.sacado.findMany()
     * 
     * // Get first 10 Sacados
     * const sacados = await prisma.sacado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sacadoWithIdOnly = await prisma.sacado.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sacadoFindManyArgs>(
      args?: SelectSubset<T, sacadoFindManyArgs>
    ): PrismaPromise<Array<sacadoGetPayload<T>>>

    /**
     * Create a Sacado.
     * @param {sacadoCreateArgs} args - Arguments to create a Sacado.
     * @example
     * // Create one Sacado
     * const Sacado = await prisma.sacado.create({
     *   data: {
     *     // ... data to create a Sacado
     *   }
     * })
     * 
    **/
    create<T extends sacadoCreateArgs>(
      args: SelectSubset<T, sacadoCreateArgs>
    ): Prisma__sacadoClient<sacadoGetPayload<T>>

    /**
     * Create many Sacados.
     *     @param {sacadoCreateManyArgs} args - Arguments to create many Sacados.
     *     @example
     *     // Create many Sacados
     *     const sacado = await prisma.sacado.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sacadoCreateManyArgs>(
      args?: SelectSubset<T, sacadoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Sacado.
     * @param {sacadoDeleteArgs} args - Arguments to delete one Sacado.
     * @example
     * // Delete one Sacado
     * const Sacado = await prisma.sacado.delete({
     *   where: {
     *     // ... filter to delete one Sacado
     *   }
     * })
     * 
    **/
    delete<T extends sacadoDeleteArgs>(
      args: SelectSubset<T, sacadoDeleteArgs>
    ): Prisma__sacadoClient<sacadoGetPayload<T>>

    /**
     * Update one Sacado.
     * @param {sacadoUpdateArgs} args - Arguments to update one Sacado.
     * @example
     * // Update one Sacado
     * const sacado = await prisma.sacado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sacadoUpdateArgs>(
      args: SelectSubset<T, sacadoUpdateArgs>
    ): Prisma__sacadoClient<sacadoGetPayload<T>>

    /**
     * Delete zero or more Sacados.
     * @param {sacadoDeleteManyArgs} args - Arguments to filter Sacados to delete.
     * @example
     * // Delete a few Sacados
     * const { count } = await prisma.sacado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sacadoDeleteManyArgs>(
      args?: SelectSubset<T, sacadoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sacados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sacadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sacados
     * const sacado = await prisma.sacado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sacadoUpdateManyArgs>(
      args: SelectSubset<T, sacadoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Sacado.
     * @param {sacadoUpsertArgs} args - Arguments to update or create a Sacado.
     * @example
     * // Update or create a Sacado
     * const sacado = await prisma.sacado.upsert({
     *   create: {
     *     // ... data to create a Sacado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sacado we want to update
     *   }
     * })
    **/
    upsert<T extends sacadoUpsertArgs>(
      args: SelectSubset<T, sacadoUpsertArgs>
    ): Prisma__sacadoClient<sacadoGetPayload<T>>

    /**
     * Find one Sacado that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {sacadoFindUniqueOrThrowArgs} args - Arguments to find a Sacado
     * @example
     * // Get one Sacado
     * const sacado = await prisma.sacado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sacadoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, sacadoFindUniqueOrThrowArgs>
    ): Prisma__sacadoClient<sacadoGetPayload<T>>

    /**
     * Find the first Sacado that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sacadoFindFirstOrThrowArgs} args - Arguments to find a Sacado
     * @example
     * // Get one Sacado
     * const sacado = await prisma.sacado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sacadoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, sacadoFindFirstOrThrowArgs>
    ): Prisma__sacadoClient<sacadoGetPayload<T>>

    /**
     * Count the number of Sacados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sacadoCountArgs} args - Arguments to filter Sacados to count.
     * @example
     * // Count the number of Sacados
     * const count = await prisma.sacado.count({
     *   where: {
     *     // ... the filter for the Sacados we want to count
     *   }
     * })
    **/
    count<T extends sacadoCountArgs>(
      args?: Subset<T, sacadoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SacadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sacado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SacadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SacadoAggregateArgs>(args: Subset<T, SacadoAggregateArgs>): PrismaPromise<GetSacadoAggregateType<T>>

    /**
     * Group by Sacado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SacadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SacadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SacadoGroupByArgs['orderBy'] }
        : { orderBy?: SacadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SacadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSacadoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for sacado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sacadoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cedente_n_sacados<T extends cedente_n_sacadosFindManyArgs= {}>(args?: Subset<T, cedente_n_sacadosFindManyArgs>): PrismaPromise<Array<cedente_n_sacadosGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * sacado base type for findUnique actions
   */
  export type sacadoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the sacado
     * 
    **/
    select?: sacadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sacadoInclude | null
    /**
     * Filter, which sacado to fetch.
     * 
    **/
    where: sacadoWhereUniqueInput
  }

  /**
   * sacado: findUnique
   */
  export interface sacadoFindUniqueArgs extends sacadoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sacado base type for findFirst actions
   */
  export type sacadoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the sacado
     * 
    **/
    select?: sacadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sacadoInclude | null
    /**
     * Filter, which sacado to fetch.
     * 
    **/
    where?: sacadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sacados to fetch.
     * 
    **/
    orderBy?: Enumerable<sacadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sacados.
     * 
    **/
    cursor?: sacadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sacados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sacados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sacados.
     * 
    **/
    distinct?: Enumerable<SacadoScalarFieldEnum>
  }

  /**
   * sacado: findFirst
   */
  export interface sacadoFindFirstArgs extends sacadoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sacado findMany
   */
  export type sacadoFindManyArgs = {
    /**
     * Select specific fields to fetch from the sacado
     * 
    **/
    select?: sacadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sacadoInclude | null
    /**
     * Filter, which sacados to fetch.
     * 
    **/
    where?: sacadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sacados to fetch.
     * 
    **/
    orderBy?: Enumerable<sacadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sacados.
     * 
    **/
    cursor?: sacadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sacados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sacados.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SacadoScalarFieldEnum>
  }


  /**
   * sacado create
   */
  export type sacadoCreateArgs = {
    /**
     * Select specific fields to fetch from the sacado
     * 
    **/
    select?: sacadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sacadoInclude | null
    /**
     * The data needed to create a sacado.
     * 
    **/
    data: XOR<sacadoCreateInput, sacadoUncheckedCreateInput>
  }


  /**
   * sacado createMany
   */
  export type sacadoCreateManyArgs = {
    /**
     * The data used to create many sacados.
     * 
    **/
    data: Enumerable<sacadoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * sacado update
   */
  export type sacadoUpdateArgs = {
    /**
     * Select specific fields to fetch from the sacado
     * 
    **/
    select?: sacadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sacadoInclude | null
    /**
     * The data needed to update a sacado.
     * 
    **/
    data: XOR<sacadoUpdateInput, sacadoUncheckedUpdateInput>
    /**
     * Choose, which sacado to update.
     * 
    **/
    where: sacadoWhereUniqueInput
  }


  /**
   * sacado updateMany
   */
  export type sacadoUpdateManyArgs = {
    /**
     * The data used to update sacados.
     * 
    **/
    data: XOR<sacadoUpdateManyMutationInput, sacadoUncheckedUpdateManyInput>
    /**
     * Filter which sacados to update
     * 
    **/
    where?: sacadoWhereInput
  }


  /**
   * sacado upsert
   */
  export type sacadoUpsertArgs = {
    /**
     * Select specific fields to fetch from the sacado
     * 
    **/
    select?: sacadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sacadoInclude | null
    /**
     * The filter to search for the sacado to update in case it exists.
     * 
    **/
    where: sacadoWhereUniqueInput
    /**
     * In case the sacado found by the `where` argument doesn't exist, create a new sacado with this data.
     * 
    **/
    create: XOR<sacadoCreateInput, sacadoUncheckedCreateInput>
    /**
     * In case the sacado was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<sacadoUpdateInput, sacadoUncheckedUpdateInput>
  }


  /**
   * sacado delete
   */
  export type sacadoDeleteArgs = {
    /**
     * Select specific fields to fetch from the sacado
     * 
    **/
    select?: sacadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sacadoInclude | null
    /**
     * Filter which sacado to delete.
     * 
    **/
    where: sacadoWhereUniqueInput
  }


  /**
   * sacado deleteMany
   */
  export type sacadoDeleteManyArgs = {
    /**
     * Filter which sacados to delete
     * 
    **/
    where?: sacadoWhereInput
  }


  /**
   * sacado: findUniqueOrThrow
   */
  export type sacadoFindUniqueOrThrowArgs = sacadoFindUniqueArgsBase
      

  /**
   * sacado: findFirstOrThrow
   */
  export type sacadoFindFirstOrThrowArgs = sacadoFindFirstArgsBase
      

  /**
   * sacado without action
   */
  export type sacadoArgs = {
    /**
     * Select specific fields to fetch from the sacado
     * 
    **/
    select?: sacadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sacadoInclude | null
  }



  /**
   * Model titulo
   */


  export type AggregateTitulo = {
    _count: TituloCountAggregateOutputType | null
    _avg: TituloAvgAggregateOutputType | null
    _sum: TituloSumAggregateOutputType | null
    _min: TituloMinAggregateOutputType | null
    _max: TituloMaxAggregateOutputType | null
  }

  export type TituloAvgAggregateOutputType = {
    id: number | null
    titulo_tipo_id: number | null
    bordero_id: number | null
    valor: number | null
  }

  export type TituloSumAggregateOutputType = {
    id: number | null
    titulo_tipo_id: number | null
    bordero_id: number | null
    valor: number | null
  }

  export type TituloMinAggregateOutputType = {
    id: number | null
    titulo_tipo_id: number | null
    bordero_id: number | null
    nf: string | null
    valor: number | null
    vencimento: Date | null
    numero: string | null
    emissao: Date | null
    parcela: string | null
  }

  export type TituloMaxAggregateOutputType = {
    id: number | null
    titulo_tipo_id: number | null
    bordero_id: number | null
    nf: string | null
    valor: number | null
    vencimento: Date | null
    numero: string | null
    emissao: Date | null
    parcela: string | null
  }

  export type TituloCountAggregateOutputType = {
    id: number
    titulo_tipo_id: number
    bordero_id: number
    nf: number
    valor: number
    vencimento: number
    numero: number
    emissao: number
    parcela: number
    _all: number
  }


  export type TituloAvgAggregateInputType = {
    id?: true
    titulo_tipo_id?: true
    bordero_id?: true
    valor?: true
  }

  export type TituloSumAggregateInputType = {
    id?: true
    titulo_tipo_id?: true
    bordero_id?: true
    valor?: true
  }

  export type TituloMinAggregateInputType = {
    id?: true
    titulo_tipo_id?: true
    bordero_id?: true
    nf?: true
    valor?: true
    vencimento?: true
    numero?: true
    emissao?: true
    parcela?: true
  }

  export type TituloMaxAggregateInputType = {
    id?: true
    titulo_tipo_id?: true
    bordero_id?: true
    nf?: true
    valor?: true
    vencimento?: true
    numero?: true
    emissao?: true
    parcela?: true
  }

  export type TituloCountAggregateInputType = {
    id?: true
    titulo_tipo_id?: true
    bordero_id?: true
    nf?: true
    valor?: true
    vencimento?: true
    numero?: true
    emissao?: true
    parcela?: true
    _all?: true
  }

  export type TituloAggregateArgs = {
    /**
     * Filter which titulo to aggregate.
     * 
    **/
    where?: tituloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulos to fetch.
     * 
    **/
    orderBy?: Enumerable<tituloOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: tituloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned titulos
    **/
    _count?: true | TituloCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TituloAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TituloSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TituloMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TituloMaxAggregateInputType
  }

  export type GetTituloAggregateType<T extends TituloAggregateArgs> = {
        [P in keyof T & keyof AggregateTitulo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTitulo[P]>
      : GetScalarType<T[P], AggregateTitulo[P]>
  }




  export type TituloGroupByArgs = {
    where?: tituloWhereInput
    orderBy?: Enumerable<tituloOrderByWithAggregationInput>
    by: Array<TituloScalarFieldEnum>
    having?: tituloScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TituloCountAggregateInputType | true
    _avg?: TituloAvgAggregateInputType
    _sum?: TituloSumAggregateInputType
    _min?: TituloMinAggregateInputType
    _max?: TituloMaxAggregateInputType
  }


  export type TituloGroupByOutputType = {
    id: number
    titulo_tipo_id: number
    bordero_id: number
    nf: string | null
    valor: number | null
    vencimento: Date | null
    numero: string | null
    emissao: Date | null
    parcela: string | null
    _count: TituloCountAggregateOutputType | null
    _avg: TituloAvgAggregateOutputType | null
    _sum: TituloSumAggregateOutputType | null
    _min: TituloMinAggregateOutputType | null
    _max: TituloMaxAggregateOutputType | null
  }

  type GetTituloGroupByPayload<T extends TituloGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TituloGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TituloGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TituloGroupByOutputType[P]>
            : GetScalarType<T[P], TituloGroupByOutputType[P]>
        }
      >
    >


  export type tituloSelect = {
    id?: boolean
    titulo_tipo_id?: boolean
    bordero_id?: boolean
    nf?: boolean
    valor?: boolean
    vencimento?: boolean
    numero?: boolean
    emissao?: boolean
    parcela?: boolean
    titulo_tipo?: boolean | titulo_tipoArgs
    bordero?: boolean | borderoArgs
  }


  export type tituloInclude = {
    titulo_tipo?: boolean | titulo_tipoArgs
    bordero?: boolean | borderoArgs
  } 

  export type tituloGetPayload<S extends boolean | null | undefined | tituloArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? titulo :
    S extends undefined ? never :
    S extends { include: any } & (tituloArgs | tituloFindManyArgs)
    ? titulo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'titulo_tipo' ? titulo_tipoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'bordero' ? borderoGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (tituloArgs | tituloFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'titulo_tipo' ? titulo_tipoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'bordero' ? borderoGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof titulo ? titulo[P] : never
  } 
      : titulo


  type tituloCountArgs = Merge<
    Omit<tituloFindManyArgs, 'select' | 'include'> & {
      select?: TituloCountAggregateInputType | true
    }
  >

  export interface tituloDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Titulo that matches the filter.
     * @param {tituloFindUniqueArgs} args - Arguments to find a Titulo
     * @example
     * // Get one Titulo
     * const titulo = await prisma.titulo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tituloFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tituloFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'titulo'> extends True ? Prisma__tituloClient<tituloGetPayload<T>> : Prisma__tituloClient<tituloGetPayload<T> | null, null>

    /**
     * Find the first Titulo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tituloFindFirstArgs} args - Arguments to find a Titulo
     * @example
     * // Get one Titulo
     * const titulo = await prisma.titulo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tituloFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tituloFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'titulo'> extends True ? Prisma__tituloClient<tituloGetPayload<T>> : Prisma__tituloClient<tituloGetPayload<T> | null, null>

    /**
     * Find zero or more Titulos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tituloFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Titulos
     * const titulos = await prisma.titulo.findMany()
     * 
     * // Get first 10 Titulos
     * const titulos = await prisma.titulo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tituloWithIdOnly = await prisma.titulo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tituloFindManyArgs>(
      args?: SelectSubset<T, tituloFindManyArgs>
    ): PrismaPromise<Array<tituloGetPayload<T>>>

    /**
     * Create a Titulo.
     * @param {tituloCreateArgs} args - Arguments to create a Titulo.
     * @example
     * // Create one Titulo
     * const Titulo = await prisma.titulo.create({
     *   data: {
     *     // ... data to create a Titulo
     *   }
     * })
     * 
    **/
    create<T extends tituloCreateArgs>(
      args: SelectSubset<T, tituloCreateArgs>
    ): Prisma__tituloClient<tituloGetPayload<T>>

    /**
     * Create many Titulos.
     *     @param {tituloCreateManyArgs} args - Arguments to create many Titulos.
     *     @example
     *     // Create many Titulos
     *     const titulo = await prisma.titulo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tituloCreateManyArgs>(
      args?: SelectSubset<T, tituloCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Titulo.
     * @param {tituloDeleteArgs} args - Arguments to delete one Titulo.
     * @example
     * // Delete one Titulo
     * const Titulo = await prisma.titulo.delete({
     *   where: {
     *     // ... filter to delete one Titulo
     *   }
     * })
     * 
    **/
    delete<T extends tituloDeleteArgs>(
      args: SelectSubset<T, tituloDeleteArgs>
    ): Prisma__tituloClient<tituloGetPayload<T>>

    /**
     * Update one Titulo.
     * @param {tituloUpdateArgs} args - Arguments to update one Titulo.
     * @example
     * // Update one Titulo
     * const titulo = await prisma.titulo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tituloUpdateArgs>(
      args: SelectSubset<T, tituloUpdateArgs>
    ): Prisma__tituloClient<tituloGetPayload<T>>

    /**
     * Delete zero or more Titulos.
     * @param {tituloDeleteManyArgs} args - Arguments to filter Titulos to delete.
     * @example
     * // Delete a few Titulos
     * const { count } = await prisma.titulo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tituloDeleteManyArgs>(
      args?: SelectSubset<T, tituloDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Titulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tituloUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Titulos
     * const titulo = await prisma.titulo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tituloUpdateManyArgs>(
      args: SelectSubset<T, tituloUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Titulo.
     * @param {tituloUpsertArgs} args - Arguments to update or create a Titulo.
     * @example
     * // Update or create a Titulo
     * const titulo = await prisma.titulo.upsert({
     *   create: {
     *     // ... data to create a Titulo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Titulo we want to update
     *   }
     * })
    **/
    upsert<T extends tituloUpsertArgs>(
      args: SelectSubset<T, tituloUpsertArgs>
    ): Prisma__tituloClient<tituloGetPayload<T>>

    /**
     * Find one Titulo that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {tituloFindUniqueOrThrowArgs} args - Arguments to find a Titulo
     * @example
     * // Get one Titulo
     * const titulo = await prisma.titulo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tituloFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tituloFindUniqueOrThrowArgs>
    ): Prisma__tituloClient<tituloGetPayload<T>>

    /**
     * Find the first Titulo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tituloFindFirstOrThrowArgs} args - Arguments to find a Titulo
     * @example
     * // Get one Titulo
     * const titulo = await prisma.titulo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tituloFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tituloFindFirstOrThrowArgs>
    ): Prisma__tituloClient<tituloGetPayload<T>>

    /**
     * Count the number of Titulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tituloCountArgs} args - Arguments to filter Titulos to count.
     * @example
     * // Count the number of Titulos
     * const count = await prisma.titulo.count({
     *   where: {
     *     // ... the filter for the Titulos we want to count
     *   }
     * })
    **/
    count<T extends tituloCountArgs>(
      args?: Subset<T, tituloCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TituloCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Titulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TituloAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TituloAggregateArgs>(args: Subset<T, TituloAggregateArgs>): PrismaPromise<GetTituloAggregateType<T>>

    /**
     * Group by Titulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TituloGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TituloGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TituloGroupByArgs['orderBy'] }
        : { orderBy?: TituloGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TituloGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTituloGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for titulo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tituloClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    titulo_tipo<T extends titulo_tipoArgs= {}>(args?: Subset<T, titulo_tipoArgs>): Prisma__titulo_tipoClient<titulo_tipoGetPayload<T> | Null>;

    bordero<T extends borderoArgs= {}>(args?: Subset<T, borderoArgs>): Prisma__borderoClient<borderoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * titulo base type for findUnique actions
   */
  export type tituloFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the titulo
     * 
    **/
    select?: tituloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: tituloInclude | null
    /**
     * Filter, which titulo to fetch.
     * 
    **/
    where: tituloWhereUniqueInput
  }

  /**
   * titulo: findUnique
   */
  export interface tituloFindUniqueArgs extends tituloFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulo base type for findFirst actions
   */
  export type tituloFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the titulo
     * 
    **/
    select?: tituloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: tituloInclude | null
    /**
     * Filter, which titulo to fetch.
     * 
    **/
    where?: tituloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulos to fetch.
     * 
    **/
    orderBy?: Enumerable<tituloOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for titulos.
     * 
    **/
    cursor?: tituloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of titulos.
     * 
    **/
    distinct?: Enumerable<TituloScalarFieldEnum>
  }

  /**
   * titulo: findFirst
   */
  export interface tituloFindFirstArgs extends tituloFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulo findMany
   */
  export type tituloFindManyArgs = {
    /**
     * Select specific fields to fetch from the titulo
     * 
    **/
    select?: tituloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: tituloInclude | null
    /**
     * Filter, which titulos to fetch.
     * 
    **/
    where?: tituloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulos to fetch.
     * 
    **/
    orderBy?: Enumerable<tituloOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing titulos.
     * 
    **/
    cursor?: tituloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TituloScalarFieldEnum>
  }


  /**
   * titulo create
   */
  export type tituloCreateArgs = {
    /**
     * Select specific fields to fetch from the titulo
     * 
    **/
    select?: tituloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: tituloInclude | null
    /**
     * The data needed to create a titulo.
     * 
    **/
    data: XOR<tituloCreateInput, tituloUncheckedCreateInput>
  }


  /**
   * titulo createMany
   */
  export type tituloCreateManyArgs = {
    /**
     * The data used to create many titulos.
     * 
    **/
    data: Enumerable<tituloCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * titulo update
   */
  export type tituloUpdateArgs = {
    /**
     * Select specific fields to fetch from the titulo
     * 
    **/
    select?: tituloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: tituloInclude | null
    /**
     * The data needed to update a titulo.
     * 
    **/
    data: XOR<tituloUpdateInput, tituloUncheckedUpdateInput>
    /**
     * Choose, which titulo to update.
     * 
    **/
    where: tituloWhereUniqueInput
  }


  /**
   * titulo updateMany
   */
  export type tituloUpdateManyArgs = {
    /**
     * The data used to update titulos.
     * 
    **/
    data: XOR<tituloUpdateManyMutationInput, tituloUncheckedUpdateManyInput>
    /**
     * Filter which titulos to update
     * 
    **/
    where?: tituloWhereInput
  }


  /**
   * titulo upsert
   */
  export type tituloUpsertArgs = {
    /**
     * Select specific fields to fetch from the titulo
     * 
    **/
    select?: tituloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: tituloInclude | null
    /**
     * The filter to search for the titulo to update in case it exists.
     * 
    **/
    where: tituloWhereUniqueInput
    /**
     * In case the titulo found by the `where` argument doesn't exist, create a new titulo with this data.
     * 
    **/
    create: XOR<tituloCreateInput, tituloUncheckedCreateInput>
    /**
     * In case the titulo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<tituloUpdateInput, tituloUncheckedUpdateInput>
  }


  /**
   * titulo delete
   */
  export type tituloDeleteArgs = {
    /**
     * Select specific fields to fetch from the titulo
     * 
    **/
    select?: tituloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: tituloInclude | null
    /**
     * Filter which titulo to delete.
     * 
    **/
    where: tituloWhereUniqueInput
  }


  /**
   * titulo deleteMany
   */
  export type tituloDeleteManyArgs = {
    /**
     * Filter which titulos to delete
     * 
    **/
    where?: tituloWhereInput
  }


  /**
   * titulo: findUniqueOrThrow
   */
  export type tituloFindUniqueOrThrowArgs = tituloFindUniqueArgsBase
      

  /**
   * titulo: findFirstOrThrow
   */
  export type tituloFindFirstOrThrowArgs = tituloFindFirstArgsBase
      

  /**
   * titulo without action
   */
  export type tituloArgs = {
    /**
     * Select specific fields to fetch from the titulo
     * 
    **/
    select?: tituloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: tituloInclude | null
  }



  /**
   * Model titulo_tipo
   */


  export type AggregateTitulo_tipo = {
    _count: Titulo_tipoCountAggregateOutputType | null
    _avg: Titulo_tipoAvgAggregateOutputType | null
    _sum: Titulo_tipoSumAggregateOutputType | null
    _min: Titulo_tipoMinAggregateOutputType | null
    _max: Titulo_tipoMaxAggregateOutputType | null
  }

  export type Titulo_tipoAvgAggregateOutputType = {
    id: number | null
  }

  export type Titulo_tipoSumAggregateOutputType = {
    id: number | null
  }

  export type Titulo_tipoMinAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Titulo_tipoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Titulo_tipoCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type Titulo_tipoAvgAggregateInputType = {
    id?: true
  }

  export type Titulo_tipoSumAggregateInputType = {
    id?: true
  }

  export type Titulo_tipoMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Titulo_tipoMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Titulo_tipoCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type Titulo_tipoAggregateArgs = {
    /**
     * Filter which titulo_tipo to aggregate.
     * 
    **/
    where?: titulo_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: titulo_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned titulo_tipos
    **/
    _count?: true | Titulo_tipoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Titulo_tipoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Titulo_tipoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Titulo_tipoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Titulo_tipoMaxAggregateInputType
  }

  export type GetTitulo_tipoAggregateType<T extends Titulo_tipoAggregateArgs> = {
        [P in keyof T & keyof AggregateTitulo_tipo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTitulo_tipo[P]>
      : GetScalarType<T[P], AggregateTitulo_tipo[P]>
  }




  export type Titulo_tipoGroupByArgs = {
    where?: titulo_tipoWhereInput
    orderBy?: Enumerable<titulo_tipoOrderByWithAggregationInput>
    by: Array<Titulo_tipoScalarFieldEnum>
    having?: titulo_tipoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Titulo_tipoCountAggregateInputType | true
    _avg?: Titulo_tipoAvgAggregateInputType
    _sum?: Titulo_tipoSumAggregateInputType
    _min?: Titulo_tipoMinAggregateInputType
    _max?: Titulo_tipoMaxAggregateInputType
  }


  export type Titulo_tipoGroupByOutputType = {
    id: number
    nome: string | null
    _count: Titulo_tipoCountAggregateOutputType | null
    _avg: Titulo_tipoAvgAggregateOutputType | null
    _sum: Titulo_tipoSumAggregateOutputType | null
    _min: Titulo_tipoMinAggregateOutputType | null
    _max: Titulo_tipoMaxAggregateOutputType | null
  }

  type GetTitulo_tipoGroupByPayload<T extends Titulo_tipoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Titulo_tipoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Titulo_tipoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Titulo_tipoGroupByOutputType[P]>
            : GetScalarType<T[P], Titulo_tipoGroupByOutputType[P]>
        }
      >
    >


  export type titulo_tipoSelect = {
    id?: boolean
    nome?: boolean
    titulo?: boolean | tituloFindManyArgs
    _count?: boolean | Titulo_tipoCountOutputTypeArgs
  }


  export type titulo_tipoInclude = {
    titulo?: boolean | tituloFindManyArgs
    _count?: boolean | Titulo_tipoCountOutputTypeArgs
  } 

  export type titulo_tipoGetPayload<S extends boolean | null | undefined | titulo_tipoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? titulo_tipo :
    S extends undefined ? never :
    S extends { include: any } & (titulo_tipoArgs | titulo_tipoFindManyArgs)
    ? titulo_tipo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'titulo' ? Array < tituloGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Titulo_tipoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (titulo_tipoArgs | titulo_tipoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'titulo' ? Array < tituloGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Titulo_tipoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof titulo_tipo ? titulo_tipo[P] : never
  } 
      : titulo_tipo


  type titulo_tipoCountArgs = Merge<
    Omit<titulo_tipoFindManyArgs, 'select' | 'include'> & {
      select?: Titulo_tipoCountAggregateInputType | true
    }
  >

  export interface titulo_tipoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Titulo_tipo that matches the filter.
     * @param {titulo_tipoFindUniqueArgs} args - Arguments to find a Titulo_tipo
     * @example
     * // Get one Titulo_tipo
     * const titulo_tipo = await prisma.titulo_tipo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends titulo_tipoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, titulo_tipoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'titulo_tipo'> extends True ? Prisma__titulo_tipoClient<titulo_tipoGetPayload<T>> : Prisma__titulo_tipoClient<titulo_tipoGetPayload<T> | null, null>

    /**
     * Find the first Titulo_tipo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_tipoFindFirstArgs} args - Arguments to find a Titulo_tipo
     * @example
     * // Get one Titulo_tipo
     * const titulo_tipo = await prisma.titulo_tipo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends titulo_tipoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, titulo_tipoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'titulo_tipo'> extends True ? Prisma__titulo_tipoClient<titulo_tipoGetPayload<T>> : Prisma__titulo_tipoClient<titulo_tipoGetPayload<T> | null, null>

    /**
     * Find zero or more Titulo_tipos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_tipoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Titulo_tipos
     * const titulo_tipos = await prisma.titulo_tipo.findMany()
     * 
     * // Get first 10 Titulo_tipos
     * const titulo_tipos = await prisma.titulo_tipo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const titulo_tipoWithIdOnly = await prisma.titulo_tipo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends titulo_tipoFindManyArgs>(
      args?: SelectSubset<T, titulo_tipoFindManyArgs>
    ): PrismaPromise<Array<titulo_tipoGetPayload<T>>>

    /**
     * Create a Titulo_tipo.
     * @param {titulo_tipoCreateArgs} args - Arguments to create a Titulo_tipo.
     * @example
     * // Create one Titulo_tipo
     * const Titulo_tipo = await prisma.titulo_tipo.create({
     *   data: {
     *     // ... data to create a Titulo_tipo
     *   }
     * })
     * 
    **/
    create<T extends titulo_tipoCreateArgs>(
      args: SelectSubset<T, titulo_tipoCreateArgs>
    ): Prisma__titulo_tipoClient<titulo_tipoGetPayload<T>>

    /**
     * Create many Titulo_tipos.
     *     @param {titulo_tipoCreateManyArgs} args - Arguments to create many Titulo_tipos.
     *     @example
     *     // Create many Titulo_tipos
     *     const titulo_tipo = await prisma.titulo_tipo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends titulo_tipoCreateManyArgs>(
      args?: SelectSubset<T, titulo_tipoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Titulo_tipo.
     * @param {titulo_tipoDeleteArgs} args - Arguments to delete one Titulo_tipo.
     * @example
     * // Delete one Titulo_tipo
     * const Titulo_tipo = await prisma.titulo_tipo.delete({
     *   where: {
     *     // ... filter to delete one Titulo_tipo
     *   }
     * })
     * 
    **/
    delete<T extends titulo_tipoDeleteArgs>(
      args: SelectSubset<T, titulo_tipoDeleteArgs>
    ): Prisma__titulo_tipoClient<titulo_tipoGetPayload<T>>

    /**
     * Update one Titulo_tipo.
     * @param {titulo_tipoUpdateArgs} args - Arguments to update one Titulo_tipo.
     * @example
     * // Update one Titulo_tipo
     * const titulo_tipo = await prisma.titulo_tipo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends titulo_tipoUpdateArgs>(
      args: SelectSubset<T, titulo_tipoUpdateArgs>
    ): Prisma__titulo_tipoClient<titulo_tipoGetPayload<T>>

    /**
     * Delete zero or more Titulo_tipos.
     * @param {titulo_tipoDeleteManyArgs} args - Arguments to filter Titulo_tipos to delete.
     * @example
     * // Delete a few Titulo_tipos
     * const { count } = await prisma.titulo_tipo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends titulo_tipoDeleteManyArgs>(
      args?: SelectSubset<T, titulo_tipoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Titulo_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_tipoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Titulo_tipos
     * const titulo_tipo = await prisma.titulo_tipo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends titulo_tipoUpdateManyArgs>(
      args: SelectSubset<T, titulo_tipoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Titulo_tipo.
     * @param {titulo_tipoUpsertArgs} args - Arguments to update or create a Titulo_tipo.
     * @example
     * // Update or create a Titulo_tipo
     * const titulo_tipo = await prisma.titulo_tipo.upsert({
     *   create: {
     *     // ... data to create a Titulo_tipo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Titulo_tipo we want to update
     *   }
     * })
    **/
    upsert<T extends titulo_tipoUpsertArgs>(
      args: SelectSubset<T, titulo_tipoUpsertArgs>
    ): Prisma__titulo_tipoClient<titulo_tipoGetPayload<T>>

    /**
     * Find one Titulo_tipo that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {titulo_tipoFindUniqueOrThrowArgs} args - Arguments to find a Titulo_tipo
     * @example
     * // Get one Titulo_tipo
     * const titulo_tipo = await prisma.titulo_tipo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends titulo_tipoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, titulo_tipoFindUniqueOrThrowArgs>
    ): Prisma__titulo_tipoClient<titulo_tipoGetPayload<T>>

    /**
     * Find the first Titulo_tipo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_tipoFindFirstOrThrowArgs} args - Arguments to find a Titulo_tipo
     * @example
     * // Get one Titulo_tipo
     * const titulo_tipo = await prisma.titulo_tipo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends titulo_tipoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, titulo_tipoFindFirstOrThrowArgs>
    ): Prisma__titulo_tipoClient<titulo_tipoGetPayload<T>>

    /**
     * Count the number of Titulo_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_tipoCountArgs} args - Arguments to filter Titulo_tipos to count.
     * @example
     * // Count the number of Titulo_tipos
     * const count = await prisma.titulo_tipo.count({
     *   where: {
     *     // ... the filter for the Titulo_tipos we want to count
     *   }
     * })
    **/
    count<T extends titulo_tipoCountArgs>(
      args?: Subset<T, titulo_tipoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Titulo_tipoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Titulo_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Titulo_tipoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Titulo_tipoAggregateArgs>(args: Subset<T, Titulo_tipoAggregateArgs>): PrismaPromise<GetTitulo_tipoAggregateType<T>>

    /**
     * Group by Titulo_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Titulo_tipoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Titulo_tipoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Titulo_tipoGroupByArgs['orderBy'] }
        : { orderBy?: Titulo_tipoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Titulo_tipoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTitulo_tipoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for titulo_tipo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__titulo_tipoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    titulo<T extends tituloFindManyArgs= {}>(args?: Subset<T, tituloFindManyArgs>): PrismaPromise<Array<tituloGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * titulo_tipo base type for findUnique actions
   */
  export type titulo_tipoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the titulo_tipo
     * 
    **/
    select?: titulo_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_tipoInclude | null
    /**
     * Filter, which titulo_tipo to fetch.
     * 
    **/
    where: titulo_tipoWhereUniqueInput
  }

  /**
   * titulo_tipo: findUnique
   */
  export interface titulo_tipoFindUniqueArgs extends titulo_tipoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulo_tipo base type for findFirst actions
   */
  export type titulo_tipoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the titulo_tipo
     * 
    **/
    select?: titulo_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_tipoInclude | null
    /**
     * Filter, which titulo_tipo to fetch.
     * 
    **/
    where?: titulo_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for titulo_tipos.
     * 
    **/
    cursor?: titulo_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of titulo_tipos.
     * 
    **/
    distinct?: Enumerable<Titulo_tipoScalarFieldEnum>
  }

  /**
   * titulo_tipo: findFirst
   */
  export interface titulo_tipoFindFirstArgs extends titulo_tipoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulo_tipo findMany
   */
  export type titulo_tipoFindManyArgs = {
    /**
     * Select specific fields to fetch from the titulo_tipo
     * 
    **/
    select?: titulo_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_tipoInclude | null
    /**
     * Filter, which titulo_tipos to fetch.
     * 
    **/
    where?: titulo_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing titulo_tipos.
     * 
    **/
    cursor?: titulo_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_tipos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Titulo_tipoScalarFieldEnum>
  }


  /**
   * titulo_tipo create
   */
  export type titulo_tipoCreateArgs = {
    /**
     * Select specific fields to fetch from the titulo_tipo
     * 
    **/
    select?: titulo_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_tipoInclude | null
    /**
     * The data needed to create a titulo_tipo.
     * 
    **/
    data: XOR<titulo_tipoCreateInput, titulo_tipoUncheckedCreateInput>
  }


  /**
   * titulo_tipo createMany
   */
  export type titulo_tipoCreateManyArgs = {
    /**
     * The data used to create many titulo_tipos.
     * 
    **/
    data: Enumerable<titulo_tipoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * titulo_tipo update
   */
  export type titulo_tipoUpdateArgs = {
    /**
     * Select specific fields to fetch from the titulo_tipo
     * 
    **/
    select?: titulo_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_tipoInclude | null
    /**
     * The data needed to update a titulo_tipo.
     * 
    **/
    data: XOR<titulo_tipoUpdateInput, titulo_tipoUncheckedUpdateInput>
    /**
     * Choose, which titulo_tipo to update.
     * 
    **/
    where: titulo_tipoWhereUniqueInput
  }


  /**
   * titulo_tipo updateMany
   */
  export type titulo_tipoUpdateManyArgs = {
    /**
     * The data used to update titulo_tipos.
     * 
    **/
    data: XOR<titulo_tipoUpdateManyMutationInput, titulo_tipoUncheckedUpdateManyInput>
    /**
     * Filter which titulo_tipos to update
     * 
    **/
    where?: titulo_tipoWhereInput
  }


  /**
   * titulo_tipo upsert
   */
  export type titulo_tipoUpsertArgs = {
    /**
     * Select specific fields to fetch from the titulo_tipo
     * 
    **/
    select?: titulo_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_tipoInclude | null
    /**
     * The filter to search for the titulo_tipo to update in case it exists.
     * 
    **/
    where: titulo_tipoWhereUniqueInput
    /**
     * In case the titulo_tipo found by the `where` argument doesn't exist, create a new titulo_tipo with this data.
     * 
    **/
    create: XOR<titulo_tipoCreateInput, titulo_tipoUncheckedCreateInput>
    /**
     * In case the titulo_tipo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<titulo_tipoUpdateInput, titulo_tipoUncheckedUpdateInput>
  }


  /**
   * titulo_tipo delete
   */
  export type titulo_tipoDeleteArgs = {
    /**
     * Select specific fields to fetch from the titulo_tipo
     * 
    **/
    select?: titulo_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_tipoInclude | null
    /**
     * Filter which titulo_tipo to delete.
     * 
    **/
    where: titulo_tipoWhereUniqueInput
  }


  /**
   * titulo_tipo deleteMany
   */
  export type titulo_tipoDeleteManyArgs = {
    /**
     * Filter which titulo_tipos to delete
     * 
    **/
    where?: titulo_tipoWhereInput
  }


  /**
   * titulo_tipo: findUniqueOrThrow
   */
  export type titulo_tipoFindUniqueOrThrowArgs = titulo_tipoFindUniqueArgsBase
      

  /**
   * titulo_tipo: findFirstOrThrow
   */
  export type titulo_tipoFindFirstOrThrowArgs = titulo_tipoFindFirstArgsBase
      

  /**
   * titulo_tipo without action
   */
  export type titulo_tipoArgs = {
    /**
     * Select specific fields to fetch from the titulo_tipo
     * 
    **/
    select?: titulo_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_tipoInclude | null
  }



  /**
   * Model titulo_x_cedente
   */


  export type AggregateTitulo_x_cedente = {
    _count: Titulo_x_cedenteCountAggregateOutputType | null
    _avg: Titulo_x_cedenteAvgAggregateOutputType | null
    _sum: Titulo_x_cedenteSumAggregateOutputType | null
    _min: Titulo_x_cedenteMinAggregateOutputType | null
    _max: Titulo_x_cedenteMaxAggregateOutputType | null
  }

  export type Titulo_x_cedenteAvgAggregateOutputType = {
    id: number | null
    cedente: number | null
  }

  export type Titulo_x_cedenteSumAggregateOutputType = {
    id: number | null
    cedente: number | null
  }

  export type Titulo_x_cedenteMinAggregateOutputType = {
    id: number | null
    cedente: number | null
  }

  export type Titulo_x_cedenteMaxAggregateOutputType = {
    id: number | null
    cedente: number | null
  }

  export type Titulo_x_cedenteCountAggregateOutputType = {
    id: number
    cedente: number
    _all: number
  }


  export type Titulo_x_cedenteAvgAggregateInputType = {
    id?: true
    cedente?: true
  }

  export type Titulo_x_cedenteSumAggregateInputType = {
    id?: true
    cedente?: true
  }

  export type Titulo_x_cedenteMinAggregateInputType = {
    id?: true
    cedente?: true
  }

  export type Titulo_x_cedenteMaxAggregateInputType = {
    id?: true
    cedente?: true
  }

  export type Titulo_x_cedenteCountAggregateInputType = {
    id?: true
    cedente?: true
    _all?: true
  }

  export type Titulo_x_cedenteAggregateArgs = {
    /**
     * Filter which titulo_x_cedente to aggregate.
     * 
    **/
    where?: titulo_x_cedenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_x_cedentes to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_x_cedenteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: titulo_x_cedenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_x_cedentes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_x_cedentes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned titulo_x_cedentes
    **/
    _count?: true | Titulo_x_cedenteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Titulo_x_cedenteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Titulo_x_cedenteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Titulo_x_cedenteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Titulo_x_cedenteMaxAggregateInputType
  }

  export type GetTitulo_x_cedenteAggregateType<T extends Titulo_x_cedenteAggregateArgs> = {
        [P in keyof T & keyof AggregateTitulo_x_cedente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTitulo_x_cedente[P]>
      : GetScalarType<T[P], AggregateTitulo_x_cedente[P]>
  }




  export type Titulo_x_cedenteGroupByArgs = {
    where?: titulo_x_cedenteWhereInput
    orderBy?: Enumerable<titulo_x_cedenteOrderByWithAggregationInput>
    by: Array<Titulo_x_cedenteScalarFieldEnum>
    having?: titulo_x_cedenteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Titulo_x_cedenteCountAggregateInputType | true
    _avg?: Titulo_x_cedenteAvgAggregateInputType
    _sum?: Titulo_x_cedenteSumAggregateInputType
    _min?: Titulo_x_cedenteMinAggregateInputType
    _max?: Titulo_x_cedenteMaxAggregateInputType
  }


  export type Titulo_x_cedenteGroupByOutputType = {
    id: number
    cedente: number
    _count: Titulo_x_cedenteCountAggregateOutputType | null
    _avg: Titulo_x_cedenteAvgAggregateOutputType | null
    _sum: Titulo_x_cedenteSumAggregateOutputType | null
    _min: Titulo_x_cedenteMinAggregateOutputType | null
    _max: Titulo_x_cedenteMaxAggregateOutputType | null
  }

  type GetTitulo_x_cedenteGroupByPayload<T extends Titulo_x_cedenteGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Titulo_x_cedenteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Titulo_x_cedenteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Titulo_x_cedenteGroupByOutputType[P]>
            : GetScalarType<T[P], Titulo_x_cedenteGroupByOutputType[P]>
        }
      >
    >


  export type titulo_x_cedenteSelect = {
    id?: boolean
    cedente?: boolean
    cedente_cedenteTotitulo_x_cedente?: boolean | cedenteArgs
  }


  export type titulo_x_cedenteInclude = {
    cedente_cedenteTotitulo_x_cedente?: boolean | cedenteArgs
  } 

  export type titulo_x_cedenteGetPayload<S extends boolean | null | undefined | titulo_x_cedenteArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? titulo_x_cedente :
    S extends undefined ? never :
    S extends { include: any } & (titulo_x_cedenteArgs | titulo_x_cedenteFindManyArgs)
    ? titulo_x_cedente  & {
    [P in TrueKeys<S['include']>]:
        P extends 'cedente_cedenteTotitulo_x_cedente' ? cedenteGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (titulo_x_cedenteArgs | titulo_x_cedenteFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'cedente_cedenteTotitulo_x_cedente' ? cedenteGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof titulo_x_cedente ? titulo_x_cedente[P] : never
  } 
      : titulo_x_cedente


  type titulo_x_cedenteCountArgs = Merge<
    Omit<titulo_x_cedenteFindManyArgs, 'select' | 'include'> & {
      select?: Titulo_x_cedenteCountAggregateInputType | true
    }
  >

  export interface titulo_x_cedenteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Titulo_x_cedente that matches the filter.
     * @param {titulo_x_cedenteFindUniqueArgs} args - Arguments to find a Titulo_x_cedente
     * @example
     * // Get one Titulo_x_cedente
     * const titulo_x_cedente = await prisma.titulo_x_cedente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends titulo_x_cedenteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, titulo_x_cedenteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'titulo_x_cedente'> extends True ? Prisma__titulo_x_cedenteClient<titulo_x_cedenteGetPayload<T>> : Prisma__titulo_x_cedenteClient<titulo_x_cedenteGetPayload<T> | null, null>

    /**
     * Find the first Titulo_x_cedente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_x_cedenteFindFirstArgs} args - Arguments to find a Titulo_x_cedente
     * @example
     * // Get one Titulo_x_cedente
     * const titulo_x_cedente = await prisma.titulo_x_cedente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends titulo_x_cedenteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, titulo_x_cedenteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'titulo_x_cedente'> extends True ? Prisma__titulo_x_cedenteClient<titulo_x_cedenteGetPayload<T>> : Prisma__titulo_x_cedenteClient<titulo_x_cedenteGetPayload<T> | null, null>

    /**
     * Find zero or more Titulo_x_cedentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_x_cedenteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Titulo_x_cedentes
     * const titulo_x_cedentes = await prisma.titulo_x_cedente.findMany()
     * 
     * // Get first 10 Titulo_x_cedentes
     * const titulo_x_cedentes = await prisma.titulo_x_cedente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const titulo_x_cedenteWithIdOnly = await prisma.titulo_x_cedente.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends titulo_x_cedenteFindManyArgs>(
      args?: SelectSubset<T, titulo_x_cedenteFindManyArgs>
    ): PrismaPromise<Array<titulo_x_cedenteGetPayload<T>>>

    /**
     * Create a Titulo_x_cedente.
     * @param {titulo_x_cedenteCreateArgs} args - Arguments to create a Titulo_x_cedente.
     * @example
     * // Create one Titulo_x_cedente
     * const Titulo_x_cedente = await prisma.titulo_x_cedente.create({
     *   data: {
     *     // ... data to create a Titulo_x_cedente
     *   }
     * })
     * 
    **/
    create<T extends titulo_x_cedenteCreateArgs>(
      args: SelectSubset<T, titulo_x_cedenteCreateArgs>
    ): Prisma__titulo_x_cedenteClient<titulo_x_cedenteGetPayload<T>>

    /**
     * Create many Titulo_x_cedentes.
     *     @param {titulo_x_cedenteCreateManyArgs} args - Arguments to create many Titulo_x_cedentes.
     *     @example
     *     // Create many Titulo_x_cedentes
     *     const titulo_x_cedente = await prisma.titulo_x_cedente.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends titulo_x_cedenteCreateManyArgs>(
      args?: SelectSubset<T, titulo_x_cedenteCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Titulo_x_cedente.
     * @param {titulo_x_cedenteDeleteArgs} args - Arguments to delete one Titulo_x_cedente.
     * @example
     * // Delete one Titulo_x_cedente
     * const Titulo_x_cedente = await prisma.titulo_x_cedente.delete({
     *   where: {
     *     // ... filter to delete one Titulo_x_cedente
     *   }
     * })
     * 
    **/
    delete<T extends titulo_x_cedenteDeleteArgs>(
      args: SelectSubset<T, titulo_x_cedenteDeleteArgs>
    ): Prisma__titulo_x_cedenteClient<titulo_x_cedenteGetPayload<T>>

    /**
     * Update one Titulo_x_cedente.
     * @param {titulo_x_cedenteUpdateArgs} args - Arguments to update one Titulo_x_cedente.
     * @example
     * // Update one Titulo_x_cedente
     * const titulo_x_cedente = await prisma.titulo_x_cedente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends titulo_x_cedenteUpdateArgs>(
      args: SelectSubset<T, titulo_x_cedenteUpdateArgs>
    ): Prisma__titulo_x_cedenteClient<titulo_x_cedenteGetPayload<T>>

    /**
     * Delete zero or more Titulo_x_cedentes.
     * @param {titulo_x_cedenteDeleteManyArgs} args - Arguments to filter Titulo_x_cedentes to delete.
     * @example
     * // Delete a few Titulo_x_cedentes
     * const { count } = await prisma.titulo_x_cedente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends titulo_x_cedenteDeleteManyArgs>(
      args?: SelectSubset<T, titulo_x_cedenteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Titulo_x_cedentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_x_cedenteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Titulo_x_cedentes
     * const titulo_x_cedente = await prisma.titulo_x_cedente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends titulo_x_cedenteUpdateManyArgs>(
      args: SelectSubset<T, titulo_x_cedenteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Titulo_x_cedente.
     * @param {titulo_x_cedenteUpsertArgs} args - Arguments to update or create a Titulo_x_cedente.
     * @example
     * // Update or create a Titulo_x_cedente
     * const titulo_x_cedente = await prisma.titulo_x_cedente.upsert({
     *   create: {
     *     // ... data to create a Titulo_x_cedente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Titulo_x_cedente we want to update
     *   }
     * })
    **/
    upsert<T extends titulo_x_cedenteUpsertArgs>(
      args: SelectSubset<T, titulo_x_cedenteUpsertArgs>
    ): Prisma__titulo_x_cedenteClient<titulo_x_cedenteGetPayload<T>>

    /**
     * Find one Titulo_x_cedente that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {titulo_x_cedenteFindUniqueOrThrowArgs} args - Arguments to find a Titulo_x_cedente
     * @example
     * // Get one Titulo_x_cedente
     * const titulo_x_cedente = await prisma.titulo_x_cedente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends titulo_x_cedenteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, titulo_x_cedenteFindUniqueOrThrowArgs>
    ): Prisma__titulo_x_cedenteClient<titulo_x_cedenteGetPayload<T>>

    /**
     * Find the first Titulo_x_cedente that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_x_cedenteFindFirstOrThrowArgs} args - Arguments to find a Titulo_x_cedente
     * @example
     * // Get one Titulo_x_cedente
     * const titulo_x_cedente = await prisma.titulo_x_cedente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends titulo_x_cedenteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, titulo_x_cedenteFindFirstOrThrowArgs>
    ): Prisma__titulo_x_cedenteClient<titulo_x_cedenteGetPayload<T>>

    /**
     * Count the number of Titulo_x_cedentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_x_cedenteCountArgs} args - Arguments to filter Titulo_x_cedentes to count.
     * @example
     * // Count the number of Titulo_x_cedentes
     * const count = await prisma.titulo_x_cedente.count({
     *   where: {
     *     // ... the filter for the Titulo_x_cedentes we want to count
     *   }
     * })
    **/
    count<T extends titulo_x_cedenteCountArgs>(
      args?: Subset<T, titulo_x_cedenteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Titulo_x_cedenteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Titulo_x_cedente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Titulo_x_cedenteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Titulo_x_cedenteAggregateArgs>(args: Subset<T, Titulo_x_cedenteAggregateArgs>): PrismaPromise<GetTitulo_x_cedenteAggregateType<T>>

    /**
     * Group by Titulo_x_cedente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Titulo_x_cedenteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Titulo_x_cedenteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Titulo_x_cedenteGroupByArgs['orderBy'] }
        : { orderBy?: Titulo_x_cedenteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Titulo_x_cedenteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTitulo_x_cedenteGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for titulo_x_cedente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__titulo_x_cedenteClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cedente_cedenteTotitulo_x_cedente<T extends cedenteArgs= {}>(args?: Subset<T, cedenteArgs>): Prisma__cedenteClient<cedenteGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * titulo_x_cedente base type for findUnique actions
   */
  export type titulo_x_cedenteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the titulo_x_cedente
     * 
    **/
    select?: titulo_x_cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_x_cedenteInclude | null
    /**
     * Filter, which titulo_x_cedente to fetch.
     * 
    **/
    where: titulo_x_cedenteWhereUniqueInput
  }

  /**
   * titulo_x_cedente: findUnique
   */
  export interface titulo_x_cedenteFindUniqueArgs extends titulo_x_cedenteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulo_x_cedente base type for findFirst actions
   */
  export type titulo_x_cedenteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the titulo_x_cedente
     * 
    **/
    select?: titulo_x_cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_x_cedenteInclude | null
    /**
     * Filter, which titulo_x_cedente to fetch.
     * 
    **/
    where?: titulo_x_cedenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_x_cedentes to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_x_cedenteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for titulo_x_cedentes.
     * 
    **/
    cursor?: titulo_x_cedenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_x_cedentes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_x_cedentes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of titulo_x_cedentes.
     * 
    **/
    distinct?: Enumerable<Titulo_x_cedenteScalarFieldEnum>
  }

  /**
   * titulo_x_cedente: findFirst
   */
  export interface titulo_x_cedenteFindFirstArgs extends titulo_x_cedenteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulo_x_cedente findMany
   */
  export type titulo_x_cedenteFindManyArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_cedente
     * 
    **/
    select?: titulo_x_cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_x_cedenteInclude | null
    /**
     * Filter, which titulo_x_cedentes to fetch.
     * 
    **/
    where?: titulo_x_cedenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_x_cedentes to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_x_cedenteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing titulo_x_cedentes.
     * 
    **/
    cursor?: titulo_x_cedenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_x_cedentes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_x_cedentes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Titulo_x_cedenteScalarFieldEnum>
  }


  /**
   * titulo_x_cedente create
   */
  export type titulo_x_cedenteCreateArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_cedente
     * 
    **/
    select?: titulo_x_cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_x_cedenteInclude | null
    /**
     * The data needed to create a titulo_x_cedente.
     * 
    **/
    data: XOR<titulo_x_cedenteCreateInput, titulo_x_cedenteUncheckedCreateInput>
  }


  /**
   * titulo_x_cedente createMany
   */
  export type titulo_x_cedenteCreateManyArgs = {
    /**
     * The data used to create many titulo_x_cedentes.
     * 
    **/
    data: Enumerable<titulo_x_cedenteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * titulo_x_cedente update
   */
  export type titulo_x_cedenteUpdateArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_cedente
     * 
    **/
    select?: titulo_x_cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_x_cedenteInclude | null
    /**
     * The data needed to update a titulo_x_cedente.
     * 
    **/
    data: XOR<titulo_x_cedenteUpdateInput, titulo_x_cedenteUncheckedUpdateInput>
    /**
     * Choose, which titulo_x_cedente to update.
     * 
    **/
    where: titulo_x_cedenteWhereUniqueInput
  }


  /**
   * titulo_x_cedente updateMany
   */
  export type titulo_x_cedenteUpdateManyArgs = {
    /**
     * The data used to update titulo_x_cedentes.
     * 
    **/
    data: XOR<titulo_x_cedenteUpdateManyMutationInput, titulo_x_cedenteUncheckedUpdateManyInput>
    /**
     * Filter which titulo_x_cedentes to update
     * 
    **/
    where?: titulo_x_cedenteWhereInput
  }


  /**
   * titulo_x_cedente upsert
   */
  export type titulo_x_cedenteUpsertArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_cedente
     * 
    **/
    select?: titulo_x_cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_x_cedenteInclude | null
    /**
     * The filter to search for the titulo_x_cedente to update in case it exists.
     * 
    **/
    where: titulo_x_cedenteWhereUniqueInput
    /**
     * In case the titulo_x_cedente found by the `where` argument doesn't exist, create a new titulo_x_cedente with this data.
     * 
    **/
    create: XOR<titulo_x_cedenteCreateInput, titulo_x_cedenteUncheckedCreateInput>
    /**
     * In case the titulo_x_cedente was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<titulo_x_cedenteUpdateInput, titulo_x_cedenteUncheckedUpdateInput>
  }


  /**
   * titulo_x_cedente delete
   */
  export type titulo_x_cedenteDeleteArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_cedente
     * 
    **/
    select?: titulo_x_cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_x_cedenteInclude | null
    /**
     * Filter which titulo_x_cedente to delete.
     * 
    **/
    where: titulo_x_cedenteWhereUniqueInput
  }


  /**
   * titulo_x_cedente deleteMany
   */
  export type titulo_x_cedenteDeleteManyArgs = {
    /**
     * Filter which titulo_x_cedentes to delete
     * 
    **/
    where?: titulo_x_cedenteWhereInput
  }


  /**
   * titulo_x_cedente: findUniqueOrThrow
   */
  export type titulo_x_cedenteFindUniqueOrThrowArgs = titulo_x_cedenteFindUniqueArgsBase
      

  /**
   * titulo_x_cedente: findFirstOrThrow
   */
  export type titulo_x_cedenteFindFirstOrThrowArgs = titulo_x_cedenteFindFirstArgsBase
      

  /**
   * titulo_x_cedente without action
   */
  export type titulo_x_cedenteArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_cedente
     * 
    **/
    select?: titulo_x_cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_x_cedenteInclude | null
  }



  /**
   * Model titulo_x_empresa
   */


  export type AggregateTitulo_x_empresa = {
    _count: Titulo_x_empresaCountAggregateOutputType | null
    _avg: Titulo_x_empresaAvgAggregateOutputType | null
    _sum: Titulo_x_empresaSumAggregateOutputType | null
    _min: Titulo_x_empresaMinAggregateOutputType | null
    _max: Titulo_x_empresaMaxAggregateOutputType | null
  }

  export type Titulo_x_empresaAvgAggregateOutputType = {
    id: number | null
  }

  export type Titulo_x_empresaSumAggregateOutputType = {
    id: number | null
  }

  export type Titulo_x_empresaMinAggregateOutputType = {
    id: number | null
  }

  export type Titulo_x_empresaMaxAggregateOutputType = {
    id: number | null
  }

  export type Titulo_x_empresaCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type Titulo_x_empresaAvgAggregateInputType = {
    id?: true
  }

  export type Titulo_x_empresaSumAggregateInputType = {
    id?: true
  }

  export type Titulo_x_empresaMinAggregateInputType = {
    id?: true
  }

  export type Titulo_x_empresaMaxAggregateInputType = {
    id?: true
  }

  export type Titulo_x_empresaCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type Titulo_x_empresaAggregateArgs = {
    /**
     * Filter which titulo_x_empresa to aggregate.
     * 
    **/
    where?: titulo_x_empresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_x_empresas to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_x_empresaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: titulo_x_empresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_x_empresas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_x_empresas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned titulo_x_empresas
    **/
    _count?: true | Titulo_x_empresaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Titulo_x_empresaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Titulo_x_empresaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Titulo_x_empresaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Titulo_x_empresaMaxAggregateInputType
  }

  export type GetTitulo_x_empresaAggregateType<T extends Titulo_x_empresaAggregateArgs> = {
        [P in keyof T & keyof AggregateTitulo_x_empresa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTitulo_x_empresa[P]>
      : GetScalarType<T[P], AggregateTitulo_x_empresa[P]>
  }




  export type Titulo_x_empresaGroupByArgs = {
    where?: titulo_x_empresaWhereInput
    orderBy?: Enumerable<titulo_x_empresaOrderByWithAggregationInput>
    by: Array<Titulo_x_empresaScalarFieldEnum>
    having?: titulo_x_empresaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Titulo_x_empresaCountAggregateInputType | true
    _avg?: Titulo_x_empresaAvgAggregateInputType
    _sum?: Titulo_x_empresaSumAggregateInputType
    _min?: Titulo_x_empresaMinAggregateInputType
    _max?: Titulo_x_empresaMaxAggregateInputType
  }


  export type Titulo_x_empresaGroupByOutputType = {
    id: number
    _count: Titulo_x_empresaCountAggregateOutputType | null
    _avg: Titulo_x_empresaAvgAggregateOutputType | null
    _sum: Titulo_x_empresaSumAggregateOutputType | null
    _min: Titulo_x_empresaMinAggregateOutputType | null
    _max: Titulo_x_empresaMaxAggregateOutputType | null
  }

  type GetTitulo_x_empresaGroupByPayload<T extends Titulo_x_empresaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Titulo_x_empresaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Titulo_x_empresaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Titulo_x_empresaGroupByOutputType[P]>
            : GetScalarType<T[P], Titulo_x_empresaGroupByOutputType[P]>
        }
      >
    >


  export type titulo_x_empresaSelect = {
    id?: boolean
  }


  export type titulo_x_empresaGetPayload<S extends boolean | null | undefined | titulo_x_empresaArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? titulo_x_empresa :
    S extends undefined ? never :
    S extends { include: any } & (titulo_x_empresaArgs | titulo_x_empresaFindManyArgs)
    ? titulo_x_empresa 
    : S extends { select: any } & (titulo_x_empresaArgs | titulo_x_empresaFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof titulo_x_empresa ? titulo_x_empresa[P] : never
  } 
      : titulo_x_empresa


  type titulo_x_empresaCountArgs = Merge<
    Omit<titulo_x_empresaFindManyArgs, 'select' | 'include'> & {
      select?: Titulo_x_empresaCountAggregateInputType | true
    }
  >

  export interface titulo_x_empresaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Titulo_x_empresa that matches the filter.
     * @param {titulo_x_empresaFindUniqueArgs} args - Arguments to find a Titulo_x_empresa
     * @example
     * // Get one Titulo_x_empresa
     * const titulo_x_empresa = await prisma.titulo_x_empresa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends titulo_x_empresaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, titulo_x_empresaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'titulo_x_empresa'> extends True ? Prisma__titulo_x_empresaClient<titulo_x_empresaGetPayload<T>> : Prisma__titulo_x_empresaClient<titulo_x_empresaGetPayload<T> | null, null>

    /**
     * Find the first Titulo_x_empresa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_x_empresaFindFirstArgs} args - Arguments to find a Titulo_x_empresa
     * @example
     * // Get one Titulo_x_empresa
     * const titulo_x_empresa = await prisma.titulo_x_empresa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends titulo_x_empresaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, titulo_x_empresaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'titulo_x_empresa'> extends True ? Prisma__titulo_x_empresaClient<titulo_x_empresaGetPayload<T>> : Prisma__titulo_x_empresaClient<titulo_x_empresaGetPayload<T> | null, null>

    /**
     * Find zero or more Titulo_x_empresas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_x_empresaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Titulo_x_empresas
     * const titulo_x_empresas = await prisma.titulo_x_empresa.findMany()
     * 
     * // Get first 10 Titulo_x_empresas
     * const titulo_x_empresas = await prisma.titulo_x_empresa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const titulo_x_empresaWithIdOnly = await prisma.titulo_x_empresa.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends titulo_x_empresaFindManyArgs>(
      args?: SelectSubset<T, titulo_x_empresaFindManyArgs>
    ): PrismaPromise<Array<titulo_x_empresaGetPayload<T>>>

    /**
     * Create a Titulo_x_empresa.
     * @param {titulo_x_empresaCreateArgs} args - Arguments to create a Titulo_x_empresa.
     * @example
     * // Create one Titulo_x_empresa
     * const Titulo_x_empresa = await prisma.titulo_x_empresa.create({
     *   data: {
     *     // ... data to create a Titulo_x_empresa
     *   }
     * })
     * 
    **/
    create<T extends titulo_x_empresaCreateArgs>(
      args: SelectSubset<T, titulo_x_empresaCreateArgs>
    ): Prisma__titulo_x_empresaClient<titulo_x_empresaGetPayload<T>>

    /**
     * Create many Titulo_x_empresas.
     *     @param {titulo_x_empresaCreateManyArgs} args - Arguments to create many Titulo_x_empresas.
     *     @example
     *     // Create many Titulo_x_empresas
     *     const titulo_x_empresa = await prisma.titulo_x_empresa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends titulo_x_empresaCreateManyArgs>(
      args?: SelectSubset<T, titulo_x_empresaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Titulo_x_empresa.
     * @param {titulo_x_empresaDeleteArgs} args - Arguments to delete one Titulo_x_empresa.
     * @example
     * // Delete one Titulo_x_empresa
     * const Titulo_x_empresa = await prisma.titulo_x_empresa.delete({
     *   where: {
     *     // ... filter to delete one Titulo_x_empresa
     *   }
     * })
     * 
    **/
    delete<T extends titulo_x_empresaDeleteArgs>(
      args: SelectSubset<T, titulo_x_empresaDeleteArgs>
    ): Prisma__titulo_x_empresaClient<titulo_x_empresaGetPayload<T>>

    /**
     * Update one Titulo_x_empresa.
     * @param {titulo_x_empresaUpdateArgs} args - Arguments to update one Titulo_x_empresa.
     * @example
     * // Update one Titulo_x_empresa
     * const titulo_x_empresa = await prisma.titulo_x_empresa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends titulo_x_empresaUpdateArgs>(
      args: SelectSubset<T, titulo_x_empresaUpdateArgs>
    ): Prisma__titulo_x_empresaClient<titulo_x_empresaGetPayload<T>>

    /**
     * Delete zero or more Titulo_x_empresas.
     * @param {titulo_x_empresaDeleteManyArgs} args - Arguments to filter Titulo_x_empresas to delete.
     * @example
     * // Delete a few Titulo_x_empresas
     * const { count } = await prisma.titulo_x_empresa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends titulo_x_empresaDeleteManyArgs>(
      args?: SelectSubset<T, titulo_x_empresaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Titulo_x_empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_x_empresaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Titulo_x_empresas
     * const titulo_x_empresa = await prisma.titulo_x_empresa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends titulo_x_empresaUpdateManyArgs>(
      args: SelectSubset<T, titulo_x_empresaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Titulo_x_empresa.
     * @param {titulo_x_empresaUpsertArgs} args - Arguments to update or create a Titulo_x_empresa.
     * @example
     * // Update or create a Titulo_x_empresa
     * const titulo_x_empresa = await prisma.titulo_x_empresa.upsert({
     *   create: {
     *     // ... data to create a Titulo_x_empresa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Titulo_x_empresa we want to update
     *   }
     * })
    **/
    upsert<T extends titulo_x_empresaUpsertArgs>(
      args: SelectSubset<T, titulo_x_empresaUpsertArgs>
    ): Prisma__titulo_x_empresaClient<titulo_x_empresaGetPayload<T>>

    /**
     * Find one Titulo_x_empresa that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {titulo_x_empresaFindUniqueOrThrowArgs} args - Arguments to find a Titulo_x_empresa
     * @example
     * // Get one Titulo_x_empresa
     * const titulo_x_empresa = await prisma.titulo_x_empresa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends titulo_x_empresaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, titulo_x_empresaFindUniqueOrThrowArgs>
    ): Prisma__titulo_x_empresaClient<titulo_x_empresaGetPayload<T>>

    /**
     * Find the first Titulo_x_empresa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_x_empresaFindFirstOrThrowArgs} args - Arguments to find a Titulo_x_empresa
     * @example
     * // Get one Titulo_x_empresa
     * const titulo_x_empresa = await prisma.titulo_x_empresa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends titulo_x_empresaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, titulo_x_empresaFindFirstOrThrowArgs>
    ): Prisma__titulo_x_empresaClient<titulo_x_empresaGetPayload<T>>

    /**
     * Count the number of Titulo_x_empresas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_x_empresaCountArgs} args - Arguments to filter Titulo_x_empresas to count.
     * @example
     * // Count the number of Titulo_x_empresas
     * const count = await prisma.titulo_x_empresa.count({
     *   where: {
     *     // ... the filter for the Titulo_x_empresas we want to count
     *   }
     * })
    **/
    count<T extends titulo_x_empresaCountArgs>(
      args?: Subset<T, titulo_x_empresaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Titulo_x_empresaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Titulo_x_empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Titulo_x_empresaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Titulo_x_empresaAggregateArgs>(args: Subset<T, Titulo_x_empresaAggregateArgs>): PrismaPromise<GetTitulo_x_empresaAggregateType<T>>

    /**
     * Group by Titulo_x_empresa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Titulo_x_empresaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Titulo_x_empresaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Titulo_x_empresaGroupByArgs['orderBy'] }
        : { orderBy?: Titulo_x_empresaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Titulo_x_empresaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTitulo_x_empresaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for titulo_x_empresa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__titulo_x_empresaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * titulo_x_empresa base type for findUnique actions
   */
  export type titulo_x_empresaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the titulo_x_empresa
     * 
    **/
    select?: titulo_x_empresaSelect | null
    /**
     * Filter, which titulo_x_empresa to fetch.
     * 
    **/
    where: titulo_x_empresaWhereUniqueInput
  }

  /**
   * titulo_x_empresa: findUnique
   */
  export interface titulo_x_empresaFindUniqueArgs extends titulo_x_empresaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulo_x_empresa base type for findFirst actions
   */
  export type titulo_x_empresaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the titulo_x_empresa
     * 
    **/
    select?: titulo_x_empresaSelect | null
    /**
     * Filter, which titulo_x_empresa to fetch.
     * 
    **/
    where?: titulo_x_empresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_x_empresas to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_x_empresaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for titulo_x_empresas.
     * 
    **/
    cursor?: titulo_x_empresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_x_empresas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_x_empresas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of titulo_x_empresas.
     * 
    **/
    distinct?: Enumerable<Titulo_x_empresaScalarFieldEnum>
  }

  /**
   * titulo_x_empresa: findFirst
   */
  export interface titulo_x_empresaFindFirstArgs extends titulo_x_empresaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulo_x_empresa findMany
   */
  export type titulo_x_empresaFindManyArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_empresa
     * 
    **/
    select?: titulo_x_empresaSelect | null
    /**
     * Filter, which titulo_x_empresas to fetch.
     * 
    **/
    where?: titulo_x_empresaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_x_empresas to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_x_empresaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing titulo_x_empresas.
     * 
    **/
    cursor?: titulo_x_empresaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_x_empresas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_x_empresas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Titulo_x_empresaScalarFieldEnum>
  }


  /**
   * titulo_x_empresa create
   */
  export type titulo_x_empresaCreateArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_empresa
     * 
    **/
    select?: titulo_x_empresaSelect | null
    /**
     * The data needed to create a titulo_x_empresa.
     * 
    **/
    data?: XOR<titulo_x_empresaCreateInput, titulo_x_empresaUncheckedCreateInput>
  }


  /**
   * titulo_x_empresa createMany
   */
  export type titulo_x_empresaCreateManyArgs = {
    /**
     * The data used to create many titulo_x_empresas.
     * 
    **/
    data: Enumerable<titulo_x_empresaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * titulo_x_empresa update
   */
  export type titulo_x_empresaUpdateArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_empresa
     * 
    **/
    select?: titulo_x_empresaSelect | null
    /**
     * The data needed to update a titulo_x_empresa.
     * 
    **/
    data: XOR<titulo_x_empresaUpdateInput, titulo_x_empresaUncheckedUpdateInput>
    /**
     * Choose, which titulo_x_empresa to update.
     * 
    **/
    where: titulo_x_empresaWhereUniqueInput
  }


  /**
   * titulo_x_empresa updateMany
   */
  export type titulo_x_empresaUpdateManyArgs = {
    /**
     * The data used to update titulo_x_empresas.
     * 
    **/
    data: XOR<titulo_x_empresaUpdateManyMutationInput, titulo_x_empresaUncheckedUpdateManyInput>
    /**
     * Filter which titulo_x_empresas to update
     * 
    **/
    where?: titulo_x_empresaWhereInput
  }


  /**
   * titulo_x_empresa upsert
   */
  export type titulo_x_empresaUpsertArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_empresa
     * 
    **/
    select?: titulo_x_empresaSelect | null
    /**
     * The filter to search for the titulo_x_empresa to update in case it exists.
     * 
    **/
    where: titulo_x_empresaWhereUniqueInput
    /**
     * In case the titulo_x_empresa found by the `where` argument doesn't exist, create a new titulo_x_empresa with this data.
     * 
    **/
    create: XOR<titulo_x_empresaCreateInput, titulo_x_empresaUncheckedCreateInput>
    /**
     * In case the titulo_x_empresa was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<titulo_x_empresaUpdateInput, titulo_x_empresaUncheckedUpdateInput>
  }


  /**
   * titulo_x_empresa delete
   */
  export type titulo_x_empresaDeleteArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_empresa
     * 
    **/
    select?: titulo_x_empresaSelect | null
    /**
     * Filter which titulo_x_empresa to delete.
     * 
    **/
    where: titulo_x_empresaWhereUniqueInput
  }


  /**
   * titulo_x_empresa deleteMany
   */
  export type titulo_x_empresaDeleteManyArgs = {
    /**
     * Filter which titulo_x_empresas to delete
     * 
    **/
    where?: titulo_x_empresaWhereInput
  }


  /**
   * titulo_x_empresa: findUniqueOrThrow
   */
  export type titulo_x_empresaFindUniqueOrThrowArgs = titulo_x_empresaFindUniqueArgsBase
      

  /**
   * titulo_x_empresa: findFirstOrThrow
   */
  export type titulo_x_empresaFindFirstOrThrowArgs = titulo_x_empresaFindFirstArgsBase
      

  /**
   * titulo_x_empresa without action
   */
  export type titulo_x_empresaArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_empresa
     * 
    **/
    select?: titulo_x_empresaSelect | null
  }



  /**
   * Model titulo_x_plataforma
   */


  export type AggregateTitulo_x_plataforma = {
    _count: Titulo_x_plataformaCountAggregateOutputType | null
    _avg: Titulo_x_plataformaAvgAggregateOutputType | null
    _sum: Titulo_x_plataformaSumAggregateOutputType | null
    _min: Titulo_x_plataformaMinAggregateOutputType | null
    _max: Titulo_x_plataformaMaxAggregateOutputType | null
  }

  export type Titulo_x_plataformaAvgAggregateOutputType = {
    id: number | null
  }

  export type Titulo_x_plataformaSumAggregateOutputType = {
    id: number | null
  }

  export type Titulo_x_plataformaMinAggregateOutputType = {
    id: number | null
  }

  export type Titulo_x_plataformaMaxAggregateOutputType = {
    id: number | null
  }

  export type Titulo_x_plataformaCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type Titulo_x_plataformaAvgAggregateInputType = {
    id?: true
  }

  export type Titulo_x_plataformaSumAggregateInputType = {
    id?: true
  }

  export type Titulo_x_plataformaMinAggregateInputType = {
    id?: true
  }

  export type Titulo_x_plataformaMaxAggregateInputType = {
    id?: true
  }

  export type Titulo_x_plataformaCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type Titulo_x_plataformaAggregateArgs = {
    /**
     * Filter which titulo_x_plataforma to aggregate.
     * 
    **/
    where?: titulo_x_plataformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_x_plataformas to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_x_plataformaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: titulo_x_plataformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_x_plataformas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_x_plataformas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned titulo_x_plataformas
    **/
    _count?: true | Titulo_x_plataformaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Titulo_x_plataformaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Titulo_x_plataformaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Titulo_x_plataformaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Titulo_x_plataformaMaxAggregateInputType
  }

  export type GetTitulo_x_plataformaAggregateType<T extends Titulo_x_plataformaAggregateArgs> = {
        [P in keyof T & keyof AggregateTitulo_x_plataforma]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTitulo_x_plataforma[P]>
      : GetScalarType<T[P], AggregateTitulo_x_plataforma[P]>
  }




  export type Titulo_x_plataformaGroupByArgs = {
    where?: titulo_x_plataformaWhereInput
    orderBy?: Enumerable<titulo_x_plataformaOrderByWithAggregationInput>
    by: Array<Titulo_x_plataformaScalarFieldEnum>
    having?: titulo_x_plataformaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Titulo_x_plataformaCountAggregateInputType | true
    _avg?: Titulo_x_plataformaAvgAggregateInputType
    _sum?: Titulo_x_plataformaSumAggregateInputType
    _min?: Titulo_x_plataformaMinAggregateInputType
    _max?: Titulo_x_plataformaMaxAggregateInputType
  }


  export type Titulo_x_plataformaGroupByOutputType = {
    id: number
    _count: Titulo_x_plataformaCountAggregateOutputType | null
    _avg: Titulo_x_plataformaAvgAggregateOutputType | null
    _sum: Titulo_x_plataformaSumAggregateOutputType | null
    _min: Titulo_x_plataformaMinAggregateOutputType | null
    _max: Titulo_x_plataformaMaxAggregateOutputType | null
  }

  type GetTitulo_x_plataformaGroupByPayload<T extends Titulo_x_plataformaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Titulo_x_plataformaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Titulo_x_plataformaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Titulo_x_plataformaGroupByOutputType[P]>
            : GetScalarType<T[P], Titulo_x_plataformaGroupByOutputType[P]>
        }
      >
    >


  export type titulo_x_plataformaSelect = {
    id?: boolean
  }


  export type titulo_x_plataformaGetPayload<S extends boolean | null | undefined | titulo_x_plataformaArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? titulo_x_plataforma :
    S extends undefined ? never :
    S extends { include: any } & (titulo_x_plataformaArgs | titulo_x_plataformaFindManyArgs)
    ? titulo_x_plataforma 
    : S extends { select: any } & (titulo_x_plataformaArgs | titulo_x_plataformaFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof titulo_x_plataforma ? titulo_x_plataforma[P] : never
  } 
      : titulo_x_plataforma


  type titulo_x_plataformaCountArgs = Merge<
    Omit<titulo_x_plataformaFindManyArgs, 'select' | 'include'> & {
      select?: Titulo_x_plataformaCountAggregateInputType | true
    }
  >

  export interface titulo_x_plataformaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Titulo_x_plataforma that matches the filter.
     * @param {titulo_x_plataformaFindUniqueArgs} args - Arguments to find a Titulo_x_plataforma
     * @example
     * // Get one Titulo_x_plataforma
     * const titulo_x_plataforma = await prisma.titulo_x_plataforma.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends titulo_x_plataformaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, titulo_x_plataformaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'titulo_x_plataforma'> extends True ? Prisma__titulo_x_plataformaClient<titulo_x_plataformaGetPayload<T>> : Prisma__titulo_x_plataformaClient<titulo_x_plataformaGetPayload<T> | null, null>

    /**
     * Find the first Titulo_x_plataforma that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_x_plataformaFindFirstArgs} args - Arguments to find a Titulo_x_plataforma
     * @example
     * // Get one Titulo_x_plataforma
     * const titulo_x_plataforma = await prisma.titulo_x_plataforma.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends titulo_x_plataformaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, titulo_x_plataformaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'titulo_x_plataforma'> extends True ? Prisma__titulo_x_plataformaClient<titulo_x_plataformaGetPayload<T>> : Prisma__titulo_x_plataformaClient<titulo_x_plataformaGetPayload<T> | null, null>

    /**
     * Find zero or more Titulo_x_plataformas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_x_plataformaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Titulo_x_plataformas
     * const titulo_x_plataformas = await prisma.titulo_x_plataforma.findMany()
     * 
     * // Get first 10 Titulo_x_plataformas
     * const titulo_x_plataformas = await prisma.titulo_x_plataforma.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const titulo_x_plataformaWithIdOnly = await prisma.titulo_x_plataforma.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends titulo_x_plataformaFindManyArgs>(
      args?: SelectSubset<T, titulo_x_plataformaFindManyArgs>
    ): PrismaPromise<Array<titulo_x_plataformaGetPayload<T>>>

    /**
     * Create a Titulo_x_plataforma.
     * @param {titulo_x_plataformaCreateArgs} args - Arguments to create a Titulo_x_plataforma.
     * @example
     * // Create one Titulo_x_plataforma
     * const Titulo_x_plataforma = await prisma.titulo_x_plataforma.create({
     *   data: {
     *     // ... data to create a Titulo_x_plataforma
     *   }
     * })
     * 
    **/
    create<T extends titulo_x_plataformaCreateArgs>(
      args: SelectSubset<T, titulo_x_plataformaCreateArgs>
    ): Prisma__titulo_x_plataformaClient<titulo_x_plataformaGetPayload<T>>

    /**
     * Create many Titulo_x_plataformas.
     *     @param {titulo_x_plataformaCreateManyArgs} args - Arguments to create many Titulo_x_plataformas.
     *     @example
     *     // Create many Titulo_x_plataformas
     *     const titulo_x_plataforma = await prisma.titulo_x_plataforma.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends titulo_x_plataformaCreateManyArgs>(
      args?: SelectSubset<T, titulo_x_plataformaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Titulo_x_plataforma.
     * @param {titulo_x_plataformaDeleteArgs} args - Arguments to delete one Titulo_x_plataforma.
     * @example
     * // Delete one Titulo_x_plataforma
     * const Titulo_x_plataforma = await prisma.titulo_x_plataforma.delete({
     *   where: {
     *     // ... filter to delete one Titulo_x_plataforma
     *   }
     * })
     * 
    **/
    delete<T extends titulo_x_plataformaDeleteArgs>(
      args: SelectSubset<T, titulo_x_plataformaDeleteArgs>
    ): Prisma__titulo_x_plataformaClient<titulo_x_plataformaGetPayload<T>>

    /**
     * Update one Titulo_x_plataforma.
     * @param {titulo_x_plataformaUpdateArgs} args - Arguments to update one Titulo_x_plataforma.
     * @example
     * // Update one Titulo_x_plataforma
     * const titulo_x_plataforma = await prisma.titulo_x_plataforma.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends titulo_x_plataformaUpdateArgs>(
      args: SelectSubset<T, titulo_x_plataformaUpdateArgs>
    ): Prisma__titulo_x_plataformaClient<titulo_x_plataformaGetPayload<T>>

    /**
     * Delete zero or more Titulo_x_plataformas.
     * @param {titulo_x_plataformaDeleteManyArgs} args - Arguments to filter Titulo_x_plataformas to delete.
     * @example
     * // Delete a few Titulo_x_plataformas
     * const { count } = await prisma.titulo_x_plataforma.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends titulo_x_plataformaDeleteManyArgs>(
      args?: SelectSubset<T, titulo_x_plataformaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Titulo_x_plataformas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_x_plataformaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Titulo_x_plataformas
     * const titulo_x_plataforma = await prisma.titulo_x_plataforma.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends titulo_x_plataformaUpdateManyArgs>(
      args: SelectSubset<T, titulo_x_plataformaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Titulo_x_plataforma.
     * @param {titulo_x_plataformaUpsertArgs} args - Arguments to update or create a Titulo_x_plataforma.
     * @example
     * // Update or create a Titulo_x_plataforma
     * const titulo_x_plataforma = await prisma.titulo_x_plataforma.upsert({
     *   create: {
     *     // ... data to create a Titulo_x_plataforma
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Titulo_x_plataforma we want to update
     *   }
     * })
    **/
    upsert<T extends titulo_x_plataformaUpsertArgs>(
      args: SelectSubset<T, titulo_x_plataformaUpsertArgs>
    ): Prisma__titulo_x_plataformaClient<titulo_x_plataformaGetPayload<T>>

    /**
     * Find one Titulo_x_plataforma that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {titulo_x_plataformaFindUniqueOrThrowArgs} args - Arguments to find a Titulo_x_plataforma
     * @example
     * // Get one Titulo_x_plataforma
     * const titulo_x_plataforma = await prisma.titulo_x_plataforma.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends titulo_x_plataformaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, titulo_x_plataformaFindUniqueOrThrowArgs>
    ): Prisma__titulo_x_plataformaClient<titulo_x_plataformaGetPayload<T>>

    /**
     * Find the first Titulo_x_plataforma that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_x_plataformaFindFirstOrThrowArgs} args - Arguments to find a Titulo_x_plataforma
     * @example
     * // Get one Titulo_x_plataforma
     * const titulo_x_plataforma = await prisma.titulo_x_plataforma.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends titulo_x_plataformaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, titulo_x_plataformaFindFirstOrThrowArgs>
    ): Prisma__titulo_x_plataformaClient<titulo_x_plataformaGetPayload<T>>

    /**
     * Count the number of Titulo_x_plataformas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_x_plataformaCountArgs} args - Arguments to filter Titulo_x_plataformas to count.
     * @example
     * // Count the number of Titulo_x_plataformas
     * const count = await prisma.titulo_x_plataforma.count({
     *   where: {
     *     // ... the filter for the Titulo_x_plataformas we want to count
     *   }
     * })
    **/
    count<T extends titulo_x_plataformaCountArgs>(
      args?: Subset<T, titulo_x_plataformaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Titulo_x_plataformaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Titulo_x_plataforma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Titulo_x_plataformaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Titulo_x_plataformaAggregateArgs>(args: Subset<T, Titulo_x_plataformaAggregateArgs>): PrismaPromise<GetTitulo_x_plataformaAggregateType<T>>

    /**
     * Group by Titulo_x_plataforma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Titulo_x_plataformaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Titulo_x_plataformaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Titulo_x_plataformaGroupByArgs['orderBy'] }
        : { orderBy?: Titulo_x_plataformaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Titulo_x_plataformaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTitulo_x_plataformaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for titulo_x_plataforma.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__titulo_x_plataformaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * titulo_x_plataforma base type for findUnique actions
   */
  export type titulo_x_plataformaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the titulo_x_plataforma
     * 
    **/
    select?: titulo_x_plataformaSelect | null
    /**
     * Filter, which titulo_x_plataforma to fetch.
     * 
    **/
    where: titulo_x_plataformaWhereUniqueInput
  }

  /**
   * titulo_x_plataforma: findUnique
   */
  export interface titulo_x_plataformaFindUniqueArgs extends titulo_x_plataformaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulo_x_plataforma base type for findFirst actions
   */
  export type titulo_x_plataformaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the titulo_x_plataforma
     * 
    **/
    select?: titulo_x_plataformaSelect | null
    /**
     * Filter, which titulo_x_plataforma to fetch.
     * 
    **/
    where?: titulo_x_plataformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_x_plataformas to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_x_plataformaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for titulo_x_plataformas.
     * 
    **/
    cursor?: titulo_x_plataformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_x_plataformas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_x_plataformas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of titulo_x_plataformas.
     * 
    **/
    distinct?: Enumerable<Titulo_x_plataformaScalarFieldEnum>
  }

  /**
   * titulo_x_plataforma: findFirst
   */
  export interface titulo_x_plataformaFindFirstArgs extends titulo_x_plataformaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulo_x_plataforma findMany
   */
  export type titulo_x_plataformaFindManyArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_plataforma
     * 
    **/
    select?: titulo_x_plataformaSelect | null
    /**
     * Filter, which titulo_x_plataformas to fetch.
     * 
    **/
    where?: titulo_x_plataformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_x_plataformas to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_x_plataformaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing titulo_x_plataformas.
     * 
    **/
    cursor?: titulo_x_plataformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_x_plataformas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_x_plataformas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Titulo_x_plataformaScalarFieldEnum>
  }


  /**
   * titulo_x_plataforma create
   */
  export type titulo_x_plataformaCreateArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_plataforma
     * 
    **/
    select?: titulo_x_plataformaSelect | null
    /**
     * The data needed to create a titulo_x_plataforma.
     * 
    **/
    data?: XOR<titulo_x_plataformaCreateInput, titulo_x_plataformaUncheckedCreateInput>
  }


  /**
   * titulo_x_plataforma createMany
   */
  export type titulo_x_plataformaCreateManyArgs = {
    /**
     * The data used to create many titulo_x_plataformas.
     * 
    **/
    data: Enumerable<titulo_x_plataformaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * titulo_x_plataforma update
   */
  export type titulo_x_plataformaUpdateArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_plataforma
     * 
    **/
    select?: titulo_x_plataformaSelect | null
    /**
     * The data needed to update a titulo_x_plataforma.
     * 
    **/
    data: XOR<titulo_x_plataformaUpdateInput, titulo_x_plataformaUncheckedUpdateInput>
    /**
     * Choose, which titulo_x_plataforma to update.
     * 
    **/
    where: titulo_x_plataformaWhereUniqueInput
  }


  /**
   * titulo_x_plataforma updateMany
   */
  export type titulo_x_plataformaUpdateManyArgs = {
    /**
     * The data used to update titulo_x_plataformas.
     * 
    **/
    data: XOR<titulo_x_plataformaUpdateManyMutationInput, titulo_x_plataformaUncheckedUpdateManyInput>
    /**
     * Filter which titulo_x_plataformas to update
     * 
    **/
    where?: titulo_x_plataformaWhereInput
  }


  /**
   * titulo_x_plataforma upsert
   */
  export type titulo_x_plataformaUpsertArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_plataforma
     * 
    **/
    select?: titulo_x_plataformaSelect | null
    /**
     * The filter to search for the titulo_x_plataforma to update in case it exists.
     * 
    **/
    where: titulo_x_plataformaWhereUniqueInput
    /**
     * In case the titulo_x_plataforma found by the `where` argument doesn't exist, create a new titulo_x_plataforma with this data.
     * 
    **/
    create: XOR<titulo_x_plataformaCreateInput, titulo_x_plataformaUncheckedCreateInput>
    /**
     * In case the titulo_x_plataforma was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<titulo_x_plataformaUpdateInput, titulo_x_plataformaUncheckedUpdateInput>
  }


  /**
   * titulo_x_plataforma delete
   */
  export type titulo_x_plataformaDeleteArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_plataforma
     * 
    **/
    select?: titulo_x_plataformaSelect | null
    /**
     * Filter which titulo_x_plataforma to delete.
     * 
    **/
    where: titulo_x_plataformaWhereUniqueInput
  }


  /**
   * titulo_x_plataforma deleteMany
   */
  export type titulo_x_plataformaDeleteManyArgs = {
    /**
     * Filter which titulo_x_plataformas to delete
     * 
    **/
    where?: titulo_x_plataformaWhereInput
  }


  /**
   * titulo_x_plataforma: findUniqueOrThrow
   */
  export type titulo_x_plataformaFindUniqueOrThrowArgs = titulo_x_plataformaFindUniqueArgsBase
      

  /**
   * titulo_x_plataforma: findFirstOrThrow
   */
  export type titulo_x_plataformaFindFirstOrThrowArgs = titulo_x_plataformaFindFirstArgsBase
      

  /**
   * titulo_x_plataforma without action
   */
  export type titulo_x_plataformaArgs = {
    /**
     * Select specific fields to fetch from the titulo_x_plataforma
     * 
    **/
    select?: titulo_x_plataformaSelect | null
  }



  /**
   * Model titulos_x_usuario
   */


  export type AggregateTitulos_x_usuario = {
    _count: Titulos_x_usuarioCountAggregateOutputType | null
    _avg: Titulos_x_usuarioAvgAggregateOutputType | null
    _sum: Titulos_x_usuarioSumAggregateOutputType | null
    _min: Titulos_x_usuarioMinAggregateOutputType | null
    _max: Titulos_x_usuarioMaxAggregateOutputType | null
  }

  export type Titulos_x_usuarioAvgAggregateOutputType = {
    id: number | null
    usuario: number | null
    bordero: number | null
  }

  export type Titulos_x_usuarioSumAggregateOutputType = {
    id: number | null
    usuario: number | null
    bordero: number | null
  }

  export type Titulos_x_usuarioMinAggregateOutputType = {
    id: number | null
    usuario: number | null
    bordero: number | null
    status: string | null
  }

  export type Titulos_x_usuarioMaxAggregateOutputType = {
    id: number | null
    usuario: number | null
    bordero: number | null
    status: string | null
  }

  export type Titulos_x_usuarioCountAggregateOutputType = {
    id: number
    usuario: number
    bordero: number
    status: number
    _all: number
  }


  export type Titulos_x_usuarioAvgAggregateInputType = {
    id?: true
    usuario?: true
    bordero?: true
  }

  export type Titulos_x_usuarioSumAggregateInputType = {
    id?: true
    usuario?: true
    bordero?: true
  }

  export type Titulos_x_usuarioMinAggregateInputType = {
    id?: true
    usuario?: true
    bordero?: true
    status?: true
  }

  export type Titulos_x_usuarioMaxAggregateInputType = {
    id?: true
    usuario?: true
    bordero?: true
    status?: true
  }

  export type Titulos_x_usuarioCountAggregateInputType = {
    id?: true
    usuario?: true
    bordero?: true
    status?: true
    _all?: true
  }

  export type Titulos_x_usuarioAggregateArgs = {
    /**
     * Filter which titulos_x_usuario to aggregate.
     * 
    **/
    where?: titulos_x_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulos_x_usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<titulos_x_usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: titulos_x_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulos_x_usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulos_x_usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned titulos_x_usuarios
    **/
    _count?: true | Titulos_x_usuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Titulos_x_usuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Titulos_x_usuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Titulos_x_usuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Titulos_x_usuarioMaxAggregateInputType
  }

  export type GetTitulos_x_usuarioAggregateType<T extends Titulos_x_usuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateTitulos_x_usuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTitulos_x_usuario[P]>
      : GetScalarType<T[P], AggregateTitulos_x_usuario[P]>
  }




  export type Titulos_x_usuarioGroupByArgs = {
    where?: titulos_x_usuarioWhereInput
    orderBy?: Enumerable<titulos_x_usuarioOrderByWithAggregationInput>
    by: Array<Titulos_x_usuarioScalarFieldEnum>
    having?: titulos_x_usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Titulos_x_usuarioCountAggregateInputType | true
    _avg?: Titulos_x_usuarioAvgAggregateInputType
    _sum?: Titulos_x_usuarioSumAggregateInputType
    _min?: Titulos_x_usuarioMinAggregateInputType
    _max?: Titulos_x_usuarioMaxAggregateInputType
  }


  export type Titulos_x_usuarioGroupByOutputType = {
    id: number
    usuario: number | null
    bordero: number | null
    status: string | null
    _count: Titulos_x_usuarioCountAggregateOutputType | null
    _avg: Titulos_x_usuarioAvgAggregateOutputType | null
    _sum: Titulos_x_usuarioSumAggregateOutputType | null
    _min: Titulos_x_usuarioMinAggregateOutputType | null
    _max: Titulos_x_usuarioMaxAggregateOutputType | null
  }

  type GetTitulos_x_usuarioGroupByPayload<T extends Titulos_x_usuarioGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Titulos_x_usuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Titulos_x_usuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Titulos_x_usuarioGroupByOutputType[P]>
            : GetScalarType<T[P], Titulos_x_usuarioGroupByOutputType[P]>
        }
      >
    >


  export type titulos_x_usuarioSelect = {
    id?: boolean
    usuario?: boolean
    bordero?: boolean
    status?: boolean
    bordero_borderoTotitulos_x_usuario?: boolean | borderoArgs
    usuario_titulos_x_usuarioTousuario?: boolean | usuarioArgs
  }


  export type titulos_x_usuarioInclude = {
    bordero_borderoTotitulos_x_usuario?: boolean | borderoArgs
    usuario_titulos_x_usuarioTousuario?: boolean | usuarioArgs
  } 

  export type titulos_x_usuarioGetPayload<S extends boolean | null | undefined | titulos_x_usuarioArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? titulos_x_usuario :
    S extends undefined ? never :
    S extends { include: any } & (titulos_x_usuarioArgs | titulos_x_usuarioFindManyArgs)
    ? titulos_x_usuario  & {
    [P in TrueKeys<S['include']>]:
        P extends 'bordero_borderoTotitulos_x_usuario' ? borderoGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'usuario_titulos_x_usuarioTousuario' ? usuarioGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : S extends { select: any } & (titulos_x_usuarioArgs | titulos_x_usuarioFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'bordero_borderoTotitulos_x_usuario' ? borderoGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'usuario_titulos_x_usuarioTousuario' ? usuarioGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof titulos_x_usuario ? titulos_x_usuario[P] : never
  } 
      : titulos_x_usuario


  type titulos_x_usuarioCountArgs = Merge<
    Omit<titulos_x_usuarioFindManyArgs, 'select' | 'include'> & {
      select?: Titulos_x_usuarioCountAggregateInputType | true
    }
  >

  export interface titulos_x_usuarioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Titulos_x_usuario that matches the filter.
     * @param {titulos_x_usuarioFindUniqueArgs} args - Arguments to find a Titulos_x_usuario
     * @example
     * // Get one Titulos_x_usuario
     * const titulos_x_usuario = await prisma.titulos_x_usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends titulos_x_usuarioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, titulos_x_usuarioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'titulos_x_usuario'> extends True ? Prisma__titulos_x_usuarioClient<titulos_x_usuarioGetPayload<T>> : Prisma__titulos_x_usuarioClient<titulos_x_usuarioGetPayload<T> | null, null>

    /**
     * Find the first Titulos_x_usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulos_x_usuarioFindFirstArgs} args - Arguments to find a Titulos_x_usuario
     * @example
     * // Get one Titulos_x_usuario
     * const titulos_x_usuario = await prisma.titulos_x_usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends titulos_x_usuarioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, titulos_x_usuarioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'titulos_x_usuario'> extends True ? Prisma__titulos_x_usuarioClient<titulos_x_usuarioGetPayload<T>> : Prisma__titulos_x_usuarioClient<titulos_x_usuarioGetPayload<T> | null, null>

    /**
     * Find zero or more Titulos_x_usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulos_x_usuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Titulos_x_usuarios
     * const titulos_x_usuarios = await prisma.titulos_x_usuario.findMany()
     * 
     * // Get first 10 Titulos_x_usuarios
     * const titulos_x_usuarios = await prisma.titulos_x_usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const titulos_x_usuarioWithIdOnly = await prisma.titulos_x_usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends titulos_x_usuarioFindManyArgs>(
      args?: SelectSubset<T, titulos_x_usuarioFindManyArgs>
    ): PrismaPromise<Array<titulos_x_usuarioGetPayload<T>>>

    /**
     * Create a Titulos_x_usuario.
     * @param {titulos_x_usuarioCreateArgs} args - Arguments to create a Titulos_x_usuario.
     * @example
     * // Create one Titulos_x_usuario
     * const Titulos_x_usuario = await prisma.titulos_x_usuario.create({
     *   data: {
     *     // ... data to create a Titulos_x_usuario
     *   }
     * })
     * 
    **/
    create<T extends titulos_x_usuarioCreateArgs>(
      args: SelectSubset<T, titulos_x_usuarioCreateArgs>
    ): Prisma__titulos_x_usuarioClient<titulos_x_usuarioGetPayload<T>>

    /**
     * Create many Titulos_x_usuarios.
     *     @param {titulos_x_usuarioCreateManyArgs} args - Arguments to create many Titulos_x_usuarios.
     *     @example
     *     // Create many Titulos_x_usuarios
     *     const titulos_x_usuario = await prisma.titulos_x_usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends titulos_x_usuarioCreateManyArgs>(
      args?: SelectSubset<T, titulos_x_usuarioCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Titulos_x_usuario.
     * @param {titulos_x_usuarioDeleteArgs} args - Arguments to delete one Titulos_x_usuario.
     * @example
     * // Delete one Titulos_x_usuario
     * const Titulos_x_usuario = await prisma.titulos_x_usuario.delete({
     *   where: {
     *     // ... filter to delete one Titulos_x_usuario
     *   }
     * })
     * 
    **/
    delete<T extends titulos_x_usuarioDeleteArgs>(
      args: SelectSubset<T, titulos_x_usuarioDeleteArgs>
    ): Prisma__titulos_x_usuarioClient<titulos_x_usuarioGetPayload<T>>

    /**
     * Update one Titulos_x_usuario.
     * @param {titulos_x_usuarioUpdateArgs} args - Arguments to update one Titulos_x_usuario.
     * @example
     * // Update one Titulos_x_usuario
     * const titulos_x_usuario = await prisma.titulos_x_usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends titulos_x_usuarioUpdateArgs>(
      args: SelectSubset<T, titulos_x_usuarioUpdateArgs>
    ): Prisma__titulos_x_usuarioClient<titulos_x_usuarioGetPayload<T>>

    /**
     * Delete zero or more Titulos_x_usuarios.
     * @param {titulos_x_usuarioDeleteManyArgs} args - Arguments to filter Titulos_x_usuarios to delete.
     * @example
     * // Delete a few Titulos_x_usuarios
     * const { count } = await prisma.titulos_x_usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends titulos_x_usuarioDeleteManyArgs>(
      args?: SelectSubset<T, titulos_x_usuarioDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Titulos_x_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulos_x_usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Titulos_x_usuarios
     * const titulos_x_usuario = await prisma.titulos_x_usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends titulos_x_usuarioUpdateManyArgs>(
      args: SelectSubset<T, titulos_x_usuarioUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Titulos_x_usuario.
     * @param {titulos_x_usuarioUpsertArgs} args - Arguments to update or create a Titulos_x_usuario.
     * @example
     * // Update or create a Titulos_x_usuario
     * const titulos_x_usuario = await prisma.titulos_x_usuario.upsert({
     *   create: {
     *     // ... data to create a Titulos_x_usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Titulos_x_usuario we want to update
     *   }
     * })
    **/
    upsert<T extends titulos_x_usuarioUpsertArgs>(
      args: SelectSubset<T, titulos_x_usuarioUpsertArgs>
    ): Prisma__titulos_x_usuarioClient<titulos_x_usuarioGetPayload<T>>

    /**
     * Find one Titulos_x_usuario that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {titulos_x_usuarioFindUniqueOrThrowArgs} args - Arguments to find a Titulos_x_usuario
     * @example
     * // Get one Titulos_x_usuario
     * const titulos_x_usuario = await prisma.titulos_x_usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends titulos_x_usuarioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, titulos_x_usuarioFindUniqueOrThrowArgs>
    ): Prisma__titulos_x_usuarioClient<titulos_x_usuarioGetPayload<T>>

    /**
     * Find the first Titulos_x_usuario that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulos_x_usuarioFindFirstOrThrowArgs} args - Arguments to find a Titulos_x_usuario
     * @example
     * // Get one Titulos_x_usuario
     * const titulos_x_usuario = await prisma.titulos_x_usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends titulos_x_usuarioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, titulos_x_usuarioFindFirstOrThrowArgs>
    ): Prisma__titulos_x_usuarioClient<titulos_x_usuarioGetPayload<T>>

    /**
     * Count the number of Titulos_x_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulos_x_usuarioCountArgs} args - Arguments to filter Titulos_x_usuarios to count.
     * @example
     * // Count the number of Titulos_x_usuarios
     * const count = await prisma.titulos_x_usuario.count({
     *   where: {
     *     // ... the filter for the Titulos_x_usuarios we want to count
     *   }
     * })
    **/
    count<T extends titulos_x_usuarioCountArgs>(
      args?: Subset<T, titulos_x_usuarioCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Titulos_x_usuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Titulos_x_usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Titulos_x_usuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Titulos_x_usuarioAggregateArgs>(args: Subset<T, Titulos_x_usuarioAggregateArgs>): PrismaPromise<GetTitulos_x_usuarioAggregateType<T>>

    /**
     * Group by Titulos_x_usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Titulos_x_usuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Titulos_x_usuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Titulos_x_usuarioGroupByArgs['orderBy'] }
        : { orderBy?: Titulos_x_usuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Titulos_x_usuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTitulos_x_usuarioGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for titulos_x_usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__titulos_x_usuarioClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    bordero_borderoTotitulos_x_usuario<T extends borderoArgs= {}>(args?: Subset<T, borderoArgs>): Prisma__borderoClient<borderoGetPayload<T> | Null>;

    usuario_titulos_x_usuarioTousuario<T extends usuarioArgs= {}>(args?: Subset<T, usuarioArgs>): Prisma__usuarioClient<usuarioGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * titulos_x_usuario base type for findUnique actions
   */
  export type titulos_x_usuarioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the titulos_x_usuario
     * 
    **/
    select?: titulos_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulos_x_usuarioInclude | null
    /**
     * Filter, which titulos_x_usuario to fetch.
     * 
    **/
    where: titulos_x_usuarioWhereUniqueInput
  }

  /**
   * titulos_x_usuario: findUnique
   */
  export interface titulos_x_usuarioFindUniqueArgs extends titulos_x_usuarioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulos_x_usuario base type for findFirst actions
   */
  export type titulos_x_usuarioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the titulos_x_usuario
     * 
    **/
    select?: titulos_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulos_x_usuarioInclude | null
    /**
     * Filter, which titulos_x_usuario to fetch.
     * 
    **/
    where?: titulos_x_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulos_x_usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<titulos_x_usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for titulos_x_usuarios.
     * 
    **/
    cursor?: titulos_x_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulos_x_usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulos_x_usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of titulos_x_usuarios.
     * 
    **/
    distinct?: Enumerable<Titulos_x_usuarioScalarFieldEnum>
  }

  /**
   * titulos_x_usuario: findFirst
   */
  export interface titulos_x_usuarioFindFirstArgs extends titulos_x_usuarioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulos_x_usuario findMany
   */
  export type titulos_x_usuarioFindManyArgs = {
    /**
     * Select specific fields to fetch from the titulos_x_usuario
     * 
    **/
    select?: titulos_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulos_x_usuarioInclude | null
    /**
     * Filter, which titulos_x_usuarios to fetch.
     * 
    **/
    where?: titulos_x_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulos_x_usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<titulos_x_usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing titulos_x_usuarios.
     * 
    **/
    cursor?: titulos_x_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulos_x_usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulos_x_usuarios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Titulos_x_usuarioScalarFieldEnum>
  }


  /**
   * titulos_x_usuario create
   */
  export type titulos_x_usuarioCreateArgs = {
    /**
     * Select specific fields to fetch from the titulos_x_usuario
     * 
    **/
    select?: titulos_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulos_x_usuarioInclude | null
    /**
     * The data needed to create a titulos_x_usuario.
     * 
    **/
    data: XOR<titulos_x_usuarioCreateInput, titulos_x_usuarioUncheckedCreateInput>
  }


  /**
   * titulos_x_usuario createMany
   */
  export type titulos_x_usuarioCreateManyArgs = {
    /**
     * The data used to create many titulos_x_usuarios.
     * 
    **/
    data: Enumerable<titulos_x_usuarioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * titulos_x_usuario update
   */
  export type titulos_x_usuarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the titulos_x_usuario
     * 
    **/
    select?: titulos_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulos_x_usuarioInclude | null
    /**
     * The data needed to update a titulos_x_usuario.
     * 
    **/
    data: XOR<titulos_x_usuarioUpdateInput, titulos_x_usuarioUncheckedUpdateInput>
    /**
     * Choose, which titulos_x_usuario to update.
     * 
    **/
    where: titulos_x_usuarioWhereUniqueInput
  }


  /**
   * titulos_x_usuario updateMany
   */
  export type titulos_x_usuarioUpdateManyArgs = {
    /**
     * The data used to update titulos_x_usuarios.
     * 
    **/
    data: XOR<titulos_x_usuarioUpdateManyMutationInput, titulos_x_usuarioUncheckedUpdateManyInput>
    /**
     * Filter which titulos_x_usuarios to update
     * 
    **/
    where?: titulos_x_usuarioWhereInput
  }


  /**
   * titulos_x_usuario upsert
   */
  export type titulos_x_usuarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the titulos_x_usuario
     * 
    **/
    select?: titulos_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulos_x_usuarioInclude | null
    /**
     * The filter to search for the titulos_x_usuario to update in case it exists.
     * 
    **/
    where: titulos_x_usuarioWhereUniqueInput
    /**
     * In case the titulos_x_usuario found by the `where` argument doesn't exist, create a new titulos_x_usuario with this data.
     * 
    **/
    create: XOR<titulos_x_usuarioCreateInput, titulos_x_usuarioUncheckedCreateInput>
    /**
     * In case the titulos_x_usuario was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<titulos_x_usuarioUpdateInput, titulos_x_usuarioUncheckedUpdateInput>
  }


  /**
   * titulos_x_usuario delete
   */
  export type titulos_x_usuarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the titulos_x_usuario
     * 
    **/
    select?: titulos_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulos_x_usuarioInclude | null
    /**
     * Filter which titulos_x_usuario to delete.
     * 
    **/
    where: titulos_x_usuarioWhereUniqueInput
  }


  /**
   * titulos_x_usuario deleteMany
   */
  export type titulos_x_usuarioDeleteManyArgs = {
    /**
     * Filter which titulos_x_usuarios to delete
     * 
    **/
    where?: titulos_x_usuarioWhereInput
  }


  /**
   * titulos_x_usuario: findUniqueOrThrow
   */
  export type titulos_x_usuarioFindUniqueOrThrowArgs = titulos_x_usuarioFindUniqueArgsBase
      

  /**
   * titulos_x_usuario: findFirstOrThrow
   */
  export type titulos_x_usuarioFindFirstOrThrowArgs = titulos_x_usuarioFindFirstArgsBase
      

  /**
   * titulos_x_usuario without action
   */
  export type titulos_x_usuarioArgs = {
    /**
     * Select specific fields to fetch from the titulos_x_usuario
     * 
    **/
    select?: titulos_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulos_x_usuarioInclude | null
  }



  /**
   * Model usuario
   */


  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    email: string | null
    senha: string | null
    pessoa_id: number | null
    status: string | null
    primeiro_acesso: boolean | null
    confirmou_cadastro: boolean | null
    codigo_confirma_cadastro: string | null
    codigo_reset_senha: string | null
    codigo_data_expiracao: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    email: string | null
    senha: string | null
    pessoa_id: number | null
    status: string | null
    primeiro_acesso: boolean | null
    confirmou_cadastro: boolean | null
    codigo_confirma_cadastro: string | null
    codigo_reset_senha: string | null
    codigo_data_expiracao: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    email: number
    senha: number
    pessoa_id: number
    status: number
    primeiro_acesso: number
    confirmou_cadastro: number
    codigo_confirma_cadastro: number
    codigo_reset_senha: number
    codigo_data_expiracao: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
    pessoa_id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
    pessoa_id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    email?: true
    senha?: true
    pessoa_id?: true
    status?: true
    primeiro_acesso?: true
    confirmou_cadastro?: true
    codigo_confirma_cadastro?: true
    codigo_reset_senha?: true
    codigo_data_expiracao?: true
    created_at?: true
    updated_at?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    email?: true
    senha?: true
    pessoa_id?: true
    status?: true
    primeiro_acesso?: true
    confirmou_cadastro?: true
    codigo_confirma_cadastro?: true
    codigo_reset_senha?: true
    codigo_data_expiracao?: true
    created_at?: true
    updated_at?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    email?: true
    senha?: true
    pessoa_id?: true
    status?: true
    primeiro_acesso?: true
    confirmou_cadastro?: true
    codigo_confirma_cadastro?: true
    codigo_reset_senha?: true
    codigo_data_expiracao?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsuarioAggregateArgs = {
    /**
     * Filter which usuario to aggregate.
     * 
    **/
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs = {
    where?: usuarioWhereInput
    orderBy?: Enumerable<usuarioOrderByWithAggregationInput>
    by: Array<UsuarioScalarFieldEnum>
    having?: usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }


  export type UsuarioGroupByOutputType = {
    id: number
    email: string
    senha: string
    pessoa_id: number
    status: string | null
    primeiro_acesso: boolean | null
    confirmou_cadastro: boolean | null
    codigo_confirma_cadastro: string | null
    codigo_reset_senha: string | null
    codigo_data_expiracao: Date | null
    created_at: Date
    updated_at: Date | null
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type usuarioSelect = {
    id?: boolean
    email?: boolean
    senha?: boolean
    pessoa_id?: boolean
    status?: boolean
    primeiro_acesso?: boolean
    confirmou_cadastro?: boolean
    codigo_confirma_cadastro?: boolean
    codigo_reset_senha?: boolean
    codigo_data_expiracao?: boolean
    created_at?: boolean
    updated_at?: boolean
    auditoria?: boolean | auditoriaFindManyArgs
    checagem?: boolean | checagemFindManyArgs
    fidic_fundo_x_usuario?: boolean | fidic_fundo_x_usuarioFindManyArgs
    titulos_x_usuario?: boolean | titulos_x_usuarioFindManyArgs
    pessoa?: boolean | pessoaArgs
    usuario_x_perfil?: boolean | usuario_x_perfilFindManyArgs
    _count?: boolean | UsuarioCountOutputTypeArgs
  }


  export type usuarioInclude = {
    auditoria?: boolean | auditoriaFindManyArgs
    checagem?: boolean | checagemFindManyArgs
    fidic_fundo_x_usuario?: boolean | fidic_fundo_x_usuarioFindManyArgs
    titulos_x_usuario?: boolean | titulos_x_usuarioFindManyArgs
    pessoa?: boolean | pessoaArgs
    usuario_x_perfil?: boolean | usuario_x_perfilFindManyArgs
    _count?: boolean | UsuarioCountOutputTypeArgs
  } 

  export type usuarioGetPayload<S extends boolean | null | undefined | usuarioArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? usuario :
    S extends undefined ? never :
    S extends { include: any } & (usuarioArgs | usuarioFindManyArgs)
    ? usuario  & {
    [P in TrueKeys<S['include']>]:
        P extends 'auditoria' ? Array < auditoriaGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'checagem' ? Array < checagemGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'fidic_fundo_x_usuario' ? Array < fidic_fundo_x_usuarioGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'titulos_x_usuario' ? Array < titulos_x_usuarioGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'pessoa' ? pessoaGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'usuario_x_perfil' ? Array < usuario_x_perfilGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? UsuarioCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (usuarioArgs | usuarioFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'auditoria' ? Array < auditoriaGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'checagem' ? Array < checagemGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'fidic_fundo_x_usuario' ? Array < fidic_fundo_x_usuarioGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'titulos_x_usuario' ? Array < titulos_x_usuarioGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'pessoa' ? pessoaGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'usuario_x_perfil' ? Array < usuario_x_perfilGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? UsuarioCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof usuario ? usuario[P] : never
  } 
      : usuario


  type usuarioCountArgs = Merge<
    Omit<usuarioFindManyArgs, 'select' | 'include'> & {
      select?: UsuarioCountAggregateInputType | true
    }
  >

  export interface usuarioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {usuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usuarioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usuarioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'usuario'> extends True ? Prisma__usuarioClient<usuarioGetPayload<T>> : Prisma__usuarioClient<usuarioGetPayload<T> | null, null>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usuarioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usuarioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'usuario'> extends True ? Prisma__usuarioClient<usuarioGetPayload<T>> : Prisma__usuarioClient<usuarioGetPayload<T> | null, null>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usuarioFindManyArgs>(
      args?: SelectSubset<T, usuarioFindManyArgs>
    ): PrismaPromise<Array<usuarioGetPayload<T>>>

    /**
     * Create a Usuario.
     * @param {usuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends usuarioCreateArgs>(
      args: SelectSubset<T, usuarioCreateArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Create many Usuarios.
     *     @param {usuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usuarioCreateManyArgs>(
      args?: SelectSubset<T, usuarioCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {usuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends usuarioDeleteArgs>(
      args: SelectSubset<T, usuarioDeleteArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Update one Usuario.
     * @param {usuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usuarioUpdateArgs>(
      args: SelectSubset<T, usuarioUpdateArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Delete zero or more Usuarios.
     * @param {usuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usuarioDeleteManyArgs>(
      args?: SelectSubset<T, usuarioDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usuarioUpdateManyArgs>(
      args: SelectSubset<T, usuarioUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {usuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends usuarioUpsertArgs>(
      args: SelectSubset<T, usuarioUpsertArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Find one Usuario that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {usuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usuarioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usuarioFindUniqueOrThrowArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Find the first Usuario that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usuarioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usuarioFindFirstOrThrowArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuarioCountArgs>(
      args?: Subset<T, usuarioCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usuarioClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    auditoria<T extends auditoriaFindManyArgs= {}>(args?: Subset<T, auditoriaFindManyArgs>): PrismaPromise<Array<auditoriaGetPayload<T>>| Null>;

    checagem<T extends checagemFindManyArgs= {}>(args?: Subset<T, checagemFindManyArgs>): PrismaPromise<Array<checagemGetPayload<T>>| Null>;

    fidic_fundo_x_usuario<T extends fidic_fundo_x_usuarioFindManyArgs= {}>(args?: Subset<T, fidic_fundo_x_usuarioFindManyArgs>): PrismaPromise<Array<fidic_fundo_x_usuarioGetPayload<T>>| Null>;

    titulos_x_usuario<T extends titulos_x_usuarioFindManyArgs= {}>(args?: Subset<T, titulos_x_usuarioFindManyArgs>): PrismaPromise<Array<titulos_x_usuarioGetPayload<T>>| Null>;

    pessoa<T extends pessoaArgs= {}>(args?: Subset<T, pessoaArgs>): Prisma__pessoaClient<pessoaGetPayload<T> | Null>;

    usuario_x_perfil<T extends usuario_x_perfilFindManyArgs= {}>(args?: Subset<T, usuario_x_perfilFindManyArgs>): PrismaPromise<Array<usuario_x_perfilGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * usuario base type for findUnique actions
   */
  export type usuarioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * Filter, which usuario to fetch.
     * 
    **/
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario: findUnique
   */
  export interface usuarioFindUniqueArgs extends usuarioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario base type for findFirst actions
   */
  export type usuarioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * Filter, which usuario to fetch.
     * 
    **/
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     * 
    **/
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     * 
    **/
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }

  /**
   * usuario: findFirst
   */
  export interface usuarioFindFirstArgs extends usuarioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario findMany
   */
  export type usuarioFindManyArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * Filter, which usuarios to fetch.
     * 
    **/
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     * 
    **/
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * usuario create
   */
  export type usuarioCreateArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * The data needed to create a usuario.
     * 
    **/
    data: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
  }


  /**
   * usuario createMany
   */
  export type usuarioCreateManyArgs = {
    /**
     * The data used to create many usuarios.
     * 
    **/
    data: Enumerable<usuarioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * usuario update
   */
  export type usuarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * The data needed to update a usuario.
     * 
    **/
    data: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
    /**
     * Choose, which usuario to update.
     * 
    **/
    where: usuarioWhereUniqueInput
  }


  /**
   * usuario updateMany
   */
  export type usuarioUpdateManyArgs = {
    /**
     * The data used to update usuarios.
     * 
    **/
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     * 
    **/
    where?: usuarioWhereInput
  }


  /**
   * usuario upsert
   */
  export type usuarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * The filter to search for the usuario to update in case it exists.
     * 
    **/
    where: usuarioWhereUniqueInput
    /**
     * In case the usuario found by the `where` argument doesn't exist, create a new usuario with this data.
     * 
    **/
    create: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
    /**
     * In case the usuario was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
  }


  /**
   * usuario delete
   */
  export type usuarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * Filter which usuario to delete.
     * 
    **/
    where: usuarioWhereUniqueInput
  }


  /**
   * usuario deleteMany
   */
  export type usuarioDeleteManyArgs = {
    /**
     * Filter which usuarios to delete
     * 
    **/
    where?: usuarioWhereInput
  }


  /**
   * usuario: findUniqueOrThrow
   */
  export type usuarioFindUniqueOrThrowArgs = usuarioFindUniqueArgsBase
      

  /**
   * usuario: findFirstOrThrow
   */
  export type usuarioFindFirstOrThrowArgs = usuarioFindFirstArgsBase
      

  /**
   * usuario without action
   */
  export type usuarioArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
  }



  /**
   * Model usuario__pessoa
   */


  export type AggregateUsuario__pessoa = {
    _count: Usuario__pessoaCountAggregateOutputType | null
    _avg: Usuario__pessoaAvgAggregateOutputType | null
    _sum: Usuario__pessoaSumAggregateOutputType | null
    _min: Usuario__pessoaMinAggregateOutputType | null
    _max: Usuario__pessoaMaxAggregateOutputType | null
  }

  export type Usuario__pessoaAvgAggregateOutputType = {
    id: number | null
  }

  export type Usuario__pessoaSumAggregateOutputType = {
    id: number | null
  }

  export type Usuario__pessoaMinAggregateOutputType = {
    id: number | null
  }

  export type Usuario__pessoaMaxAggregateOutputType = {
    id: number | null
  }

  export type Usuario__pessoaCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type Usuario__pessoaAvgAggregateInputType = {
    id?: true
  }

  export type Usuario__pessoaSumAggregateInputType = {
    id?: true
  }

  export type Usuario__pessoaMinAggregateInputType = {
    id?: true
  }

  export type Usuario__pessoaMaxAggregateInputType = {
    id?: true
  }

  export type Usuario__pessoaCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type Usuario__pessoaAggregateArgs = {
    /**
     * Filter which usuario__pessoa to aggregate.
     * 
    **/
    where?: usuario__pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario__pessoas to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario__pessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: usuario__pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario__pessoas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario__pessoas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuario__pessoas
    **/
    _count?: true | Usuario__pessoaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Usuario__pessoaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Usuario__pessoaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Usuario__pessoaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Usuario__pessoaMaxAggregateInputType
  }

  export type GetUsuario__pessoaAggregateType<T extends Usuario__pessoaAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario__pessoa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario__pessoa[P]>
      : GetScalarType<T[P], AggregateUsuario__pessoa[P]>
  }




  export type Usuario__pessoaGroupByArgs = {
    where?: usuario__pessoaWhereInput
    orderBy?: Enumerable<usuario__pessoaOrderByWithAggregationInput>
    by: Array<Usuario__pessoaScalarFieldEnum>
    having?: usuario__pessoaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Usuario__pessoaCountAggregateInputType | true
    _avg?: Usuario__pessoaAvgAggregateInputType
    _sum?: Usuario__pessoaSumAggregateInputType
    _min?: Usuario__pessoaMinAggregateInputType
    _max?: Usuario__pessoaMaxAggregateInputType
  }


  export type Usuario__pessoaGroupByOutputType = {
    id: number
    _count: Usuario__pessoaCountAggregateOutputType | null
    _avg: Usuario__pessoaAvgAggregateOutputType | null
    _sum: Usuario__pessoaSumAggregateOutputType | null
    _min: Usuario__pessoaMinAggregateOutputType | null
    _max: Usuario__pessoaMaxAggregateOutputType | null
  }

  type GetUsuario__pessoaGroupByPayload<T extends Usuario__pessoaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Usuario__pessoaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Usuario__pessoaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Usuario__pessoaGroupByOutputType[P]>
            : GetScalarType<T[P], Usuario__pessoaGroupByOutputType[P]>
        }
      >
    >


  export type usuario__pessoaSelect = {
    id?: boolean
  }


  export type usuario__pessoaGetPayload<S extends boolean | null | undefined | usuario__pessoaArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? usuario__pessoa :
    S extends undefined ? never :
    S extends { include: any } & (usuario__pessoaArgs | usuario__pessoaFindManyArgs)
    ? usuario__pessoa 
    : S extends { select: any } & (usuario__pessoaArgs | usuario__pessoaFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof usuario__pessoa ? usuario__pessoa[P] : never
  } 
      : usuario__pessoa


  type usuario__pessoaCountArgs = Merge<
    Omit<usuario__pessoaFindManyArgs, 'select' | 'include'> & {
      select?: Usuario__pessoaCountAggregateInputType | true
    }
  >

  export interface usuario__pessoaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Usuario__pessoa that matches the filter.
     * @param {usuario__pessoaFindUniqueArgs} args - Arguments to find a Usuario__pessoa
     * @example
     * // Get one Usuario__pessoa
     * const usuario__pessoa = await prisma.usuario__pessoa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usuario__pessoaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usuario__pessoaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'usuario__pessoa'> extends True ? Prisma__usuario__pessoaClient<usuario__pessoaGetPayload<T>> : Prisma__usuario__pessoaClient<usuario__pessoaGetPayload<T> | null, null>

    /**
     * Find the first Usuario__pessoa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario__pessoaFindFirstArgs} args - Arguments to find a Usuario__pessoa
     * @example
     * // Get one Usuario__pessoa
     * const usuario__pessoa = await prisma.usuario__pessoa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usuario__pessoaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usuario__pessoaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'usuario__pessoa'> extends True ? Prisma__usuario__pessoaClient<usuario__pessoaGetPayload<T>> : Prisma__usuario__pessoaClient<usuario__pessoaGetPayload<T> | null, null>

    /**
     * Find zero or more Usuario__pessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario__pessoaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuario__pessoas
     * const usuario__pessoas = await prisma.usuario__pessoa.findMany()
     * 
     * // Get first 10 Usuario__pessoas
     * const usuario__pessoas = await prisma.usuario__pessoa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuario__pessoaWithIdOnly = await prisma.usuario__pessoa.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usuario__pessoaFindManyArgs>(
      args?: SelectSubset<T, usuario__pessoaFindManyArgs>
    ): PrismaPromise<Array<usuario__pessoaGetPayload<T>>>

    /**
     * Create a Usuario__pessoa.
     * @param {usuario__pessoaCreateArgs} args - Arguments to create a Usuario__pessoa.
     * @example
     * // Create one Usuario__pessoa
     * const Usuario__pessoa = await prisma.usuario__pessoa.create({
     *   data: {
     *     // ... data to create a Usuario__pessoa
     *   }
     * })
     * 
    **/
    create<T extends usuario__pessoaCreateArgs>(
      args: SelectSubset<T, usuario__pessoaCreateArgs>
    ): Prisma__usuario__pessoaClient<usuario__pessoaGetPayload<T>>

    /**
     * Create many Usuario__pessoas.
     *     @param {usuario__pessoaCreateManyArgs} args - Arguments to create many Usuario__pessoas.
     *     @example
     *     // Create many Usuario__pessoas
     *     const usuario__pessoa = await prisma.usuario__pessoa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usuario__pessoaCreateManyArgs>(
      args?: SelectSubset<T, usuario__pessoaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario__pessoa.
     * @param {usuario__pessoaDeleteArgs} args - Arguments to delete one Usuario__pessoa.
     * @example
     * // Delete one Usuario__pessoa
     * const Usuario__pessoa = await prisma.usuario__pessoa.delete({
     *   where: {
     *     // ... filter to delete one Usuario__pessoa
     *   }
     * })
     * 
    **/
    delete<T extends usuario__pessoaDeleteArgs>(
      args: SelectSubset<T, usuario__pessoaDeleteArgs>
    ): Prisma__usuario__pessoaClient<usuario__pessoaGetPayload<T>>

    /**
     * Update one Usuario__pessoa.
     * @param {usuario__pessoaUpdateArgs} args - Arguments to update one Usuario__pessoa.
     * @example
     * // Update one Usuario__pessoa
     * const usuario__pessoa = await prisma.usuario__pessoa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usuario__pessoaUpdateArgs>(
      args: SelectSubset<T, usuario__pessoaUpdateArgs>
    ): Prisma__usuario__pessoaClient<usuario__pessoaGetPayload<T>>

    /**
     * Delete zero or more Usuario__pessoas.
     * @param {usuario__pessoaDeleteManyArgs} args - Arguments to filter Usuario__pessoas to delete.
     * @example
     * // Delete a few Usuario__pessoas
     * const { count } = await prisma.usuario__pessoa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usuario__pessoaDeleteManyArgs>(
      args?: SelectSubset<T, usuario__pessoaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuario__pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario__pessoaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuario__pessoas
     * const usuario__pessoa = await prisma.usuario__pessoa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usuario__pessoaUpdateManyArgs>(
      args: SelectSubset<T, usuario__pessoaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario__pessoa.
     * @param {usuario__pessoaUpsertArgs} args - Arguments to update or create a Usuario__pessoa.
     * @example
     * // Update or create a Usuario__pessoa
     * const usuario__pessoa = await prisma.usuario__pessoa.upsert({
     *   create: {
     *     // ... data to create a Usuario__pessoa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario__pessoa we want to update
     *   }
     * })
    **/
    upsert<T extends usuario__pessoaUpsertArgs>(
      args: SelectSubset<T, usuario__pessoaUpsertArgs>
    ): Prisma__usuario__pessoaClient<usuario__pessoaGetPayload<T>>

    /**
     * Find one Usuario__pessoa that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {usuario__pessoaFindUniqueOrThrowArgs} args - Arguments to find a Usuario__pessoa
     * @example
     * // Get one Usuario__pessoa
     * const usuario__pessoa = await prisma.usuario__pessoa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usuario__pessoaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usuario__pessoaFindUniqueOrThrowArgs>
    ): Prisma__usuario__pessoaClient<usuario__pessoaGetPayload<T>>

    /**
     * Find the first Usuario__pessoa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario__pessoaFindFirstOrThrowArgs} args - Arguments to find a Usuario__pessoa
     * @example
     * // Get one Usuario__pessoa
     * const usuario__pessoa = await prisma.usuario__pessoa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usuario__pessoaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usuario__pessoaFindFirstOrThrowArgs>
    ): Prisma__usuario__pessoaClient<usuario__pessoaGetPayload<T>>

    /**
     * Count the number of Usuario__pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario__pessoaCountArgs} args - Arguments to filter Usuario__pessoas to count.
     * @example
     * // Count the number of Usuario__pessoas
     * const count = await prisma.usuario__pessoa.count({
     *   where: {
     *     // ... the filter for the Usuario__pessoas we want to count
     *   }
     * })
    **/
    count<T extends usuario__pessoaCountArgs>(
      args?: Subset<T, usuario__pessoaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Usuario__pessoaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario__pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Usuario__pessoaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Usuario__pessoaAggregateArgs>(args: Subset<T, Usuario__pessoaAggregateArgs>): PrismaPromise<GetUsuario__pessoaAggregateType<T>>

    /**
     * Group by Usuario__pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Usuario__pessoaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Usuario__pessoaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Usuario__pessoaGroupByArgs['orderBy'] }
        : { orderBy?: Usuario__pessoaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Usuario__pessoaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuario__pessoaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario__pessoa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usuario__pessoaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * usuario__pessoa base type for findUnique actions
   */
  export type usuario__pessoaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the usuario__pessoa
     * 
    **/
    select?: usuario__pessoaSelect | null
    /**
     * Filter, which usuario__pessoa to fetch.
     * 
    **/
    where: usuario__pessoaWhereUniqueInput
  }

  /**
   * usuario__pessoa: findUnique
   */
  export interface usuario__pessoaFindUniqueArgs extends usuario__pessoaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario__pessoa base type for findFirst actions
   */
  export type usuario__pessoaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the usuario__pessoa
     * 
    **/
    select?: usuario__pessoaSelect | null
    /**
     * Filter, which usuario__pessoa to fetch.
     * 
    **/
    where?: usuario__pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario__pessoas to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario__pessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuario__pessoas.
     * 
    **/
    cursor?: usuario__pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario__pessoas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario__pessoas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuario__pessoas.
     * 
    **/
    distinct?: Enumerable<Usuario__pessoaScalarFieldEnum>
  }

  /**
   * usuario__pessoa: findFirst
   */
  export interface usuario__pessoaFindFirstArgs extends usuario__pessoaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario__pessoa findMany
   */
  export type usuario__pessoaFindManyArgs = {
    /**
     * Select specific fields to fetch from the usuario__pessoa
     * 
    **/
    select?: usuario__pessoaSelect | null
    /**
     * Filter, which usuario__pessoas to fetch.
     * 
    **/
    where?: usuario__pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario__pessoas to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario__pessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuario__pessoas.
     * 
    **/
    cursor?: usuario__pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario__pessoas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario__pessoas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Usuario__pessoaScalarFieldEnum>
  }


  /**
   * usuario__pessoa create
   */
  export type usuario__pessoaCreateArgs = {
    /**
     * Select specific fields to fetch from the usuario__pessoa
     * 
    **/
    select?: usuario__pessoaSelect | null
    /**
     * The data needed to create a usuario__pessoa.
     * 
    **/
    data?: XOR<usuario__pessoaCreateInput, usuario__pessoaUncheckedCreateInput>
  }


  /**
   * usuario__pessoa createMany
   */
  export type usuario__pessoaCreateManyArgs = {
    /**
     * The data used to create many usuario__pessoas.
     * 
    **/
    data: Enumerable<usuario__pessoaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * usuario__pessoa update
   */
  export type usuario__pessoaUpdateArgs = {
    /**
     * Select specific fields to fetch from the usuario__pessoa
     * 
    **/
    select?: usuario__pessoaSelect | null
    /**
     * The data needed to update a usuario__pessoa.
     * 
    **/
    data: XOR<usuario__pessoaUpdateInput, usuario__pessoaUncheckedUpdateInput>
    /**
     * Choose, which usuario__pessoa to update.
     * 
    **/
    where: usuario__pessoaWhereUniqueInput
  }


  /**
   * usuario__pessoa updateMany
   */
  export type usuario__pessoaUpdateManyArgs = {
    /**
     * The data used to update usuario__pessoas.
     * 
    **/
    data: XOR<usuario__pessoaUpdateManyMutationInput, usuario__pessoaUncheckedUpdateManyInput>
    /**
     * Filter which usuario__pessoas to update
     * 
    **/
    where?: usuario__pessoaWhereInput
  }


  /**
   * usuario__pessoa upsert
   */
  export type usuario__pessoaUpsertArgs = {
    /**
     * Select specific fields to fetch from the usuario__pessoa
     * 
    **/
    select?: usuario__pessoaSelect | null
    /**
     * The filter to search for the usuario__pessoa to update in case it exists.
     * 
    **/
    where: usuario__pessoaWhereUniqueInput
    /**
     * In case the usuario__pessoa found by the `where` argument doesn't exist, create a new usuario__pessoa with this data.
     * 
    **/
    create: XOR<usuario__pessoaCreateInput, usuario__pessoaUncheckedCreateInput>
    /**
     * In case the usuario__pessoa was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<usuario__pessoaUpdateInput, usuario__pessoaUncheckedUpdateInput>
  }


  /**
   * usuario__pessoa delete
   */
  export type usuario__pessoaDeleteArgs = {
    /**
     * Select specific fields to fetch from the usuario__pessoa
     * 
    **/
    select?: usuario__pessoaSelect | null
    /**
     * Filter which usuario__pessoa to delete.
     * 
    **/
    where: usuario__pessoaWhereUniqueInput
  }


  /**
   * usuario__pessoa deleteMany
   */
  export type usuario__pessoaDeleteManyArgs = {
    /**
     * Filter which usuario__pessoas to delete
     * 
    **/
    where?: usuario__pessoaWhereInput
  }


  /**
   * usuario__pessoa: findUniqueOrThrow
   */
  export type usuario__pessoaFindUniqueOrThrowArgs = usuario__pessoaFindUniqueArgsBase
      

  /**
   * usuario__pessoa: findFirstOrThrow
   */
  export type usuario__pessoaFindFirstOrThrowArgs = usuario__pessoaFindFirstArgsBase
      

  /**
   * usuario__pessoa without action
   */
  export type usuario__pessoaArgs = {
    /**
     * Select specific fields to fetch from the usuario__pessoa
     * 
    **/
    select?: usuario__pessoaSelect | null
  }



  /**
   * Model usuario_n_borderos
   */


  export type AggregateUsuario_n_borderos = {
    _count: Usuario_n_borderosCountAggregateOutputType | null
    _avg: Usuario_n_borderosAvgAggregateOutputType | null
    _sum: Usuario_n_borderosSumAggregateOutputType | null
    _min: Usuario_n_borderosMinAggregateOutputType | null
    _max: Usuario_n_borderosMaxAggregateOutputType | null
  }

  export type Usuario_n_borderosAvgAggregateOutputType = {
    id: number | null
  }

  export type Usuario_n_borderosSumAggregateOutputType = {
    id: number | null
  }

  export type Usuario_n_borderosMinAggregateOutputType = {
    id: number | null
  }

  export type Usuario_n_borderosMaxAggregateOutputType = {
    id: number | null
  }

  export type Usuario_n_borderosCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type Usuario_n_borderosAvgAggregateInputType = {
    id?: true
  }

  export type Usuario_n_borderosSumAggregateInputType = {
    id?: true
  }

  export type Usuario_n_borderosMinAggregateInputType = {
    id?: true
  }

  export type Usuario_n_borderosMaxAggregateInputType = {
    id?: true
  }

  export type Usuario_n_borderosCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type Usuario_n_borderosAggregateArgs = {
    /**
     * Filter which usuario_n_borderos to aggregate.
     * 
    **/
    where?: usuario_n_borderosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_n_borderos to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario_n_borderosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: usuario_n_borderosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_n_borderos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_n_borderos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuario_n_borderos
    **/
    _count?: true | Usuario_n_borderosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Usuario_n_borderosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Usuario_n_borderosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Usuario_n_borderosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Usuario_n_borderosMaxAggregateInputType
  }

  export type GetUsuario_n_borderosAggregateType<T extends Usuario_n_borderosAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario_n_borderos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario_n_borderos[P]>
      : GetScalarType<T[P], AggregateUsuario_n_borderos[P]>
  }




  export type Usuario_n_borderosGroupByArgs = {
    where?: usuario_n_borderosWhereInput
    orderBy?: Enumerable<usuario_n_borderosOrderByWithAggregationInput>
    by: Array<Usuario_n_borderosScalarFieldEnum>
    having?: usuario_n_borderosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Usuario_n_borderosCountAggregateInputType | true
    _avg?: Usuario_n_borderosAvgAggregateInputType
    _sum?: Usuario_n_borderosSumAggregateInputType
    _min?: Usuario_n_borderosMinAggregateInputType
    _max?: Usuario_n_borderosMaxAggregateInputType
  }


  export type Usuario_n_borderosGroupByOutputType = {
    id: number
    _count: Usuario_n_borderosCountAggregateOutputType | null
    _avg: Usuario_n_borderosAvgAggregateOutputType | null
    _sum: Usuario_n_borderosSumAggregateOutputType | null
    _min: Usuario_n_borderosMinAggregateOutputType | null
    _max: Usuario_n_borderosMaxAggregateOutputType | null
  }

  type GetUsuario_n_borderosGroupByPayload<T extends Usuario_n_borderosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Usuario_n_borderosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Usuario_n_borderosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Usuario_n_borderosGroupByOutputType[P]>
            : GetScalarType<T[P], Usuario_n_borderosGroupByOutputType[P]>
        }
      >
    >


  export type usuario_n_borderosSelect = {
    id?: boolean
  }


  export type usuario_n_borderosGetPayload<S extends boolean | null | undefined | usuario_n_borderosArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? usuario_n_borderos :
    S extends undefined ? never :
    S extends { include: any } & (usuario_n_borderosArgs | usuario_n_borderosFindManyArgs)
    ? usuario_n_borderos 
    : S extends { select: any } & (usuario_n_borderosArgs | usuario_n_borderosFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof usuario_n_borderos ? usuario_n_borderos[P] : never
  } 
      : usuario_n_borderos


  type usuario_n_borderosCountArgs = Merge<
    Omit<usuario_n_borderosFindManyArgs, 'select' | 'include'> & {
      select?: Usuario_n_borderosCountAggregateInputType | true
    }
  >

  export interface usuario_n_borderosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Usuario_n_borderos that matches the filter.
     * @param {usuario_n_borderosFindUniqueArgs} args - Arguments to find a Usuario_n_borderos
     * @example
     * // Get one Usuario_n_borderos
     * const usuario_n_borderos = await prisma.usuario_n_borderos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usuario_n_borderosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usuario_n_borderosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'usuario_n_borderos'> extends True ? Prisma__usuario_n_borderosClient<usuario_n_borderosGetPayload<T>> : Prisma__usuario_n_borderosClient<usuario_n_borderosGetPayload<T> | null, null>

    /**
     * Find the first Usuario_n_borderos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_n_borderosFindFirstArgs} args - Arguments to find a Usuario_n_borderos
     * @example
     * // Get one Usuario_n_borderos
     * const usuario_n_borderos = await prisma.usuario_n_borderos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usuario_n_borderosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usuario_n_borderosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'usuario_n_borderos'> extends True ? Prisma__usuario_n_borderosClient<usuario_n_borderosGetPayload<T>> : Prisma__usuario_n_borderosClient<usuario_n_borderosGetPayload<T> | null, null>

    /**
     * Find zero or more Usuario_n_borderos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_n_borderosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuario_n_borderos
     * const usuario_n_borderos = await prisma.usuario_n_borderos.findMany()
     * 
     * // Get first 10 Usuario_n_borderos
     * const usuario_n_borderos = await prisma.usuario_n_borderos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuario_n_borderosWithIdOnly = await prisma.usuario_n_borderos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usuario_n_borderosFindManyArgs>(
      args?: SelectSubset<T, usuario_n_borderosFindManyArgs>
    ): PrismaPromise<Array<usuario_n_borderosGetPayload<T>>>

    /**
     * Create a Usuario_n_borderos.
     * @param {usuario_n_borderosCreateArgs} args - Arguments to create a Usuario_n_borderos.
     * @example
     * // Create one Usuario_n_borderos
     * const Usuario_n_borderos = await prisma.usuario_n_borderos.create({
     *   data: {
     *     // ... data to create a Usuario_n_borderos
     *   }
     * })
     * 
    **/
    create<T extends usuario_n_borderosCreateArgs>(
      args: SelectSubset<T, usuario_n_borderosCreateArgs>
    ): Prisma__usuario_n_borderosClient<usuario_n_borderosGetPayload<T>>

    /**
     * Create many Usuario_n_borderos.
     *     @param {usuario_n_borderosCreateManyArgs} args - Arguments to create many Usuario_n_borderos.
     *     @example
     *     // Create many Usuario_n_borderos
     *     const usuario_n_borderos = await prisma.usuario_n_borderos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usuario_n_borderosCreateManyArgs>(
      args?: SelectSubset<T, usuario_n_borderosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario_n_borderos.
     * @param {usuario_n_borderosDeleteArgs} args - Arguments to delete one Usuario_n_borderos.
     * @example
     * // Delete one Usuario_n_borderos
     * const Usuario_n_borderos = await prisma.usuario_n_borderos.delete({
     *   where: {
     *     // ... filter to delete one Usuario_n_borderos
     *   }
     * })
     * 
    **/
    delete<T extends usuario_n_borderosDeleteArgs>(
      args: SelectSubset<T, usuario_n_borderosDeleteArgs>
    ): Prisma__usuario_n_borderosClient<usuario_n_borderosGetPayload<T>>

    /**
     * Update one Usuario_n_borderos.
     * @param {usuario_n_borderosUpdateArgs} args - Arguments to update one Usuario_n_borderos.
     * @example
     * // Update one Usuario_n_borderos
     * const usuario_n_borderos = await prisma.usuario_n_borderos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usuario_n_borderosUpdateArgs>(
      args: SelectSubset<T, usuario_n_borderosUpdateArgs>
    ): Prisma__usuario_n_borderosClient<usuario_n_borderosGetPayload<T>>

    /**
     * Delete zero or more Usuario_n_borderos.
     * @param {usuario_n_borderosDeleteManyArgs} args - Arguments to filter Usuario_n_borderos to delete.
     * @example
     * // Delete a few Usuario_n_borderos
     * const { count } = await prisma.usuario_n_borderos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usuario_n_borderosDeleteManyArgs>(
      args?: SelectSubset<T, usuario_n_borderosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuario_n_borderos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_n_borderosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuario_n_borderos
     * const usuario_n_borderos = await prisma.usuario_n_borderos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usuario_n_borderosUpdateManyArgs>(
      args: SelectSubset<T, usuario_n_borderosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario_n_borderos.
     * @param {usuario_n_borderosUpsertArgs} args - Arguments to update or create a Usuario_n_borderos.
     * @example
     * // Update or create a Usuario_n_borderos
     * const usuario_n_borderos = await prisma.usuario_n_borderos.upsert({
     *   create: {
     *     // ... data to create a Usuario_n_borderos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario_n_borderos we want to update
     *   }
     * })
    **/
    upsert<T extends usuario_n_borderosUpsertArgs>(
      args: SelectSubset<T, usuario_n_borderosUpsertArgs>
    ): Prisma__usuario_n_borderosClient<usuario_n_borderosGetPayload<T>>

    /**
     * Find one Usuario_n_borderos that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {usuario_n_borderosFindUniqueOrThrowArgs} args - Arguments to find a Usuario_n_borderos
     * @example
     * // Get one Usuario_n_borderos
     * const usuario_n_borderos = await prisma.usuario_n_borderos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usuario_n_borderosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usuario_n_borderosFindUniqueOrThrowArgs>
    ): Prisma__usuario_n_borderosClient<usuario_n_borderosGetPayload<T>>

    /**
     * Find the first Usuario_n_borderos that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_n_borderosFindFirstOrThrowArgs} args - Arguments to find a Usuario_n_borderos
     * @example
     * // Get one Usuario_n_borderos
     * const usuario_n_borderos = await prisma.usuario_n_borderos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usuario_n_borderosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usuario_n_borderosFindFirstOrThrowArgs>
    ): Prisma__usuario_n_borderosClient<usuario_n_borderosGetPayload<T>>

    /**
     * Count the number of Usuario_n_borderos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_n_borderosCountArgs} args - Arguments to filter Usuario_n_borderos to count.
     * @example
     * // Count the number of Usuario_n_borderos
     * const count = await prisma.usuario_n_borderos.count({
     *   where: {
     *     // ... the filter for the Usuario_n_borderos we want to count
     *   }
     * })
    **/
    count<T extends usuario_n_borderosCountArgs>(
      args?: Subset<T, usuario_n_borderosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Usuario_n_borderosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario_n_borderos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Usuario_n_borderosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Usuario_n_borderosAggregateArgs>(args: Subset<T, Usuario_n_borderosAggregateArgs>): PrismaPromise<GetUsuario_n_borderosAggregateType<T>>

    /**
     * Group by Usuario_n_borderos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Usuario_n_borderosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Usuario_n_borderosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Usuario_n_borderosGroupByArgs['orderBy'] }
        : { orderBy?: Usuario_n_borderosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Usuario_n_borderosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuario_n_borderosGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario_n_borderos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usuario_n_borderosClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * usuario_n_borderos base type for findUnique actions
   */
  export type usuario_n_borderosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the usuario_n_borderos
     * 
    **/
    select?: usuario_n_borderosSelect | null
    /**
     * Filter, which usuario_n_borderos to fetch.
     * 
    **/
    where: usuario_n_borderosWhereUniqueInput
  }

  /**
   * usuario_n_borderos: findUnique
   */
  export interface usuario_n_borderosFindUniqueArgs extends usuario_n_borderosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario_n_borderos base type for findFirst actions
   */
  export type usuario_n_borderosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the usuario_n_borderos
     * 
    **/
    select?: usuario_n_borderosSelect | null
    /**
     * Filter, which usuario_n_borderos to fetch.
     * 
    **/
    where?: usuario_n_borderosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_n_borderos to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario_n_borderosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuario_n_borderos.
     * 
    **/
    cursor?: usuario_n_borderosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_n_borderos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_n_borderos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuario_n_borderos.
     * 
    **/
    distinct?: Enumerable<Usuario_n_borderosScalarFieldEnum>
  }

  /**
   * usuario_n_borderos: findFirst
   */
  export interface usuario_n_borderosFindFirstArgs extends usuario_n_borderosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario_n_borderos findMany
   */
  export type usuario_n_borderosFindManyArgs = {
    /**
     * Select specific fields to fetch from the usuario_n_borderos
     * 
    **/
    select?: usuario_n_borderosSelect | null
    /**
     * Filter, which usuario_n_borderos to fetch.
     * 
    **/
    where?: usuario_n_borderosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_n_borderos to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario_n_borderosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuario_n_borderos.
     * 
    **/
    cursor?: usuario_n_borderosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_n_borderos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_n_borderos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Usuario_n_borderosScalarFieldEnum>
  }


  /**
   * usuario_n_borderos create
   */
  export type usuario_n_borderosCreateArgs = {
    /**
     * Select specific fields to fetch from the usuario_n_borderos
     * 
    **/
    select?: usuario_n_borderosSelect | null
    /**
     * The data needed to create a usuario_n_borderos.
     * 
    **/
    data?: XOR<usuario_n_borderosCreateInput, usuario_n_borderosUncheckedCreateInput>
  }


  /**
   * usuario_n_borderos createMany
   */
  export type usuario_n_borderosCreateManyArgs = {
    /**
     * The data used to create many usuario_n_borderos.
     * 
    **/
    data: Enumerable<usuario_n_borderosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * usuario_n_borderos update
   */
  export type usuario_n_borderosUpdateArgs = {
    /**
     * Select specific fields to fetch from the usuario_n_borderos
     * 
    **/
    select?: usuario_n_borderosSelect | null
    /**
     * The data needed to update a usuario_n_borderos.
     * 
    **/
    data: XOR<usuario_n_borderosUpdateInput, usuario_n_borderosUncheckedUpdateInput>
    /**
     * Choose, which usuario_n_borderos to update.
     * 
    **/
    where: usuario_n_borderosWhereUniqueInput
  }


  /**
   * usuario_n_borderos updateMany
   */
  export type usuario_n_borderosUpdateManyArgs = {
    /**
     * The data used to update usuario_n_borderos.
     * 
    **/
    data: XOR<usuario_n_borderosUpdateManyMutationInput, usuario_n_borderosUncheckedUpdateManyInput>
    /**
     * Filter which usuario_n_borderos to update
     * 
    **/
    where?: usuario_n_borderosWhereInput
  }


  /**
   * usuario_n_borderos upsert
   */
  export type usuario_n_borderosUpsertArgs = {
    /**
     * Select specific fields to fetch from the usuario_n_borderos
     * 
    **/
    select?: usuario_n_borderosSelect | null
    /**
     * The filter to search for the usuario_n_borderos to update in case it exists.
     * 
    **/
    where: usuario_n_borderosWhereUniqueInput
    /**
     * In case the usuario_n_borderos found by the `where` argument doesn't exist, create a new usuario_n_borderos with this data.
     * 
    **/
    create: XOR<usuario_n_borderosCreateInput, usuario_n_borderosUncheckedCreateInput>
    /**
     * In case the usuario_n_borderos was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<usuario_n_borderosUpdateInput, usuario_n_borderosUncheckedUpdateInput>
  }


  /**
   * usuario_n_borderos delete
   */
  export type usuario_n_borderosDeleteArgs = {
    /**
     * Select specific fields to fetch from the usuario_n_borderos
     * 
    **/
    select?: usuario_n_borderosSelect | null
    /**
     * Filter which usuario_n_borderos to delete.
     * 
    **/
    where: usuario_n_borderosWhereUniqueInput
  }


  /**
   * usuario_n_borderos deleteMany
   */
  export type usuario_n_borderosDeleteManyArgs = {
    /**
     * Filter which usuario_n_borderos to delete
     * 
    **/
    where?: usuario_n_borderosWhereInput
  }


  /**
   * usuario_n_borderos: findUniqueOrThrow
   */
  export type usuario_n_borderosFindUniqueOrThrowArgs = usuario_n_borderosFindUniqueArgsBase
      

  /**
   * usuario_n_borderos: findFirstOrThrow
   */
  export type usuario_n_borderosFindFirstOrThrowArgs = usuario_n_borderosFindFirstArgsBase
      

  /**
   * usuario_n_borderos without action
   */
  export type usuario_n_borderosArgs = {
    /**
     * Select specific fields to fetch from the usuario_n_borderos
     * 
    **/
    select?: usuario_n_borderosSelect | null
  }



  /**
   * Model usuario_perfil_tipo
   */


  export type AggregateUsuario_perfil_tipo = {
    _count: Usuario_perfil_tipoCountAggregateOutputType | null
    _avg: Usuario_perfil_tipoAvgAggregateOutputType | null
    _sum: Usuario_perfil_tipoSumAggregateOutputType | null
    _min: Usuario_perfil_tipoMinAggregateOutputType | null
    _max: Usuario_perfil_tipoMaxAggregateOutputType | null
  }

  export type Usuario_perfil_tipoAvgAggregateOutputType = {
    id: number | null
  }

  export type Usuario_perfil_tipoSumAggregateOutputType = {
    id: number | null
  }

  export type Usuario_perfil_tipoMinAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Usuario_perfil_tipoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Usuario_perfil_tipoCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type Usuario_perfil_tipoAvgAggregateInputType = {
    id?: true
  }

  export type Usuario_perfil_tipoSumAggregateInputType = {
    id?: true
  }

  export type Usuario_perfil_tipoMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Usuario_perfil_tipoMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Usuario_perfil_tipoCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type Usuario_perfil_tipoAggregateArgs = {
    /**
     * Filter which usuario_perfil_tipo to aggregate.
     * 
    **/
    where?: usuario_perfil_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_perfil_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario_perfil_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: usuario_perfil_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_perfil_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_perfil_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuario_perfil_tipos
    **/
    _count?: true | Usuario_perfil_tipoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Usuario_perfil_tipoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Usuario_perfil_tipoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Usuario_perfil_tipoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Usuario_perfil_tipoMaxAggregateInputType
  }

  export type GetUsuario_perfil_tipoAggregateType<T extends Usuario_perfil_tipoAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario_perfil_tipo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario_perfil_tipo[P]>
      : GetScalarType<T[P], AggregateUsuario_perfil_tipo[P]>
  }




  export type Usuario_perfil_tipoGroupByArgs = {
    where?: usuario_perfil_tipoWhereInput
    orderBy?: Enumerable<usuario_perfil_tipoOrderByWithAggregationInput>
    by: Array<Usuario_perfil_tipoScalarFieldEnum>
    having?: usuario_perfil_tipoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Usuario_perfil_tipoCountAggregateInputType | true
    _avg?: Usuario_perfil_tipoAvgAggregateInputType
    _sum?: Usuario_perfil_tipoSumAggregateInputType
    _min?: Usuario_perfil_tipoMinAggregateInputType
    _max?: Usuario_perfil_tipoMaxAggregateInputType
  }


  export type Usuario_perfil_tipoGroupByOutputType = {
    id: number
    nome: string
    _count: Usuario_perfil_tipoCountAggregateOutputType | null
    _avg: Usuario_perfil_tipoAvgAggregateOutputType | null
    _sum: Usuario_perfil_tipoSumAggregateOutputType | null
    _min: Usuario_perfil_tipoMinAggregateOutputType | null
    _max: Usuario_perfil_tipoMaxAggregateOutputType | null
  }

  type GetUsuario_perfil_tipoGroupByPayload<T extends Usuario_perfil_tipoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Usuario_perfil_tipoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Usuario_perfil_tipoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Usuario_perfil_tipoGroupByOutputType[P]>
            : GetScalarType<T[P], Usuario_perfil_tipoGroupByOutputType[P]>
        }
      >
    >


  export type usuario_perfil_tipoSelect = {
    id?: boolean
    nome?: boolean
    usuario_x_perfil?: boolean | usuario_x_perfilFindManyArgs
    _count?: boolean | Usuario_perfil_tipoCountOutputTypeArgs
  }


  export type usuario_perfil_tipoInclude = {
    usuario_x_perfil?: boolean | usuario_x_perfilFindManyArgs
    _count?: boolean | Usuario_perfil_tipoCountOutputTypeArgs
  } 

  export type usuario_perfil_tipoGetPayload<S extends boolean | null | undefined | usuario_perfil_tipoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? usuario_perfil_tipo :
    S extends undefined ? never :
    S extends { include: any } & (usuario_perfil_tipoArgs | usuario_perfil_tipoFindManyArgs)
    ? usuario_perfil_tipo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'usuario_x_perfil' ? Array < usuario_x_perfilGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Usuario_perfil_tipoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (usuario_perfil_tipoArgs | usuario_perfil_tipoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'usuario_x_perfil' ? Array < usuario_x_perfilGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Usuario_perfil_tipoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof usuario_perfil_tipo ? usuario_perfil_tipo[P] : never
  } 
      : usuario_perfil_tipo


  type usuario_perfil_tipoCountArgs = Merge<
    Omit<usuario_perfil_tipoFindManyArgs, 'select' | 'include'> & {
      select?: Usuario_perfil_tipoCountAggregateInputType | true
    }
  >

  export interface usuario_perfil_tipoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Usuario_perfil_tipo that matches the filter.
     * @param {usuario_perfil_tipoFindUniqueArgs} args - Arguments to find a Usuario_perfil_tipo
     * @example
     * // Get one Usuario_perfil_tipo
     * const usuario_perfil_tipo = await prisma.usuario_perfil_tipo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usuario_perfil_tipoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usuario_perfil_tipoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'usuario_perfil_tipo'> extends True ? Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T>> : Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T> | null, null>

    /**
     * Find the first Usuario_perfil_tipo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_perfil_tipoFindFirstArgs} args - Arguments to find a Usuario_perfil_tipo
     * @example
     * // Get one Usuario_perfil_tipo
     * const usuario_perfil_tipo = await prisma.usuario_perfil_tipo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usuario_perfil_tipoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usuario_perfil_tipoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'usuario_perfil_tipo'> extends True ? Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T>> : Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T> | null, null>

    /**
     * Find zero or more Usuario_perfil_tipos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_perfil_tipoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuario_perfil_tipos
     * const usuario_perfil_tipos = await prisma.usuario_perfil_tipo.findMany()
     * 
     * // Get first 10 Usuario_perfil_tipos
     * const usuario_perfil_tipos = await prisma.usuario_perfil_tipo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuario_perfil_tipoWithIdOnly = await prisma.usuario_perfil_tipo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usuario_perfil_tipoFindManyArgs>(
      args?: SelectSubset<T, usuario_perfil_tipoFindManyArgs>
    ): PrismaPromise<Array<usuario_perfil_tipoGetPayload<T>>>

    /**
     * Create a Usuario_perfil_tipo.
     * @param {usuario_perfil_tipoCreateArgs} args - Arguments to create a Usuario_perfil_tipo.
     * @example
     * // Create one Usuario_perfil_tipo
     * const Usuario_perfil_tipo = await prisma.usuario_perfil_tipo.create({
     *   data: {
     *     // ... data to create a Usuario_perfil_tipo
     *   }
     * })
     * 
    **/
    create<T extends usuario_perfil_tipoCreateArgs>(
      args: SelectSubset<T, usuario_perfil_tipoCreateArgs>
    ): Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T>>

    /**
     * Create many Usuario_perfil_tipos.
     *     @param {usuario_perfil_tipoCreateManyArgs} args - Arguments to create many Usuario_perfil_tipos.
     *     @example
     *     // Create many Usuario_perfil_tipos
     *     const usuario_perfil_tipo = await prisma.usuario_perfil_tipo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usuario_perfil_tipoCreateManyArgs>(
      args?: SelectSubset<T, usuario_perfil_tipoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario_perfil_tipo.
     * @param {usuario_perfil_tipoDeleteArgs} args - Arguments to delete one Usuario_perfil_tipo.
     * @example
     * // Delete one Usuario_perfil_tipo
     * const Usuario_perfil_tipo = await prisma.usuario_perfil_tipo.delete({
     *   where: {
     *     // ... filter to delete one Usuario_perfil_tipo
     *   }
     * })
     * 
    **/
    delete<T extends usuario_perfil_tipoDeleteArgs>(
      args: SelectSubset<T, usuario_perfil_tipoDeleteArgs>
    ): Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T>>

    /**
     * Update one Usuario_perfil_tipo.
     * @param {usuario_perfil_tipoUpdateArgs} args - Arguments to update one Usuario_perfil_tipo.
     * @example
     * // Update one Usuario_perfil_tipo
     * const usuario_perfil_tipo = await prisma.usuario_perfil_tipo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usuario_perfil_tipoUpdateArgs>(
      args: SelectSubset<T, usuario_perfil_tipoUpdateArgs>
    ): Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T>>

    /**
     * Delete zero or more Usuario_perfil_tipos.
     * @param {usuario_perfil_tipoDeleteManyArgs} args - Arguments to filter Usuario_perfil_tipos to delete.
     * @example
     * // Delete a few Usuario_perfil_tipos
     * const { count } = await prisma.usuario_perfil_tipo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usuario_perfil_tipoDeleteManyArgs>(
      args?: SelectSubset<T, usuario_perfil_tipoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuario_perfil_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_perfil_tipoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuario_perfil_tipos
     * const usuario_perfil_tipo = await prisma.usuario_perfil_tipo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usuario_perfil_tipoUpdateManyArgs>(
      args: SelectSubset<T, usuario_perfil_tipoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario_perfil_tipo.
     * @param {usuario_perfil_tipoUpsertArgs} args - Arguments to update or create a Usuario_perfil_tipo.
     * @example
     * // Update or create a Usuario_perfil_tipo
     * const usuario_perfil_tipo = await prisma.usuario_perfil_tipo.upsert({
     *   create: {
     *     // ... data to create a Usuario_perfil_tipo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario_perfil_tipo we want to update
     *   }
     * })
    **/
    upsert<T extends usuario_perfil_tipoUpsertArgs>(
      args: SelectSubset<T, usuario_perfil_tipoUpsertArgs>
    ): Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T>>

    /**
     * Find one Usuario_perfil_tipo that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {usuario_perfil_tipoFindUniqueOrThrowArgs} args - Arguments to find a Usuario_perfil_tipo
     * @example
     * // Get one Usuario_perfil_tipo
     * const usuario_perfil_tipo = await prisma.usuario_perfil_tipo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usuario_perfil_tipoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usuario_perfil_tipoFindUniqueOrThrowArgs>
    ): Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T>>

    /**
     * Find the first Usuario_perfil_tipo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_perfil_tipoFindFirstOrThrowArgs} args - Arguments to find a Usuario_perfil_tipo
     * @example
     * // Get one Usuario_perfil_tipo
     * const usuario_perfil_tipo = await prisma.usuario_perfil_tipo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usuario_perfil_tipoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usuario_perfil_tipoFindFirstOrThrowArgs>
    ): Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T>>

    /**
     * Count the number of Usuario_perfil_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_perfil_tipoCountArgs} args - Arguments to filter Usuario_perfil_tipos to count.
     * @example
     * // Count the number of Usuario_perfil_tipos
     * const count = await prisma.usuario_perfil_tipo.count({
     *   where: {
     *     // ... the filter for the Usuario_perfil_tipos we want to count
     *   }
     * })
    **/
    count<T extends usuario_perfil_tipoCountArgs>(
      args?: Subset<T, usuario_perfil_tipoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Usuario_perfil_tipoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario_perfil_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Usuario_perfil_tipoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Usuario_perfil_tipoAggregateArgs>(args: Subset<T, Usuario_perfil_tipoAggregateArgs>): PrismaPromise<GetUsuario_perfil_tipoAggregateType<T>>

    /**
     * Group by Usuario_perfil_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Usuario_perfil_tipoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Usuario_perfil_tipoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Usuario_perfil_tipoGroupByArgs['orderBy'] }
        : { orderBy?: Usuario_perfil_tipoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Usuario_perfil_tipoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuario_perfil_tipoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario_perfil_tipo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usuario_perfil_tipoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    usuario_x_perfil<T extends usuario_x_perfilFindManyArgs= {}>(args?: Subset<T, usuario_x_perfilFindManyArgs>): PrismaPromise<Array<usuario_x_perfilGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * usuario_perfil_tipo base type for findUnique actions
   */
  export type usuario_perfil_tipoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the usuario_perfil_tipo
     * 
    **/
    select?: usuario_perfil_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfil_tipoInclude | null
    /**
     * Filter, which usuario_perfil_tipo to fetch.
     * 
    **/
    where: usuario_perfil_tipoWhereUniqueInput
  }

  /**
   * usuario_perfil_tipo: findUnique
   */
  export interface usuario_perfil_tipoFindUniqueArgs extends usuario_perfil_tipoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario_perfil_tipo base type for findFirst actions
   */
  export type usuario_perfil_tipoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the usuario_perfil_tipo
     * 
    **/
    select?: usuario_perfil_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfil_tipoInclude | null
    /**
     * Filter, which usuario_perfil_tipo to fetch.
     * 
    **/
    where?: usuario_perfil_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_perfil_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario_perfil_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuario_perfil_tipos.
     * 
    **/
    cursor?: usuario_perfil_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_perfil_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_perfil_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuario_perfil_tipos.
     * 
    **/
    distinct?: Enumerable<Usuario_perfil_tipoScalarFieldEnum>
  }

  /**
   * usuario_perfil_tipo: findFirst
   */
  export interface usuario_perfil_tipoFindFirstArgs extends usuario_perfil_tipoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario_perfil_tipo findMany
   */
  export type usuario_perfil_tipoFindManyArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil_tipo
     * 
    **/
    select?: usuario_perfil_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfil_tipoInclude | null
    /**
     * Filter, which usuario_perfil_tipos to fetch.
     * 
    **/
    where?: usuario_perfil_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_perfil_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario_perfil_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuario_perfil_tipos.
     * 
    **/
    cursor?: usuario_perfil_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_perfil_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_perfil_tipos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Usuario_perfil_tipoScalarFieldEnum>
  }


  /**
   * usuario_perfil_tipo create
   */
  export type usuario_perfil_tipoCreateArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil_tipo
     * 
    **/
    select?: usuario_perfil_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfil_tipoInclude | null
    /**
     * The data needed to create a usuario_perfil_tipo.
     * 
    **/
    data: XOR<usuario_perfil_tipoCreateInput, usuario_perfil_tipoUncheckedCreateInput>
  }


  /**
   * usuario_perfil_tipo createMany
   */
  export type usuario_perfil_tipoCreateManyArgs = {
    /**
     * The data used to create many usuario_perfil_tipos.
     * 
    **/
    data: Enumerable<usuario_perfil_tipoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * usuario_perfil_tipo update
   */
  export type usuario_perfil_tipoUpdateArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil_tipo
     * 
    **/
    select?: usuario_perfil_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfil_tipoInclude | null
    /**
     * The data needed to update a usuario_perfil_tipo.
     * 
    **/
    data: XOR<usuario_perfil_tipoUpdateInput, usuario_perfil_tipoUncheckedUpdateInput>
    /**
     * Choose, which usuario_perfil_tipo to update.
     * 
    **/
    where: usuario_perfil_tipoWhereUniqueInput
  }


  /**
   * usuario_perfil_tipo updateMany
   */
  export type usuario_perfil_tipoUpdateManyArgs = {
    /**
     * The data used to update usuario_perfil_tipos.
     * 
    **/
    data: XOR<usuario_perfil_tipoUpdateManyMutationInput, usuario_perfil_tipoUncheckedUpdateManyInput>
    /**
     * Filter which usuario_perfil_tipos to update
     * 
    **/
    where?: usuario_perfil_tipoWhereInput
  }


  /**
   * usuario_perfil_tipo upsert
   */
  export type usuario_perfil_tipoUpsertArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil_tipo
     * 
    **/
    select?: usuario_perfil_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfil_tipoInclude | null
    /**
     * The filter to search for the usuario_perfil_tipo to update in case it exists.
     * 
    **/
    where: usuario_perfil_tipoWhereUniqueInput
    /**
     * In case the usuario_perfil_tipo found by the `where` argument doesn't exist, create a new usuario_perfil_tipo with this data.
     * 
    **/
    create: XOR<usuario_perfil_tipoCreateInput, usuario_perfil_tipoUncheckedCreateInput>
    /**
     * In case the usuario_perfil_tipo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<usuario_perfil_tipoUpdateInput, usuario_perfil_tipoUncheckedUpdateInput>
  }


  /**
   * usuario_perfil_tipo delete
   */
  export type usuario_perfil_tipoDeleteArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil_tipo
     * 
    **/
    select?: usuario_perfil_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfil_tipoInclude | null
    /**
     * Filter which usuario_perfil_tipo to delete.
     * 
    **/
    where: usuario_perfil_tipoWhereUniqueInput
  }


  /**
   * usuario_perfil_tipo deleteMany
   */
  export type usuario_perfil_tipoDeleteManyArgs = {
    /**
     * Filter which usuario_perfil_tipos to delete
     * 
    **/
    where?: usuario_perfil_tipoWhereInput
  }


  /**
   * usuario_perfil_tipo: findUniqueOrThrow
   */
  export type usuario_perfil_tipoFindUniqueOrThrowArgs = usuario_perfil_tipoFindUniqueArgsBase
      

  /**
   * usuario_perfil_tipo: findFirstOrThrow
   */
  export type usuario_perfil_tipoFindFirstOrThrowArgs = usuario_perfil_tipoFindFirstArgsBase
      

  /**
   * usuario_perfil_tipo without action
   */
  export type usuario_perfil_tipoArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil_tipo
     * 
    **/
    select?: usuario_perfil_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfil_tipoInclude | null
  }



  /**
   * Model usuario_x_perfil
   */


  export type AggregateUsuario_x_perfil = {
    _count: Usuario_x_perfilCountAggregateOutputType | null
    _avg: Usuario_x_perfilAvgAggregateOutputType | null
    _sum: Usuario_x_perfilSumAggregateOutputType | null
    _min: Usuario_x_perfilMinAggregateOutputType | null
    _max: Usuario_x_perfilMaxAggregateOutputType | null
  }

  export type Usuario_x_perfilAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    usuario_perfil_id: number | null
  }

  export type Usuario_x_perfilSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    usuario_perfil_id: number | null
  }

  export type Usuario_x_perfilMinAggregateOutputType = {
    id: number | null
    senha: string | null
    usuario_id: number | null
    usuario_perfil_id: number | null
  }

  export type Usuario_x_perfilMaxAggregateOutputType = {
    id: number | null
    senha: string | null
    usuario_id: number | null
    usuario_perfil_id: number | null
  }

  export type Usuario_x_perfilCountAggregateOutputType = {
    id: number
    senha: number
    usuario_id: number
    usuario_perfil_id: number
    _all: number
  }


  export type Usuario_x_perfilAvgAggregateInputType = {
    id?: true
    usuario_id?: true
    usuario_perfil_id?: true
  }

  export type Usuario_x_perfilSumAggregateInputType = {
    id?: true
    usuario_id?: true
    usuario_perfil_id?: true
  }

  export type Usuario_x_perfilMinAggregateInputType = {
    id?: true
    senha?: true
    usuario_id?: true
    usuario_perfil_id?: true
  }

  export type Usuario_x_perfilMaxAggregateInputType = {
    id?: true
    senha?: true
    usuario_id?: true
    usuario_perfil_id?: true
  }

  export type Usuario_x_perfilCountAggregateInputType = {
    id?: true
    senha?: true
    usuario_id?: true
    usuario_perfil_id?: true
    _all?: true
  }

  export type Usuario_x_perfilAggregateArgs = {
    /**
     * Filter which usuario_x_perfil to aggregate.
     * 
    **/
    where?: usuario_x_perfilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_x_perfils to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario_x_perfilOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: usuario_x_perfilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_x_perfils from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_x_perfils.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuario_x_perfils
    **/
    _count?: true | Usuario_x_perfilCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Usuario_x_perfilAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Usuario_x_perfilSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Usuario_x_perfilMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Usuario_x_perfilMaxAggregateInputType
  }

  export type GetUsuario_x_perfilAggregateType<T extends Usuario_x_perfilAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario_x_perfil]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario_x_perfil[P]>
      : GetScalarType<T[P], AggregateUsuario_x_perfil[P]>
  }




  export type Usuario_x_perfilGroupByArgs = {
    where?: usuario_x_perfilWhereInput
    orderBy?: Enumerable<usuario_x_perfilOrderByWithAggregationInput>
    by: Array<Usuario_x_perfilScalarFieldEnum>
    having?: usuario_x_perfilScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Usuario_x_perfilCountAggregateInputType | true
    _avg?: Usuario_x_perfilAvgAggregateInputType
    _sum?: Usuario_x_perfilSumAggregateInputType
    _min?: Usuario_x_perfilMinAggregateInputType
    _max?: Usuario_x_perfilMaxAggregateInputType
  }


  export type Usuario_x_perfilGroupByOutputType = {
    id: number
    senha: string
    usuario_id: number
    usuario_perfil_id: number
    _count: Usuario_x_perfilCountAggregateOutputType | null
    _avg: Usuario_x_perfilAvgAggregateOutputType | null
    _sum: Usuario_x_perfilSumAggregateOutputType | null
    _min: Usuario_x_perfilMinAggregateOutputType | null
    _max: Usuario_x_perfilMaxAggregateOutputType | null
  }

  type GetUsuario_x_perfilGroupByPayload<T extends Usuario_x_perfilGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Usuario_x_perfilGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Usuario_x_perfilGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Usuario_x_perfilGroupByOutputType[P]>
            : GetScalarType<T[P], Usuario_x_perfilGroupByOutputType[P]>
        }
      >
    >


  export type usuario_x_perfilSelect = {
    id?: boolean
    senha?: boolean
    usuario_id?: boolean
    usuario_perfil_id?: boolean
    usuario?: boolean | usuarioArgs
    usuario_perfil_tipo?: boolean | usuario_perfil_tipoArgs
  }


  export type usuario_x_perfilInclude = {
    usuario?: boolean | usuarioArgs
    usuario_perfil_tipo?: boolean | usuario_perfil_tipoArgs
  } 

  export type usuario_x_perfilGetPayload<S extends boolean | null | undefined | usuario_x_perfilArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? usuario_x_perfil :
    S extends undefined ? never :
    S extends { include: any } & (usuario_x_perfilArgs | usuario_x_perfilFindManyArgs)
    ? usuario_x_perfil  & {
    [P in TrueKeys<S['include']>]:
        P extends 'usuario' ? usuarioGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'usuario_perfil_tipo' ? usuario_perfil_tipoGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (usuario_x_perfilArgs | usuario_x_perfilFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'usuario' ? usuarioGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'usuario_perfil_tipo' ? usuario_perfil_tipoGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof usuario_x_perfil ? usuario_x_perfil[P] : never
  } 
      : usuario_x_perfil


  type usuario_x_perfilCountArgs = Merge<
    Omit<usuario_x_perfilFindManyArgs, 'select' | 'include'> & {
      select?: Usuario_x_perfilCountAggregateInputType | true
    }
  >

  export interface usuario_x_perfilDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Usuario_x_perfil that matches the filter.
     * @param {usuario_x_perfilFindUniqueArgs} args - Arguments to find a Usuario_x_perfil
     * @example
     * // Get one Usuario_x_perfil
     * const usuario_x_perfil = await prisma.usuario_x_perfil.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usuario_x_perfilFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usuario_x_perfilFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'usuario_x_perfil'> extends True ? Prisma__usuario_x_perfilClient<usuario_x_perfilGetPayload<T>> : Prisma__usuario_x_perfilClient<usuario_x_perfilGetPayload<T> | null, null>

    /**
     * Find the first Usuario_x_perfil that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_x_perfilFindFirstArgs} args - Arguments to find a Usuario_x_perfil
     * @example
     * // Get one Usuario_x_perfil
     * const usuario_x_perfil = await prisma.usuario_x_perfil.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usuario_x_perfilFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usuario_x_perfilFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'usuario_x_perfil'> extends True ? Prisma__usuario_x_perfilClient<usuario_x_perfilGetPayload<T>> : Prisma__usuario_x_perfilClient<usuario_x_perfilGetPayload<T> | null, null>

    /**
     * Find zero or more Usuario_x_perfils that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_x_perfilFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuario_x_perfils
     * const usuario_x_perfils = await prisma.usuario_x_perfil.findMany()
     * 
     * // Get first 10 Usuario_x_perfils
     * const usuario_x_perfils = await prisma.usuario_x_perfil.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuario_x_perfilWithIdOnly = await prisma.usuario_x_perfil.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usuario_x_perfilFindManyArgs>(
      args?: SelectSubset<T, usuario_x_perfilFindManyArgs>
    ): PrismaPromise<Array<usuario_x_perfilGetPayload<T>>>

    /**
     * Create a Usuario_x_perfil.
     * @param {usuario_x_perfilCreateArgs} args - Arguments to create a Usuario_x_perfil.
     * @example
     * // Create one Usuario_x_perfil
     * const Usuario_x_perfil = await prisma.usuario_x_perfil.create({
     *   data: {
     *     // ... data to create a Usuario_x_perfil
     *   }
     * })
     * 
    **/
    create<T extends usuario_x_perfilCreateArgs>(
      args: SelectSubset<T, usuario_x_perfilCreateArgs>
    ): Prisma__usuario_x_perfilClient<usuario_x_perfilGetPayload<T>>

    /**
     * Create many Usuario_x_perfils.
     *     @param {usuario_x_perfilCreateManyArgs} args - Arguments to create many Usuario_x_perfils.
     *     @example
     *     // Create many Usuario_x_perfils
     *     const usuario_x_perfil = await prisma.usuario_x_perfil.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usuario_x_perfilCreateManyArgs>(
      args?: SelectSubset<T, usuario_x_perfilCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario_x_perfil.
     * @param {usuario_x_perfilDeleteArgs} args - Arguments to delete one Usuario_x_perfil.
     * @example
     * // Delete one Usuario_x_perfil
     * const Usuario_x_perfil = await prisma.usuario_x_perfil.delete({
     *   where: {
     *     // ... filter to delete one Usuario_x_perfil
     *   }
     * })
     * 
    **/
    delete<T extends usuario_x_perfilDeleteArgs>(
      args: SelectSubset<T, usuario_x_perfilDeleteArgs>
    ): Prisma__usuario_x_perfilClient<usuario_x_perfilGetPayload<T>>

    /**
     * Update one Usuario_x_perfil.
     * @param {usuario_x_perfilUpdateArgs} args - Arguments to update one Usuario_x_perfil.
     * @example
     * // Update one Usuario_x_perfil
     * const usuario_x_perfil = await prisma.usuario_x_perfil.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usuario_x_perfilUpdateArgs>(
      args: SelectSubset<T, usuario_x_perfilUpdateArgs>
    ): Prisma__usuario_x_perfilClient<usuario_x_perfilGetPayload<T>>

    /**
     * Delete zero or more Usuario_x_perfils.
     * @param {usuario_x_perfilDeleteManyArgs} args - Arguments to filter Usuario_x_perfils to delete.
     * @example
     * // Delete a few Usuario_x_perfils
     * const { count } = await prisma.usuario_x_perfil.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usuario_x_perfilDeleteManyArgs>(
      args?: SelectSubset<T, usuario_x_perfilDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuario_x_perfils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_x_perfilUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuario_x_perfils
     * const usuario_x_perfil = await prisma.usuario_x_perfil.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usuario_x_perfilUpdateManyArgs>(
      args: SelectSubset<T, usuario_x_perfilUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario_x_perfil.
     * @param {usuario_x_perfilUpsertArgs} args - Arguments to update or create a Usuario_x_perfil.
     * @example
     * // Update or create a Usuario_x_perfil
     * const usuario_x_perfil = await prisma.usuario_x_perfil.upsert({
     *   create: {
     *     // ... data to create a Usuario_x_perfil
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario_x_perfil we want to update
     *   }
     * })
    **/
    upsert<T extends usuario_x_perfilUpsertArgs>(
      args: SelectSubset<T, usuario_x_perfilUpsertArgs>
    ): Prisma__usuario_x_perfilClient<usuario_x_perfilGetPayload<T>>

    /**
     * Find one Usuario_x_perfil that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {usuario_x_perfilFindUniqueOrThrowArgs} args - Arguments to find a Usuario_x_perfil
     * @example
     * // Get one Usuario_x_perfil
     * const usuario_x_perfil = await prisma.usuario_x_perfil.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usuario_x_perfilFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usuario_x_perfilFindUniqueOrThrowArgs>
    ): Prisma__usuario_x_perfilClient<usuario_x_perfilGetPayload<T>>

    /**
     * Find the first Usuario_x_perfil that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_x_perfilFindFirstOrThrowArgs} args - Arguments to find a Usuario_x_perfil
     * @example
     * // Get one Usuario_x_perfil
     * const usuario_x_perfil = await prisma.usuario_x_perfil.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usuario_x_perfilFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usuario_x_perfilFindFirstOrThrowArgs>
    ): Prisma__usuario_x_perfilClient<usuario_x_perfilGetPayload<T>>

    /**
     * Count the number of Usuario_x_perfils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_x_perfilCountArgs} args - Arguments to filter Usuario_x_perfils to count.
     * @example
     * // Count the number of Usuario_x_perfils
     * const count = await prisma.usuario_x_perfil.count({
     *   where: {
     *     // ... the filter for the Usuario_x_perfils we want to count
     *   }
     * })
    **/
    count<T extends usuario_x_perfilCountArgs>(
      args?: Subset<T, usuario_x_perfilCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Usuario_x_perfilCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario_x_perfil.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Usuario_x_perfilAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Usuario_x_perfilAggregateArgs>(args: Subset<T, Usuario_x_perfilAggregateArgs>): PrismaPromise<GetUsuario_x_perfilAggregateType<T>>

    /**
     * Group by Usuario_x_perfil.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Usuario_x_perfilGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Usuario_x_perfilGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Usuario_x_perfilGroupByArgs['orderBy'] }
        : { orderBy?: Usuario_x_perfilGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Usuario_x_perfilGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuario_x_perfilGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario_x_perfil.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usuario_x_perfilClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    usuario<T extends usuarioArgs= {}>(args?: Subset<T, usuarioArgs>): Prisma__usuarioClient<usuarioGetPayload<T> | Null>;

    usuario_perfil_tipo<T extends usuario_perfil_tipoArgs= {}>(args?: Subset<T, usuario_perfil_tipoArgs>): Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * usuario_x_perfil base type for findUnique actions
   */
  export type usuario_x_perfilFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the usuario_x_perfil
     * 
    **/
    select?: usuario_x_perfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_x_perfilInclude | null
    /**
     * Filter, which usuario_x_perfil to fetch.
     * 
    **/
    where: usuario_x_perfilWhereUniqueInput
  }

  /**
   * usuario_x_perfil: findUnique
   */
  export interface usuario_x_perfilFindUniqueArgs extends usuario_x_perfilFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario_x_perfil base type for findFirst actions
   */
  export type usuario_x_perfilFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the usuario_x_perfil
     * 
    **/
    select?: usuario_x_perfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_x_perfilInclude | null
    /**
     * Filter, which usuario_x_perfil to fetch.
     * 
    **/
    where?: usuario_x_perfilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_x_perfils to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario_x_perfilOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuario_x_perfils.
     * 
    **/
    cursor?: usuario_x_perfilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_x_perfils from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_x_perfils.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuario_x_perfils.
     * 
    **/
    distinct?: Enumerable<Usuario_x_perfilScalarFieldEnum>
  }

  /**
   * usuario_x_perfil: findFirst
   */
  export interface usuario_x_perfilFindFirstArgs extends usuario_x_perfilFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario_x_perfil findMany
   */
  export type usuario_x_perfilFindManyArgs = {
    /**
     * Select specific fields to fetch from the usuario_x_perfil
     * 
    **/
    select?: usuario_x_perfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_x_perfilInclude | null
    /**
     * Filter, which usuario_x_perfils to fetch.
     * 
    **/
    where?: usuario_x_perfilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_x_perfils to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario_x_perfilOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuario_x_perfils.
     * 
    **/
    cursor?: usuario_x_perfilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_x_perfils from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_x_perfils.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Usuario_x_perfilScalarFieldEnum>
  }


  /**
   * usuario_x_perfil create
   */
  export type usuario_x_perfilCreateArgs = {
    /**
     * Select specific fields to fetch from the usuario_x_perfil
     * 
    **/
    select?: usuario_x_perfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_x_perfilInclude | null
    /**
     * The data needed to create a usuario_x_perfil.
     * 
    **/
    data: XOR<usuario_x_perfilCreateInput, usuario_x_perfilUncheckedCreateInput>
  }


  /**
   * usuario_x_perfil createMany
   */
  export type usuario_x_perfilCreateManyArgs = {
    /**
     * The data used to create many usuario_x_perfils.
     * 
    **/
    data: Enumerable<usuario_x_perfilCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * usuario_x_perfil update
   */
  export type usuario_x_perfilUpdateArgs = {
    /**
     * Select specific fields to fetch from the usuario_x_perfil
     * 
    **/
    select?: usuario_x_perfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_x_perfilInclude | null
    /**
     * The data needed to update a usuario_x_perfil.
     * 
    **/
    data: XOR<usuario_x_perfilUpdateInput, usuario_x_perfilUncheckedUpdateInput>
    /**
     * Choose, which usuario_x_perfil to update.
     * 
    **/
    where: usuario_x_perfilWhereUniqueInput
  }


  /**
   * usuario_x_perfil updateMany
   */
  export type usuario_x_perfilUpdateManyArgs = {
    /**
     * The data used to update usuario_x_perfils.
     * 
    **/
    data: XOR<usuario_x_perfilUpdateManyMutationInput, usuario_x_perfilUncheckedUpdateManyInput>
    /**
     * Filter which usuario_x_perfils to update
     * 
    **/
    where?: usuario_x_perfilWhereInput
  }


  /**
   * usuario_x_perfil upsert
   */
  export type usuario_x_perfilUpsertArgs = {
    /**
     * Select specific fields to fetch from the usuario_x_perfil
     * 
    **/
    select?: usuario_x_perfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_x_perfilInclude | null
    /**
     * The filter to search for the usuario_x_perfil to update in case it exists.
     * 
    **/
    where: usuario_x_perfilWhereUniqueInput
    /**
     * In case the usuario_x_perfil found by the `where` argument doesn't exist, create a new usuario_x_perfil with this data.
     * 
    **/
    create: XOR<usuario_x_perfilCreateInput, usuario_x_perfilUncheckedCreateInput>
    /**
     * In case the usuario_x_perfil was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<usuario_x_perfilUpdateInput, usuario_x_perfilUncheckedUpdateInput>
  }


  /**
   * usuario_x_perfil delete
   */
  export type usuario_x_perfilDeleteArgs = {
    /**
     * Select specific fields to fetch from the usuario_x_perfil
     * 
    **/
    select?: usuario_x_perfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_x_perfilInclude | null
    /**
     * Filter which usuario_x_perfil to delete.
     * 
    **/
    where: usuario_x_perfilWhereUniqueInput
  }


  /**
   * usuario_x_perfil deleteMany
   */
  export type usuario_x_perfilDeleteManyArgs = {
    /**
     * Filter which usuario_x_perfils to delete
     * 
    **/
    where?: usuario_x_perfilWhereInput
  }


  /**
   * usuario_x_perfil: findUniqueOrThrow
   */
  export type usuario_x_perfilFindUniqueOrThrowArgs = usuario_x_perfilFindUniqueArgsBase
      

  /**
   * usuario_x_perfil: findFirstOrThrow
   */
  export type usuario_x_perfilFindFirstOrThrowArgs = usuario_x_perfilFindFirstArgsBase
      

  /**
   * usuario_x_perfil without action
   */
  export type usuario_x_perfilArgs = {
    /**
     * Select specific fields to fetch from the usuario_x_perfil
     * 
    **/
    select?: usuario_x_perfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_x_perfilInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AuditoriaScalarFieldEnum: {
    action: 'action',
    usuario: 'usuario',
    data: 'data',
    modulo: 'modulo',
    id: 'id'
  };

  export type AuditoriaScalarFieldEnum = (typeof AuditoriaScalarFieldEnum)[keyof typeof AuditoriaScalarFieldEnum]


  export const BorderoScalarFieldEnum: {
    id: 'id',
    carteira_id: 'carteira_id'
  };

  export type BorderoScalarFieldEnum = (typeof BorderoScalarFieldEnum)[keyof typeof BorderoScalarFieldEnum]


  export const CarteiraScalarFieldEnum: {
    id: 'id',
    fiduc_fundo_id: 'fiduc_fundo_id'
  };

  export type CarteiraScalarFieldEnum = (typeof CarteiraScalarFieldEnum)[keyof typeof CarteiraScalarFieldEnum]


  export const CedenteScalarFieldEnum: {
    id: 'id',
    pessoa_id: 'pessoa_id',
    razao_social: 'razao_social',
    nome_fantasia: 'nome_fantasia',
    abertura: 'abertura',
    cnpj: 'cnpj',
    endereco: 'endereco',
    numero: 'numero',
    cep: 'cep',
    bairro: 'bairro',
    cidade: 'cidade',
    uf: 'uf',
    telefone: 'telefone'
  };

  export type CedenteScalarFieldEnum = (typeof CedenteScalarFieldEnum)[keyof typeof CedenteScalarFieldEnum]


  export const Cedente_analiseScalarFieldEnum: {
    id: 'id',
    status: 'status',
    cedente: 'cedente'
  };

  export type Cedente_analiseScalarFieldEnum = (typeof Cedente_analiseScalarFieldEnum)[keyof typeof Cedente_analiseScalarFieldEnum]


  export const Cedente_n_sacadosScalarFieldEnum: {
    id: 'id',
    cedente: 'cedente',
    sacado: 'sacado'
  };

  export type Cedente_n_sacadosScalarFieldEnum = (typeof Cedente_n_sacadosScalarFieldEnum)[keyof typeof Cedente_n_sacadosScalarFieldEnum]


  export const ChecagemScalarFieldEnum: {
    id: 'id',
    nf: 'nf',
    status: 'status',
    usuario: 'usuario',
    titulos: 'titulos'
  };

  export type ChecagemScalarFieldEnum = (typeof ChecagemScalarFieldEnum)[keyof typeof ChecagemScalarFieldEnum]


  export const Fidic_fundoScalarFieldEnum: {
    id: 'id',
    pessoa_id: 'pessoa_id',
    razao_social: 'razao_social',
    nome_fantasia: 'nome_fantasia',
    abertura: 'abertura',
    cnpj: 'cnpj'
  };

  export type Fidic_fundoScalarFieldEnum = (typeof Fidic_fundoScalarFieldEnum)[keyof typeof Fidic_fundoScalarFieldEnum]


  export const Fidic_fundo_carteira_n_cedentesScalarFieldEnum: {
    id: 'id'
  };

  export type Fidic_fundo_carteira_n_cedentesScalarFieldEnum = (typeof Fidic_fundo_carteira_n_cedentesScalarFieldEnum)[keyof typeof Fidic_fundo_carteira_n_cedentesScalarFieldEnum]


  export const Fidic_fundo_x_usuarioScalarFieldEnum: {
    id: 'id',
    usuario: 'usuario',
    fidic: 'fidic'
  };

  export type Fidic_fundo_x_usuarioScalarFieldEnum = (typeof Fidic_fundo_x_usuarioScalarFieldEnum)[keyof typeof Fidic_fundo_x_usuarioScalarFieldEnum]


  export const OrganogramaScalarFieldEnum: {
    id: 'id'
  };

  export type OrganogramaScalarFieldEnum = (typeof OrganogramaScalarFieldEnum)[keyof typeof OrganogramaScalarFieldEnum]


  export const Organograma_tipoScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type Organograma_tipoScalarFieldEnum = (typeof Organograma_tipoScalarFieldEnum)[keyof typeof Organograma_tipoScalarFieldEnum]


  export const Organograma_x_regiaoScalarFieldEnum: {
    id: 'id',
    organograma_id: 'organograma_id',
    regiao_id: 'regiao_id'
  };

  export type Organograma_x_regiaoScalarFieldEnum = (typeof Organograma_x_regiaoScalarFieldEnum)[keyof typeof Organograma_x_regiaoScalarFieldEnum]


  export const Organograma_x_regiao_atuacaoScalarFieldEnum: {
    id: 'id',
    organograma_id: 'organograma_id',
    regiao_id: 'regiao_id'
  };

  export type Organograma_x_regiao_atuacaoScalarFieldEnum = (typeof Organograma_x_regiao_atuacaoScalarFieldEnum)[keyof typeof Organograma_x_regiao_atuacaoScalarFieldEnum]


  export const PessoaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    sobrenome: 'sobrenome',
    sexo: 'sexo',
    nascimento: 'nascimento',
    cpf: 'cpf',
    rg: 'rg'
  };

  export type PessoaScalarFieldEnum = (typeof PessoaScalarFieldEnum)[keyof typeof PessoaScalarFieldEnum]


  export const PlataformaScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type PlataformaScalarFieldEnum = (typeof PlataformaScalarFieldEnum)[keyof typeof PlataformaScalarFieldEnum]


  export const Plataforma_n_borderosScalarFieldEnum: {
    id: 'id'
  };

  export type Plataforma_n_borderosScalarFieldEnum = (typeof Plataforma_n_borderosScalarFieldEnum)[keyof typeof Plataforma_n_borderosScalarFieldEnum]


  export const Plataforma_papel_tipoScalarFieldEnum: {
    id: 'id'
  };

  export type Plataforma_papel_tipoScalarFieldEnum = (typeof Plataforma_papel_tipoScalarFieldEnum)[keyof typeof Plataforma_papel_tipoScalarFieldEnum]


  export const Plataforma_papel_x_pessoaScalarFieldEnum: {
    id: 'id'
  };

  export type Plataforma_papel_x_pessoaScalarFieldEnum = (typeof Plataforma_papel_x_pessoaScalarFieldEnum)[keyof typeof Plataforma_papel_x_pessoaScalarFieldEnum]


  export const Plataforma_x_regiao_atuacaoScalarFieldEnum: {
    id: 'id'
  };

  export type Plataforma_x_regiao_atuacaoScalarFieldEnum = (typeof Plataforma_x_regiao_atuacaoScalarFieldEnum)[keyof typeof Plataforma_x_regiao_atuacaoScalarFieldEnum]


  export const Regiao_atuacaoScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type Regiao_atuacaoScalarFieldEnum = (typeof Regiao_atuacaoScalarFieldEnum)[keyof typeof Regiao_atuacaoScalarFieldEnum]


  export const Regiao_atuacao_tipoScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type Regiao_atuacao_tipoScalarFieldEnum = (typeof Regiao_atuacao_tipoScalarFieldEnum)[keyof typeof Regiao_atuacao_tipoScalarFieldEnum]


  export const SacadoScalarFieldEnum: {
    id: 'id',
    pessoa_id: 'pessoa_id',
    razao_social: 'razao_social',
    nome_fantasia: 'nome_fantasia',
    abertura: 'abertura',
    cnpj: 'cnpj'
  };

  export type SacadoScalarFieldEnum = (typeof SacadoScalarFieldEnum)[keyof typeof SacadoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TituloScalarFieldEnum: {
    id: 'id',
    titulo_tipo_id: 'titulo_tipo_id',
    bordero_id: 'bordero_id',
    nf: 'nf',
    valor: 'valor',
    vencimento: 'vencimento',
    numero: 'numero',
    emissao: 'emissao',
    parcela: 'parcela'
  };

  export type TituloScalarFieldEnum = (typeof TituloScalarFieldEnum)[keyof typeof TituloScalarFieldEnum]


  export const Titulo_tipoScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type Titulo_tipoScalarFieldEnum = (typeof Titulo_tipoScalarFieldEnum)[keyof typeof Titulo_tipoScalarFieldEnum]


  export const Titulo_x_cedenteScalarFieldEnum: {
    id: 'id',
    cedente: 'cedente'
  };

  export type Titulo_x_cedenteScalarFieldEnum = (typeof Titulo_x_cedenteScalarFieldEnum)[keyof typeof Titulo_x_cedenteScalarFieldEnum]


  export const Titulo_x_empresaScalarFieldEnum: {
    id: 'id'
  };

  export type Titulo_x_empresaScalarFieldEnum = (typeof Titulo_x_empresaScalarFieldEnum)[keyof typeof Titulo_x_empresaScalarFieldEnum]


  export const Titulo_x_plataformaScalarFieldEnum: {
    id: 'id'
  };

  export type Titulo_x_plataformaScalarFieldEnum = (typeof Titulo_x_plataformaScalarFieldEnum)[keyof typeof Titulo_x_plataformaScalarFieldEnum]


  export const Titulos_x_usuarioScalarFieldEnum: {
    id: 'id',
    usuario: 'usuario',
    bordero: 'bordero',
    status: 'status'
  };

  export type Titulos_x_usuarioScalarFieldEnum = (typeof Titulos_x_usuarioScalarFieldEnum)[keyof typeof Titulos_x_usuarioScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    email: 'email',
    senha: 'senha',
    pessoa_id: 'pessoa_id',
    status: 'status',
    primeiro_acesso: 'primeiro_acesso',
    confirmou_cadastro: 'confirmou_cadastro',
    codigo_confirma_cadastro: 'codigo_confirma_cadastro',
    codigo_reset_senha: 'codigo_reset_senha',
    codigo_data_expiracao: 'codigo_data_expiracao',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const Usuario__pessoaScalarFieldEnum: {
    id: 'id'
  };

  export type Usuario__pessoaScalarFieldEnum = (typeof Usuario__pessoaScalarFieldEnum)[keyof typeof Usuario__pessoaScalarFieldEnum]


  export const Usuario_n_borderosScalarFieldEnum: {
    id: 'id'
  };

  export type Usuario_n_borderosScalarFieldEnum = (typeof Usuario_n_borderosScalarFieldEnum)[keyof typeof Usuario_n_borderosScalarFieldEnum]


  export const Usuario_perfil_tipoScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type Usuario_perfil_tipoScalarFieldEnum = (typeof Usuario_perfil_tipoScalarFieldEnum)[keyof typeof Usuario_perfil_tipoScalarFieldEnum]


  export const Usuario_x_perfilScalarFieldEnum: {
    id: 'id',
    senha: 'senha',
    usuario_id: 'usuario_id',
    usuario_perfil_id: 'usuario_perfil_id'
  };

  export type Usuario_x_perfilScalarFieldEnum = (typeof Usuario_x_perfilScalarFieldEnum)[keyof typeof Usuario_x_perfilScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type auditoriaWhereInput = {
    AND?: Enumerable<auditoriaWhereInput>
    OR?: Enumerable<auditoriaWhereInput>
    NOT?: Enumerable<auditoriaWhereInput>
    action?: StringNullableFilter | string | null
    usuario?: IntNullableFilter | number | null
    data?: DateTimeNullableFilter | Date | string | null
    modulo?: StringNullableFilter | string | null
    id?: IntFilter | number
    usuario_auditoriaTousuario?: XOR<UsuarioRelationFilter, usuarioWhereInput> | null
  }

  export type auditoriaOrderByWithRelationInput = {
    action?: SortOrder
    usuario?: SortOrder
    data?: SortOrder
    modulo?: SortOrder
    id?: SortOrder
    usuario_auditoriaTousuario?: usuarioOrderByWithRelationInput
  }

  export type auditoriaWhereUniqueInput = {
    id?: number
  }

  export type auditoriaOrderByWithAggregationInput = {
    action?: SortOrder
    usuario?: SortOrder
    data?: SortOrder
    modulo?: SortOrder
    id?: SortOrder
    _count?: auditoriaCountOrderByAggregateInput
    _avg?: auditoriaAvgOrderByAggregateInput
    _max?: auditoriaMaxOrderByAggregateInput
    _min?: auditoriaMinOrderByAggregateInput
    _sum?: auditoriaSumOrderByAggregateInput
  }

  export type auditoriaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<auditoriaScalarWhereWithAggregatesInput>
    OR?: Enumerable<auditoriaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<auditoriaScalarWhereWithAggregatesInput>
    action?: StringNullableWithAggregatesFilter | string | null
    usuario?: IntNullableWithAggregatesFilter | number | null
    data?: DateTimeNullableWithAggregatesFilter | Date | string | null
    modulo?: StringNullableWithAggregatesFilter | string | null
    id?: IntWithAggregatesFilter | number
  }

  export type borderoWhereInput = {
    AND?: Enumerable<borderoWhereInput>
    OR?: Enumerable<borderoWhereInput>
    NOT?: Enumerable<borderoWhereInput>
    id?: IntFilter | number
    carteira_id?: IntFilter | number
    titulo?: TituloListRelationFilter
    titulos_x_usuario?: Titulos_x_usuarioListRelationFilter
  }

  export type borderoOrderByWithRelationInput = {
    id?: SortOrder
    carteira_id?: SortOrder
    titulo?: tituloOrderByRelationAggregateInput
    titulos_x_usuario?: titulos_x_usuarioOrderByRelationAggregateInput
  }

  export type borderoWhereUniqueInput = {
    id?: number
  }

  export type borderoOrderByWithAggregationInput = {
    id?: SortOrder
    carteira_id?: SortOrder
    _count?: borderoCountOrderByAggregateInput
    _avg?: borderoAvgOrderByAggregateInput
    _max?: borderoMaxOrderByAggregateInput
    _min?: borderoMinOrderByAggregateInput
    _sum?: borderoSumOrderByAggregateInput
  }

  export type borderoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<borderoScalarWhereWithAggregatesInput>
    OR?: Enumerable<borderoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<borderoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    carteira_id?: IntWithAggregatesFilter | number
  }

  export type carteiraWhereInput = {
    AND?: Enumerable<carteiraWhereInput>
    OR?: Enumerable<carteiraWhereInput>
    NOT?: Enumerable<carteiraWhereInput>
    id?: IntFilter | number
    fiduc_fundo_id?: IntFilter | number
    fidic_fundo?: XOR<Fidic_fundoRelationFilter, fidic_fundoWhereInput>
  }

  export type carteiraOrderByWithRelationInput = {
    id?: SortOrder
    fiduc_fundo_id?: SortOrder
    fidic_fundo?: fidic_fundoOrderByWithRelationInput
  }

  export type carteiraWhereUniqueInput = {
    id?: number
  }

  export type carteiraOrderByWithAggregationInput = {
    id?: SortOrder
    fiduc_fundo_id?: SortOrder
    _count?: carteiraCountOrderByAggregateInput
    _avg?: carteiraAvgOrderByAggregateInput
    _max?: carteiraMaxOrderByAggregateInput
    _min?: carteiraMinOrderByAggregateInput
    _sum?: carteiraSumOrderByAggregateInput
  }

  export type carteiraScalarWhereWithAggregatesInput = {
    AND?: Enumerable<carteiraScalarWhereWithAggregatesInput>
    OR?: Enumerable<carteiraScalarWhereWithAggregatesInput>
    NOT?: Enumerable<carteiraScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fiduc_fundo_id?: IntWithAggregatesFilter | number
  }

  export type cedenteWhereInput = {
    AND?: Enumerable<cedenteWhereInput>
    OR?: Enumerable<cedenteWhereInput>
    NOT?: Enumerable<cedenteWhereInput>
    id?: IntFilter | number
    pessoa_id?: IntFilter | number
    razao_social?: StringFilter | string
    nome_fantasia?: StringNullableFilter | string | null
    abertura?: DateTimeNullableFilter | Date | string | null
    cnpj?: StringNullableFilter | string | null
    endereco?: StringNullableFilter | string | null
    numero?: StringNullableFilter | string | null
    cep?: StringNullableFilter | string | null
    bairro?: StringNullableFilter | string | null
    cidade?: StringNullableFilter | string | null
    uf?: StringNullableFilter | string | null
    telefone?: StringNullableFilter | string | null
    cedente_analise?: Cedente_analiseListRelationFilter
    cedente_n_sacados?: Cedente_n_sacadosListRelationFilter
    titulo_x_cedente?: Titulo_x_cedenteListRelationFilter
  }

  export type cedenteOrderByWithRelationInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrder
    numero?: SortOrder
    cep?: SortOrder
    bairro?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    telefone?: SortOrder
    cedente_analise?: cedente_analiseOrderByRelationAggregateInput
    cedente_n_sacados?: cedente_n_sacadosOrderByRelationAggregateInput
    titulo_x_cedente?: titulo_x_cedenteOrderByRelationAggregateInput
  }

  export type cedenteWhereUniqueInput = {
    id?: number
  }

  export type cedenteOrderByWithAggregationInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrder
    numero?: SortOrder
    cep?: SortOrder
    bairro?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    telefone?: SortOrder
    _count?: cedenteCountOrderByAggregateInput
    _avg?: cedenteAvgOrderByAggregateInput
    _max?: cedenteMaxOrderByAggregateInput
    _min?: cedenteMinOrderByAggregateInput
    _sum?: cedenteSumOrderByAggregateInput
  }

  export type cedenteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<cedenteScalarWhereWithAggregatesInput>
    OR?: Enumerable<cedenteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<cedenteScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    pessoa_id?: IntWithAggregatesFilter | number
    razao_social?: StringWithAggregatesFilter | string
    nome_fantasia?: StringNullableWithAggregatesFilter | string | null
    abertura?: DateTimeNullableWithAggregatesFilter | Date | string | null
    cnpj?: StringNullableWithAggregatesFilter | string | null
    endereco?: StringNullableWithAggregatesFilter | string | null
    numero?: StringNullableWithAggregatesFilter | string | null
    cep?: StringNullableWithAggregatesFilter | string | null
    bairro?: StringNullableWithAggregatesFilter | string | null
    cidade?: StringNullableWithAggregatesFilter | string | null
    uf?: StringNullableWithAggregatesFilter | string | null
    telefone?: StringNullableWithAggregatesFilter | string | null
  }

  export type cedente_analiseWhereInput = {
    AND?: Enumerable<cedente_analiseWhereInput>
    OR?: Enumerable<cedente_analiseWhereInput>
    NOT?: Enumerable<cedente_analiseWhereInput>
    id?: IntFilter | number
    status?: StringNullableFilter | string | null
    cedente?: IntNullableFilter | number | null
    cedente_cedenteTocedente_analise?: XOR<CedenteRelationFilter, cedenteWhereInput> | null
  }

  export type cedente_analiseOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    cedente?: SortOrder
    cedente_cedenteTocedente_analise?: cedenteOrderByWithRelationInput
  }

  export type cedente_analiseWhereUniqueInput = {
    id?: number
  }

  export type cedente_analiseOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    cedente?: SortOrder
    _count?: cedente_analiseCountOrderByAggregateInput
    _avg?: cedente_analiseAvgOrderByAggregateInput
    _max?: cedente_analiseMaxOrderByAggregateInput
    _min?: cedente_analiseMinOrderByAggregateInput
    _sum?: cedente_analiseSumOrderByAggregateInput
  }

  export type cedente_analiseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<cedente_analiseScalarWhereWithAggregatesInput>
    OR?: Enumerable<cedente_analiseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<cedente_analiseScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    status?: StringNullableWithAggregatesFilter | string | null
    cedente?: IntNullableWithAggregatesFilter | number | null
  }

  export type cedente_n_sacadosWhereInput = {
    AND?: Enumerable<cedente_n_sacadosWhereInput>
    OR?: Enumerable<cedente_n_sacadosWhereInput>
    NOT?: Enumerable<cedente_n_sacadosWhereInput>
    id?: IntFilter | number
    cedente?: IntNullableFilter | number | null
    sacado?: IntNullableFilter | number | null
    cedente_cedenteTocedente_n_sacados?: XOR<CedenteRelationFilter, cedenteWhereInput> | null
    sacado_cedente_n_sacadosTosacado?: XOR<SacadoRelationFilter, sacadoWhereInput> | null
  }

  export type cedente_n_sacadosOrderByWithRelationInput = {
    id?: SortOrder
    cedente?: SortOrder
    sacado?: SortOrder
    cedente_cedenteTocedente_n_sacados?: cedenteOrderByWithRelationInput
    sacado_cedente_n_sacadosTosacado?: sacadoOrderByWithRelationInput
  }

  export type cedente_n_sacadosWhereUniqueInput = {
    id?: number
  }

  export type cedente_n_sacadosOrderByWithAggregationInput = {
    id?: SortOrder
    cedente?: SortOrder
    sacado?: SortOrder
    _count?: cedente_n_sacadosCountOrderByAggregateInput
    _avg?: cedente_n_sacadosAvgOrderByAggregateInput
    _max?: cedente_n_sacadosMaxOrderByAggregateInput
    _min?: cedente_n_sacadosMinOrderByAggregateInput
    _sum?: cedente_n_sacadosSumOrderByAggregateInput
  }

  export type cedente_n_sacadosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<cedente_n_sacadosScalarWhereWithAggregatesInput>
    OR?: Enumerable<cedente_n_sacadosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<cedente_n_sacadosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    cedente?: IntNullableWithAggregatesFilter | number | null
    sacado?: IntNullableWithAggregatesFilter | number | null
  }

  export type checagemWhereInput = {
    AND?: Enumerable<checagemWhereInput>
    OR?: Enumerable<checagemWhereInput>
    NOT?: Enumerable<checagemWhereInput>
    id?: IntFilter | number
    nf?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    usuario?: IntNullableFilter | number | null
    titulos?: StringNullableFilter | string | null
    usuario_checagemTousuario?: XOR<UsuarioRelationFilter, usuarioWhereInput> | null
  }

  export type checagemOrderByWithRelationInput = {
    id?: SortOrder
    nf?: SortOrder
    status?: SortOrder
    usuario?: SortOrder
    titulos?: SortOrder
    usuario_checagemTousuario?: usuarioOrderByWithRelationInput
  }

  export type checagemWhereUniqueInput = {
    id?: number
  }

  export type checagemOrderByWithAggregationInput = {
    id?: SortOrder
    nf?: SortOrder
    status?: SortOrder
    usuario?: SortOrder
    titulos?: SortOrder
    _count?: checagemCountOrderByAggregateInput
    _avg?: checagemAvgOrderByAggregateInput
    _max?: checagemMaxOrderByAggregateInput
    _min?: checagemMinOrderByAggregateInput
    _sum?: checagemSumOrderByAggregateInput
  }

  export type checagemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<checagemScalarWhereWithAggregatesInput>
    OR?: Enumerable<checagemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<checagemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nf?: StringNullableWithAggregatesFilter | string | null
    status?: StringNullableWithAggregatesFilter | string | null
    usuario?: IntNullableWithAggregatesFilter | number | null
    titulos?: StringNullableWithAggregatesFilter | string | null
  }

  export type fidic_fundoWhereInput = {
    AND?: Enumerable<fidic_fundoWhereInput>
    OR?: Enumerable<fidic_fundoWhereInput>
    NOT?: Enumerable<fidic_fundoWhereInput>
    id?: IntFilter | number
    pessoa_id?: IntFilter | number
    razao_social?: StringFilter | string
    nome_fantasia?: StringNullableFilter | string | null
    abertura?: DateTimeNullableFilter | Date | string | null
    cnpj?: StringNullableFilter | string | null
    carteira?: CarteiraListRelationFilter
    fidic_fundo_x_usuario?: Fidic_fundo_x_usuarioListRelationFilter
  }

  export type fidic_fundoOrderByWithRelationInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    carteira?: carteiraOrderByRelationAggregateInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioOrderByRelationAggregateInput
  }

  export type fidic_fundoWhereUniqueInput = {
    id?: number
  }

  export type fidic_fundoOrderByWithAggregationInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    _count?: fidic_fundoCountOrderByAggregateInput
    _avg?: fidic_fundoAvgOrderByAggregateInput
    _max?: fidic_fundoMaxOrderByAggregateInput
    _min?: fidic_fundoMinOrderByAggregateInput
    _sum?: fidic_fundoSumOrderByAggregateInput
  }

  export type fidic_fundoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<fidic_fundoScalarWhereWithAggregatesInput>
    OR?: Enumerable<fidic_fundoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<fidic_fundoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    pessoa_id?: IntWithAggregatesFilter | number
    razao_social?: StringWithAggregatesFilter | string
    nome_fantasia?: StringNullableWithAggregatesFilter | string | null
    abertura?: DateTimeNullableWithAggregatesFilter | Date | string | null
    cnpj?: StringNullableWithAggregatesFilter | string | null
  }

  export type fidic_fundo_carteira_n_cedentesWhereInput = {
    AND?: Enumerable<fidic_fundo_carteira_n_cedentesWhereInput>
    OR?: Enumerable<fidic_fundo_carteira_n_cedentesWhereInput>
    NOT?: Enumerable<fidic_fundo_carteira_n_cedentesWhereInput>
    id?: IntFilter | number
  }

  export type fidic_fundo_carteira_n_cedentesOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type fidic_fundo_carteira_n_cedentesWhereUniqueInput = {
    id?: number
  }

  export type fidic_fundo_carteira_n_cedentesOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: fidic_fundo_carteira_n_cedentesCountOrderByAggregateInput
    _avg?: fidic_fundo_carteira_n_cedentesAvgOrderByAggregateInput
    _max?: fidic_fundo_carteira_n_cedentesMaxOrderByAggregateInput
    _min?: fidic_fundo_carteira_n_cedentesMinOrderByAggregateInput
    _sum?: fidic_fundo_carteira_n_cedentesSumOrderByAggregateInput
  }

  export type fidic_fundo_carteira_n_cedentesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<fidic_fundo_carteira_n_cedentesScalarWhereWithAggregatesInput>
    OR?: Enumerable<fidic_fundo_carteira_n_cedentesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<fidic_fundo_carteira_n_cedentesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type fidic_fundo_x_usuarioWhereInput = {
    AND?: Enumerable<fidic_fundo_x_usuarioWhereInput>
    OR?: Enumerable<fidic_fundo_x_usuarioWhereInput>
    NOT?: Enumerable<fidic_fundo_x_usuarioWhereInput>
    id?: IntFilter | number
    usuario?: IntNullableFilter | number | null
    fidic?: IntFilter | number
    fidic_fundo?: XOR<Fidic_fundoRelationFilter, fidic_fundoWhereInput>
    usuario_fidic_fundo_x_usuarioTousuario?: XOR<UsuarioRelationFilter, usuarioWhereInput> | null
  }

  export type fidic_fundo_x_usuarioOrderByWithRelationInput = {
    id?: SortOrder
    usuario?: SortOrder
    fidic?: SortOrder
    fidic_fundo?: fidic_fundoOrderByWithRelationInput
    usuario_fidic_fundo_x_usuarioTousuario?: usuarioOrderByWithRelationInput
  }

  export type fidic_fundo_x_usuarioWhereUniqueInput = {
    id?: number
  }

  export type fidic_fundo_x_usuarioOrderByWithAggregationInput = {
    id?: SortOrder
    usuario?: SortOrder
    fidic?: SortOrder
    _count?: fidic_fundo_x_usuarioCountOrderByAggregateInput
    _avg?: fidic_fundo_x_usuarioAvgOrderByAggregateInput
    _max?: fidic_fundo_x_usuarioMaxOrderByAggregateInput
    _min?: fidic_fundo_x_usuarioMinOrderByAggregateInput
    _sum?: fidic_fundo_x_usuarioSumOrderByAggregateInput
  }

  export type fidic_fundo_x_usuarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<fidic_fundo_x_usuarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<fidic_fundo_x_usuarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<fidic_fundo_x_usuarioScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    usuario?: IntNullableWithAggregatesFilter | number | null
    fidic?: IntWithAggregatesFilter | number
  }

  export type organogramaWhereInput = {
    AND?: Enumerable<organogramaWhereInput>
    OR?: Enumerable<organogramaWhereInput>
    NOT?: Enumerable<organogramaWhereInput>
    id?: IntFilter | number
  }

  export type organogramaOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type organogramaWhereUniqueInput = {
    id?: number
  }

  export type organogramaOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: organogramaCountOrderByAggregateInput
    _avg?: organogramaAvgOrderByAggregateInput
    _max?: organogramaMaxOrderByAggregateInput
    _min?: organogramaMinOrderByAggregateInput
    _sum?: organogramaSumOrderByAggregateInput
  }

  export type organogramaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<organogramaScalarWhereWithAggregatesInput>
    OR?: Enumerable<organogramaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<organogramaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type organograma_tipoWhereInput = {
    AND?: Enumerable<organograma_tipoWhereInput>
    OR?: Enumerable<organograma_tipoWhereInput>
    NOT?: Enumerable<organograma_tipoWhereInput>
    id?: IntFilter | number
    nome?: StringFilter | string
  }

  export type organograma_tipoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type organograma_tipoWhereUniqueInput = {
    id?: number
  }

  export type organograma_tipoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    _count?: organograma_tipoCountOrderByAggregateInput
    _avg?: organograma_tipoAvgOrderByAggregateInput
    _max?: organograma_tipoMaxOrderByAggregateInput
    _min?: organograma_tipoMinOrderByAggregateInput
    _sum?: organograma_tipoSumOrderByAggregateInput
  }

  export type organograma_tipoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<organograma_tipoScalarWhereWithAggregatesInput>
    OR?: Enumerable<organograma_tipoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<organograma_tipoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
  }

  export type organograma_x_regiaoWhereInput = {
    AND?: Enumerable<organograma_x_regiaoWhereInput>
    OR?: Enumerable<organograma_x_regiaoWhereInput>
    NOT?: Enumerable<organograma_x_regiaoWhereInput>
    id?: IntFilter | number
    organograma_id?: IntFilter | number
    regiao_id?: IntFilter | number
  }

  export type organograma_x_regiaoOrderByWithRelationInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_id?: SortOrder
  }

  export type organograma_x_regiaoWhereUniqueInput = {
    id?: number
  }

  export type organograma_x_regiaoOrderByWithAggregationInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_id?: SortOrder
    _count?: organograma_x_regiaoCountOrderByAggregateInput
    _avg?: organograma_x_regiaoAvgOrderByAggregateInput
    _max?: organograma_x_regiaoMaxOrderByAggregateInput
    _min?: organograma_x_regiaoMinOrderByAggregateInput
    _sum?: organograma_x_regiaoSumOrderByAggregateInput
  }

  export type organograma_x_regiaoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<organograma_x_regiaoScalarWhereWithAggregatesInput>
    OR?: Enumerable<organograma_x_regiaoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<organograma_x_regiaoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    organograma_id?: IntWithAggregatesFilter | number
    regiao_id?: IntWithAggregatesFilter | number
  }

  export type organograma_x_regiao_atuacaoWhereInput = {
    AND?: Enumerable<organograma_x_regiao_atuacaoWhereInput>
    OR?: Enumerable<organograma_x_regiao_atuacaoWhereInput>
    NOT?: Enumerable<organograma_x_regiao_atuacaoWhereInput>
    id?: IntFilter | number
    organograma_id?: IntFilter | number
    regiao_id?: IntFilter | number
  }

  export type organograma_x_regiao_atuacaoOrderByWithRelationInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_id?: SortOrder
  }

  export type organograma_x_regiao_atuacaoWhereUniqueInput = {
    id?: number
  }

  export type organograma_x_regiao_atuacaoOrderByWithAggregationInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_id?: SortOrder
    _count?: organograma_x_regiao_atuacaoCountOrderByAggregateInput
    _avg?: organograma_x_regiao_atuacaoAvgOrderByAggregateInput
    _max?: organograma_x_regiao_atuacaoMaxOrderByAggregateInput
    _min?: organograma_x_regiao_atuacaoMinOrderByAggregateInput
    _sum?: organograma_x_regiao_atuacaoSumOrderByAggregateInput
  }

  export type organograma_x_regiao_atuacaoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<organograma_x_regiao_atuacaoScalarWhereWithAggregatesInput>
    OR?: Enumerable<organograma_x_regiao_atuacaoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<organograma_x_regiao_atuacaoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    organograma_id?: IntWithAggregatesFilter | number
    regiao_id?: IntWithAggregatesFilter | number
  }

  export type pessoaWhereInput = {
    AND?: Enumerable<pessoaWhereInput>
    OR?: Enumerable<pessoaWhereInput>
    NOT?: Enumerable<pessoaWhereInput>
    id?: IntFilter | number
    nome?: StringFilter | string
    sobrenome?: StringFilter | string
    sexo?: StringNullableFilter | string | null
    nascimento?: DateTimeNullableFilter | Date | string | null
    cpf?: StringNullableFilter | string | null
    rg?: StringNullableFilter | string | null
    usuario?: UsuarioListRelationFilter
  }

  export type pessoaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    sexo?: SortOrder
    nascimento?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
    usuario?: usuarioOrderByRelationAggregateInput
  }

  export type pessoaWhereUniqueInput = {
    id?: number
  }

  export type pessoaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    sexo?: SortOrder
    nascimento?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
    _count?: pessoaCountOrderByAggregateInput
    _avg?: pessoaAvgOrderByAggregateInput
    _max?: pessoaMaxOrderByAggregateInput
    _min?: pessoaMinOrderByAggregateInput
    _sum?: pessoaSumOrderByAggregateInput
  }

  export type pessoaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<pessoaScalarWhereWithAggregatesInput>
    OR?: Enumerable<pessoaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<pessoaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
    sobrenome?: StringWithAggregatesFilter | string
    sexo?: StringNullableWithAggregatesFilter | string | null
    nascimento?: DateTimeNullableWithAggregatesFilter | Date | string | null
    cpf?: StringNullableWithAggregatesFilter | string | null
    rg?: StringNullableWithAggregatesFilter | string | null
  }

  export type plataformaWhereInput = {
    AND?: Enumerable<plataformaWhereInput>
    OR?: Enumerable<plataformaWhereInput>
    NOT?: Enumerable<plataformaWhereInput>
    id?: IntFilter | number
    nome?: StringNullableFilter | string | null
  }

  export type plataformaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type plataformaWhereUniqueInput = {
    id?: number
  }

  export type plataformaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    _count?: plataformaCountOrderByAggregateInput
    _avg?: plataformaAvgOrderByAggregateInput
    _max?: plataformaMaxOrderByAggregateInput
    _min?: plataformaMinOrderByAggregateInput
    _sum?: plataformaSumOrderByAggregateInput
  }

  export type plataformaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<plataformaScalarWhereWithAggregatesInput>
    OR?: Enumerable<plataformaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<plataformaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringNullableWithAggregatesFilter | string | null
  }

  export type plataforma_n_borderosWhereInput = {
    AND?: Enumerable<plataforma_n_borderosWhereInput>
    OR?: Enumerable<plataforma_n_borderosWhereInput>
    NOT?: Enumerable<plataforma_n_borderosWhereInput>
    id?: IntFilter | number
  }

  export type plataforma_n_borderosOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type plataforma_n_borderosWhereUniqueInput = {
    id?: number
  }

  export type plataforma_n_borderosOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: plataforma_n_borderosCountOrderByAggregateInput
    _avg?: plataforma_n_borderosAvgOrderByAggregateInput
    _max?: plataforma_n_borderosMaxOrderByAggregateInput
    _min?: plataforma_n_borderosMinOrderByAggregateInput
    _sum?: plataforma_n_borderosSumOrderByAggregateInput
  }

  export type plataforma_n_borderosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<plataforma_n_borderosScalarWhereWithAggregatesInput>
    OR?: Enumerable<plataforma_n_borderosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<plataforma_n_borderosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type plataforma_papel_tipoWhereInput = {
    AND?: Enumerable<plataforma_papel_tipoWhereInput>
    OR?: Enumerable<plataforma_papel_tipoWhereInput>
    NOT?: Enumerable<plataforma_papel_tipoWhereInput>
    id?: IntFilter | number
  }

  export type plataforma_papel_tipoOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type plataforma_papel_tipoWhereUniqueInput = {
    id?: number
  }

  export type plataforma_papel_tipoOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: plataforma_papel_tipoCountOrderByAggregateInput
    _avg?: plataforma_papel_tipoAvgOrderByAggregateInput
    _max?: plataforma_papel_tipoMaxOrderByAggregateInput
    _min?: plataforma_papel_tipoMinOrderByAggregateInput
    _sum?: plataforma_papel_tipoSumOrderByAggregateInput
  }

  export type plataforma_papel_tipoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<plataforma_papel_tipoScalarWhereWithAggregatesInput>
    OR?: Enumerable<plataforma_papel_tipoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<plataforma_papel_tipoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type plataforma_papel_x_pessoaWhereInput = {
    AND?: Enumerable<plataforma_papel_x_pessoaWhereInput>
    OR?: Enumerable<plataforma_papel_x_pessoaWhereInput>
    NOT?: Enumerable<plataforma_papel_x_pessoaWhereInput>
    id?: IntFilter | number
  }

  export type plataforma_papel_x_pessoaOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type plataforma_papel_x_pessoaWhereUniqueInput = {
    id?: number
  }

  export type plataforma_papel_x_pessoaOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: plataforma_papel_x_pessoaCountOrderByAggregateInput
    _avg?: plataforma_papel_x_pessoaAvgOrderByAggregateInput
    _max?: plataforma_papel_x_pessoaMaxOrderByAggregateInput
    _min?: plataforma_papel_x_pessoaMinOrderByAggregateInput
    _sum?: plataforma_papel_x_pessoaSumOrderByAggregateInput
  }

  export type plataforma_papel_x_pessoaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<plataforma_papel_x_pessoaScalarWhereWithAggregatesInput>
    OR?: Enumerable<plataforma_papel_x_pessoaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<plataforma_papel_x_pessoaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type plataforma_x_regiao_atuacaoWhereInput = {
    AND?: Enumerable<plataforma_x_regiao_atuacaoWhereInput>
    OR?: Enumerable<plataforma_x_regiao_atuacaoWhereInput>
    NOT?: Enumerable<plataforma_x_regiao_atuacaoWhereInput>
    id?: IntFilter | number
  }

  export type plataforma_x_regiao_atuacaoOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type plataforma_x_regiao_atuacaoWhereUniqueInput = {
    id?: number
  }

  export type plataforma_x_regiao_atuacaoOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: plataforma_x_regiao_atuacaoCountOrderByAggregateInput
    _avg?: plataforma_x_regiao_atuacaoAvgOrderByAggregateInput
    _max?: plataforma_x_regiao_atuacaoMaxOrderByAggregateInput
    _min?: plataforma_x_regiao_atuacaoMinOrderByAggregateInput
    _sum?: plataforma_x_regiao_atuacaoSumOrderByAggregateInput
  }

  export type plataforma_x_regiao_atuacaoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<plataforma_x_regiao_atuacaoScalarWhereWithAggregatesInput>
    OR?: Enumerable<plataforma_x_regiao_atuacaoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<plataforma_x_regiao_atuacaoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type regiao_atuacaoWhereInput = {
    AND?: Enumerable<regiao_atuacaoWhereInput>
    OR?: Enumerable<regiao_atuacaoWhereInput>
    NOT?: Enumerable<regiao_atuacaoWhereInput>
    id?: IntFilter | number
    nome?: StringFilter | string
  }

  export type regiao_atuacaoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type regiao_atuacaoWhereUniqueInput = {
    id?: number
  }

  export type regiao_atuacaoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    _count?: regiao_atuacaoCountOrderByAggregateInput
    _avg?: regiao_atuacaoAvgOrderByAggregateInput
    _max?: regiao_atuacaoMaxOrderByAggregateInput
    _min?: regiao_atuacaoMinOrderByAggregateInput
    _sum?: regiao_atuacaoSumOrderByAggregateInput
  }

  export type regiao_atuacaoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<regiao_atuacaoScalarWhereWithAggregatesInput>
    OR?: Enumerable<regiao_atuacaoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<regiao_atuacaoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
  }

  export type regiao_atuacao_tipoWhereInput = {
    AND?: Enumerable<regiao_atuacao_tipoWhereInput>
    OR?: Enumerable<regiao_atuacao_tipoWhereInput>
    NOT?: Enumerable<regiao_atuacao_tipoWhereInput>
    id?: IntFilter | number
    nome?: StringFilter | string
  }

  export type regiao_atuacao_tipoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type regiao_atuacao_tipoWhereUniqueInput = {
    id?: number
  }

  export type regiao_atuacao_tipoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    _count?: regiao_atuacao_tipoCountOrderByAggregateInput
    _avg?: regiao_atuacao_tipoAvgOrderByAggregateInput
    _max?: regiao_atuacao_tipoMaxOrderByAggregateInput
    _min?: regiao_atuacao_tipoMinOrderByAggregateInput
    _sum?: regiao_atuacao_tipoSumOrderByAggregateInput
  }

  export type regiao_atuacao_tipoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<regiao_atuacao_tipoScalarWhereWithAggregatesInput>
    OR?: Enumerable<regiao_atuacao_tipoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<regiao_atuacao_tipoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
  }

  export type sacadoWhereInput = {
    AND?: Enumerable<sacadoWhereInput>
    OR?: Enumerable<sacadoWhereInput>
    NOT?: Enumerable<sacadoWhereInput>
    id?: IntFilter | number
    pessoa_id?: IntFilter | number
    razao_social?: StringFilter | string
    nome_fantasia?: StringNullableFilter | string | null
    abertura?: DateTimeNullableFilter | Date | string | null
    cnpj?: StringNullableFilter | string | null
    cedente_n_sacados?: Cedente_n_sacadosListRelationFilter
  }

  export type sacadoOrderByWithRelationInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    cedente_n_sacados?: cedente_n_sacadosOrderByRelationAggregateInput
  }

  export type sacadoWhereUniqueInput = {
    id?: number
  }

  export type sacadoOrderByWithAggregationInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    _count?: sacadoCountOrderByAggregateInput
    _avg?: sacadoAvgOrderByAggregateInput
    _max?: sacadoMaxOrderByAggregateInput
    _min?: sacadoMinOrderByAggregateInput
    _sum?: sacadoSumOrderByAggregateInput
  }

  export type sacadoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<sacadoScalarWhereWithAggregatesInput>
    OR?: Enumerable<sacadoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<sacadoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    pessoa_id?: IntWithAggregatesFilter | number
    razao_social?: StringWithAggregatesFilter | string
    nome_fantasia?: StringNullableWithAggregatesFilter | string | null
    abertura?: DateTimeNullableWithAggregatesFilter | Date | string | null
    cnpj?: StringNullableWithAggregatesFilter | string | null
  }

  export type tituloWhereInput = {
    AND?: Enumerable<tituloWhereInput>
    OR?: Enumerable<tituloWhereInput>
    NOT?: Enumerable<tituloWhereInput>
    id?: IntFilter | number
    titulo_tipo_id?: IntFilter | number
    bordero_id?: IntFilter | number
    nf?: StringNullableFilter | string | null
    valor?: FloatNullableFilter | number | null
    vencimento?: DateTimeNullableFilter | Date | string | null
    numero?: StringNullableFilter | string | null
    emissao?: DateTimeNullableFilter | Date | string | null
    parcela?: StringNullableFilter | string | null
    titulo_tipo?: XOR<Titulo_tipoRelationFilter, titulo_tipoWhereInput>
    bordero?: XOR<BorderoRelationFilter, borderoWhereInput>
  }

  export type tituloOrderByWithRelationInput = {
    id?: SortOrder
    titulo_tipo_id?: SortOrder
    bordero_id?: SortOrder
    nf?: SortOrder
    valor?: SortOrder
    vencimento?: SortOrder
    numero?: SortOrder
    emissao?: SortOrder
    parcela?: SortOrder
    titulo_tipo?: titulo_tipoOrderByWithRelationInput
    bordero?: borderoOrderByWithRelationInput
  }

  export type tituloWhereUniqueInput = {
    id?: number
  }

  export type tituloOrderByWithAggregationInput = {
    id?: SortOrder
    titulo_tipo_id?: SortOrder
    bordero_id?: SortOrder
    nf?: SortOrder
    valor?: SortOrder
    vencimento?: SortOrder
    numero?: SortOrder
    emissao?: SortOrder
    parcela?: SortOrder
    _count?: tituloCountOrderByAggregateInput
    _avg?: tituloAvgOrderByAggregateInput
    _max?: tituloMaxOrderByAggregateInput
    _min?: tituloMinOrderByAggregateInput
    _sum?: tituloSumOrderByAggregateInput
  }

  export type tituloScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tituloScalarWhereWithAggregatesInput>
    OR?: Enumerable<tituloScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tituloScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    titulo_tipo_id?: IntWithAggregatesFilter | number
    bordero_id?: IntWithAggregatesFilter | number
    nf?: StringNullableWithAggregatesFilter | string | null
    valor?: FloatNullableWithAggregatesFilter | number | null
    vencimento?: DateTimeNullableWithAggregatesFilter | Date | string | null
    numero?: StringNullableWithAggregatesFilter | string | null
    emissao?: DateTimeNullableWithAggregatesFilter | Date | string | null
    parcela?: StringNullableWithAggregatesFilter | string | null
  }

  export type titulo_tipoWhereInput = {
    AND?: Enumerable<titulo_tipoWhereInput>
    OR?: Enumerable<titulo_tipoWhereInput>
    NOT?: Enumerable<titulo_tipoWhereInput>
    id?: IntFilter | number
    nome?: StringNullableFilter | string | null
    titulo?: TituloListRelationFilter
  }

  export type titulo_tipoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    titulo?: tituloOrderByRelationAggregateInput
  }

  export type titulo_tipoWhereUniqueInput = {
    id?: number
  }

  export type titulo_tipoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    _count?: titulo_tipoCountOrderByAggregateInput
    _avg?: titulo_tipoAvgOrderByAggregateInput
    _max?: titulo_tipoMaxOrderByAggregateInput
    _min?: titulo_tipoMinOrderByAggregateInput
    _sum?: titulo_tipoSumOrderByAggregateInput
  }

  export type titulo_tipoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<titulo_tipoScalarWhereWithAggregatesInput>
    OR?: Enumerable<titulo_tipoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<titulo_tipoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringNullableWithAggregatesFilter | string | null
  }

  export type titulo_x_cedenteWhereInput = {
    AND?: Enumerable<titulo_x_cedenteWhereInput>
    OR?: Enumerable<titulo_x_cedenteWhereInput>
    NOT?: Enumerable<titulo_x_cedenteWhereInput>
    id?: IntFilter | number
    cedente?: IntFilter | number
    cedente_cedenteTotitulo_x_cedente?: XOR<CedenteRelationFilter, cedenteWhereInput>
  }

  export type titulo_x_cedenteOrderByWithRelationInput = {
    id?: SortOrder
    cedente?: SortOrder
    cedente_cedenteTotitulo_x_cedente?: cedenteOrderByWithRelationInput
  }

  export type titulo_x_cedenteWhereUniqueInput = {
    id?: number
  }

  export type titulo_x_cedenteOrderByWithAggregationInput = {
    id?: SortOrder
    cedente?: SortOrder
    _count?: titulo_x_cedenteCountOrderByAggregateInput
    _avg?: titulo_x_cedenteAvgOrderByAggregateInput
    _max?: titulo_x_cedenteMaxOrderByAggregateInput
    _min?: titulo_x_cedenteMinOrderByAggregateInput
    _sum?: titulo_x_cedenteSumOrderByAggregateInput
  }

  export type titulo_x_cedenteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<titulo_x_cedenteScalarWhereWithAggregatesInput>
    OR?: Enumerable<titulo_x_cedenteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<titulo_x_cedenteScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    cedente?: IntWithAggregatesFilter | number
  }

  export type titulo_x_empresaWhereInput = {
    AND?: Enumerable<titulo_x_empresaWhereInput>
    OR?: Enumerable<titulo_x_empresaWhereInput>
    NOT?: Enumerable<titulo_x_empresaWhereInput>
    id?: IntFilter | number
  }

  export type titulo_x_empresaOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type titulo_x_empresaWhereUniqueInput = {
    id?: number
  }

  export type titulo_x_empresaOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: titulo_x_empresaCountOrderByAggregateInput
    _avg?: titulo_x_empresaAvgOrderByAggregateInput
    _max?: titulo_x_empresaMaxOrderByAggregateInput
    _min?: titulo_x_empresaMinOrderByAggregateInput
    _sum?: titulo_x_empresaSumOrderByAggregateInput
  }

  export type titulo_x_empresaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<titulo_x_empresaScalarWhereWithAggregatesInput>
    OR?: Enumerable<titulo_x_empresaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<titulo_x_empresaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type titulo_x_plataformaWhereInput = {
    AND?: Enumerable<titulo_x_plataformaWhereInput>
    OR?: Enumerable<titulo_x_plataformaWhereInput>
    NOT?: Enumerable<titulo_x_plataformaWhereInput>
    id?: IntFilter | number
  }

  export type titulo_x_plataformaOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type titulo_x_plataformaWhereUniqueInput = {
    id?: number
  }

  export type titulo_x_plataformaOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: titulo_x_plataformaCountOrderByAggregateInput
    _avg?: titulo_x_plataformaAvgOrderByAggregateInput
    _max?: titulo_x_plataformaMaxOrderByAggregateInput
    _min?: titulo_x_plataformaMinOrderByAggregateInput
    _sum?: titulo_x_plataformaSumOrderByAggregateInput
  }

  export type titulo_x_plataformaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<titulo_x_plataformaScalarWhereWithAggregatesInput>
    OR?: Enumerable<titulo_x_plataformaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<titulo_x_plataformaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type titulos_x_usuarioWhereInput = {
    AND?: Enumerable<titulos_x_usuarioWhereInput>
    OR?: Enumerable<titulos_x_usuarioWhereInput>
    NOT?: Enumerable<titulos_x_usuarioWhereInput>
    id?: IntFilter | number
    usuario?: IntNullableFilter | number | null
    bordero?: IntNullableFilter | number | null
    status?: StringNullableFilter | string | null
    bordero_borderoTotitulos_x_usuario?: XOR<BorderoRelationFilter, borderoWhereInput> | null
    usuario_titulos_x_usuarioTousuario?: XOR<UsuarioRelationFilter, usuarioWhereInput> | null
  }

  export type titulos_x_usuarioOrderByWithRelationInput = {
    id?: SortOrder
    usuario?: SortOrder
    bordero?: SortOrder
    status?: SortOrder
    bordero_borderoTotitulos_x_usuario?: borderoOrderByWithRelationInput
    usuario_titulos_x_usuarioTousuario?: usuarioOrderByWithRelationInput
  }

  export type titulos_x_usuarioWhereUniqueInput = {
    id?: number
  }

  export type titulos_x_usuarioOrderByWithAggregationInput = {
    id?: SortOrder
    usuario?: SortOrder
    bordero?: SortOrder
    status?: SortOrder
    _count?: titulos_x_usuarioCountOrderByAggregateInput
    _avg?: titulos_x_usuarioAvgOrderByAggregateInput
    _max?: titulos_x_usuarioMaxOrderByAggregateInput
    _min?: titulos_x_usuarioMinOrderByAggregateInput
    _sum?: titulos_x_usuarioSumOrderByAggregateInput
  }

  export type titulos_x_usuarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<titulos_x_usuarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<titulos_x_usuarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<titulos_x_usuarioScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    usuario?: IntNullableWithAggregatesFilter | number | null
    bordero?: IntNullableWithAggregatesFilter | number | null
    status?: StringNullableWithAggregatesFilter | string | null
  }

  export type usuarioWhereInput = {
    AND?: Enumerable<usuarioWhereInput>
    OR?: Enumerable<usuarioWhereInput>
    NOT?: Enumerable<usuarioWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    senha?: StringFilter | string
    pessoa_id?: IntFilter | number
    status?: StringNullableFilter | string | null
    primeiro_acesso?: BoolNullableFilter | boolean | null
    confirmou_cadastro?: BoolNullableFilter | boolean | null
    codigo_confirma_cadastro?: StringNullableFilter | string | null
    codigo_reset_senha?: StringNullableFilter | string | null
    codigo_data_expiracao?: DateTimeNullableFilter | Date | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeNullableFilter | Date | string | null
    auditoria?: AuditoriaListRelationFilter
    checagem?: ChecagemListRelationFilter
    fidic_fundo_x_usuario?: Fidic_fundo_x_usuarioListRelationFilter
    titulos_x_usuario?: Titulos_x_usuarioListRelationFilter
    pessoa?: XOR<PessoaRelationFilter, pessoaWhereInput>
    usuario_x_perfil?: Usuario_x_perfilListRelationFilter
  }

  export type usuarioOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    pessoa_id?: SortOrder
    status?: SortOrder
    primeiro_acesso?: SortOrder
    confirmou_cadastro?: SortOrder
    codigo_confirma_cadastro?: SortOrder
    codigo_reset_senha?: SortOrder
    codigo_data_expiracao?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    auditoria?: auditoriaOrderByRelationAggregateInput
    checagem?: checagemOrderByRelationAggregateInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioOrderByRelationAggregateInput
    titulos_x_usuario?: titulos_x_usuarioOrderByRelationAggregateInput
    pessoa?: pessoaOrderByWithRelationInput
    usuario_x_perfil?: usuario_x_perfilOrderByRelationAggregateInput
  }

  export type usuarioWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type usuarioOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    pessoa_id?: SortOrder
    status?: SortOrder
    primeiro_acesso?: SortOrder
    confirmou_cadastro?: SortOrder
    codigo_confirma_cadastro?: SortOrder
    codigo_reset_senha?: SortOrder
    codigo_data_expiracao?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: usuarioCountOrderByAggregateInput
    _avg?: usuarioAvgOrderByAggregateInput
    _max?: usuarioMaxOrderByAggregateInput
    _min?: usuarioMinOrderByAggregateInput
    _sum?: usuarioSumOrderByAggregateInput
  }

  export type usuarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usuarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<usuarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usuarioScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    senha?: StringWithAggregatesFilter | string
    pessoa_id?: IntWithAggregatesFilter | number
    status?: StringNullableWithAggregatesFilter | string | null
    primeiro_acesso?: BoolNullableWithAggregatesFilter | boolean | null
    confirmou_cadastro?: BoolNullableWithAggregatesFilter | boolean | null
    codigo_confirma_cadastro?: StringNullableWithAggregatesFilter | string | null
    codigo_reset_senha?: StringNullableWithAggregatesFilter | string | null
    codigo_data_expiracao?: DateTimeNullableWithAggregatesFilter | Date | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type usuario__pessoaWhereInput = {
    AND?: Enumerable<usuario__pessoaWhereInput>
    OR?: Enumerable<usuario__pessoaWhereInput>
    NOT?: Enumerable<usuario__pessoaWhereInput>
    id?: IntFilter | number
  }

  export type usuario__pessoaOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type usuario__pessoaWhereUniqueInput = {
    id?: number
  }

  export type usuario__pessoaOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: usuario__pessoaCountOrderByAggregateInput
    _avg?: usuario__pessoaAvgOrderByAggregateInput
    _max?: usuario__pessoaMaxOrderByAggregateInput
    _min?: usuario__pessoaMinOrderByAggregateInput
    _sum?: usuario__pessoaSumOrderByAggregateInput
  }

  export type usuario__pessoaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usuario__pessoaScalarWhereWithAggregatesInput>
    OR?: Enumerable<usuario__pessoaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usuario__pessoaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type usuario_n_borderosWhereInput = {
    AND?: Enumerable<usuario_n_borderosWhereInput>
    OR?: Enumerable<usuario_n_borderosWhereInput>
    NOT?: Enumerable<usuario_n_borderosWhereInput>
    id?: IntFilter | number
  }

  export type usuario_n_borderosOrderByWithRelationInput = {
    id?: SortOrder
  }

  export type usuario_n_borderosWhereUniqueInput = {
    id?: number
  }

  export type usuario_n_borderosOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: usuario_n_borderosCountOrderByAggregateInput
    _avg?: usuario_n_borderosAvgOrderByAggregateInput
    _max?: usuario_n_borderosMaxOrderByAggregateInput
    _min?: usuario_n_borderosMinOrderByAggregateInput
    _sum?: usuario_n_borderosSumOrderByAggregateInput
  }

  export type usuario_n_borderosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usuario_n_borderosScalarWhereWithAggregatesInput>
    OR?: Enumerable<usuario_n_borderosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usuario_n_borderosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type usuario_perfil_tipoWhereInput = {
    AND?: Enumerable<usuario_perfil_tipoWhereInput>
    OR?: Enumerable<usuario_perfil_tipoWhereInput>
    NOT?: Enumerable<usuario_perfil_tipoWhereInput>
    id?: IntFilter | number
    nome?: StringFilter | string
    usuario_x_perfil?: Usuario_x_perfilListRelationFilter
  }

  export type usuario_perfil_tipoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    usuario_x_perfil?: usuario_x_perfilOrderByRelationAggregateInput
  }

  export type usuario_perfil_tipoWhereUniqueInput = {
    id?: number
  }

  export type usuario_perfil_tipoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    _count?: usuario_perfil_tipoCountOrderByAggregateInput
    _avg?: usuario_perfil_tipoAvgOrderByAggregateInput
    _max?: usuario_perfil_tipoMaxOrderByAggregateInput
    _min?: usuario_perfil_tipoMinOrderByAggregateInput
    _sum?: usuario_perfil_tipoSumOrderByAggregateInput
  }

  export type usuario_perfil_tipoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usuario_perfil_tipoScalarWhereWithAggregatesInput>
    OR?: Enumerable<usuario_perfil_tipoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usuario_perfil_tipoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
  }

  export type usuario_x_perfilWhereInput = {
    AND?: Enumerable<usuario_x_perfilWhereInput>
    OR?: Enumerable<usuario_x_perfilWhereInput>
    NOT?: Enumerable<usuario_x_perfilWhereInput>
    id?: IntFilter | number
    senha?: StringFilter | string
    usuario_id?: IntFilter | number
    usuario_perfil_id?: IntFilter | number
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    usuario_perfil_tipo?: XOR<Usuario_perfil_tipoRelationFilter, usuario_perfil_tipoWhereInput>
  }

  export type usuario_x_perfilOrderByWithRelationInput = {
    id?: SortOrder
    senha?: SortOrder
    usuario_id?: SortOrder
    usuario_perfil_id?: SortOrder
    usuario?: usuarioOrderByWithRelationInput
    usuario_perfil_tipo?: usuario_perfil_tipoOrderByWithRelationInput
  }

  export type usuario_x_perfilWhereUniqueInput = {
    id?: number
  }

  export type usuario_x_perfilOrderByWithAggregationInput = {
    id?: SortOrder
    senha?: SortOrder
    usuario_id?: SortOrder
    usuario_perfil_id?: SortOrder
    _count?: usuario_x_perfilCountOrderByAggregateInput
    _avg?: usuario_x_perfilAvgOrderByAggregateInput
    _max?: usuario_x_perfilMaxOrderByAggregateInput
    _min?: usuario_x_perfilMinOrderByAggregateInput
    _sum?: usuario_x_perfilSumOrderByAggregateInput
  }

  export type usuario_x_perfilScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usuario_x_perfilScalarWhereWithAggregatesInput>
    OR?: Enumerable<usuario_x_perfilScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usuario_x_perfilScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    senha?: StringWithAggregatesFilter | string
    usuario_id?: IntWithAggregatesFilter | number
    usuario_perfil_id?: IntWithAggregatesFilter | number
  }

  export type auditoriaCreateInput = {
    action?: string | null
    data?: Date | string | null
    modulo?: string | null
    usuario_auditoriaTousuario?: usuarioCreateNestedOneWithoutAuditoriaInput
  }

  export type auditoriaUncheckedCreateInput = {
    action?: string | null
    usuario?: number | null
    data?: Date | string | null
    modulo?: string | null
    id?: number
  }

  export type auditoriaUpdateInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modulo?: NullableStringFieldUpdateOperationsInput | string | null
    usuario_auditoriaTousuario?: usuarioUpdateOneWithoutAuditoriaNestedInput
  }

  export type auditoriaUncheckedUpdateInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modulo?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type auditoriaCreateManyInput = {
    action?: string | null
    usuario?: number | null
    data?: Date | string | null
    modulo?: string | null
    id?: number
  }

  export type auditoriaUpdateManyMutationInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modulo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditoriaUncheckedUpdateManyInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modulo?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type borderoCreateInput = {
    carteira_id: number
    titulo?: tituloCreateNestedManyWithoutBorderoInput
    titulos_x_usuario?: titulos_x_usuarioCreateNestedManyWithoutBordero_borderoTotitulos_x_usuarioInput
  }

  export type borderoUncheckedCreateInput = {
    id?: number
    carteira_id: number
    titulo?: tituloUncheckedCreateNestedManyWithoutBorderoInput
    titulos_x_usuario?: titulos_x_usuarioUncheckedCreateNestedManyWithoutBordero_borderoTotitulos_x_usuarioInput
  }

  export type borderoUpdateInput = {
    carteira_id?: IntFieldUpdateOperationsInput | number
    titulo?: tituloUpdateManyWithoutBorderoNestedInput
    titulos_x_usuario?: titulos_x_usuarioUpdateManyWithoutBordero_borderoTotitulos_x_usuarioNestedInput
  }

  export type borderoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    carteira_id?: IntFieldUpdateOperationsInput | number
    titulo?: tituloUncheckedUpdateManyWithoutBorderoNestedInput
    titulos_x_usuario?: titulos_x_usuarioUncheckedUpdateManyWithoutBordero_borderoTotitulos_x_usuarioNestedInput
  }

  export type borderoCreateManyInput = {
    id?: number
    carteira_id: number
  }

  export type borderoUpdateManyMutationInput = {
    carteira_id?: IntFieldUpdateOperationsInput | number
  }

  export type borderoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    carteira_id?: IntFieldUpdateOperationsInput | number
  }

  export type carteiraCreateInput = {
    fidic_fundo: fidic_fundoCreateNestedOneWithoutCarteiraInput
  }

  export type carteiraUncheckedCreateInput = {
    id?: number
    fiduc_fundo_id: number
  }

  export type carteiraUpdateInput = {
    fidic_fundo?: fidic_fundoUpdateOneRequiredWithoutCarteiraNestedInput
  }

  export type carteiraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fiduc_fundo_id?: IntFieldUpdateOperationsInput | number
  }

  export type carteiraCreateManyInput = {
    id?: number
    fiduc_fundo_id: number
  }

  export type carteiraUpdateManyMutationInput = {

  }

  export type carteiraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fiduc_fundo_id?: IntFieldUpdateOperationsInput | number
  }

  export type cedenteCreateInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    cedente_analise?: cedente_analiseCreateNestedManyWithoutCedente_cedenteTocedente_analiseInput
    cedente_n_sacados?: cedente_n_sacadosCreateNestedManyWithoutCedente_cedenteTocedente_n_sacadosInput
    titulo_x_cedente?: titulo_x_cedenteCreateNestedManyWithoutCedente_cedenteTotitulo_x_cedenteInput
  }

  export type cedenteUncheckedCreateInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    cedente_analise?: cedente_analiseUncheckedCreateNestedManyWithoutCedente_cedenteTocedente_analiseInput
    cedente_n_sacados?: cedente_n_sacadosUncheckedCreateNestedManyWithoutCedente_cedenteTocedente_n_sacadosInput
    titulo_x_cedente?: titulo_x_cedenteUncheckedCreateNestedManyWithoutCedente_cedenteTotitulo_x_cedenteInput
  }

  export type cedenteUpdateInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cedente_analise?: cedente_analiseUpdateManyWithoutCedente_cedenteTocedente_analiseNestedInput
    cedente_n_sacados?: cedente_n_sacadosUpdateManyWithoutCedente_cedenteTocedente_n_sacadosNestedInput
    titulo_x_cedente?: titulo_x_cedenteUpdateManyWithoutCedente_cedenteTotitulo_x_cedenteNestedInput
  }

  export type cedenteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cedente_analise?: cedente_analiseUncheckedUpdateManyWithoutCedente_cedenteTocedente_analiseNestedInput
    cedente_n_sacados?: cedente_n_sacadosUncheckedUpdateManyWithoutCedente_cedenteTocedente_n_sacadosNestedInput
    titulo_x_cedente?: titulo_x_cedenteUncheckedUpdateManyWithoutCedente_cedenteTotitulo_x_cedenteNestedInput
  }

  export type cedenteCreateManyInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
  }

  export type cedenteUpdateManyMutationInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cedenteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cedente_analiseCreateInput = {
    status?: string | null
    cedente_cedenteTocedente_analise?: cedenteCreateNestedOneWithoutCedente_analiseInput
  }

  export type cedente_analiseUncheckedCreateInput = {
    id?: number
    status?: string | null
    cedente?: number | null
  }

  export type cedente_analiseUpdateInput = {
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cedente_cedenteTocedente_analise?: cedenteUpdateOneWithoutCedente_analiseNestedInput
  }

  export type cedente_analiseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cedente?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cedente_analiseCreateManyInput = {
    id?: number
    status?: string | null
    cedente?: number | null
  }

  export type cedente_analiseUpdateManyMutationInput = {
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cedente_analiseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cedente?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cedente_n_sacadosCreateInput = {
    cedente_cedenteTocedente_n_sacados?: cedenteCreateNestedOneWithoutCedente_n_sacadosInput
    sacado_cedente_n_sacadosTosacado?: sacadoCreateNestedOneWithoutCedente_n_sacadosInput
  }

  export type cedente_n_sacadosUncheckedCreateInput = {
    id?: number
    cedente?: number | null
    sacado?: number | null
  }

  export type cedente_n_sacadosUpdateInput = {
    cedente_cedenteTocedente_n_sacados?: cedenteUpdateOneWithoutCedente_n_sacadosNestedInput
    sacado_cedente_n_sacadosTosacado?: sacadoUpdateOneWithoutCedente_n_sacadosNestedInput
  }

  export type cedente_n_sacadosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedente?: NullableIntFieldUpdateOperationsInput | number | null
    sacado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cedente_n_sacadosCreateManyInput = {
    id?: number
    cedente?: number | null
    sacado?: number | null
  }

  export type cedente_n_sacadosUpdateManyMutationInput = {

  }

  export type cedente_n_sacadosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedente?: NullableIntFieldUpdateOperationsInput | number | null
    sacado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type checagemCreateInput = {
    nf?: string | null
    status?: string | null
    titulos?: string | null
    usuario_checagemTousuario?: usuarioCreateNestedOneWithoutChecagemInput
  }

  export type checagemUncheckedCreateInput = {
    id?: number
    nf?: string | null
    status?: string | null
    usuario?: number | null
    titulos?: string | null
  }

  export type checagemUpdateInput = {
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    titulos?: NullableStringFieldUpdateOperationsInput | string | null
    usuario_checagemTousuario?: usuarioUpdateOneWithoutChecagemNestedInput
  }

  export type checagemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    titulos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type checagemCreateManyInput = {
    id?: number
    nf?: string | null
    status?: string | null
    usuario?: number | null
    titulos?: string | null
  }

  export type checagemUpdateManyMutationInput = {
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    titulos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type checagemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    titulos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fidic_fundoCreateInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    carteira?: carteiraCreateNestedManyWithoutFidic_fundoInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioCreateNestedManyWithoutFidic_fundoInput
  }

  export type fidic_fundoUncheckedCreateInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    carteira?: carteiraUncheckedCreateNestedManyWithoutFidic_fundoInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedCreateNestedManyWithoutFidic_fundoInput
  }

  export type fidic_fundoUpdateInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    carteira?: carteiraUpdateManyWithoutFidic_fundoNestedInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUpdateManyWithoutFidic_fundoNestedInput
  }

  export type fidic_fundoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    carteira?: carteiraUncheckedUpdateManyWithoutFidic_fundoNestedInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedUpdateManyWithoutFidic_fundoNestedInput
  }

  export type fidic_fundoCreateManyInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
  }

  export type fidic_fundoUpdateManyMutationInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fidic_fundoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fidic_fundo_carteira_n_cedentesCreateInput = {

  }

  export type fidic_fundo_carteira_n_cedentesUncheckedCreateInput = {
    id?: number
  }

  export type fidic_fundo_carteira_n_cedentesUpdateInput = {

  }

  export type fidic_fundo_carteira_n_cedentesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type fidic_fundo_carteira_n_cedentesCreateManyInput = {
    id?: number
  }

  export type fidic_fundo_carteira_n_cedentesUpdateManyMutationInput = {

  }

  export type fidic_fundo_carteira_n_cedentesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type fidic_fundo_x_usuarioCreateInput = {
    fidic_fundo: fidic_fundoCreateNestedOneWithoutFidic_fundo_x_usuarioInput
    usuario_fidic_fundo_x_usuarioTousuario?: usuarioCreateNestedOneWithoutFidic_fundo_x_usuarioInput
  }

  export type fidic_fundo_x_usuarioUncheckedCreateInput = {
    id?: number
    usuario?: number | null
    fidic: number
  }

  export type fidic_fundo_x_usuarioUpdateInput = {
    fidic_fundo?: fidic_fundoUpdateOneRequiredWithoutFidic_fundo_x_usuarioNestedInput
    usuario_fidic_fundo_x_usuarioTousuario?: usuarioUpdateOneWithoutFidic_fundo_x_usuarioNestedInput
  }

  export type fidic_fundo_x_usuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    fidic?: IntFieldUpdateOperationsInput | number
  }

  export type fidic_fundo_x_usuarioCreateManyInput = {
    id?: number
    usuario?: number | null
    fidic: number
  }

  export type fidic_fundo_x_usuarioUpdateManyMutationInput = {

  }

  export type fidic_fundo_x_usuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    fidic?: IntFieldUpdateOperationsInput | number
  }

  export type organogramaCreateInput = {

  }

  export type organogramaUncheckedCreateInput = {
    id?: number
  }

  export type organogramaUpdateInput = {

  }

  export type organogramaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type organogramaCreateManyInput = {
    id?: number
  }

  export type organogramaUpdateManyMutationInput = {

  }

  export type organogramaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_tipoCreateInput = {
    nome: string
  }

  export type organograma_tipoUncheckedCreateInput = {
    id?: number
    nome: string
  }

  export type organograma_tipoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type organograma_tipoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type organograma_tipoCreateManyInput = {
    id?: number
    nome: string
  }

  export type organograma_tipoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type organograma_tipoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type organograma_x_regiaoCreateInput = {
    organograma_id: number
    regiao_id: number
  }

  export type organograma_x_regiaoUncheckedCreateInput = {
    id?: number
    organograma_id: number
    regiao_id: number
  }

  export type organograma_x_regiaoUpdateInput = {
    organograma_id?: IntFieldUpdateOperationsInput | number
    regiao_id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_x_regiaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organograma_id?: IntFieldUpdateOperationsInput | number
    regiao_id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_x_regiaoCreateManyInput = {
    id?: number
    organograma_id: number
    regiao_id: number
  }

  export type organograma_x_regiaoUpdateManyMutationInput = {
    organograma_id?: IntFieldUpdateOperationsInput | number
    regiao_id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_x_regiaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organograma_id?: IntFieldUpdateOperationsInput | number
    regiao_id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_x_regiao_atuacaoCreateInput = {
    organograma_id: number
    regiao_id: number
  }

  export type organograma_x_regiao_atuacaoUncheckedCreateInput = {
    id?: number
    organograma_id: number
    regiao_id: number
  }

  export type organograma_x_regiao_atuacaoUpdateInput = {
    organograma_id?: IntFieldUpdateOperationsInput | number
    regiao_id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_x_regiao_atuacaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organograma_id?: IntFieldUpdateOperationsInput | number
    regiao_id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_x_regiao_atuacaoCreateManyInput = {
    id?: number
    organograma_id: number
    regiao_id: number
  }

  export type organograma_x_regiao_atuacaoUpdateManyMutationInput = {
    organograma_id?: IntFieldUpdateOperationsInput | number
    regiao_id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_x_regiao_atuacaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organograma_id?: IntFieldUpdateOperationsInput | number
    regiao_id?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCreateInput = {
    nome: string
    sobrenome: string
    sexo?: string | null
    nascimento?: Date | string | null
    cpf?: string | null
    rg?: string | null
    usuario?: usuarioCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateInput = {
    id?: number
    nome: string
    sobrenome: string
    sexo?: string | null
    nascimento?: Date | string | null
    cpf?: string | null
    rg?: string | null
    usuario?: usuarioUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: usuarioUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: usuarioUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaCreateManyInput = {
    id?: number
    nome: string
    sobrenome: string
    sexo?: string | null
    nascimento?: Date | string | null
    cpf?: string | null
    rg?: string | null
  }

  export type pessoaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pessoaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plataformaCreateInput = {
    nome?: string | null
  }

  export type plataformaUncheckedCreateInput = {
    id?: number
    nome?: string | null
  }

  export type plataformaUpdateInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plataformaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plataformaCreateManyInput = {
    id?: number
    nome?: string | null
  }

  export type plataformaUpdateManyMutationInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plataformaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plataforma_n_borderosCreateInput = {

  }

  export type plataforma_n_borderosUncheckedCreateInput = {
    id?: number
  }

  export type plataforma_n_borderosUpdateInput = {

  }

  export type plataforma_n_borderosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_n_borderosCreateManyInput = {
    id?: number
  }

  export type plataforma_n_borderosUpdateManyMutationInput = {

  }

  export type plataforma_n_borderosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_papel_tipoCreateInput = {

  }

  export type plataforma_papel_tipoUncheckedCreateInput = {
    id?: number
  }

  export type plataforma_papel_tipoUpdateInput = {

  }

  export type plataforma_papel_tipoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_papel_tipoCreateManyInput = {
    id?: number
  }

  export type plataforma_papel_tipoUpdateManyMutationInput = {

  }

  export type plataforma_papel_tipoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_papel_x_pessoaCreateInput = {

  }

  export type plataforma_papel_x_pessoaUncheckedCreateInput = {
    id?: number
  }

  export type plataforma_papel_x_pessoaUpdateInput = {

  }

  export type plataforma_papel_x_pessoaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_papel_x_pessoaCreateManyInput = {
    id?: number
  }

  export type plataforma_papel_x_pessoaUpdateManyMutationInput = {

  }

  export type plataforma_papel_x_pessoaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_x_regiao_atuacaoCreateInput = {

  }

  export type plataforma_x_regiao_atuacaoUncheckedCreateInput = {
    id?: number
  }

  export type plataforma_x_regiao_atuacaoUpdateInput = {

  }

  export type plataforma_x_regiao_atuacaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_x_regiao_atuacaoCreateManyInput = {
    id?: number
  }

  export type plataforma_x_regiao_atuacaoUpdateManyMutationInput = {

  }

  export type plataforma_x_regiao_atuacaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type regiao_atuacaoCreateInput = {
    nome: string
  }

  export type regiao_atuacaoUncheckedCreateInput = {
    id?: number
    nome: string
  }

  export type regiao_atuacaoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type regiao_atuacaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type regiao_atuacaoCreateManyInput = {
    id?: number
    nome: string
  }

  export type regiao_atuacaoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type regiao_atuacaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type regiao_atuacao_tipoCreateInput = {
    nome: string
  }

  export type regiao_atuacao_tipoUncheckedCreateInput = {
    id?: number
    nome: string
  }

  export type regiao_atuacao_tipoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type regiao_atuacao_tipoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type regiao_atuacao_tipoCreateManyInput = {
    id?: number
    nome: string
  }

  export type regiao_atuacao_tipoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type regiao_atuacao_tipoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type sacadoCreateInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    cedente_n_sacados?: cedente_n_sacadosCreateNestedManyWithoutSacado_cedente_n_sacadosTosacadoInput
  }

  export type sacadoUncheckedCreateInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    cedente_n_sacados?: cedente_n_sacadosUncheckedCreateNestedManyWithoutSacado_cedente_n_sacadosTosacadoInput
  }

  export type sacadoUpdateInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cedente_n_sacados?: cedente_n_sacadosUpdateManyWithoutSacado_cedente_n_sacadosTosacadoNestedInput
  }

  export type sacadoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cedente_n_sacados?: cedente_n_sacadosUncheckedUpdateManyWithoutSacado_cedente_n_sacadosTosacadoNestedInput
  }

  export type sacadoCreateManyInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
  }

  export type sacadoUpdateManyMutationInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sacadoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tituloCreateInput = {
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
    titulo_tipo: titulo_tipoCreateNestedOneWithoutTituloInput
    bordero: borderoCreateNestedOneWithoutTituloInput
  }

  export type tituloUncheckedCreateInput = {
    id?: number
    titulo_tipo_id: number
    bordero_id: number
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
  }

  export type tituloUpdateInput = {
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    titulo_tipo?: titulo_tipoUpdateOneRequiredWithoutTituloNestedInput
    bordero?: borderoUpdateOneRequiredWithoutTituloNestedInput
  }

  export type tituloUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo_tipo_id?: IntFieldUpdateOperationsInput | number
    bordero_id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tituloCreateManyInput = {
    id?: number
    titulo_tipo_id: number
    bordero_id: number
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
  }

  export type tituloUpdateManyMutationInput = {
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tituloUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo_tipo_id?: IntFieldUpdateOperationsInput | number
    bordero_id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type titulo_tipoCreateInput = {
    nome?: string | null
    titulo?: tituloCreateNestedManyWithoutTitulo_tipoInput
  }

  export type titulo_tipoUncheckedCreateInput = {
    id?: number
    nome?: string | null
    titulo?: tituloUncheckedCreateNestedManyWithoutTitulo_tipoInput
  }

  export type titulo_tipoUpdateInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: tituloUpdateManyWithoutTitulo_tipoNestedInput
  }

  export type titulo_tipoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: tituloUncheckedUpdateManyWithoutTitulo_tipoNestedInput
  }

  export type titulo_tipoCreateManyInput = {
    id?: number
    nome?: string | null
  }

  export type titulo_tipoUpdateManyMutationInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type titulo_tipoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type titulo_x_cedenteCreateInput = {
    cedente_cedenteTotitulo_x_cedente: cedenteCreateNestedOneWithoutTitulo_x_cedenteInput
  }

  export type titulo_x_cedenteUncheckedCreateInput = {
    id?: number
    cedente: number
  }

  export type titulo_x_cedenteUpdateInput = {
    cedente_cedenteTotitulo_x_cedente?: cedenteUpdateOneRequiredWithoutTitulo_x_cedenteNestedInput
  }

  export type titulo_x_cedenteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedente?: IntFieldUpdateOperationsInput | number
  }

  export type titulo_x_cedenteCreateManyInput = {
    id?: number
    cedente: number
  }

  export type titulo_x_cedenteUpdateManyMutationInput = {

  }

  export type titulo_x_cedenteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedente?: IntFieldUpdateOperationsInput | number
  }

  export type titulo_x_empresaCreateInput = {

  }

  export type titulo_x_empresaUncheckedCreateInput = {
    id?: number
  }

  export type titulo_x_empresaUpdateInput = {

  }

  export type titulo_x_empresaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type titulo_x_empresaCreateManyInput = {
    id?: number
  }

  export type titulo_x_empresaUpdateManyMutationInput = {

  }

  export type titulo_x_empresaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type titulo_x_plataformaCreateInput = {

  }

  export type titulo_x_plataformaUncheckedCreateInput = {
    id?: number
  }

  export type titulo_x_plataformaUpdateInput = {

  }

  export type titulo_x_plataformaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type titulo_x_plataformaCreateManyInput = {
    id?: number
  }

  export type titulo_x_plataformaUpdateManyMutationInput = {

  }

  export type titulo_x_plataformaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type titulos_x_usuarioCreateInput = {
    status?: string | null
    bordero_borderoTotitulos_x_usuario?: borderoCreateNestedOneWithoutTitulos_x_usuarioInput
    usuario_titulos_x_usuarioTousuario?: usuarioCreateNestedOneWithoutTitulos_x_usuarioInput
  }

  export type titulos_x_usuarioUncheckedCreateInput = {
    id?: number
    usuario?: number | null
    bordero?: number | null
    status?: string | null
  }

  export type titulos_x_usuarioUpdateInput = {
    status?: NullableStringFieldUpdateOperationsInput | string | null
    bordero_borderoTotitulos_x_usuario?: borderoUpdateOneWithoutTitulos_x_usuarioNestedInput
    usuario_titulos_x_usuarioTousuario?: usuarioUpdateOneWithoutTitulos_x_usuarioNestedInput
  }

  export type titulos_x_usuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    bordero?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type titulos_x_usuarioCreateManyInput = {
    id?: number
    usuario?: number | null
    bordero?: number | null
    status?: string | null
  }

  export type titulos_x_usuarioUpdateManyMutationInput = {
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type titulos_x_usuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    bordero?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuarioCreateInput = {
    email: string
    senha: string
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    auditoria?: auditoriaCreateNestedManyWithoutUsuario_auditoriaTousuarioInput
    checagem?: checagemCreateNestedManyWithoutUsuario_checagemTousuarioInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioCreateNestedManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput
    titulos_x_usuario?: titulos_x_usuarioCreateNestedManyWithoutUsuario_titulos_x_usuarioTousuarioInput
    pessoa: pessoaCreateNestedOneWithoutUsuarioInput
    usuario_x_perfil?: usuario_x_perfilCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateInput = {
    id?: number
    email: string
    senha: string
    pessoa_id: number
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuario_auditoriaTousuarioInput
    checagem?: checagemUncheckedCreateNestedManyWithoutUsuario_checagemTousuarioInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedCreateNestedManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput
    titulos_x_usuario?: titulos_x_usuarioUncheckedCreateNestedManyWithoutUsuario_titulos_x_usuarioTousuarioInput
    usuario_x_perfil?: usuario_x_perfilUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditoria?: auditoriaUpdateManyWithoutUsuario_auditoriaTousuarioNestedInput
    checagem?: checagemUpdateManyWithoutUsuario_checagemTousuarioNestedInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUpdateManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioNestedInput
    titulos_x_usuario?: titulos_x_usuarioUpdateManyWithoutUsuario_titulos_x_usuarioTousuarioNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutUsuarioNestedInput
    usuario_x_perfil?: usuario_x_perfilUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    pessoa_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuario_auditoriaTousuarioNestedInput
    checagem?: checagemUncheckedUpdateManyWithoutUsuario_checagemTousuarioNestedInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedUpdateManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioNestedInput
    titulos_x_usuario?: titulos_x_usuarioUncheckedUpdateManyWithoutUsuario_titulos_x_usuarioTousuarioNestedInput
    usuario_x_perfil?: usuario_x_perfilUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioCreateManyInput = {
    id?: number
    email: string
    senha: string
    pessoa_id: number
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type usuarioUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    pessoa_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuario__pessoaCreateInput = {

  }

  export type usuario__pessoaUncheckedCreateInput = {
    id?: number
  }

  export type usuario__pessoaUpdateInput = {

  }

  export type usuario__pessoaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type usuario__pessoaCreateManyInput = {
    id?: number
  }

  export type usuario__pessoaUpdateManyMutationInput = {

  }

  export type usuario__pessoaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type usuario_n_borderosCreateInput = {

  }

  export type usuario_n_borderosUncheckedCreateInput = {
    id?: number
  }

  export type usuario_n_borderosUpdateInput = {

  }

  export type usuario_n_borderosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type usuario_n_borderosCreateManyInput = {
    id?: number
  }

  export type usuario_n_borderosUpdateManyMutationInput = {

  }

  export type usuario_n_borderosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type usuario_perfil_tipoCreateInput = {
    nome: string
    usuario_x_perfil?: usuario_x_perfilCreateNestedManyWithoutUsuario_perfil_tipoInput
  }

  export type usuario_perfil_tipoUncheckedCreateInput = {
    id?: number
    nome: string
    usuario_x_perfil?: usuario_x_perfilUncheckedCreateNestedManyWithoutUsuario_perfil_tipoInput
  }

  export type usuario_perfil_tipoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    usuario_x_perfil?: usuario_x_perfilUpdateManyWithoutUsuario_perfil_tipoNestedInput
  }

  export type usuario_perfil_tipoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    usuario_x_perfil?: usuario_x_perfilUncheckedUpdateManyWithoutUsuario_perfil_tipoNestedInput
  }

  export type usuario_perfil_tipoCreateManyInput = {
    id?: number
    nome: string
  }

  export type usuario_perfil_tipoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type usuario_perfil_tipoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type usuario_x_perfilCreateInput = {
    senha: string
    usuario: usuarioCreateNestedOneWithoutUsuario_x_perfilInput
    usuario_perfil_tipo: usuario_perfil_tipoCreateNestedOneWithoutUsuario_x_perfilInput
  }

  export type usuario_x_perfilUncheckedCreateInput = {
    id?: number
    senha: string
    usuario_id: number
    usuario_perfil_id: number
  }

  export type usuario_x_perfilUpdateInput = {
    senha?: StringFieldUpdateOperationsInput | string
    usuario?: usuarioUpdateOneRequiredWithoutUsuario_x_perfilNestedInput
    usuario_perfil_tipo?: usuario_perfil_tipoUpdateOneRequiredWithoutUsuario_x_perfilNestedInput
  }

  export type usuario_x_perfilUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    usuario_id?: IntFieldUpdateOperationsInput | number
    usuario_perfil_id?: IntFieldUpdateOperationsInput | number
  }

  export type usuario_x_perfilCreateManyInput = {
    id?: number
    senha: string
    usuario_id: number
    usuario_perfil_id: number
  }

  export type usuario_x_perfilUpdateManyMutationInput = {
    senha?: StringFieldUpdateOperationsInput | string
  }

  export type usuario_x_perfilUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    usuario_id?: IntFieldUpdateOperationsInput | number
    usuario_perfil_id?: IntFieldUpdateOperationsInput | number
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type UsuarioRelationFilter = {
    is?: usuarioWhereInput | null
    isNot?: usuarioWhereInput | null
  }

  export type auditoriaCountOrderByAggregateInput = {
    action?: SortOrder
    usuario?: SortOrder
    data?: SortOrder
    modulo?: SortOrder
    id?: SortOrder
  }

  export type auditoriaAvgOrderByAggregateInput = {
    usuario?: SortOrder
    id?: SortOrder
  }

  export type auditoriaMaxOrderByAggregateInput = {
    action?: SortOrder
    usuario?: SortOrder
    data?: SortOrder
    modulo?: SortOrder
    id?: SortOrder
  }

  export type auditoriaMinOrderByAggregateInput = {
    action?: SortOrder
    usuario?: SortOrder
    data?: SortOrder
    modulo?: SortOrder
    id?: SortOrder
  }

  export type auditoriaSumOrderByAggregateInput = {
    usuario?: SortOrder
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type TituloListRelationFilter = {
    every?: tituloWhereInput
    some?: tituloWhereInput
    none?: tituloWhereInput
  }

  export type Titulos_x_usuarioListRelationFilter = {
    every?: titulos_x_usuarioWhereInput
    some?: titulos_x_usuarioWhereInput
    none?: titulos_x_usuarioWhereInput
  }

  export type tituloOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type titulos_x_usuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type borderoCountOrderByAggregateInput = {
    id?: SortOrder
    carteira_id?: SortOrder
  }

  export type borderoAvgOrderByAggregateInput = {
    id?: SortOrder
    carteira_id?: SortOrder
  }

  export type borderoMaxOrderByAggregateInput = {
    id?: SortOrder
    carteira_id?: SortOrder
  }

  export type borderoMinOrderByAggregateInput = {
    id?: SortOrder
    carteira_id?: SortOrder
  }

  export type borderoSumOrderByAggregateInput = {
    id?: SortOrder
    carteira_id?: SortOrder
  }

  export type Fidic_fundoRelationFilter = {
    is?: fidic_fundoWhereInput
    isNot?: fidic_fundoWhereInput
  }

  export type carteiraCountOrderByAggregateInput = {
    id?: SortOrder
    fiduc_fundo_id?: SortOrder
  }

  export type carteiraAvgOrderByAggregateInput = {
    id?: SortOrder
    fiduc_fundo_id?: SortOrder
  }

  export type carteiraMaxOrderByAggregateInput = {
    id?: SortOrder
    fiduc_fundo_id?: SortOrder
  }

  export type carteiraMinOrderByAggregateInput = {
    id?: SortOrder
    fiduc_fundo_id?: SortOrder
  }

  export type carteiraSumOrderByAggregateInput = {
    id?: SortOrder
    fiduc_fundo_id?: SortOrder
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type Cedente_analiseListRelationFilter = {
    every?: cedente_analiseWhereInput
    some?: cedente_analiseWhereInput
    none?: cedente_analiseWhereInput
  }

  export type Cedente_n_sacadosListRelationFilter = {
    every?: cedente_n_sacadosWhereInput
    some?: cedente_n_sacadosWhereInput
    none?: cedente_n_sacadosWhereInput
  }

  export type Titulo_x_cedenteListRelationFilter = {
    every?: titulo_x_cedenteWhereInput
    some?: titulo_x_cedenteWhereInput
    none?: titulo_x_cedenteWhereInput
  }

  export type cedente_analiseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cedente_n_sacadosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type titulo_x_cedenteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cedenteCountOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrder
    numero?: SortOrder
    cep?: SortOrder
    bairro?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    telefone?: SortOrder
  }

  export type cedenteAvgOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
  }

  export type cedenteMaxOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrder
    numero?: SortOrder
    cep?: SortOrder
    bairro?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    telefone?: SortOrder
  }

  export type cedenteMinOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrder
    numero?: SortOrder
    cep?: SortOrder
    bairro?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    telefone?: SortOrder
  }

  export type cedenteSumOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type CedenteRelationFilter = {
    is?: cedenteWhereInput | null
    isNot?: cedenteWhereInput | null
  }

  export type cedente_analiseCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    cedente?: SortOrder
  }

  export type cedente_analiseAvgOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
  }

  export type cedente_analiseMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    cedente?: SortOrder
  }

  export type cedente_analiseMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    cedente?: SortOrder
  }

  export type cedente_analiseSumOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
  }

  export type SacadoRelationFilter = {
    is?: sacadoWhereInput | null
    isNot?: sacadoWhereInput | null
  }

  export type cedente_n_sacadosCountOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
    sacado?: SortOrder
  }

  export type cedente_n_sacadosAvgOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
    sacado?: SortOrder
  }

  export type cedente_n_sacadosMaxOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
    sacado?: SortOrder
  }

  export type cedente_n_sacadosMinOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
    sacado?: SortOrder
  }

  export type cedente_n_sacadosSumOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
    sacado?: SortOrder
  }

  export type checagemCountOrderByAggregateInput = {
    id?: SortOrder
    nf?: SortOrder
    status?: SortOrder
    usuario?: SortOrder
    titulos?: SortOrder
  }

  export type checagemAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
  }

  export type checagemMaxOrderByAggregateInput = {
    id?: SortOrder
    nf?: SortOrder
    status?: SortOrder
    usuario?: SortOrder
    titulos?: SortOrder
  }

  export type checagemMinOrderByAggregateInput = {
    id?: SortOrder
    nf?: SortOrder
    status?: SortOrder
    usuario?: SortOrder
    titulos?: SortOrder
  }

  export type checagemSumOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
  }

  export type CarteiraListRelationFilter = {
    every?: carteiraWhereInput
    some?: carteiraWhereInput
    none?: carteiraWhereInput
  }

  export type Fidic_fundo_x_usuarioListRelationFilter = {
    every?: fidic_fundo_x_usuarioWhereInput
    some?: fidic_fundo_x_usuarioWhereInput
    none?: fidic_fundo_x_usuarioWhereInput
  }

  export type carteiraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type fidic_fundo_x_usuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type fidic_fundoCountOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
  }

  export type fidic_fundoAvgOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
  }

  export type fidic_fundoMaxOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
  }

  export type fidic_fundoMinOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
  }

  export type fidic_fundoSumOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
  }

  export type fidic_fundo_carteira_n_cedentesCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type fidic_fundo_carteira_n_cedentesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type fidic_fundo_carteira_n_cedentesMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type fidic_fundo_carteira_n_cedentesMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type fidic_fundo_carteira_n_cedentesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type fidic_fundo_x_usuarioCountOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
    fidic?: SortOrder
  }

  export type fidic_fundo_x_usuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
    fidic?: SortOrder
  }

  export type fidic_fundo_x_usuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
    fidic?: SortOrder
  }

  export type fidic_fundo_x_usuarioMinOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
    fidic?: SortOrder
  }

  export type fidic_fundo_x_usuarioSumOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
    fidic?: SortOrder
  }

  export type organogramaCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type organogramaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type organogramaMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type organogramaMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type organogramaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type organograma_tipoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type organograma_tipoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type organograma_tipoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type organograma_tipoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type organograma_tipoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type organograma_x_regiaoCountOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_id?: SortOrder
  }

  export type organograma_x_regiaoAvgOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_id?: SortOrder
  }

  export type organograma_x_regiaoMaxOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_id?: SortOrder
  }

  export type organograma_x_regiaoMinOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_id?: SortOrder
  }

  export type organograma_x_regiaoSumOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_id?: SortOrder
  }

  export type organograma_x_regiao_atuacaoCountOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_id?: SortOrder
  }

  export type organograma_x_regiao_atuacaoAvgOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_id?: SortOrder
  }

  export type organograma_x_regiao_atuacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_id?: SortOrder
  }

  export type organograma_x_regiao_atuacaoMinOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_id?: SortOrder
  }

  export type organograma_x_regiao_atuacaoSumOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_id?: SortOrder
  }

  export type UsuarioListRelationFilter = {
    every?: usuarioWhereInput
    some?: usuarioWhereInput
    none?: usuarioWhereInput
  }

  export type usuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pessoaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    sexo?: SortOrder
    nascimento?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
  }

  export type pessoaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pessoaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    sexo?: SortOrder
    nascimento?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
  }

  export type pessoaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    sexo?: SortOrder
    nascimento?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
  }

  export type pessoaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataformaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type plataformaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataformaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type plataformaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type plataformaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_n_borderosCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_n_borderosAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_n_borderosMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_n_borderosMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_n_borderosSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_papel_tipoCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_papel_tipoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_papel_tipoMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_papel_tipoMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_papel_tipoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_papel_x_pessoaCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_papel_x_pessoaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_papel_x_pessoaMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_papel_x_pessoaMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_papel_x_pessoaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_x_regiao_atuacaoCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_x_regiao_atuacaoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_x_regiao_atuacaoMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_x_regiao_atuacaoMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_x_regiao_atuacaoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type regiao_atuacaoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type regiao_atuacaoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type regiao_atuacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type regiao_atuacaoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type regiao_atuacaoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type regiao_atuacao_tipoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type regiao_atuacao_tipoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type regiao_atuacao_tipoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type regiao_atuacao_tipoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type regiao_atuacao_tipoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sacadoCountOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
  }

  export type sacadoAvgOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
  }

  export type sacadoMaxOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
  }

  export type sacadoMinOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
  }

  export type sacadoSumOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type Titulo_tipoRelationFilter = {
    is?: titulo_tipoWhereInput
    isNot?: titulo_tipoWhereInput
  }

  export type BorderoRelationFilter = {
    is?: borderoWhereInput | null
    isNot?: borderoWhereInput | null
  }

  export type tituloCountOrderByAggregateInput = {
    id?: SortOrder
    titulo_tipo_id?: SortOrder
    bordero_id?: SortOrder
    nf?: SortOrder
    valor?: SortOrder
    vencimento?: SortOrder
    numero?: SortOrder
    emissao?: SortOrder
    parcela?: SortOrder
  }

  export type tituloAvgOrderByAggregateInput = {
    id?: SortOrder
    titulo_tipo_id?: SortOrder
    bordero_id?: SortOrder
    valor?: SortOrder
  }

  export type tituloMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo_tipo_id?: SortOrder
    bordero_id?: SortOrder
    nf?: SortOrder
    valor?: SortOrder
    vencimento?: SortOrder
    numero?: SortOrder
    emissao?: SortOrder
    parcela?: SortOrder
  }

  export type tituloMinOrderByAggregateInput = {
    id?: SortOrder
    titulo_tipo_id?: SortOrder
    bordero_id?: SortOrder
    nf?: SortOrder
    valor?: SortOrder
    vencimento?: SortOrder
    numero?: SortOrder
    emissao?: SortOrder
    parcela?: SortOrder
  }

  export type tituloSumOrderByAggregateInput = {
    id?: SortOrder
    titulo_tipo_id?: SortOrder
    bordero_id?: SortOrder
    valor?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type titulo_tipoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type titulo_tipoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type titulo_tipoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type titulo_tipoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type titulo_tipoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type titulo_x_cedenteCountOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
  }

  export type titulo_x_cedenteAvgOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
  }

  export type titulo_x_cedenteMaxOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
  }

  export type titulo_x_cedenteMinOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
  }

  export type titulo_x_cedenteSumOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
  }

  export type titulo_x_empresaCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type titulo_x_empresaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type titulo_x_empresaMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type titulo_x_empresaMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type titulo_x_empresaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type titulo_x_plataformaCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type titulo_x_plataformaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type titulo_x_plataformaMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type titulo_x_plataformaMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type titulo_x_plataformaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type titulos_x_usuarioCountOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
    bordero?: SortOrder
    status?: SortOrder
  }

  export type titulos_x_usuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
    bordero?: SortOrder
  }

  export type titulos_x_usuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
    bordero?: SortOrder
    status?: SortOrder
  }

  export type titulos_x_usuarioMinOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
    bordero?: SortOrder
    status?: SortOrder
  }

  export type titulos_x_usuarioSumOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
    bordero?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type AuditoriaListRelationFilter = {
    every?: auditoriaWhereInput
    some?: auditoriaWhereInput
    none?: auditoriaWhereInput
  }

  export type ChecagemListRelationFilter = {
    every?: checagemWhereInput
    some?: checagemWhereInput
    none?: checagemWhereInput
  }

  export type PessoaRelationFilter = {
    is?: pessoaWhereInput
    isNot?: pessoaWhereInput
  }

  export type Usuario_x_perfilListRelationFilter = {
    every?: usuario_x_perfilWhereInput
    some?: usuario_x_perfilWhereInput
    none?: usuario_x_perfilWhereInput
  }

  export type auditoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type checagemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuario_x_perfilOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuarioCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    pessoa_id?: SortOrder
    status?: SortOrder
    primeiro_acesso?: SortOrder
    confirmou_cadastro?: SortOrder
    codigo_confirma_cadastro?: SortOrder
    codigo_reset_senha?: SortOrder
    codigo_data_expiracao?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
  }

  export type usuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    pessoa_id?: SortOrder
    status?: SortOrder
    primeiro_acesso?: SortOrder
    confirmou_cadastro?: SortOrder
    codigo_confirma_cadastro?: SortOrder
    codigo_reset_senha?: SortOrder
    codigo_data_expiracao?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usuarioMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    pessoa_id?: SortOrder
    status?: SortOrder
    primeiro_acesso?: SortOrder
    confirmou_cadastro?: SortOrder
    codigo_confirma_cadastro?: SortOrder
    codigo_reset_senha?: SortOrder
    codigo_data_expiracao?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usuarioSumOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type usuario__pessoaCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usuario__pessoaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usuario__pessoaMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usuario__pessoaMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usuario__pessoaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usuario_n_borderosCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usuario_n_borderosAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usuario_n_borderosMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usuario_n_borderosMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usuario_n_borderosSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usuario_perfil_tipoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type usuario_perfil_tipoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usuario_perfil_tipoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type usuario_perfil_tipoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type usuario_perfil_tipoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Usuario_perfil_tipoRelationFilter = {
    is?: usuario_perfil_tipoWhereInput
    isNot?: usuario_perfil_tipoWhereInput
  }

  export type usuario_x_perfilCountOrderByAggregateInput = {
    id?: SortOrder
    senha?: SortOrder
    usuario_id?: SortOrder
    usuario_perfil_id?: SortOrder
  }

  export type usuario_x_perfilAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    usuario_perfil_id?: SortOrder
  }

  export type usuario_x_perfilMaxOrderByAggregateInput = {
    id?: SortOrder
    senha?: SortOrder
    usuario_id?: SortOrder
    usuario_perfil_id?: SortOrder
  }

  export type usuario_x_perfilMinOrderByAggregateInput = {
    id?: SortOrder
    senha?: SortOrder
    usuario_id?: SortOrder
    usuario_perfil_id?: SortOrder
  }

  export type usuario_x_perfilSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    usuario_perfil_id?: SortOrder
  }

  export type usuarioCreateNestedOneWithoutAuditoriaInput = {
    create?: XOR<usuarioCreateWithoutAuditoriaInput, usuarioUncheckedCreateWithoutAuditoriaInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutAuditoriaInput
    connect?: usuarioWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type usuarioUpdateOneWithoutAuditoriaNestedInput = {
    create?: XOR<usuarioCreateWithoutAuditoriaInput, usuarioUncheckedCreateWithoutAuditoriaInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutAuditoriaInput
    upsert?: usuarioUpsertWithoutAuditoriaInput
    disconnect?: boolean
    delete?: boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<usuarioUpdateWithoutAuditoriaInput, usuarioUncheckedUpdateWithoutAuditoriaInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type tituloCreateNestedManyWithoutBorderoInput = {
    create?: XOR<Enumerable<tituloCreateWithoutBorderoInput>, Enumerable<tituloUncheckedCreateWithoutBorderoInput>>
    connectOrCreate?: Enumerable<tituloCreateOrConnectWithoutBorderoInput>
    createMany?: tituloCreateManyBorderoInputEnvelope
    connect?: Enumerable<tituloWhereUniqueInput>
  }

  export type titulos_x_usuarioCreateNestedManyWithoutBordero_borderoTotitulos_x_usuarioInput = {
    create?: XOR<Enumerable<titulos_x_usuarioCreateWithoutBordero_borderoTotitulos_x_usuarioInput>, Enumerable<titulos_x_usuarioUncheckedCreateWithoutBordero_borderoTotitulos_x_usuarioInput>>
    connectOrCreate?: Enumerable<titulos_x_usuarioCreateOrConnectWithoutBordero_borderoTotitulos_x_usuarioInput>
    createMany?: titulos_x_usuarioCreateManyBordero_borderoTotitulos_x_usuarioInputEnvelope
    connect?: Enumerable<titulos_x_usuarioWhereUniqueInput>
  }

  export type tituloUncheckedCreateNestedManyWithoutBorderoInput = {
    create?: XOR<Enumerable<tituloCreateWithoutBorderoInput>, Enumerable<tituloUncheckedCreateWithoutBorderoInput>>
    connectOrCreate?: Enumerable<tituloCreateOrConnectWithoutBorderoInput>
    createMany?: tituloCreateManyBorderoInputEnvelope
    connect?: Enumerable<tituloWhereUniqueInput>
  }

  export type titulos_x_usuarioUncheckedCreateNestedManyWithoutBordero_borderoTotitulos_x_usuarioInput = {
    create?: XOR<Enumerable<titulos_x_usuarioCreateWithoutBordero_borderoTotitulos_x_usuarioInput>, Enumerable<titulos_x_usuarioUncheckedCreateWithoutBordero_borderoTotitulos_x_usuarioInput>>
    connectOrCreate?: Enumerable<titulos_x_usuarioCreateOrConnectWithoutBordero_borderoTotitulos_x_usuarioInput>
    createMany?: titulos_x_usuarioCreateManyBordero_borderoTotitulos_x_usuarioInputEnvelope
    connect?: Enumerable<titulos_x_usuarioWhereUniqueInput>
  }

  export type tituloUpdateManyWithoutBorderoNestedInput = {
    create?: XOR<Enumerable<tituloCreateWithoutBorderoInput>, Enumerable<tituloUncheckedCreateWithoutBorderoInput>>
    connectOrCreate?: Enumerable<tituloCreateOrConnectWithoutBorderoInput>
    upsert?: Enumerable<tituloUpsertWithWhereUniqueWithoutBorderoInput>
    createMany?: tituloCreateManyBorderoInputEnvelope
    set?: Enumerable<tituloWhereUniqueInput>
    disconnect?: Enumerable<tituloWhereUniqueInput>
    delete?: Enumerable<tituloWhereUniqueInput>
    connect?: Enumerable<tituloWhereUniqueInput>
    update?: Enumerable<tituloUpdateWithWhereUniqueWithoutBorderoInput>
    updateMany?: Enumerable<tituloUpdateManyWithWhereWithoutBorderoInput>
    deleteMany?: Enumerable<tituloScalarWhereInput>
  }

  export type titulos_x_usuarioUpdateManyWithoutBordero_borderoTotitulos_x_usuarioNestedInput = {
    create?: XOR<Enumerable<titulos_x_usuarioCreateWithoutBordero_borderoTotitulos_x_usuarioInput>, Enumerable<titulos_x_usuarioUncheckedCreateWithoutBordero_borderoTotitulos_x_usuarioInput>>
    connectOrCreate?: Enumerable<titulos_x_usuarioCreateOrConnectWithoutBordero_borderoTotitulos_x_usuarioInput>
    upsert?: Enumerable<titulos_x_usuarioUpsertWithWhereUniqueWithoutBordero_borderoTotitulos_x_usuarioInput>
    createMany?: titulos_x_usuarioCreateManyBordero_borderoTotitulos_x_usuarioInputEnvelope
    set?: Enumerable<titulos_x_usuarioWhereUniqueInput>
    disconnect?: Enumerable<titulos_x_usuarioWhereUniqueInput>
    delete?: Enumerable<titulos_x_usuarioWhereUniqueInput>
    connect?: Enumerable<titulos_x_usuarioWhereUniqueInput>
    update?: Enumerable<titulos_x_usuarioUpdateWithWhereUniqueWithoutBordero_borderoTotitulos_x_usuarioInput>
    updateMany?: Enumerable<titulos_x_usuarioUpdateManyWithWhereWithoutBordero_borderoTotitulos_x_usuarioInput>
    deleteMany?: Enumerable<titulos_x_usuarioScalarWhereInput>
  }

  export type tituloUncheckedUpdateManyWithoutBorderoNestedInput = {
    create?: XOR<Enumerable<tituloCreateWithoutBorderoInput>, Enumerable<tituloUncheckedCreateWithoutBorderoInput>>
    connectOrCreate?: Enumerable<tituloCreateOrConnectWithoutBorderoInput>
    upsert?: Enumerable<tituloUpsertWithWhereUniqueWithoutBorderoInput>
    createMany?: tituloCreateManyBorderoInputEnvelope
    set?: Enumerable<tituloWhereUniqueInput>
    disconnect?: Enumerable<tituloWhereUniqueInput>
    delete?: Enumerable<tituloWhereUniqueInput>
    connect?: Enumerable<tituloWhereUniqueInput>
    update?: Enumerable<tituloUpdateWithWhereUniqueWithoutBorderoInput>
    updateMany?: Enumerable<tituloUpdateManyWithWhereWithoutBorderoInput>
    deleteMany?: Enumerable<tituloScalarWhereInput>
  }

  export type titulos_x_usuarioUncheckedUpdateManyWithoutBordero_borderoTotitulos_x_usuarioNestedInput = {
    create?: XOR<Enumerable<titulos_x_usuarioCreateWithoutBordero_borderoTotitulos_x_usuarioInput>, Enumerable<titulos_x_usuarioUncheckedCreateWithoutBordero_borderoTotitulos_x_usuarioInput>>
    connectOrCreate?: Enumerable<titulos_x_usuarioCreateOrConnectWithoutBordero_borderoTotitulos_x_usuarioInput>
    upsert?: Enumerable<titulos_x_usuarioUpsertWithWhereUniqueWithoutBordero_borderoTotitulos_x_usuarioInput>
    createMany?: titulos_x_usuarioCreateManyBordero_borderoTotitulos_x_usuarioInputEnvelope
    set?: Enumerable<titulos_x_usuarioWhereUniqueInput>
    disconnect?: Enumerable<titulos_x_usuarioWhereUniqueInput>
    delete?: Enumerable<titulos_x_usuarioWhereUniqueInput>
    connect?: Enumerable<titulos_x_usuarioWhereUniqueInput>
    update?: Enumerable<titulos_x_usuarioUpdateWithWhereUniqueWithoutBordero_borderoTotitulos_x_usuarioInput>
    updateMany?: Enumerable<titulos_x_usuarioUpdateManyWithWhereWithoutBordero_borderoTotitulos_x_usuarioInput>
    deleteMany?: Enumerable<titulos_x_usuarioScalarWhereInput>
  }

  export type fidic_fundoCreateNestedOneWithoutCarteiraInput = {
    create?: XOR<fidic_fundoCreateWithoutCarteiraInput, fidic_fundoUncheckedCreateWithoutCarteiraInput>
    connectOrCreate?: fidic_fundoCreateOrConnectWithoutCarteiraInput
    connect?: fidic_fundoWhereUniqueInput
  }

  export type fidic_fundoUpdateOneRequiredWithoutCarteiraNestedInput = {
    create?: XOR<fidic_fundoCreateWithoutCarteiraInput, fidic_fundoUncheckedCreateWithoutCarteiraInput>
    connectOrCreate?: fidic_fundoCreateOrConnectWithoutCarteiraInput
    upsert?: fidic_fundoUpsertWithoutCarteiraInput
    connect?: fidic_fundoWhereUniqueInput
    update?: XOR<fidic_fundoUpdateWithoutCarteiraInput, fidic_fundoUncheckedUpdateWithoutCarteiraInput>
  }

  export type cedente_analiseCreateNestedManyWithoutCedente_cedenteTocedente_analiseInput = {
    create?: XOR<Enumerable<cedente_analiseCreateWithoutCedente_cedenteTocedente_analiseInput>, Enumerable<cedente_analiseUncheckedCreateWithoutCedente_cedenteTocedente_analiseInput>>
    connectOrCreate?: Enumerable<cedente_analiseCreateOrConnectWithoutCedente_cedenteTocedente_analiseInput>
    createMany?: cedente_analiseCreateManyCedente_cedenteTocedente_analiseInputEnvelope
    connect?: Enumerable<cedente_analiseWhereUniqueInput>
  }

  export type cedente_n_sacadosCreateNestedManyWithoutCedente_cedenteTocedente_n_sacadosInput = {
    create?: XOR<Enumerable<cedente_n_sacadosCreateWithoutCedente_cedenteTocedente_n_sacadosInput>, Enumerable<cedente_n_sacadosUncheckedCreateWithoutCedente_cedenteTocedente_n_sacadosInput>>
    connectOrCreate?: Enumerable<cedente_n_sacadosCreateOrConnectWithoutCedente_cedenteTocedente_n_sacadosInput>
    createMany?: cedente_n_sacadosCreateManyCedente_cedenteTocedente_n_sacadosInputEnvelope
    connect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
  }

  export type titulo_x_cedenteCreateNestedManyWithoutCedente_cedenteTotitulo_x_cedenteInput = {
    create?: XOR<Enumerable<titulo_x_cedenteCreateWithoutCedente_cedenteTotitulo_x_cedenteInput>, Enumerable<titulo_x_cedenteUncheckedCreateWithoutCedente_cedenteTotitulo_x_cedenteInput>>
    connectOrCreate?: Enumerable<titulo_x_cedenteCreateOrConnectWithoutCedente_cedenteTotitulo_x_cedenteInput>
    createMany?: titulo_x_cedenteCreateManyCedente_cedenteTotitulo_x_cedenteInputEnvelope
    connect?: Enumerable<titulo_x_cedenteWhereUniqueInput>
  }

  export type cedente_analiseUncheckedCreateNestedManyWithoutCedente_cedenteTocedente_analiseInput = {
    create?: XOR<Enumerable<cedente_analiseCreateWithoutCedente_cedenteTocedente_analiseInput>, Enumerable<cedente_analiseUncheckedCreateWithoutCedente_cedenteTocedente_analiseInput>>
    connectOrCreate?: Enumerable<cedente_analiseCreateOrConnectWithoutCedente_cedenteTocedente_analiseInput>
    createMany?: cedente_analiseCreateManyCedente_cedenteTocedente_analiseInputEnvelope
    connect?: Enumerable<cedente_analiseWhereUniqueInput>
  }

  export type cedente_n_sacadosUncheckedCreateNestedManyWithoutCedente_cedenteTocedente_n_sacadosInput = {
    create?: XOR<Enumerable<cedente_n_sacadosCreateWithoutCedente_cedenteTocedente_n_sacadosInput>, Enumerable<cedente_n_sacadosUncheckedCreateWithoutCedente_cedenteTocedente_n_sacadosInput>>
    connectOrCreate?: Enumerable<cedente_n_sacadosCreateOrConnectWithoutCedente_cedenteTocedente_n_sacadosInput>
    createMany?: cedente_n_sacadosCreateManyCedente_cedenteTocedente_n_sacadosInputEnvelope
    connect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
  }

  export type titulo_x_cedenteUncheckedCreateNestedManyWithoutCedente_cedenteTotitulo_x_cedenteInput = {
    create?: XOR<Enumerable<titulo_x_cedenteCreateWithoutCedente_cedenteTotitulo_x_cedenteInput>, Enumerable<titulo_x_cedenteUncheckedCreateWithoutCedente_cedenteTotitulo_x_cedenteInput>>
    connectOrCreate?: Enumerable<titulo_x_cedenteCreateOrConnectWithoutCedente_cedenteTotitulo_x_cedenteInput>
    createMany?: titulo_x_cedenteCreateManyCedente_cedenteTotitulo_x_cedenteInputEnvelope
    connect?: Enumerable<titulo_x_cedenteWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type cedente_analiseUpdateManyWithoutCedente_cedenteTocedente_analiseNestedInput = {
    create?: XOR<Enumerable<cedente_analiseCreateWithoutCedente_cedenteTocedente_analiseInput>, Enumerable<cedente_analiseUncheckedCreateWithoutCedente_cedenteTocedente_analiseInput>>
    connectOrCreate?: Enumerable<cedente_analiseCreateOrConnectWithoutCedente_cedenteTocedente_analiseInput>
    upsert?: Enumerable<cedente_analiseUpsertWithWhereUniqueWithoutCedente_cedenteTocedente_analiseInput>
    createMany?: cedente_analiseCreateManyCedente_cedenteTocedente_analiseInputEnvelope
    set?: Enumerable<cedente_analiseWhereUniqueInput>
    disconnect?: Enumerable<cedente_analiseWhereUniqueInput>
    delete?: Enumerable<cedente_analiseWhereUniqueInput>
    connect?: Enumerable<cedente_analiseWhereUniqueInput>
    update?: Enumerable<cedente_analiseUpdateWithWhereUniqueWithoutCedente_cedenteTocedente_analiseInput>
    updateMany?: Enumerable<cedente_analiseUpdateManyWithWhereWithoutCedente_cedenteTocedente_analiseInput>
    deleteMany?: Enumerable<cedente_analiseScalarWhereInput>
  }

  export type cedente_n_sacadosUpdateManyWithoutCedente_cedenteTocedente_n_sacadosNestedInput = {
    create?: XOR<Enumerable<cedente_n_sacadosCreateWithoutCedente_cedenteTocedente_n_sacadosInput>, Enumerable<cedente_n_sacadosUncheckedCreateWithoutCedente_cedenteTocedente_n_sacadosInput>>
    connectOrCreate?: Enumerable<cedente_n_sacadosCreateOrConnectWithoutCedente_cedenteTocedente_n_sacadosInput>
    upsert?: Enumerable<cedente_n_sacadosUpsertWithWhereUniqueWithoutCedente_cedenteTocedente_n_sacadosInput>
    createMany?: cedente_n_sacadosCreateManyCedente_cedenteTocedente_n_sacadosInputEnvelope
    set?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    disconnect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    delete?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    connect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    update?: Enumerable<cedente_n_sacadosUpdateWithWhereUniqueWithoutCedente_cedenteTocedente_n_sacadosInput>
    updateMany?: Enumerable<cedente_n_sacadosUpdateManyWithWhereWithoutCedente_cedenteTocedente_n_sacadosInput>
    deleteMany?: Enumerable<cedente_n_sacadosScalarWhereInput>
  }

  export type titulo_x_cedenteUpdateManyWithoutCedente_cedenteTotitulo_x_cedenteNestedInput = {
    create?: XOR<Enumerable<titulo_x_cedenteCreateWithoutCedente_cedenteTotitulo_x_cedenteInput>, Enumerable<titulo_x_cedenteUncheckedCreateWithoutCedente_cedenteTotitulo_x_cedenteInput>>
    connectOrCreate?: Enumerable<titulo_x_cedenteCreateOrConnectWithoutCedente_cedenteTotitulo_x_cedenteInput>
    upsert?: Enumerable<titulo_x_cedenteUpsertWithWhereUniqueWithoutCedente_cedenteTotitulo_x_cedenteInput>
    createMany?: titulo_x_cedenteCreateManyCedente_cedenteTotitulo_x_cedenteInputEnvelope
    set?: Enumerable<titulo_x_cedenteWhereUniqueInput>
    disconnect?: Enumerable<titulo_x_cedenteWhereUniqueInput>
    delete?: Enumerable<titulo_x_cedenteWhereUniqueInput>
    connect?: Enumerable<titulo_x_cedenteWhereUniqueInput>
    update?: Enumerable<titulo_x_cedenteUpdateWithWhereUniqueWithoutCedente_cedenteTotitulo_x_cedenteInput>
    updateMany?: Enumerable<titulo_x_cedenteUpdateManyWithWhereWithoutCedente_cedenteTotitulo_x_cedenteInput>
    deleteMany?: Enumerable<titulo_x_cedenteScalarWhereInput>
  }

  export type cedente_analiseUncheckedUpdateManyWithoutCedente_cedenteTocedente_analiseNestedInput = {
    create?: XOR<Enumerable<cedente_analiseCreateWithoutCedente_cedenteTocedente_analiseInput>, Enumerable<cedente_analiseUncheckedCreateWithoutCedente_cedenteTocedente_analiseInput>>
    connectOrCreate?: Enumerable<cedente_analiseCreateOrConnectWithoutCedente_cedenteTocedente_analiseInput>
    upsert?: Enumerable<cedente_analiseUpsertWithWhereUniqueWithoutCedente_cedenteTocedente_analiseInput>
    createMany?: cedente_analiseCreateManyCedente_cedenteTocedente_analiseInputEnvelope
    set?: Enumerable<cedente_analiseWhereUniqueInput>
    disconnect?: Enumerable<cedente_analiseWhereUniqueInput>
    delete?: Enumerable<cedente_analiseWhereUniqueInput>
    connect?: Enumerable<cedente_analiseWhereUniqueInput>
    update?: Enumerable<cedente_analiseUpdateWithWhereUniqueWithoutCedente_cedenteTocedente_analiseInput>
    updateMany?: Enumerable<cedente_analiseUpdateManyWithWhereWithoutCedente_cedenteTocedente_analiseInput>
    deleteMany?: Enumerable<cedente_analiseScalarWhereInput>
  }

  export type cedente_n_sacadosUncheckedUpdateManyWithoutCedente_cedenteTocedente_n_sacadosNestedInput = {
    create?: XOR<Enumerable<cedente_n_sacadosCreateWithoutCedente_cedenteTocedente_n_sacadosInput>, Enumerable<cedente_n_sacadosUncheckedCreateWithoutCedente_cedenteTocedente_n_sacadosInput>>
    connectOrCreate?: Enumerable<cedente_n_sacadosCreateOrConnectWithoutCedente_cedenteTocedente_n_sacadosInput>
    upsert?: Enumerable<cedente_n_sacadosUpsertWithWhereUniqueWithoutCedente_cedenteTocedente_n_sacadosInput>
    createMany?: cedente_n_sacadosCreateManyCedente_cedenteTocedente_n_sacadosInputEnvelope
    set?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    disconnect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    delete?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    connect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    update?: Enumerable<cedente_n_sacadosUpdateWithWhereUniqueWithoutCedente_cedenteTocedente_n_sacadosInput>
    updateMany?: Enumerable<cedente_n_sacadosUpdateManyWithWhereWithoutCedente_cedenteTocedente_n_sacadosInput>
    deleteMany?: Enumerable<cedente_n_sacadosScalarWhereInput>
  }

  export type titulo_x_cedenteUncheckedUpdateManyWithoutCedente_cedenteTotitulo_x_cedenteNestedInput = {
    create?: XOR<Enumerable<titulo_x_cedenteCreateWithoutCedente_cedenteTotitulo_x_cedenteInput>, Enumerable<titulo_x_cedenteUncheckedCreateWithoutCedente_cedenteTotitulo_x_cedenteInput>>
    connectOrCreate?: Enumerable<titulo_x_cedenteCreateOrConnectWithoutCedente_cedenteTotitulo_x_cedenteInput>
    upsert?: Enumerable<titulo_x_cedenteUpsertWithWhereUniqueWithoutCedente_cedenteTotitulo_x_cedenteInput>
    createMany?: titulo_x_cedenteCreateManyCedente_cedenteTotitulo_x_cedenteInputEnvelope
    set?: Enumerable<titulo_x_cedenteWhereUniqueInput>
    disconnect?: Enumerable<titulo_x_cedenteWhereUniqueInput>
    delete?: Enumerable<titulo_x_cedenteWhereUniqueInput>
    connect?: Enumerable<titulo_x_cedenteWhereUniqueInput>
    update?: Enumerable<titulo_x_cedenteUpdateWithWhereUniqueWithoutCedente_cedenteTotitulo_x_cedenteInput>
    updateMany?: Enumerable<titulo_x_cedenteUpdateManyWithWhereWithoutCedente_cedenteTotitulo_x_cedenteInput>
    deleteMany?: Enumerable<titulo_x_cedenteScalarWhereInput>
  }

  export type cedenteCreateNestedOneWithoutCedente_analiseInput = {
    create?: XOR<cedenteCreateWithoutCedente_analiseInput, cedenteUncheckedCreateWithoutCedente_analiseInput>
    connectOrCreate?: cedenteCreateOrConnectWithoutCedente_analiseInput
    connect?: cedenteWhereUniqueInput
  }

  export type cedenteUpdateOneWithoutCedente_analiseNestedInput = {
    create?: XOR<cedenteCreateWithoutCedente_analiseInput, cedenteUncheckedCreateWithoutCedente_analiseInput>
    connectOrCreate?: cedenteCreateOrConnectWithoutCedente_analiseInput
    upsert?: cedenteUpsertWithoutCedente_analiseInput
    disconnect?: boolean
    delete?: boolean
    connect?: cedenteWhereUniqueInput
    update?: XOR<cedenteUpdateWithoutCedente_analiseInput, cedenteUncheckedUpdateWithoutCedente_analiseInput>
  }

  export type cedenteCreateNestedOneWithoutCedente_n_sacadosInput = {
    create?: XOR<cedenteCreateWithoutCedente_n_sacadosInput, cedenteUncheckedCreateWithoutCedente_n_sacadosInput>
    connectOrCreate?: cedenteCreateOrConnectWithoutCedente_n_sacadosInput
    connect?: cedenteWhereUniqueInput
  }

  export type sacadoCreateNestedOneWithoutCedente_n_sacadosInput = {
    create?: XOR<sacadoCreateWithoutCedente_n_sacadosInput, sacadoUncheckedCreateWithoutCedente_n_sacadosInput>
    connectOrCreate?: sacadoCreateOrConnectWithoutCedente_n_sacadosInput
    connect?: sacadoWhereUniqueInput
  }

  export type cedenteUpdateOneWithoutCedente_n_sacadosNestedInput = {
    create?: XOR<cedenteCreateWithoutCedente_n_sacadosInput, cedenteUncheckedCreateWithoutCedente_n_sacadosInput>
    connectOrCreate?: cedenteCreateOrConnectWithoutCedente_n_sacadosInput
    upsert?: cedenteUpsertWithoutCedente_n_sacadosInput
    disconnect?: boolean
    delete?: boolean
    connect?: cedenteWhereUniqueInput
    update?: XOR<cedenteUpdateWithoutCedente_n_sacadosInput, cedenteUncheckedUpdateWithoutCedente_n_sacadosInput>
  }

  export type sacadoUpdateOneWithoutCedente_n_sacadosNestedInput = {
    create?: XOR<sacadoCreateWithoutCedente_n_sacadosInput, sacadoUncheckedCreateWithoutCedente_n_sacadosInput>
    connectOrCreate?: sacadoCreateOrConnectWithoutCedente_n_sacadosInput
    upsert?: sacadoUpsertWithoutCedente_n_sacadosInput
    disconnect?: boolean
    delete?: boolean
    connect?: sacadoWhereUniqueInput
    update?: XOR<sacadoUpdateWithoutCedente_n_sacadosInput, sacadoUncheckedUpdateWithoutCedente_n_sacadosInput>
  }

  export type usuarioCreateNestedOneWithoutChecagemInput = {
    create?: XOR<usuarioCreateWithoutChecagemInput, usuarioUncheckedCreateWithoutChecagemInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutChecagemInput
    connect?: usuarioWhereUniqueInput
  }

  export type usuarioUpdateOneWithoutChecagemNestedInput = {
    create?: XOR<usuarioCreateWithoutChecagemInput, usuarioUncheckedCreateWithoutChecagemInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutChecagemInput
    upsert?: usuarioUpsertWithoutChecagemInput
    disconnect?: boolean
    delete?: boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<usuarioUpdateWithoutChecagemInput, usuarioUncheckedUpdateWithoutChecagemInput>
  }

  export type carteiraCreateNestedManyWithoutFidic_fundoInput = {
    create?: XOR<Enumerable<carteiraCreateWithoutFidic_fundoInput>, Enumerable<carteiraUncheckedCreateWithoutFidic_fundoInput>>
    connectOrCreate?: Enumerable<carteiraCreateOrConnectWithoutFidic_fundoInput>
    createMany?: carteiraCreateManyFidic_fundoInputEnvelope
    connect?: Enumerable<carteiraWhereUniqueInput>
  }

  export type fidic_fundo_x_usuarioCreateNestedManyWithoutFidic_fundoInput = {
    create?: XOR<Enumerable<fidic_fundo_x_usuarioCreateWithoutFidic_fundoInput>, Enumerable<fidic_fundo_x_usuarioUncheckedCreateWithoutFidic_fundoInput>>
    connectOrCreate?: Enumerable<fidic_fundo_x_usuarioCreateOrConnectWithoutFidic_fundoInput>
    createMany?: fidic_fundo_x_usuarioCreateManyFidic_fundoInputEnvelope
    connect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
  }

  export type carteiraUncheckedCreateNestedManyWithoutFidic_fundoInput = {
    create?: XOR<Enumerable<carteiraCreateWithoutFidic_fundoInput>, Enumerable<carteiraUncheckedCreateWithoutFidic_fundoInput>>
    connectOrCreate?: Enumerable<carteiraCreateOrConnectWithoutFidic_fundoInput>
    createMany?: carteiraCreateManyFidic_fundoInputEnvelope
    connect?: Enumerable<carteiraWhereUniqueInput>
  }

  export type fidic_fundo_x_usuarioUncheckedCreateNestedManyWithoutFidic_fundoInput = {
    create?: XOR<Enumerable<fidic_fundo_x_usuarioCreateWithoutFidic_fundoInput>, Enumerable<fidic_fundo_x_usuarioUncheckedCreateWithoutFidic_fundoInput>>
    connectOrCreate?: Enumerable<fidic_fundo_x_usuarioCreateOrConnectWithoutFidic_fundoInput>
    createMany?: fidic_fundo_x_usuarioCreateManyFidic_fundoInputEnvelope
    connect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
  }

  export type carteiraUpdateManyWithoutFidic_fundoNestedInput = {
    create?: XOR<Enumerable<carteiraCreateWithoutFidic_fundoInput>, Enumerable<carteiraUncheckedCreateWithoutFidic_fundoInput>>
    connectOrCreate?: Enumerable<carteiraCreateOrConnectWithoutFidic_fundoInput>
    upsert?: Enumerable<carteiraUpsertWithWhereUniqueWithoutFidic_fundoInput>
    createMany?: carteiraCreateManyFidic_fundoInputEnvelope
    set?: Enumerable<carteiraWhereUniqueInput>
    disconnect?: Enumerable<carteiraWhereUniqueInput>
    delete?: Enumerable<carteiraWhereUniqueInput>
    connect?: Enumerable<carteiraWhereUniqueInput>
    update?: Enumerable<carteiraUpdateWithWhereUniqueWithoutFidic_fundoInput>
    updateMany?: Enumerable<carteiraUpdateManyWithWhereWithoutFidic_fundoInput>
    deleteMany?: Enumerable<carteiraScalarWhereInput>
  }

  export type fidic_fundo_x_usuarioUpdateManyWithoutFidic_fundoNestedInput = {
    create?: XOR<Enumerable<fidic_fundo_x_usuarioCreateWithoutFidic_fundoInput>, Enumerable<fidic_fundo_x_usuarioUncheckedCreateWithoutFidic_fundoInput>>
    connectOrCreate?: Enumerable<fidic_fundo_x_usuarioCreateOrConnectWithoutFidic_fundoInput>
    upsert?: Enumerable<fidic_fundo_x_usuarioUpsertWithWhereUniqueWithoutFidic_fundoInput>
    createMany?: fidic_fundo_x_usuarioCreateManyFidic_fundoInputEnvelope
    set?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    disconnect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    delete?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    connect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    update?: Enumerable<fidic_fundo_x_usuarioUpdateWithWhereUniqueWithoutFidic_fundoInput>
    updateMany?: Enumerable<fidic_fundo_x_usuarioUpdateManyWithWhereWithoutFidic_fundoInput>
    deleteMany?: Enumerable<fidic_fundo_x_usuarioScalarWhereInput>
  }

  export type carteiraUncheckedUpdateManyWithoutFidic_fundoNestedInput = {
    create?: XOR<Enumerable<carteiraCreateWithoutFidic_fundoInput>, Enumerable<carteiraUncheckedCreateWithoutFidic_fundoInput>>
    connectOrCreate?: Enumerable<carteiraCreateOrConnectWithoutFidic_fundoInput>
    upsert?: Enumerable<carteiraUpsertWithWhereUniqueWithoutFidic_fundoInput>
    createMany?: carteiraCreateManyFidic_fundoInputEnvelope
    set?: Enumerable<carteiraWhereUniqueInput>
    disconnect?: Enumerable<carteiraWhereUniqueInput>
    delete?: Enumerable<carteiraWhereUniqueInput>
    connect?: Enumerable<carteiraWhereUniqueInput>
    update?: Enumerable<carteiraUpdateWithWhereUniqueWithoutFidic_fundoInput>
    updateMany?: Enumerable<carteiraUpdateManyWithWhereWithoutFidic_fundoInput>
    deleteMany?: Enumerable<carteiraScalarWhereInput>
  }

  export type fidic_fundo_x_usuarioUncheckedUpdateManyWithoutFidic_fundoNestedInput = {
    create?: XOR<Enumerable<fidic_fundo_x_usuarioCreateWithoutFidic_fundoInput>, Enumerable<fidic_fundo_x_usuarioUncheckedCreateWithoutFidic_fundoInput>>
    connectOrCreate?: Enumerable<fidic_fundo_x_usuarioCreateOrConnectWithoutFidic_fundoInput>
    upsert?: Enumerable<fidic_fundo_x_usuarioUpsertWithWhereUniqueWithoutFidic_fundoInput>
    createMany?: fidic_fundo_x_usuarioCreateManyFidic_fundoInputEnvelope
    set?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    disconnect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    delete?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    connect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    update?: Enumerable<fidic_fundo_x_usuarioUpdateWithWhereUniqueWithoutFidic_fundoInput>
    updateMany?: Enumerable<fidic_fundo_x_usuarioUpdateManyWithWhereWithoutFidic_fundoInput>
    deleteMany?: Enumerable<fidic_fundo_x_usuarioScalarWhereInput>
  }

  export type fidic_fundoCreateNestedOneWithoutFidic_fundo_x_usuarioInput = {
    create?: XOR<fidic_fundoCreateWithoutFidic_fundo_x_usuarioInput, fidic_fundoUncheckedCreateWithoutFidic_fundo_x_usuarioInput>
    connectOrCreate?: fidic_fundoCreateOrConnectWithoutFidic_fundo_x_usuarioInput
    connect?: fidic_fundoWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutFidic_fundo_x_usuarioInput = {
    create?: XOR<usuarioCreateWithoutFidic_fundo_x_usuarioInput, usuarioUncheckedCreateWithoutFidic_fundo_x_usuarioInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutFidic_fundo_x_usuarioInput
    connect?: usuarioWhereUniqueInput
  }

  export type fidic_fundoUpdateOneRequiredWithoutFidic_fundo_x_usuarioNestedInput = {
    create?: XOR<fidic_fundoCreateWithoutFidic_fundo_x_usuarioInput, fidic_fundoUncheckedCreateWithoutFidic_fundo_x_usuarioInput>
    connectOrCreate?: fidic_fundoCreateOrConnectWithoutFidic_fundo_x_usuarioInput
    upsert?: fidic_fundoUpsertWithoutFidic_fundo_x_usuarioInput
    connect?: fidic_fundoWhereUniqueInput
    update?: XOR<fidic_fundoUpdateWithoutFidic_fundo_x_usuarioInput, fidic_fundoUncheckedUpdateWithoutFidic_fundo_x_usuarioInput>
  }

  export type usuarioUpdateOneWithoutFidic_fundo_x_usuarioNestedInput = {
    create?: XOR<usuarioCreateWithoutFidic_fundo_x_usuarioInput, usuarioUncheckedCreateWithoutFidic_fundo_x_usuarioInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutFidic_fundo_x_usuarioInput
    upsert?: usuarioUpsertWithoutFidic_fundo_x_usuarioInput
    disconnect?: boolean
    delete?: boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<usuarioUpdateWithoutFidic_fundo_x_usuarioInput, usuarioUncheckedUpdateWithoutFidic_fundo_x_usuarioInput>
  }

  export type usuarioCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<usuarioCreateWithoutPessoaInput>, Enumerable<usuarioUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<usuarioCreateOrConnectWithoutPessoaInput>
    createMany?: usuarioCreateManyPessoaInputEnvelope
    connect?: Enumerable<usuarioWhereUniqueInput>
  }

  export type usuarioUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<usuarioCreateWithoutPessoaInput>, Enumerable<usuarioUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<usuarioCreateOrConnectWithoutPessoaInput>
    createMany?: usuarioCreateManyPessoaInputEnvelope
    connect?: Enumerable<usuarioWhereUniqueInput>
  }

  export type usuarioUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<usuarioCreateWithoutPessoaInput>, Enumerable<usuarioUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<usuarioCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<usuarioUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: usuarioCreateManyPessoaInputEnvelope
    set?: Enumerable<usuarioWhereUniqueInput>
    disconnect?: Enumerable<usuarioWhereUniqueInput>
    delete?: Enumerable<usuarioWhereUniqueInput>
    connect?: Enumerable<usuarioWhereUniqueInput>
    update?: Enumerable<usuarioUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<usuarioUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<usuarioScalarWhereInput>
  }

  export type usuarioUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<usuarioCreateWithoutPessoaInput>, Enumerable<usuarioUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<usuarioCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<usuarioUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: usuarioCreateManyPessoaInputEnvelope
    set?: Enumerable<usuarioWhereUniqueInput>
    disconnect?: Enumerable<usuarioWhereUniqueInput>
    delete?: Enumerable<usuarioWhereUniqueInput>
    connect?: Enumerable<usuarioWhereUniqueInput>
    update?: Enumerable<usuarioUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<usuarioUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<usuarioScalarWhereInput>
  }

  export type cedente_n_sacadosCreateNestedManyWithoutSacado_cedente_n_sacadosTosacadoInput = {
    create?: XOR<Enumerable<cedente_n_sacadosCreateWithoutSacado_cedente_n_sacadosTosacadoInput>, Enumerable<cedente_n_sacadosUncheckedCreateWithoutSacado_cedente_n_sacadosTosacadoInput>>
    connectOrCreate?: Enumerable<cedente_n_sacadosCreateOrConnectWithoutSacado_cedente_n_sacadosTosacadoInput>
    createMany?: cedente_n_sacadosCreateManySacado_cedente_n_sacadosTosacadoInputEnvelope
    connect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
  }

  export type cedente_n_sacadosUncheckedCreateNestedManyWithoutSacado_cedente_n_sacadosTosacadoInput = {
    create?: XOR<Enumerable<cedente_n_sacadosCreateWithoutSacado_cedente_n_sacadosTosacadoInput>, Enumerable<cedente_n_sacadosUncheckedCreateWithoutSacado_cedente_n_sacadosTosacadoInput>>
    connectOrCreate?: Enumerable<cedente_n_sacadosCreateOrConnectWithoutSacado_cedente_n_sacadosTosacadoInput>
    createMany?: cedente_n_sacadosCreateManySacado_cedente_n_sacadosTosacadoInputEnvelope
    connect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
  }

  export type cedente_n_sacadosUpdateManyWithoutSacado_cedente_n_sacadosTosacadoNestedInput = {
    create?: XOR<Enumerable<cedente_n_sacadosCreateWithoutSacado_cedente_n_sacadosTosacadoInput>, Enumerable<cedente_n_sacadosUncheckedCreateWithoutSacado_cedente_n_sacadosTosacadoInput>>
    connectOrCreate?: Enumerable<cedente_n_sacadosCreateOrConnectWithoutSacado_cedente_n_sacadosTosacadoInput>
    upsert?: Enumerable<cedente_n_sacadosUpsertWithWhereUniqueWithoutSacado_cedente_n_sacadosTosacadoInput>
    createMany?: cedente_n_sacadosCreateManySacado_cedente_n_sacadosTosacadoInputEnvelope
    set?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    disconnect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    delete?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    connect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    update?: Enumerable<cedente_n_sacadosUpdateWithWhereUniqueWithoutSacado_cedente_n_sacadosTosacadoInput>
    updateMany?: Enumerable<cedente_n_sacadosUpdateManyWithWhereWithoutSacado_cedente_n_sacadosTosacadoInput>
    deleteMany?: Enumerable<cedente_n_sacadosScalarWhereInput>
  }

  export type cedente_n_sacadosUncheckedUpdateManyWithoutSacado_cedente_n_sacadosTosacadoNestedInput = {
    create?: XOR<Enumerable<cedente_n_sacadosCreateWithoutSacado_cedente_n_sacadosTosacadoInput>, Enumerable<cedente_n_sacadosUncheckedCreateWithoutSacado_cedente_n_sacadosTosacadoInput>>
    connectOrCreate?: Enumerable<cedente_n_sacadosCreateOrConnectWithoutSacado_cedente_n_sacadosTosacadoInput>
    upsert?: Enumerable<cedente_n_sacadosUpsertWithWhereUniqueWithoutSacado_cedente_n_sacadosTosacadoInput>
    createMany?: cedente_n_sacadosCreateManySacado_cedente_n_sacadosTosacadoInputEnvelope
    set?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    disconnect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    delete?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    connect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    update?: Enumerable<cedente_n_sacadosUpdateWithWhereUniqueWithoutSacado_cedente_n_sacadosTosacadoInput>
    updateMany?: Enumerable<cedente_n_sacadosUpdateManyWithWhereWithoutSacado_cedente_n_sacadosTosacadoInput>
    deleteMany?: Enumerable<cedente_n_sacadosScalarWhereInput>
  }

  export type titulo_tipoCreateNestedOneWithoutTituloInput = {
    create?: XOR<titulo_tipoCreateWithoutTituloInput, titulo_tipoUncheckedCreateWithoutTituloInput>
    connectOrCreate?: titulo_tipoCreateOrConnectWithoutTituloInput
    connect?: titulo_tipoWhereUniqueInput
  }

  export type borderoCreateNestedOneWithoutTituloInput = {
    create?: XOR<borderoCreateWithoutTituloInput, borderoUncheckedCreateWithoutTituloInput>
    connectOrCreate?: borderoCreateOrConnectWithoutTituloInput
    connect?: borderoWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type titulo_tipoUpdateOneRequiredWithoutTituloNestedInput = {
    create?: XOR<titulo_tipoCreateWithoutTituloInput, titulo_tipoUncheckedCreateWithoutTituloInput>
    connectOrCreate?: titulo_tipoCreateOrConnectWithoutTituloInput
    upsert?: titulo_tipoUpsertWithoutTituloInput
    connect?: titulo_tipoWhereUniqueInput
    update?: XOR<titulo_tipoUpdateWithoutTituloInput, titulo_tipoUncheckedUpdateWithoutTituloInput>
  }

  export type borderoUpdateOneRequiredWithoutTituloNestedInput = {
    create?: XOR<borderoCreateWithoutTituloInput, borderoUncheckedCreateWithoutTituloInput>
    connectOrCreate?: borderoCreateOrConnectWithoutTituloInput
    upsert?: borderoUpsertWithoutTituloInput
    connect?: borderoWhereUniqueInput
    update?: XOR<borderoUpdateWithoutTituloInput, borderoUncheckedUpdateWithoutTituloInput>
  }

  export type tituloCreateNestedManyWithoutTitulo_tipoInput = {
    create?: XOR<Enumerable<tituloCreateWithoutTitulo_tipoInput>, Enumerable<tituloUncheckedCreateWithoutTitulo_tipoInput>>
    connectOrCreate?: Enumerable<tituloCreateOrConnectWithoutTitulo_tipoInput>
    createMany?: tituloCreateManyTitulo_tipoInputEnvelope
    connect?: Enumerable<tituloWhereUniqueInput>
  }

  export type tituloUncheckedCreateNestedManyWithoutTitulo_tipoInput = {
    create?: XOR<Enumerable<tituloCreateWithoutTitulo_tipoInput>, Enumerable<tituloUncheckedCreateWithoutTitulo_tipoInput>>
    connectOrCreate?: Enumerable<tituloCreateOrConnectWithoutTitulo_tipoInput>
    createMany?: tituloCreateManyTitulo_tipoInputEnvelope
    connect?: Enumerable<tituloWhereUniqueInput>
  }

  export type tituloUpdateManyWithoutTitulo_tipoNestedInput = {
    create?: XOR<Enumerable<tituloCreateWithoutTitulo_tipoInput>, Enumerable<tituloUncheckedCreateWithoutTitulo_tipoInput>>
    connectOrCreate?: Enumerable<tituloCreateOrConnectWithoutTitulo_tipoInput>
    upsert?: Enumerable<tituloUpsertWithWhereUniqueWithoutTitulo_tipoInput>
    createMany?: tituloCreateManyTitulo_tipoInputEnvelope
    set?: Enumerable<tituloWhereUniqueInput>
    disconnect?: Enumerable<tituloWhereUniqueInput>
    delete?: Enumerable<tituloWhereUniqueInput>
    connect?: Enumerable<tituloWhereUniqueInput>
    update?: Enumerable<tituloUpdateWithWhereUniqueWithoutTitulo_tipoInput>
    updateMany?: Enumerable<tituloUpdateManyWithWhereWithoutTitulo_tipoInput>
    deleteMany?: Enumerable<tituloScalarWhereInput>
  }

  export type tituloUncheckedUpdateManyWithoutTitulo_tipoNestedInput = {
    create?: XOR<Enumerable<tituloCreateWithoutTitulo_tipoInput>, Enumerable<tituloUncheckedCreateWithoutTitulo_tipoInput>>
    connectOrCreate?: Enumerable<tituloCreateOrConnectWithoutTitulo_tipoInput>
    upsert?: Enumerable<tituloUpsertWithWhereUniqueWithoutTitulo_tipoInput>
    createMany?: tituloCreateManyTitulo_tipoInputEnvelope
    set?: Enumerable<tituloWhereUniqueInput>
    disconnect?: Enumerable<tituloWhereUniqueInput>
    delete?: Enumerable<tituloWhereUniqueInput>
    connect?: Enumerable<tituloWhereUniqueInput>
    update?: Enumerable<tituloUpdateWithWhereUniqueWithoutTitulo_tipoInput>
    updateMany?: Enumerable<tituloUpdateManyWithWhereWithoutTitulo_tipoInput>
    deleteMany?: Enumerable<tituloScalarWhereInput>
  }

  export type cedenteCreateNestedOneWithoutTitulo_x_cedenteInput = {
    create?: XOR<cedenteCreateWithoutTitulo_x_cedenteInput, cedenteUncheckedCreateWithoutTitulo_x_cedenteInput>
    connectOrCreate?: cedenteCreateOrConnectWithoutTitulo_x_cedenteInput
    connect?: cedenteWhereUniqueInput
  }

  export type cedenteUpdateOneRequiredWithoutTitulo_x_cedenteNestedInput = {
    create?: XOR<cedenteCreateWithoutTitulo_x_cedenteInput, cedenteUncheckedCreateWithoutTitulo_x_cedenteInput>
    connectOrCreate?: cedenteCreateOrConnectWithoutTitulo_x_cedenteInput
    upsert?: cedenteUpsertWithoutTitulo_x_cedenteInput
    connect?: cedenteWhereUniqueInput
    update?: XOR<cedenteUpdateWithoutTitulo_x_cedenteInput, cedenteUncheckedUpdateWithoutTitulo_x_cedenteInput>
  }

  export type borderoCreateNestedOneWithoutTitulos_x_usuarioInput = {
    create?: XOR<borderoCreateWithoutTitulos_x_usuarioInput, borderoUncheckedCreateWithoutTitulos_x_usuarioInput>
    connectOrCreate?: borderoCreateOrConnectWithoutTitulos_x_usuarioInput
    connect?: borderoWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutTitulos_x_usuarioInput = {
    create?: XOR<usuarioCreateWithoutTitulos_x_usuarioInput, usuarioUncheckedCreateWithoutTitulos_x_usuarioInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutTitulos_x_usuarioInput
    connect?: usuarioWhereUniqueInput
  }

  export type borderoUpdateOneWithoutTitulos_x_usuarioNestedInput = {
    create?: XOR<borderoCreateWithoutTitulos_x_usuarioInput, borderoUncheckedCreateWithoutTitulos_x_usuarioInput>
    connectOrCreate?: borderoCreateOrConnectWithoutTitulos_x_usuarioInput
    upsert?: borderoUpsertWithoutTitulos_x_usuarioInput
    disconnect?: boolean
    delete?: boolean
    connect?: borderoWhereUniqueInput
    update?: XOR<borderoUpdateWithoutTitulos_x_usuarioInput, borderoUncheckedUpdateWithoutTitulos_x_usuarioInput>
  }

  export type usuarioUpdateOneWithoutTitulos_x_usuarioNestedInput = {
    create?: XOR<usuarioCreateWithoutTitulos_x_usuarioInput, usuarioUncheckedCreateWithoutTitulos_x_usuarioInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutTitulos_x_usuarioInput
    upsert?: usuarioUpsertWithoutTitulos_x_usuarioInput
    disconnect?: boolean
    delete?: boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<usuarioUpdateWithoutTitulos_x_usuarioInput, usuarioUncheckedUpdateWithoutTitulos_x_usuarioInput>
  }

  export type auditoriaCreateNestedManyWithoutUsuario_auditoriaTousuarioInput = {
    create?: XOR<Enumerable<auditoriaCreateWithoutUsuario_auditoriaTousuarioInput>, Enumerable<auditoriaUncheckedCreateWithoutUsuario_auditoriaTousuarioInput>>
    connectOrCreate?: Enumerable<auditoriaCreateOrConnectWithoutUsuario_auditoriaTousuarioInput>
    createMany?: auditoriaCreateManyUsuario_auditoriaTousuarioInputEnvelope
    connect?: Enumerable<auditoriaWhereUniqueInput>
  }

  export type checagemCreateNestedManyWithoutUsuario_checagemTousuarioInput = {
    create?: XOR<Enumerable<checagemCreateWithoutUsuario_checagemTousuarioInput>, Enumerable<checagemUncheckedCreateWithoutUsuario_checagemTousuarioInput>>
    connectOrCreate?: Enumerable<checagemCreateOrConnectWithoutUsuario_checagemTousuarioInput>
    createMany?: checagemCreateManyUsuario_checagemTousuarioInputEnvelope
    connect?: Enumerable<checagemWhereUniqueInput>
  }

  export type fidic_fundo_x_usuarioCreateNestedManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput = {
    create?: XOR<Enumerable<fidic_fundo_x_usuarioCreateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>, Enumerable<fidic_fundo_x_usuarioUncheckedCreateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>>
    connectOrCreate?: Enumerable<fidic_fundo_x_usuarioCreateOrConnectWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>
    createMany?: fidic_fundo_x_usuarioCreateManyUsuario_fidic_fundo_x_usuarioTousuarioInputEnvelope
    connect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
  }

  export type titulos_x_usuarioCreateNestedManyWithoutUsuario_titulos_x_usuarioTousuarioInput = {
    create?: XOR<Enumerable<titulos_x_usuarioCreateWithoutUsuario_titulos_x_usuarioTousuarioInput>, Enumerable<titulos_x_usuarioUncheckedCreateWithoutUsuario_titulos_x_usuarioTousuarioInput>>
    connectOrCreate?: Enumerable<titulos_x_usuarioCreateOrConnectWithoutUsuario_titulos_x_usuarioTousuarioInput>
    createMany?: titulos_x_usuarioCreateManyUsuario_titulos_x_usuarioTousuarioInputEnvelope
    connect?: Enumerable<titulos_x_usuarioWhereUniqueInput>
  }

  export type pessoaCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<pessoaCreateWithoutUsuarioInput, pessoaUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutUsuarioInput
    connect?: pessoaWhereUniqueInput
  }

  export type usuario_x_perfilCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<usuario_x_perfilCreateWithoutUsuarioInput>, Enumerable<usuario_x_perfilUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<usuario_x_perfilCreateOrConnectWithoutUsuarioInput>
    createMany?: usuario_x_perfilCreateManyUsuarioInputEnvelope
    connect?: Enumerable<usuario_x_perfilWhereUniqueInput>
  }

  export type auditoriaUncheckedCreateNestedManyWithoutUsuario_auditoriaTousuarioInput = {
    create?: XOR<Enumerable<auditoriaCreateWithoutUsuario_auditoriaTousuarioInput>, Enumerable<auditoriaUncheckedCreateWithoutUsuario_auditoriaTousuarioInput>>
    connectOrCreate?: Enumerable<auditoriaCreateOrConnectWithoutUsuario_auditoriaTousuarioInput>
    createMany?: auditoriaCreateManyUsuario_auditoriaTousuarioInputEnvelope
    connect?: Enumerable<auditoriaWhereUniqueInput>
  }

  export type checagemUncheckedCreateNestedManyWithoutUsuario_checagemTousuarioInput = {
    create?: XOR<Enumerable<checagemCreateWithoutUsuario_checagemTousuarioInput>, Enumerable<checagemUncheckedCreateWithoutUsuario_checagemTousuarioInput>>
    connectOrCreate?: Enumerable<checagemCreateOrConnectWithoutUsuario_checagemTousuarioInput>
    createMany?: checagemCreateManyUsuario_checagemTousuarioInputEnvelope
    connect?: Enumerable<checagemWhereUniqueInput>
  }

  export type fidic_fundo_x_usuarioUncheckedCreateNestedManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput = {
    create?: XOR<Enumerable<fidic_fundo_x_usuarioCreateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>, Enumerable<fidic_fundo_x_usuarioUncheckedCreateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>>
    connectOrCreate?: Enumerable<fidic_fundo_x_usuarioCreateOrConnectWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>
    createMany?: fidic_fundo_x_usuarioCreateManyUsuario_fidic_fundo_x_usuarioTousuarioInputEnvelope
    connect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
  }

  export type titulos_x_usuarioUncheckedCreateNestedManyWithoutUsuario_titulos_x_usuarioTousuarioInput = {
    create?: XOR<Enumerable<titulos_x_usuarioCreateWithoutUsuario_titulos_x_usuarioTousuarioInput>, Enumerable<titulos_x_usuarioUncheckedCreateWithoutUsuario_titulos_x_usuarioTousuarioInput>>
    connectOrCreate?: Enumerable<titulos_x_usuarioCreateOrConnectWithoutUsuario_titulos_x_usuarioTousuarioInput>
    createMany?: titulos_x_usuarioCreateManyUsuario_titulos_x_usuarioTousuarioInputEnvelope
    connect?: Enumerable<titulos_x_usuarioWhereUniqueInput>
  }

  export type usuario_x_perfilUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<Enumerable<usuario_x_perfilCreateWithoutUsuarioInput>, Enumerable<usuario_x_perfilUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<usuario_x_perfilCreateOrConnectWithoutUsuarioInput>
    createMany?: usuario_x_perfilCreateManyUsuarioInputEnvelope
    connect?: Enumerable<usuario_x_perfilWhereUniqueInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type auditoriaUpdateManyWithoutUsuario_auditoriaTousuarioNestedInput = {
    create?: XOR<Enumerable<auditoriaCreateWithoutUsuario_auditoriaTousuarioInput>, Enumerable<auditoriaUncheckedCreateWithoutUsuario_auditoriaTousuarioInput>>
    connectOrCreate?: Enumerable<auditoriaCreateOrConnectWithoutUsuario_auditoriaTousuarioInput>
    upsert?: Enumerable<auditoriaUpsertWithWhereUniqueWithoutUsuario_auditoriaTousuarioInput>
    createMany?: auditoriaCreateManyUsuario_auditoriaTousuarioInputEnvelope
    set?: Enumerable<auditoriaWhereUniqueInput>
    disconnect?: Enumerable<auditoriaWhereUniqueInput>
    delete?: Enumerable<auditoriaWhereUniqueInput>
    connect?: Enumerable<auditoriaWhereUniqueInput>
    update?: Enumerable<auditoriaUpdateWithWhereUniqueWithoutUsuario_auditoriaTousuarioInput>
    updateMany?: Enumerable<auditoriaUpdateManyWithWhereWithoutUsuario_auditoriaTousuarioInput>
    deleteMany?: Enumerable<auditoriaScalarWhereInput>
  }

  export type checagemUpdateManyWithoutUsuario_checagemTousuarioNestedInput = {
    create?: XOR<Enumerable<checagemCreateWithoutUsuario_checagemTousuarioInput>, Enumerable<checagemUncheckedCreateWithoutUsuario_checagemTousuarioInput>>
    connectOrCreate?: Enumerable<checagemCreateOrConnectWithoutUsuario_checagemTousuarioInput>
    upsert?: Enumerable<checagemUpsertWithWhereUniqueWithoutUsuario_checagemTousuarioInput>
    createMany?: checagemCreateManyUsuario_checagemTousuarioInputEnvelope
    set?: Enumerable<checagemWhereUniqueInput>
    disconnect?: Enumerable<checagemWhereUniqueInput>
    delete?: Enumerable<checagemWhereUniqueInput>
    connect?: Enumerable<checagemWhereUniqueInput>
    update?: Enumerable<checagemUpdateWithWhereUniqueWithoutUsuario_checagemTousuarioInput>
    updateMany?: Enumerable<checagemUpdateManyWithWhereWithoutUsuario_checagemTousuarioInput>
    deleteMany?: Enumerable<checagemScalarWhereInput>
  }

  export type fidic_fundo_x_usuarioUpdateManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioNestedInput = {
    create?: XOR<Enumerable<fidic_fundo_x_usuarioCreateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>, Enumerable<fidic_fundo_x_usuarioUncheckedCreateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>>
    connectOrCreate?: Enumerable<fidic_fundo_x_usuarioCreateOrConnectWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>
    upsert?: Enumerable<fidic_fundo_x_usuarioUpsertWithWhereUniqueWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>
    createMany?: fidic_fundo_x_usuarioCreateManyUsuario_fidic_fundo_x_usuarioTousuarioInputEnvelope
    set?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    disconnect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    delete?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    connect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    update?: Enumerable<fidic_fundo_x_usuarioUpdateWithWhereUniqueWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>
    updateMany?: Enumerable<fidic_fundo_x_usuarioUpdateManyWithWhereWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>
    deleteMany?: Enumerable<fidic_fundo_x_usuarioScalarWhereInput>
  }

  export type titulos_x_usuarioUpdateManyWithoutUsuario_titulos_x_usuarioTousuarioNestedInput = {
    create?: XOR<Enumerable<titulos_x_usuarioCreateWithoutUsuario_titulos_x_usuarioTousuarioInput>, Enumerable<titulos_x_usuarioUncheckedCreateWithoutUsuario_titulos_x_usuarioTousuarioInput>>
    connectOrCreate?: Enumerable<titulos_x_usuarioCreateOrConnectWithoutUsuario_titulos_x_usuarioTousuarioInput>
    upsert?: Enumerable<titulos_x_usuarioUpsertWithWhereUniqueWithoutUsuario_titulos_x_usuarioTousuarioInput>
    createMany?: titulos_x_usuarioCreateManyUsuario_titulos_x_usuarioTousuarioInputEnvelope
    set?: Enumerable<titulos_x_usuarioWhereUniqueInput>
    disconnect?: Enumerable<titulos_x_usuarioWhereUniqueInput>
    delete?: Enumerable<titulos_x_usuarioWhereUniqueInput>
    connect?: Enumerable<titulos_x_usuarioWhereUniqueInput>
    update?: Enumerable<titulos_x_usuarioUpdateWithWhereUniqueWithoutUsuario_titulos_x_usuarioTousuarioInput>
    updateMany?: Enumerable<titulos_x_usuarioUpdateManyWithWhereWithoutUsuario_titulos_x_usuarioTousuarioInput>
    deleteMany?: Enumerable<titulos_x_usuarioScalarWhereInput>
  }

  export type pessoaUpdateOneRequiredWithoutUsuarioNestedInput = {
    create?: XOR<pessoaCreateWithoutUsuarioInput, pessoaUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutUsuarioInput
    upsert?: pessoaUpsertWithoutUsuarioInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<pessoaUpdateWithoutUsuarioInput, pessoaUncheckedUpdateWithoutUsuarioInput>
  }

  export type usuario_x_perfilUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<usuario_x_perfilCreateWithoutUsuarioInput>, Enumerable<usuario_x_perfilUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<usuario_x_perfilCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<usuario_x_perfilUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: usuario_x_perfilCreateManyUsuarioInputEnvelope
    set?: Enumerable<usuario_x_perfilWhereUniqueInput>
    disconnect?: Enumerable<usuario_x_perfilWhereUniqueInput>
    delete?: Enumerable<usuario_x_perfilWhereUniqueInput>
    connect?: Enumerable<usuario_x_perfilWhereUniqueInput>
    update?: Enumerable<usuario_x_perfilUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<usuario_x_perfilUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<usuario_x_perfilScalarWhereInput>
  }

  export type auditoriaUncheckedUpdateManyWithoutUsuario_auditoriaTousuarioNestedInput = {
    create?: XOR<Enumerable<auditoriaCreateWithoutUsuario_auditoriaTousuarioInput>, Enumerable<auditoriaUncheckedCreateWithoutUsuario_auditoriaTousuarioInput>>
    connectOrCreate?: Enumerable<auditoriaCreateOrConnectWithoutUsuario_auditoriaTousuarioInput>
    upsert?: Enumerable<auditoriaUpsertWithWhereUniqueWithoutUsuario_auditoriaTousuarioInput>
    createMany?: auditoriaCreateManyUsuario_auditoriaTousuarioInputEnvelope
    set?: Enumerable<auditoriaWhereUniqueInput>
    disconnect?: Enumerable<auditoriaWhereUniqueInput>
    delete?: Enumerable<auditoriaWhereUniqueInput>
    connect?: Enumerable<auditoriaWhereUniqueInput>
    update?: Enumerable<auditoriaUpdateWithWhereUniqueWithoutUsuario_auditoriaTousuarioInput>
    updateMany?: Enumerable<auditoriaUpdateManyWithWhereWithoutUsuario_auditoriaTousuarioInput>
    deleteMany?: Enumerable<auditoriaScalarWhereInput>
  }

  export type checagemUncheckedUpdateManyWithoutUsuario_checagemTousuarioNestedInput = {
    create?: XOR<Enumerable<checagemCreateWithoutUsuario_checagemTousuarioInput>, Enumerable<checagemUncheckedCreateWithoutUsuario_checagemTousuarioInput>>
    connectOrCreate?: Enumerable<checagemCreateOrConnectWithoutUsuario_checagemTousuarioInput>
    upsert?: Enumerable<checagemUpsertWithWhereUniqueWithoutUsuario_checagemTousuarioInput>
    createMany?: checagemCreateManyUsuario_checagemTousuarioInputEnvelope
    set?: Enumerable<checagemWhereUniqueInput>
    disconnect?: Enumerable<checagemWhereUniqueInput>
    delete?: Enumerable<checagemWhereUniqueInput>
    connect?: Enumerable<checagemWhereUniqueInput>
    update?: Enumerable<checagemUpdateWithWhereUniqueWithoutUsuario_checagemTousuarioInput>
    updateMany?: Enumerable<checagemUpdateManyWithWhereWithoutUsuario_checagemTousuarioInput>
    deleteMany?: Enumerable<checagemScalarWhereInput>
  }

  export type fidic_fundo_x_usuarioUncheckedUpdateManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioNestedInput = {
    create?: XOR<Enumerable<fidic_fundo_x_usuarioCreateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>, Enumerable<fidic_fundo_x_usuarioUncheckedCreateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>>
    connectOrCreate?: Enumerable<fidic_fundo_x_usuarioCreateOrConnectWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>
    upsert?: Enumerable<fidic_fundo_x_usuarioUpsertWithWhereUniqueWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>
    createMany?: fidic_fundo_x_usuarioCreateManyUsuario_fidic_fundo_x_usuarioTousuarioInputEnvelope
    set?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    disconnect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    delete?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    connect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    update?: Enumerable<fidic_fundo_x_usuarioUpdateWithWhereUniqueWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>
    updateMany?: Enumerable<fidic_fundo_x_usuarioUpdateManyWithWhereWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>
    deleteMany?: Enumerable<fidic_fundo_x_usuarioScalarWhereInput>
  }

  export type titulos_x_usuarioUncheckedUpdateManyWithoutUsuario_titulos_x_usuarioTousuarioNestedInput = {
    create?: XOR<Enumerable<titulos_x_usuarioCreateWithoutUsuario_titulos_x_usuarioTousuarioInput>, Enumerable<titulos_x_usuarioUncheckedCreateWithoutUsuario_titulos_x_usuarioTousuarioInput>>
    connectOrCreate?: Enumerable<titulos_x_usuarioCreateOrConnectWithoutUsuario_titulos_x_usuarioTousuarioInput>
    upsert?: Enumerable<titulos_x_usuarioUpsertWithWhereUniqueWithoutUsuario_titulos_x_usuarioTousuarioInput>
    createMany?: titulos_x_usuarioCreateManyUsuario_titulos_x_usuarioTousuarioInputEnvelope
    set?: Enumerable<titulos_x_usuarioWhereUniqueInput>
    disconnect?: Enumerable<titulos_x_usuarioWhereUniqueInput>
    delete?: Enumerable<titulos_x_usuarioWhereUniqueInput>
    connect?: Enumerable<titulos_x_usuarioWhereUniqueInput>
    update?: Enumerable<titulos_x_usuarioUpdateWithWhereUniqueWithoutUsuario_titulos_x_usuarioTousuarioInput>
    updateMany?: Enumerable<titulos_x_usuarioUpdateManyWithWhereWithoutUsuario_titulos_x_usuarioTousuarioInput>
    deleteMany?: Enumerable<titulos_x_usuarioScalarWhereInput>
  }

  export type usuario_x_perfilUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<Enumerable<usuario_x_perfilCreateWithoutUsuarioInput>, Enumerable<usuario_x_perfilUncheckedCreateWithoutUsuarioInput>>
    connectOrCreate?: Enumerable<usuario_x_perfilCreateOrConnectWithoutUsuarioInput>
    upsert?: Enumerable<usuario_x_perfilUpsertWithWhereUniqueWithoutUsuarioInput>
    createMany?: usuario_x_perfilCreateManyUsuarioInputEnvelope
    set?: Enumerable<usuario_x_perfilWhereUniqueInput>
    disconnect?: Enumerable<usuario_x_perfilWhereUniqueInput>
    delete?: Enumerable<usuario_x_perfilWhereUniqueInput>
    connect?: Enumerable<usuario_x_perfilWhereUniqueInput>
    update?: Enumerable<usuario_x_perfilUpdateWithWhereUniqueWithoutUsuarioInput>
    updateMany?: Enumerable<usuario_x_perfilUpdateManyWithWhereWithoutUsuarioInput>
    deleteMany?: Enumerable<usuario_x_perfilScalarWhereInput>
  }

  export type usuario_x_perfilCreateNestedManyWithoutUsuario_perfil_tipoInput = {
    create?: XOR<Enumerable<usuario_x_perfilCreateWithoutUsuario_perfil_tipoInput>, Enumerable<usuario_x_perfilUncheckedCreateWithoutUsuario_perfil_tipoInput>>
    connectOrCreate?: Enumerable<usuario_x_perfilCreateOrConnectWithoutUsuario_perfil_tipoInput>
    createMany?: usuario_x_perfilCreateManyUsuario_perfil_tipoInputEnvelope
    connect?: Enumerable<usuario_x_perfilWhereUniqueInput>
  }

  export type usuario_x_perfilUncheckedCreateNestedManyWithoutUsuario_perfil_tipoInput = {
    create?: XOR<Enumerable<usuario_x_perfilCreateWithoutUsuario_perfil_tipoInput>, Enumerable<usuario_x_perfilUncheckedCreateWithoutUsuario_perfil_tipoInput>>
    connectOrCreate?: Enumerable<usuario_x_perfilCreateOrConnectWithoutUsuario_perfil_tipoInput>
    createMany?: usuario_x_perfilCreateManyUsuario_perfil_tipoInputEnvelope
    connect?: Enumerable<usuario_x_perfilWhereUniqueInput>
  }

  export type usuario_x_perfilUpdateManyWithoutUsuario_perfil_tipoNestedInput = {
    create?: XOR<Enumerable<usuario_x_perfilCreateWithoutUsuario_perfil_tipoInput>, Enumerable<usuario_x_perfilUncheckedCreateWithoutUsuario_perfil_tipoInput>>
    connectOrCreate?: Enumerable<usuario_x_perfilCreateOrConnectWithoutUsuario_perfil_tipoInput>
    upsert?: Enumerable<usuario_x_perfilUpsertWithWhereUniqueWithoutUsuario_perfil_tipoInput>
    createMany?: usuario_x_perfilCreateManyUsuario_perfil_tipoInputEnvelope
    set?: Enumerable<usuario_x_perfilWhereUniqueInput>
    disconnect?: Enumerable<usuario_x_perfilWhereUniqueInput>
    delete?: Enumerable<usuario_x_perfilWhereUniqueInput>
    connect?: Enumerable<usuario_x_perfilWhereUniqueInput>
    update?: Enumerable<usuario_x_perfilUpdateWithWhereUniqueWithoutUsuario_perfil_tipoInput>
    updateMany?: Enumerable<usuario_x_perfilUpdateManyWithWhereWithoutUsuario_perfil_tipoInput>
    deleteMany?: Enumerable<usuario_x_perfilScalarWhereInput>
  }

  export type usuario_x_perfilUncheckedUpdateManyWithoutUsuario_perfil_tipoNestedInput = {
    create?: XOR<Enumerable<usuario_x_perfilCreateWithoutUsuario_perfil_tipoInput>, Enumerable<usuario_x_perfilUncheckedCreateWithoutUsuario_perfil_tipoInput>>
    connectOrCreate?: Enumerable<usuario_x_perfilCreateOrConnectWithoutUsuario_perfil_tipoInput>
    upsert?: Enumerable<usuario_x_perfilUpsertWithWhereUniqueWithoutUsuario_perfil_tipoInput>
    createMany?: usuario_x_perfilCreateManyUsuario_perfil_tipoInputEnvelope
    set?: Enumerable<usuario_x_perfilWhereUniqueInput>
    disconnect?: Enumerable<usuario_x_perfilWhereUniqueInput>
    delete?: Enumerable<usuario_x_perfilWhereUniqueInput>
    connect?: Enumerable<usuario_x_perfilWhereUniqueInput>
    update?: Enumerable<usuario_x_perfilUpdateWithWhereUniqueWithoutUsuario_perfil_tipoInput>
    updateMany?: Enumerable<usuario_x_perfilUpdateManyWithWhereWithoutUsuario_perfil_tipoInput>
    deleteMany?: Enumerable<usuario_x_perfilScalarWhereInput>
  }

  export type usuarioCreateNestedOneWithoutUsuario_x_perfilInput = {
    create?: XOR<usuarioCreateWithoutUsuario_x_perfilInput, usuarioUncheckedCreateWithoutUsuario_x_perfilInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutUsuario_x_perfilInput
    connect?: usuarioWhereUniqueInput
  }

  export type usuario_perfil_tipoCreateNestedOneWithoutUsuario_x_perfilInput = {
    create?: XOR<usuario_perfil_tipoCreateWithoutUsuario_x_perfilInput, usuario_perfil_tipoUncheckedCreateWithoutUsuario_x_perfilInput>
    connectOrCreate?: usuario_perfil_tipoCreateOrConnectWithoutUsuario_x_perfilInput
    connect?: usuario_perfil_tipoWhereUniqueInput
  }

  export type usuarioUpdateOneRequiredWithoutUsuario_x_perfilNestedInput = {
    create?: XOR<usuarioCreateWithoutUsuario_x_perfilInput, usuarioUncheckedCreateWithoutUsuario_x_perfilInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutUsuario_x_perfilInput
    upsert?: usuarioUpsertWithoutUsuario_x_perfilInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<usuarioUpdateWithoutUsuario_x_perfilInput, usuarioUncheckedUpdateWithoutUsuario_x_perfilInput>
  }

  export type usuario_perfil_tipoUpdateOneRequiredWithoutUsuario_x_perfilNestedInput = {
    create?: XOR<usuario_perfil_tipoCreateWithoutUsuario_x_perfilInput, usuario_perfil_tipoUncheckedCreateWithoutUsuario_x_perfilInput>
    connectOrCreate?: usuario_perfil_tipoCreateOrConnectWithoutUsuario_x_perfilInput
    upsert?: usuario_perfil_tipoUpsertWithoutUsuario_x_perfilInput
    connect?: usuario_perfil_tipoWhereUniqueInput
    update?: XOR<usuario_perfil_tipoUpdateWithoutUsuario_x_perfilInput, usuario_perfil_tipoUncheckedUpdateWithoutUsuario_x_perfilInput>
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type usuarioCreateWithoutAuditoriaInput = {
    email: string
    senha: string
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    checagem?: checagemCreateNestedManyWithoutUsuario_checagemTousuarioInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioCreateNestedManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput
    titulos_x_usuario?: titulos_x_usuarioCreateNestedManyWithoutUsuario_titulos_x_usuarioTousuarioInput
    pessoa: pessoaCreateNestedOneWithoutUsuarioInput
    usuario_x_perfil?: usuario_x_perfilCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutAuditoriaInput = {
    id?: number
    email: string
    senha: string
    pessoa_id: number
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    checagem?: checagemUncheckedCreateNestedManyWithoutUsuario_checagemTousuarioInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedCreateNestedManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput
    titulos_x_usuario?: titulos_x_usuarioUncheckedCreateNestedManyWithoutUsuario_titulos_x_usuarioTousuarioInput
    usuario_x_perfil?: usuario_x_perfilUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutAuditoriaInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutAuditoriaInput, usuarioUncheckedCreateWithoutAuditoriaInput>
  }

  export type usuarioUpsertWithoutAuditoriaInput = {
    update: XOR<usuarioUpdateWithoutAuditoriaInput, usuarioUncheckedUpdateWithoutAuditoriaInput>
    create: XOR<usuarioCreateWithoutAuditoriaInput, usuarioUncheckedCreateWithoutAuditoriaInput>
  }

  export type usuarioUpdateWithoutAuditoriaInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checagem?: checagemUpdateManyWithoutUsuario_checagemTousuarioNestedInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUpdateManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioNestedInput
    titulos_x_usuario?: titulos_x_usuarioUpdateManyWithoutUsuario_titulos_x_usuarioTousuarioNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutUsuarioNestedInput
    usuario_x_perfil?: usuario_x_perfilUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutAuditoriaInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    pessoa_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checagem?: checagemUncheckedUpdateManyWithoutUsuario_checagemTousuarioNestedInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedUpdateManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioNestedInput
    titulos_x_usuario?: titulos_x_usuarioUncheckedUpdateManyWithoutUsuario_titulos_x_usuarioTousuarioNestedInput
    usuario_x_perfil?: usuario_x_perfilUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type tituloCreateWithoutBorderoInput = {
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
    titulo_tipo: titulo_tipoCreateNestedOneWithoutTituloInput
  }

  export type tituloUncheckedCreateWithoutBorderoInput = {
    id?: number
    titulo_tipo_id: number
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
  }

  export type tituloCreateOrConnectWithoutBorderoInput = {
    where: tituloWhereUniqueInput
    create: XOR<tituloCreateWithoutBorderoInput, tituloUncheckedCreateWithoutBorderoInput>
  }

  export type tituloCreateManyBorderoInputEnvelope = {
    data: Enumerable<tituloCreateManyBorderoInput>
    skipDuplicates?: boolean
  }

  export type titulos_x_usuarioCreateWithoutBordero_borderoTotitulos_x_usuarioInput = {
    status?: string | null
    usuario_titulos_x_usuarioTousuario?: usuarioCreateNestedOneWithoutTitulos_x_usuarioInput
  }

  export type titulos_x_usuarioUncheckedCreateWithoutBordero_borderoTotitulos_x_usuarioInput = {
    id?: number
    usuario?: number | null
    status?: string | null
  }

  export type titulos_x_usuarioCreateOrConnectWithoutBordero_borderoTotitulos_x_usuarioInput = {
    where: titulos_x_usuarioWhereUniqueInput
    create: XOR<titulos_x_usuarioCreateWithoutBordero_borderoTotitulos_x_usuarioInput, titulos_x_usuarioUncheckedCreateWithoutBordero_borderoTotitulos_x_usuarioInput>
  }

  export type titulos_x_usuarioCreateManyBordero_borderoTotitulos_x_usuarioInputEnvelope = {
    data: Enumerable<titulos_x_usuarioCreateManyBordero_borderoTotitulos_x_usuarioInput>
    skipDuplicates?: boolean
  }

  export type tituloUpsertWithWhereUniqueWithoutBorderoInput = {
    where: tituloWhereUniqueInput
    update: XOR<tituloUpdateWithoutBorderoInput, tituloUncheckedUpdateWithoutBorderoInput>
    create: XOR<tituloCreateWithoutBorderoInput, tituloUncheckedCreateWithoutBorderoInput>
  }

  export type tituloUpdateWithWhereUniqueWithoutBorderoInput = {
    where: tituloWhereUniqueInput
    data: XOR<tituloUpdateWithoutBorderoInput, tituloUncheckedUpdateWithoutBorderoInput>
  }

  export type tituloUpdateManyWithWhereWithoutBorderoInput = {
    where: tituloScalarWhereInput
    data: XOR<tituloUpdateManyMutationInput, tituloUncheckedUpdateManyWithoutTituloInput>
  }

  export type tituloScalarWhereInput = {
    AND?: Enumerable<tituloScalarWhereInput>
    OR?: Enumerable<tituloScalarWhereInput>
    NOT?: Enumerable<tituloScalarWhereInput>
    id?: IntFilter | number
    titulo_tipo_id?: IntFilter | number
    bordero_id?: IntFilter | number
    nf?: StringNullableFilter | string | null
    valor?: FloatNullableFilter | number | null
    vencimento?: DateTimeNullableFilter | Date | string | null
    numero?: StringNullableFilter | string | null
    emissao?: DateTimeNullableFilter | Date | string | null
    parcela?: StringNullableFilter | string | null
  }

  export type titulos_x_usuarioUpsertWithWhereUniqueWithoutBordero_borderoTotitulos_x_usuarioInput = {
    where: titulos_x_usuarioWhereUniqueInput
    update: XOR<titulos_x_usuarioUpdateWithoutBordero_borderoTotitulos_x_usuarioInput, titulos_x_usuarioUncheckedUpdateWithoutBordero_borderoTotitulos_x_usuarioInput>
    create: XOR<titulos_x_usuarioCreateWithoutBordero_borderoTotitulos_x_usuarioInput, titulos_x_usuarioUncheckedCreateWithoutBordero_borderoTotitulos_x_usuarioInput>
  }

  export type titulos_x_usuarioUpdateWithWhereUniqueWithoutBordero_borderoTotitulos_x_usuarioInput = {
    where: titulos_x_usuarioWhereUniqueInput
    data: XOR<titulos_x_usuarioUpdateWithoutBordero_borderoTotitulos_x_usuarioInput, titulos_x_usuarioUncheckedUpdateWithoutBordero_borderoTotitulos_x_usuarioInput>
  }

  export type titulos_x_usuarioUpdateManyWithWhereWithoutBordero_borderoTotitulos_x_usuarioInput = {
    where: titulos_x_usuarioScalarWhereInput
    data: XOR<titulos_x_usuarioUpdateManyMutationInput, titulos_x_usuarioUncheckedUpdateManyWithoutTitulos_x_usuarioInput>
  }

  export type titulos_x_usuarioScalarWhereInput = {
    AND?: Enumerable<titulos_x_usuarioScalarWhereInput>
    OR?: Enumerable<titulos_x_usuarioScalarWhereInput>
    NOT?: Enumerable<titulos_x_usuarioScalarWhereInput>
    id?: IntFilter | number
    usuario?: IntNullableFilter | number | null
    bordero?: IntNullableFilter | number | null
    status?: StringNullableFilter | string | null
  }

  export type fidic_fundoCreateWithoutCarteiraInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioCreateNestedManyWithoutFidic_fundoInput
  }

  export type fidic_fundoUncheckedCreateWithoutCarteiraInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedCreateNestedManyWithoutFidic_fundoInput
  }

  export type fidic_fundoCreateOrConnectWithoutCarteiraInput = {
    where: fidic_fundoWhereUniqueInput
    create: XOR<fidic_fundoCreateWithoutCarteiraInput, fidic_fundoUncheckedCreateWithoutCarteiraInput>
  }

  export type fidic_fundoUpsertWithoutCarteiraInput = {
    update: XOR<fidic_fundoUpdateWithoutCarteiraInput, fidic_fundoUncheckedUpdateWithoutCarteiraInput>
    create: XOR<fidic_fundoCreateWithoutCarteiraInput, fidic_fundoUncheckedCreateWithoutCarteiraInput>
  }

  export type fidic_fundoUpdateWithoutCarteiraInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUpdateManyWithoutFidic_fundoNestedInput
  }

  export type fidic_fundoUncheckedUpdateWithoutCarteiraInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedUpdateManyWithoutFidic_fundoNestedInput
  }

  export type cedente_analiseCreateWithoutCedente_cedenteTocedente_analiseInput = {
    status?: string | null
  }

  export type cedente_analiseUncheckedCreateWithoutCedente_cedenteTocedente_analiseInput = {
    id?: number
    status?: string | null
  }

  export type cedente_analiseCreateOrConnectWithoutCedente_cedenteTocedente_analiseInput = {
    where: cedente_analiseWhereUniqueInput
    create: XOR<cedente_analiseCreateWithoutCedente_cedenteTocedente_analiseInput, cedente_analiseUncheckedCreateWithoutCedente_cedenteTocedente_analiseInput>
  }

  export type cedente_analiseCreateManyCedente_cedenteTocedente_analiseInputEnvelope = {
    data: Enumerable<cedente_analiseCreateManyCedente_cedenteTocedente_analiseInput>
    skipDuplicates?: boolean
  }

  export type cedente_n_sacadosCreateWithoutCedente_cedenteTocedente_n_sacadosInput = {
    sacado_cedente_n_sacadosTosacado?: sacadoCreateNestedOneWithoutCedente_n_sacadosInput
  }

  export type cedente_n_sacadosUncheckedCreateWithoutCedente_cedenteTocedente_n_sacadosInput = {
    id?: number
    sacado?: number | null
  }

  export type cedente_n_sacadosCreateOrConnectWithoutCedente_cedenteTocedente_n_sacadosInput = {
    where: cedente_n_sacadosWhereUniqueInput
    create: XOR<cedente_n_sacadosCreateWithoutCedente_cedenteTocedente_n_sacadosInput, cedente_n_sacadosUncheckedCreateWithoutCedente_cedenteTocedente_n_sacadosInput>
  }

  export type cedente_n_sacadosCreateManyCedente_cedenteTocedente_n_sacadosInputEnvelope = {
    data: Enumerable<cedente_n_sacadosCreateManyCedente_cedenteTocedente_n_sacadosInput>
    skipDuplicates?: boolean
  }

  export type titulo_x_cedenteCreateWithoutCedente_cedenteTotitulo_x_cedenteInput = {

  }

  export type titulo_x_cedenteUncheckedCreateWithoutCedente_cedenteTotitulo_x_cedenteInput = {
    id?: number
  }

  export type titulo_x_cedenteCreateOrConnectWithoutCedente_cedenteTotitulo_x_cedenteInput = {
    where: titulo_x_cedenteWhereUniqueInput
    create: XOR<titulo_x_cedenteCreateWithoutCedente_cedenteTotitulo_x_cedenteInput, titulo_x_cedenteUncheckedCreateWithoutCedente_cedenteTotitulo_x_cedenteInput>
  }

  export type titulo_x_cedenteCreateManyCedente_cedenteTotitulo_x_cedenteInputEnvelope = {
    data: Enumerable<titulo_x_cedenteCreateManyCedente_cedenteTotitulo_x_cedenteInput>
    skipDuplicates?: boolean
  }

  export type cedente_analiseUpsertWithWhereUniqueWithoutCedente_cedenteTocedente_analiseInput = {
    where: cedente_analiseWhereUniqueInput
    update: XOR<cedente_analiseUpdateWithoutCedente_cedenteTocedente_analiseInput, cedente_analiseUncheckedUpdateWithoutCedente_cedenteTocedente_analiseInput>
    create: XOR<cedente_analiseCreateWithoutCedente_cedenteTocedente_analiseInput, cedente_analiseUncheckedCreateWithoutCedente_cedenteTocedente_analiseInput>
  }

  export type cedente_analiseUpdateWithWhereUniqueWithoutCedente_cedenteTocedente_analiseInput = {
    where: cedente_analiseWhereUniqueInput
    data: XOR<cedente_analiseUpdateWithoutCedente_cedenteTocedente_analiseInput, cedente_analiseUncheckedUpdateWithoutCedente_cedenteTocedente_analiseInput>
  }

  export type cedente_analiseUpdateManyWithWhereWithoutCedente_cedenteTocedente_analiseInput = {
    where: cedente_analiseScalarWhereInput
    data: XOR<cedente_analiseUpdateManyMutationInput, cedente_analiseUncheckedUpdateManyWithoutCedente_analiseInput>
  }

  export type cedente_analiseScalarWhereInput = {
    AND?: Enumerable<cedente_analiseScalarWhereInput>
    OR?: Enumerable<cedente_analiseScalarWhereInput>
    NOT?: Enumerable<cedente_analiseScalarWhereInput>
    id?: IntFilter | number
    status?: StringNullableFilter | string | null
    cedente?: IntNullableFilter | number | null
  }

  export type cedente_n_sacadosUpsertWithWhereUniqueWithoutCedente_cedenteTocedente_n_sacadosInput = {
    where: cedente_n_sacadosWhereUniqueInput
    update: XOR<cedente_n_sacadosUpdateWithoutCedente_cedenteTocedente_n_sacadosInput, cedente_n_sacadosUncheckedUpdateWithoutCedente_cedenteTocedente_n_sacadosInput>
    create: XOR<cedente_n_sacadosCreateWithoutCedente_cedenteTocedente_n_sacadosInput, cedente_n_sacadosUncheckedCreateWithoutCedente_cedenteTocedente_n_sacadosInput>
  }

  export type cedente_n_sacadosUpdateWithWhereUniqueWithoutCedente_cedenteTocedente_n_sacadosInput = {
    where: cedente_n_sacadosWhereUniqueInput
    data: XOR<cedente_n_sacadosUpdateWithoutCedente_cedenteTocedente_n_sacadosInput, cedente_n_sacadosUncheckedUpdateWithoutCedente_cedenteTocedente_n_sacadosInput>
  }

  export type cedente_n_sacadosUpdateManyWithWhereWithoutCedente_cedenteTocedente_n_sacadosInput = {
    where: cedente_n_sacadosScalarWhereInput
    data: XOR<cedente_n_sacadosUpdateManyMutationInput, cedente_n_sacadosUncheckedUpdateManyWithoutCedente_n_sacadosInput>
  }

  export type cedente_n_sacadosScalarWhereInput = {
    AND?: Enumerable<cedente_n_sacadosScalarWhereInput>
    OR?: Enumerable<cedente_n_sacadosScalarWhereInput>
    NOT?: Enumerable<cedente_n_sacadosScalarWhereInput>
    id?: IntFilter | number
    cedente?: IntNullableFilter | number | null
    sacado?: IntNullableFilter | number | null
  }

  export type titulo_x_cedenteUpsertWithWhereUniqueWithoutCedente_cedenteTotitulo_x_cedenteInput = {
    where: titulo_x_cedenteWhereUniqueInput
    update: XOR<titulo_x_cedenteUpdateWithoutCedente_cedenteTotitulo_x_cedenteInput, titulo_x_cedenteUncheckedUpdateWithoutCedente_cedenteTotitulo_x_cedenteInput>
    create: XOR<titulo_x_cedenteCreateWithoutCedente_cedenteTotitulo_x_cedenteInput, titulo_x_cedenteUncheckedCreateWithoutCedente_cedenteTotitulo_x_cedenteInput>
  }

  export type titulo_x_cedenteUpdateWithWhereUniqueWithoutCedente_cedenteTotitulo_x_cedenteInput = {
    where: titulo_x_cedenteWhereUniqueInput
    data: XOR<titulo_x_cedenteUpdateWithoutCedente_cedenteTotitulo_x_cedenteInput, titulo_x_cedenteUncheckedUpdateWithoutCedente_cedenteTotitulo_x_cedenteInput>
  }

  export type titulo_x_cedenteUpdateManyWithWhereWithoutCedente_cedenteTotitulo_x_cedenteInput = {
    where: titulo_x_cedenteScalarWhereInput
    data: XOR<titulo_x_cedenteUpdateManyMutationInput, titulo_x_cedenteUncheckedUpdateManyWithoutTitulo_x_cedenteInput>
  }

  export type titulo_x_cedenteScalarWhereInput = {
    AND?: Enumerable<titulo_x_cedenteScalarWhereInput>
    OR?: Enumerable<titulo_x_cedenteScalarWhereInput>
    NOT?: Enumerable<titulo_x_cedenteScalarWhereInput>
    id?: IntFilter | number
    cedente?: IntFilter | number
  }

  export type cedenteCreateWithoutCedente_analiseInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    cedente_n_sacados?: cedente_n_sacadosCreateNestedManyWithoutCedente_cedenteTocedente_n_sacadosInput
    titulo_x_cedente?: titulo_x_cedenteCreateNestedManyWithoutCedente_cedenteTotitulo_x_cedenteInput
  }

  export type cedenteUncheckedCreateWithoutCedente_analiseInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    cedente_n_sacados?: cedente_n_sacadosUncheckedCreateNestedManyWithoutCedente_cedenteTocedente_n_sacadosInput
    titulo_x_cedente?: titulo_x_cedenteUncheckedCreateNestedManyWithoutCedente_cedenteTotitulo_x_cedenteInput
  }

  export type cedenteCreateOrConnectWithoutCedente_analiseInput = {
    where: cedenteWhereUniqueInput
    create: XOR<cedenteCreateWithoutCedente_analiseInput, cedenteUncheckedCreateWithoutCedente_analiseInput>
  }

  export type cedenteUpsertWithoutCedente_analiseInput = {
    update: XOR<cedenteUpdateWithoutCedente_analiseInput, cedenteUncheckedUpdateWithoutCedente_analiseInput>
    create: XOR<cedenteCreateWithoutCedente_analiseInput, cedenteUncheckedCreateWithoutCedente_analiseInput>
  }

  export type cedenteUpdateWithoutCedente_analiseInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cedente_n_sacados?: cedente_n_sacadosUpdateManyWithoutCedente_cedenteTocedente_n_sacadosNestedInput
    titulo_x_cedente?: titulo_x_cedenteUpdateManyWithoutCedente_cedenteTotitulo_x_cedenteNestedInput
  }

  export type cedenteUncheckedUpdateWithoutCedente_analiseInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cedente_n_sacados?: cedente_n_sacadosUncheckedUpdateManyWithoutCedente_cedenteTocedente_n_sacadosNestedInput
    titulo_x_cedente?: titulo_x_cedenteUncheckedUpdateManyWithoutCedente_cedenteTotitulo_x_cedenteNestedInput
  }

  export type cedenteCreateWithoutCedente_n_sacadosInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    cedente_analise?: cedente_analiseCreateNestedManyWithoutCedente_cedenteTocedente_analiseInput
    titulo_x_cedente?: titulo_x_cedenteCreateNestedManyWithoutCedente_cedenteTotitulo_x_cedenteInput
  }

  export type cedenteUncheckedCreateWithoutCedente_n_sacadosInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    cedente_analise?: cedente_analiseUncheckedCreateNestedManyWithoutCedente_cedenteTocedente_analiseInput
    titulo_x_cedente?: titulo_x_cedenteUncheckedCreateNestedManyWithoutCedente_cedenteTotitulo_x_cedenteInput
  }

  export type cedenteCreateOrConnectWithoutCedente_n_sacadosInput = {
    where: cedenteWhereUniqueInput
    create: XOR<cedenteCreateWithoutCedente_n_sacadosInput, cedenteUncheckedCreateWithoutCedente_n_sacadosInput>
  }

  export type sacadoCreateWithoutCedente_n_sacadosInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
  }

  export type sacadoUncheckedCreateWithoutCedente_n_sacadosInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
  }

  export type sacadoCreateOrConnectWithoutCedente_n_sacadosInput = {
    where: sacadoWhereUniqueInput
    create: XOR<sacadoCreateWithoutCedente_n_sacadosInput, sacadoUncheckedCreateWithoutCedente_n_sacadosInput>
  }

  export type cedenteUpsertWithoutCedente_n_sacadosInput = {
    update: XOR<cedenteUpdateWithoutCedente_n_sacadosInput, cedenteUncheckedUpdateWithoutCedente_n_sacadosInput>
    create: XOR<cedenteCreateWithoutCedente_n_sacadosInput, cedenteUncheckedCreateWithoutCedente_n_sacadosInput>
  }

  export type cedenteUpdateWithoutCedente_n_sacadosInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cedente_analise?: cedente_analiseUpdateManyWithoutCedente_cedenteTocedente_analiseNestedInput
    titulo_x_cedente?: titulo_x_cedenteUpdateManyWithoutCedente_cedenteTotitulo_x_cedenteNestedInput
  }

  export type cedenteUncheckedUpdateWithoutCedente_n_sacadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cedente_analise?: cedente_analiseUncheckedUpdateManyWithoutCedente_cedenteTocedente_analiseNestedInput
    titulo_x_cedente?: titulo_x_cedenteUncheckedUpdateManyWithoutCedente_cedenteTotitulo_x_cedenteNestedInput
  }

  export type sacadoUpsertWithoutCedente_n_sacadosInput = {
    update: XOR<sacadoUpdateWithoutCedente_n_sacadosInput, sacadoUncheckedUpdateWithoutCedente_n_sacadosInput>
    create: XOR<sacadoCreateWithoutCedente_n_sacadosInput, sacadoUncheckedCreateWithoutCedente_n_sacadosInput>
  }

  export type sacadoUpdateWithoutCedente_n_sacadosInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sacadoUncheckedUpdateWithoutCedente_n_sacadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuarioCreateWithoutChecagemInput = {
    email: string
    senha: string
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    auditoria?: auditoriaCreateNestedManyWithoutUsuario_auditoriaTousuarioInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioCreateNestedManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput
    titulos_x_usuario?: titulos_x_usuarioCreateNestedManyWithoutUsuario_titulos_x_usuarioTousuarioInput
    pessoa: pessoaCreateNestedOneWithoutUsuarioInput
    usuario_x_perfil?: usuario_x_perfilCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutChecagemInput = {
    id?: number
    email: string
    senha: string
    pessoa_id: number
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuario_auditoriaTousuarioInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedCreateNestedManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput
    titulos_x_usuario?: titulos_x_usuarioUncheckedCreateNestedManyWithoutUsuario_titulos_x_usuarioTousuarioInput
    usuario_x_perfil?: usuario_x_perfilUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutChecagemInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutChecagemInput, usuarioUncheckedCreateWithoutChecagemInput>
  }

  export type usuarioUpsertWithoutChecagemInput = {
    update: XOR<usuarioUpdateWithoutChecagemInput, usuarioUncheckedUpdateWithoutChecagemInput>
    create: XOR<usuarioCreateWithoutChecagemInput, usuarioUncheckedCreateWithoutChecagemInput>
  }

  export type usuarioUpdateWithoutChecagemInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditoria?: auditoriaUpdateManyWithoutUsuario_auditoriaTousuarioNestedInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUpdateManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioNestedInput
    titulos_x_usuario?: titulos_x_usuarioUpdateManyWithoutUsuario_titulos_x_usuarioTousuarioNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutUsuarioNestedInput
    usuario_x_perfil?: usuario_x_perfilUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutChecagemInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    pessoa_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuario_auditoriaTousuarioNestedInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedUpdateManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioNestedInput
    titulos_x_usuario?: titulos_x_usuarioUncheckedUpdateManyWithoutUsuario_titulos_x_usuarioTousuarioNestedInput
    usuario_x_perfil?: usuario_x_perfilUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type carteiraCreateWithoutFidic_fundoInput = {

  }

  export type carteiraUncheckedCreateWithoutFidic_fundoInput = {
    id?: number
  }

  export type carteiraCreateOrConnectWithoutFidic_fundoInput = {
    where: carteiraWhereUniqueInput
    create: XOR<carteiraCreateWithoutFidic_fundoInput, carteiraUncheckedCreateWithoutFidic_fundoInput>
  }

  export type carteiraCreateManyFidic_fundoInputEnvelope = {
    data: Enumerable<carteiraCreateManyFidic_fundoInput>
    skipDuplicates?: boolean
  }

  export type fidic_fundo_x_usuarioCreateWithoutFidic_fundoInput = {
    usuario_fidic_fundo_x_usuarioTousuario?: usuarioCreateNestedOneWithoutFidic_fundo_x_usuarioInput
  }

  export type fidic_fundo_x_usuarioUncheckedCreateWithoutFidic_fundoInput = {
    id?: number
    usuario?: number | null
  }

  export type fidic_fundo_x_usuarioCreateOrConnectWithoutFidic_fundoInput = {
    where: fidic_fundo_x_usuarioWhereUniqueInput
    create: XOR<fidic_fundo_x_usuarioCreateWithoutFidic_fundoInput, fidic_fundo_x_usuarioUncheckedCreateWithoutFidic_fundoInput>
  }

  export type fidic_fundo_x_usuarioCreateManyFidic_fundoInputEnvelope = {
    data: Enumerable<fidic_fundo_x_usuarioCreateManyFidic_fundoInput>
    skipDuplicates?: boolean
  }

  export type carteiraUpsertWithWhereUniqueWithoutFidic_fundoInput = {
    where: carteiraWhereUniqueInput
    update: XOR<carteiraUpdateWithoutFidic_fundoInput, carteiraUncheckedUpdateWithoutFidic_fundoInput>
    create: XOR<carteiraCreateWithoutFidic_fundoInput, carteiraUncheckedCreateWithoutFidic_fundoInput>
  }

  export type carteiraUpdateWithWhereUniqueWithoutFidic_fundoInput = {
    where: carteiraWhereUniqueInput
    data: XOR<carteiraUpdateWithoutFidic_fundoInput, carteiraUncheckedUpdateWithoutFidic_fundoInput>
  }

  export type carteiraUpdateManyWithWhereWithoutFidic_fundoInput = {
    where: carteiraScalarWhereInput
    data: XOR<carteiraUpdateManyMutationInput, carteiraUncheckedUpdateManyWithoutCarteiraInput>
  }

  export type carteiraScalarWhereInput = {
    AND?: Enumerable<carteiraScalarWhereInput>
    OR?: Enumerable<carteiraScalarWhereInput>
    NOT?: Enumerable<carteiraScalarWhereInput>
    id?: IntFilter | number
    fiduc_fundo_id?: IntFilter | number
  }

  export type fidic_fundo_x_usuarioUpsertWithWhereUniqueWithoutFidic_fundoInput = {
    where: fidic_fundo_x_usuarioWhereUniqueInput
    update: XOR<fidic_fundo_x_usuarioUpdateWithoutFidic_fundoInput, fidic_fundo_x_usuarioUncheckedUpdateWithoutFidic_fundoInput>
    create: XOR<fidic_fundo_x_usuarioCreateWithoutFidic_fundoInput, fidic_fundo_x_usuarioUncheckedCreateWithoutFidic_fundoInput>
  }

  export type fidic_fundo_x_usuarioUpdateWithWhereUniqueWithoutFidic_fundoInput = {
    where: fidic_fundo_x_usuarioWhereUniqueInput
    data: XOR<fidic_fundo_x_usuarioUpdateWithoutFidic_fundoInput, fidic_fundo_x_usuarioUncheckedUpdateWithoutFidic_fundoInput>
  }

  export type fidic_fundo_x_usuarioUpdateManyWithWhereWithoutFidic_fundoInput = {
    where: fidic_fundo_x_usuarioScalarWhereInput
    data: XOR<fidic_fundo_x_usuarioUpdateManyMutationInput, fidic_fundo_x_usuarioUncheckedUpdateManyWithoutFidic_fundo_x_usuarioInput>
  }

  export type fidic_fundo_x_usuarioScalarWhereInput = {
    AND?: Enumerable<fidic_fundo_x_usuarioScalarWhereInput>
    OR?: Enumerable<fidic_fundo_x_usuarioScalarWhereInput>
    NOT?: Enumerable<fidic_fundo_x_usuarioScalarWhereInput>
    id?: IntFilter | number
    usuario?: IntNullableFilter | number | null
    fidic?: IntFilter | number
  }

  export type fidic_fundoCreateWithoutFidic_fundo_x_usuarioInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    carteira?: carteiraCreateNestedManyWithoutFidic_fundoInput
  }

  export type fidic_fundoUncheckedCreateWithoutFidic_fundo_x_usuarioInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    carteira?: carteiraUncheckedCreateNestedManyWithoutFidic_fundoInput
  }

  export type fidic_fundoCreateOrConnectWithoutFidic_fundo_x_usuarioInput = {
    where: fidic_fundoWhereUniqueInput
    create: XOR<fidic_fundoCreateWithoutFidic_fundo_x_usuarioInput, fidic_fundoUncheckedCreateWithoutFidic_fundo_x_usuarioInput>
  }

  export type usuarioCreateWithoutFidic_fundo_x_usuarioInput = {
    email: string
    senha: string
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    auditoria?: auditoriaCreateNestedManyWithoutUsuario_auditoriaTousuarioInput
    checagem?: checagemCreateNestedManyWithoutUsuario_checagemTousuarioInput
    titulos_x_usuario?: titulos_x_usuarioCreateNestedManyWithoutUsuario_titulos_x_usuarioTousuarioInput
    pessoa: pessoaCreateNestedOneWithoutUsuarioInput
    usuario_x_perfil?: usuario_x_perfilCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutFidic_fundo_x_usuarioInput = {
    id?: number
    email: string
    senha: string
    pessoa_id: number
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuario_auditoriaTousuarioInput
    checagem?: checagemUncheckedCreateNestedManyWithoutUsuario_checagemTousuarioInput
    titulos_x_usuario?: titulos_x_usuarioUncheckedCreateNestedManyWithoutUsuario_titulos_x_usuarioTousuarioInput
    usuario_x_perfil?: usuario_x_perfilUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutFidic_fundo_x_usuarioInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutFidic_fundo_x_usuarioInput, usuarioUncheckedCreateWithoutFidic_fundo_x_usuarioInput>
  }

  export type fidic_fundoUpsertWithoutFidic_fundo_x_usuarioInput = {
    update: XOR<fidic_fundoUpdateWithoutFidic_fundo_x_usuarioInput, fidic_fundoUncheckedUpdateWithoutFidic_fundo_x_usuarioInput>
    create: XOR<fidic_fundoCreateWithoutFidic_fundo_x_usuarioInput, fidic_fundoUncheckedCreateWithoutFidic_fundo_x_usuarioInput>
  }

  export type fidic_fundoUpdateWithoutFidic_fundo_x_usuarioInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    carteira?: carteiraUpdateManyWithoutFidic_fundoNestedInput
  }

  export type fidic_fundoUncheckedUpdateWithoutFidic_fundo_x_usuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    carteira?: carteiraUncheckedUpdateManyWithoutFidic_fundoNestedInput
  }

  export type usuarioUpsertWithoutFidic_fundo_x_usuarioInput = {
    update: XOR<usuarioUpdateWithoutFidic_fundo_x_usuarioInput, usuarioUncheckedUpdateWithoutFidic_fundo_x_usuarioInput>
    create: XOR<usuarioCreateWithoutFidic_fundo_x_usuarioInput, usuarioUncheckedCreateWithoutFidic_fundo_x_usuarioInput>
  }

  export type usuarioUpdateWithoutFidic_fundo_x_usuarioInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditoria?: auditoriaUpdateManyWithoutUsuario_auditoriaTousuarioNestedInput
    checagem?: checagemUpdateManyWithoutUsuario_checagemTousuarioNestedInput
    titulos_x_usuario?: titulos_x_usuarioUpdateManyWithoutUsuario_titulos_x_usuarioTousuarioNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutUsuarioNestedInput
    usuario_x_perfil?: usuario_x_perfilUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutFidic_fundo_x_usuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    pessoa_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuario_auditoriaTousuarioNestedInput
    checagem?: checagemUncheckedUpdateManyWithoutUsuario_checagemTousuarioNestedInput
    titulos_x_usuario?: titulos_x_usuarioUncheckedUpdateManyWithoutUsuario_titulos_x_usuarioTousuarioNestedInput
    usuario_x_perfil?: usuario_x_perfilUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioCreateWithoutPessoaInput = {
    email: string
    senha: string
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    auditoria?: auditoriaCreateNestedManyWithoutUsuario_auditoriaTousuarioInput
    checagem?: checagemCreateNestedManyWithoutUsuario_checagemTousuarioInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioCreateNestedManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput
    titulos_x_usuario?: titulos_x_usuarioCreateNestedManyWithoutUsuario_titulos_x_usuarioTousuarioInput
    usuario_x_perfil?: usuario_x_perfilCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutPessoaInput = {
    id?: number
    email: string
    senha: string
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuario_auditoriaTousuarioInput
    checagem?: checagemUncheckedCreateNestedManyWithoutUsuario_checagemTousuarioInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedCreateNestedManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput
    titulos_x_usuario?: titulos_x_usuarioUncheckedCreateNestedManyWithoutUsuario_titulos_x_usuarioTousuarioInput
    usuario_x_perfil?: usuario_x_perfilUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutPessoaInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutPessoaInput, usuarioUncheckedCreateWithoutPessoaInput>
  }

  export type usuarioCreateManyPessoaInputEnvelope = {
    data: Enumerable<usuarioCreateManyPessoaInput>
    skipDuplicates?: boolean
  }

  export type usuarioUpsertWithWhereUniqueWithoutPessoaInput = {
    where: usuarioWhereUniqueInput
    update: XOR<usuarioUpdateWithoutPessoaInput, usuarioUncheckedUpdateWithoutPessoaInput>
    create: XOR<usuarioCreateWithoutPessoaInput, usuarioUncheckedCreateWithoutPessoaInput>
  }

  export type usuarioUpdateWithWhereUniqueWithoutPessoaInput = {
    where: usuarioWhereUniqueInput
    data: XOR<usuarioUpdateWithoutPessoaInput, usuarioUncheckedUpdateWithoutPessoaInput>
  }

  export type usuarioUpdateManyWithWhereWithoutPessoaInput = {
    where: usuarioScalarWhereInput
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type usuarioScalarWhereInput = {
    AND?: Enumerable<usuarioScalarWhereInput>
    OR?: Enumerable<usuarioScalarWhereInput>
    NOT?: Enumerable<usuarioScalarWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    senha?: StringFilter | string
    pessoa_id?: IntFilter | number
    status?: StringNullableFilter | string | null
    primeiro_acesso?: BoolNullableFilter | boolean | null
    confirmou_cadastro?: BoolNullableFilter | boolean | null
    codigo_confirma_cadastro?: StringNullableFilter | string | null
    codigo_reset_senha?: StringNullableFilter | string | null
    codigo_data_expiracao?: DateTimeNullableFilter | Date | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type cedente_n_sacadosCreateWithoutSacado_cedente_n_sacadosTosacadoInput = {
    cedente_cedenteTocedente_n_sacados?: cedenteCreateNestedOneWithoutCedente_n_sacadosInput
  }

  export type cedente_n_sacadosUncheckedCreateWithoutSacado_cedente_n_sacadosTosacadoInput = {
    id?: number
    cedente?: number | null
  }

  export type cedente_n_sacadosCreateOrConnectWithoutSacado_cedente_n_sacadosTosacadoInput = {
    where: cedente_n_sacadosWhereUniqueInput
    create: XOR<cedente_n_sacadosCreateWithoutSacado_cedente_n_sacadosTosacadoInput, cedente_n_sacadosUncheckedCreateWithoutSacado_cedente_n_sacadosTosacadoInput>
  }

  export type cedente_n_sacadosCreateManySacado_cedente_n_sacadosTosacadoInputEnvelope = {
    data: Enumerable<cedente_n_sacadosCreateManySacado_cedente_n_sacadosTosacadoInput>
    skipDuplicates?: boolean
  }

  export type cedente_n_sacadosUpsertWithWhereUniqueWithoutSacado_cedente_n_sacadosTosacadoInput = {
    where: cedente_n_sacadosWhereUniqueInput
    update: XOR<cedente_n_sacadosUpdateWithoutSacado_cedente_n_sacadosTosacadoInput, cedente_n_sacadosUncheckedUpdateWithoutSacado_cedente_n_sacadosTosacadoInput>
    create: XOR<cedente_n_sacadosCreateWithoutSacado_cedente_n_sacadosTosacadoInput, cedente_n_sacadosUncheckedCreateWithoutSacado_cedente_n_sacadosTosacadoInput>
  }

  export type cedente_n_sacadosUpdateWithWhereUniqueWithoutSacado_cedente_n_sacadosTosacadoInput = {
    where: cedente_n_sacadosWhereUniqueInput
    data: XOR<cedente_n_sacadosUpdateWithoutSacado_cedente_n_sacadosTosacadoInput, cedente_n_sacadosUncheckedUpdateWithoutSacado_cedente_n_sacadosTosacadoInput>
  }

  export type cedente_n_sacadosUpdateManyWithWhereWithoutSacado_cedente_n_sacadosTosacadoInput = {
    where: cedente_n_sacadosScalarWhereInput
    data: XOR<cedente_n_sacadosUpdateManyMutationInput, cedente_n_sacadosUncheckedUpdateManyWithoutCedente_n_sacadosInput>
  }

  export type titulo_tipoCreateWithoutTituloInput = {
    nome?: string | null
  }

  export type titulo_tipoUncheckedCreateWithoutTituloInput = {
    id?: number
    nome?: string | null
  }

  export type titulo_tipoCreateOrConnectWithoutTituloInput = {
    where: titulo_tipoWhereUniqueInput
    create: XOR<titulo_tipoCreateWithoutTituloInput, titulo_tipoUncheckedCreateWithoutTituloInput>
  }

  export type borderoCreateWithoutTituloInput = {
    carteira_id: number
    titulos_x_usuario?: titulos_x_usuarioCreateNestedManyWithoutBordero_borderoTotitulos_x_usuarioInput
  }

  export type borderoUncheckedCreateWithoutTituloInput = {
    id?: number
    carteira_id: number
    titulos_x_usuario?: titulos_x_usuarioUncheckedCreateNestedManyWithoutBordero_borderoTotitulos_x_usuarioInput
  }

  export type borderoCreateOrConnectWithoutTituloInput = {
    where: borderoWhereUniqueInput
    create: XOR<borderoCreateWithoutTituloInput, borderoUncheckedCreateWithoutTituloInput>
  }

  export type titulo_tipoUpsertWithoutTituloInput = {
    update: XOR<titulo_tipoUpdateWithoutTituloInput, titulo_tipoUncheckedUpdateWithoutTituloInput>
    create: XOR<titulo_tipoCreateWithoutTituloInput, titulo_tipoUncheckedCreateWithoutTituloInput>
  }

  export type titulo_tipoUpdateWithoutTituloInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type titulo_tipoUncheckedUpdateWithoutTituloInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type borderoUpsertWithoutTituloInput = {
    update: XOR<borderoUpdateWithoutTituloInput, borderoUncheckedUpdateWithoutTituloInput>
    create: XOR<borderoCreateWithoutTituloInput, borderoUncheckedCreateWithoutTituloInput>
  }

  export type borderoUpdateWithoutTituloInput = {
    carteira_id?: IntFieldUpdateOperationsInput | number
    titulos_x_usuario?: titulos_x_usuarioUpdateManyWithoutBordero_borderoTotitulos_x_usuarioNestedInput
  }

  export type borderoUncheckedUpdateWithoutTituloInput = {
    id?: IntFieldUpdateOperationsInput | number
    carteira_id?: IntFieldUpdateOperationsInput | number
    titulos_x_usuario?: titulos_x_usuarioUncheckedUpdateManyWithoutBordero_borderoTotitulos_x_usuarioNestedInput
  }

  export type tituloCreateWithoutTitulo_tipoInput = {
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
    bordero: borderoCreateNestedOneWithoutTituloInput
  }

  export type tituloUncheckedCreateWithoutTitulo_tipoInput = {
    id?: number
    bordero_id: number
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
  }

  export type tituloCreateOrConnectWithoutTitulo_tipoInput = {
    where: tituloWhereUniqueInput
    create: XOR<tituloCreateWithoutTitulo_tipoInput, tituloUncheckedCreateWithoutTitulo_tipoInput>
  }

  export type tituloCreateManyTitulo_tipoInputEnvelope = {
    data: Enumerable<tituloCreateManyTitulo_tipoInput>
    skipDuplicates?: boolean
  }

  export type tituloUpsertWithWhereUniqueWithoutTitulo_tipoInput = {
    where: tituloWhereUniqueInput
    update: XOR<tituloUpdateWithoutTitulo_tipoInput, tituloUncheckedUpdateWithoutTitulo_tipoInput>
    create: XOR<tituloCreateWithoutTitulo_tipoInput, tituloUncheckedCreateWithoutTitulo_tipoInput>
  }

  export type tituloUpdateWithWhereUniqueWithoutTitulo_tipoInput = {
    where: tituloWhereUniqueInput
    data: XOR<tituloUpdateWithoutTitulo_tipoInput, tituloUncheckedUpdateWithoutTitulo_tipoInput>
  }

  export type tituloUpdateManyWithWhereWithoutTitulo_tipoInput = {
    where: tituloScalarWhereInput
    data: XOR<tituloUpdateManyMutationInput, tituloUncheckedUpdateManyWithoutTituloInput>
  }

  export type cedenteCreateWithoutTitulo_x_cedenteInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    cedente_analise?: cedente_analiseCreateNestedManyWithoutCedente_cedenteTocedente_analiseInput
    cedente_n_sacados?: cedente_n_sacadosCreateNestedManyWithoutCedente_cedenteTocedente_n_sacadosInput
  }

  export type cedenteUncheckedCreateWithoutTitulo_x_cedenteInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    cedente_analise?: cedente_analiseUncheckedCreateNestedManyWithoutCedente_cedenteTocedente_analiseInput
    cedente_n_sacados?: cedente_n_sacadosUncheckedCreateNestedManyWithoutCedente_cedenteTocedente_n_sacadosInput
  }

  export type cedenteCreateOrConnectWithoutTitulo_x_cedenteInput = {
    where: cedenteWhereUniqueInput
    create: XOR<cedenteCreateWithoutTitulo_x_cedenteInput, cedenteUncheckedCreateWithoutTitulo_x_cedenteInput>
  }

  export type cedenteUpsertWithoutTitulo_x_cedenteInput = {
    update: XOR<cedenteUpdateWithoutTitulo_x_cedenteInput, cedenteUncheckedUpdateWithoutTitulo_x_cedenteInput>
    create: XOR<cedenteCreateWithoutTitulo_x_cedenteInput, cedenteUncheckedCreateWithoutTitulo_x_cedenteInput>
  }

  export type cedenteUpdateWithoutTitulo_x_cedenteInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cedente_analise?: cedente_analiseUpdateManyWithoutCedente_cedenteTocedente_analiseNestedInput
    cedente_n_sacados?: cedente_n_sacadosUpdateManyWithoutCedente_cedenteTocedente_n_sacadosNestedInput
  }

  export type cedenteUncheckedUpdateWithoutTitulo_x_cedenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cedente_analise?: cedente_analiseUncheckedUpdateManyWithoutCedente_cedenteTocedente_analiseNestedInput
    cedente_n_sacados?: cedente_n_sacadosUncheckedUpdateManyWithoutCedente_cedenteTocedente_n_sacadosNestedInput
  }

  export type borderoCreateWithoutTitulos_x_usuarioInput = {
    carteira_id: number
    titulo?: tituloCreateNestedManyWithoutBorderoInput
  }

  export type borderoUncheckedCreateWithoutTitulos_x_usuarioInput = {
    id?: number
    carteira_id: number
    titulo?: tituloUncheckedCreateNestedManyWithoutBorderoInput
  }

  export type borderoCreateOrConnectWithoutTitulos_x_usuarioInput = {
    where: borderoWhereUniqueInput
    create: XOR<borderoCreateWithoutTitulos_x_usuarioInput, borderoUncheckedCreateWithoutTitulos_x_usuarioInput>
  }

  export type usuarioCreateWithoutTitulos_x_usuarioInput = {
    email: string
    senha: string
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    auditoria?: auditoriaCreateNestedManyWithoutUsuario_auditoriaTousuarioInput
    checagem?: checagemCreateNestedManyWithoutUsuario_checagemTousuarioInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioCreateNestedManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput
    pessoa: pessoaCreateNestedOneWithoutUsuarioInput
    usuario_x_perfil?: usuario_x_perfilCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutTitulos_x_usuarioInput = {
    id?: number
    email: string
    senha: string
    pessoa_id: number
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuario_auditoriaTousuarioInput
    checagem?: checagemUncheckedCreateNestedManyWithoutUsuario_checagemTousuarioInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedCreateNestedManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput
    usuario_x_perfil?: usuario_x_perfilUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutTitulos_x_usuarioInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutTitulos_x_usuarioInput, usuarioUncheckedCreateWithoutTitulos_x_usuarioInput>
  }

  export type borderoUpsertWithoutTitulos_x_usuarioInput = {
    update: XOR<borderoUpdateWithoutTitulos_x_usuarioInput, borderoUncheckedUpdateWithoutTitulos_x_usuarioInput>
    create: XOR<borderoCreateWithoutTitulos_x_usuarioInput, borderoUncheckedCreateWithoutTitulos_x_usuarioInput>
  }

  export type borderoUpdateWithoutTitulos_x_usuarioInput = {
    carteira_id?: IntFieldUpdateOperationsInput | number
    titulo?: tituloUpdateManyWithoutBorderoNestedInput
  }

  export type borderoUncheckedUpdateWithoutTitulos_x_usuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    carteira_id?: IntFieldUpdateOperationsInput | number
    titulo?: tituloUncheckedUpdateManyWithoutBorderoNestedInput
  }

  export type usuarioUpsertWithoutTitulos_x_usuarioInput = {
    update: XOR<usuarioUpdateWithoutTitulos_x_usuarioInput, usuarioUncheckedUpdateWithoutTitulos_x_usuarioInput>
    create: XOR<usuarioCreateWithoutTitulos_x_usuarioInput, usuarioUncheckedCreateWithoutTitulos_x_usuarioInput>
  }

  export type usuarioUpdateWithoutTitulos_x_usuarioInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditoria?: auditoriaUpdateManyWithoutUsuario_auditoriaTousuarioNestedInput
    checagem?: checagemUpdateManyWithoutUsuario_checagemTousuarioNestedInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUpdateManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutUsuarioNestedInput
    usuario_x_perfil?: usuario_x_perfilUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutTitulos_x_usuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    pessoa_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuario_auditoriaTousuarioNestedInput
    checagem?: checagemUncheckedUpdateManyWithoutUsuario_checagemTousuarioNestedInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedUpdateManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioNestedInput
    usuario_x_perfil?: usuario_x_perfilUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type auditoriaCreateWithoutUsuario_auditoriaTousuarioInput = {
    action?: string | null
    data?: Date | string | null
    modulo?: string | null
  }

  export type auditoriaUncheckedCreateWithoutUsuario_auditoriaTousuarioInput = {
    action?: string | null
    data?: Date | string | null
    modulo?: string | null
    id?: number
  }

  export type auditoriaCreateOrConnectWithoutUsuario_auditoriaTousuarioInput = {
    where: auditoriaWhereUniqueInput
    create: XOR<auditoriaCreateWithoutUsuario_auditoriaTousuarioInput, auditoriaUncheckedCreateWithoutUsuario_auditoriaTousuarioInput>
  }

  export type auditoriaCreateManyUsuario_auditoriaTousuarioInputEnvelope = {
    data: Enumerable<auditoriaCreateManyUsuario_auditoriaTousuarioInput>
    skipDuplicates?: boolean
  }

  export type checagemCreateWithoutUsuario_checagemTousuarioInput = {
    nf?: string | null
    status?: string | null
    titulos?: string | null
  }

  export type checagemUncheckedCreateWithoutUsuario_checagemTousuarioInput = {
    id?: number
    nf?: string | null
    status?: string | null
    titulos?: string | null
  }

  export type checagemCreateOrConnectWithoutUsuario_checagemTousuarioInput = {
    where: checagemWhereUniqueInput
    create: XOR<checagemCreateWithoutUsuario_checagemTousuarioInput, checagemUncheckedCreateWithoutUsuario_checagemTousuarioInput>
  }

  export type checagemCreateManyUsuario_checagemTousuarioInputEnvelope = {
    data: Enumerable<checagemCreateManyUsuario_checagemTousuarioInput>
    skipDuplicates?: boolean
  }

  export type fidic_fundo_x_usuarioCreateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput = {
    fidic_fundo: fidic_fundoCreateNestedOneWithoutFidic_fundo_x_usuarioInput
  }

  export type fidic_fundo_x_usuarioUncheckedCreateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput = {
    id?: number
    fidic: number
  }

  export type fidic_fundo_x_usuarioCreateOrConnectWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput = {
    where: fidic_fundo_x_usuarioWhereUniqueInput
    create: XOR<fidic_fundo_x_usuarioCreateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput, fidic_fundo_x_usuarioUncheckedCreateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>
  }

  export type fidic_fundo_x_usuarioCreateManyUsuario_fidic_fundo_x_usuarioTousuarioInputEnvelope = {
    data: Enumerable<fidic_fundo_x_usuarioCreateManyUsuario_fidic_fundo_x_usuarioTousuarioInput>
    skipDuplicates?: boolean
  }

  export type titulos_x_usuarioCreateWithoutUsuario_titulos_x_usuarioTousuarioInput = {
    status?: string | null
    bordero_borderoTotitulos_x_usuario?: borderoCreateNestedOneWithoutTitulos_x_usuarioInput
  }

  export type titulos_x_usuarioUncheckedCreateWithoutUsuario_titulos_x_usuarioTousuarioInput = {
    id?: number
    bordero?: number | null
    status?: string | null
  }

  export type titulos_x_usuarioCreateOrConnectWithoutUsuario_titulos_x_usuarioTousuarioInput = {
    where: titulos_x_usuarioWhereUniqueInput
    create: XOR<titulos_x_usuarioCreateWithoutUsuario_titulos_x_usuarioTousuarioInput, titulos_x_usuarioUncheckedCreateWithoutUsuario_titulos_x_usuarioTousuarioInput>
  }

  export type titulos_x_usuarioCreateManyUsuario_titulos_x_usuarioTousuarioInputEnvelope = {
    data: Enumerable<titulos_x_usuarioCreateManyUsuario_titulos_x_usuarioTousuarioInput>
    skipDuplicates?: boolean
  }

  export type pessoaCreateWithoutUsuarioInput = {
    nome: string
    sobrenome: string
    sexo?: string | null
    nascimento?: Date | string | null
    cpf?: string | null
    rg?: string | null
  }

  export type pessoaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    nome: string
    sobrenome: string
    sexo?: string | null
    nascimento?: Date | string | null
    cpf?: string | null
    rg?: string | null
  }

  export type pessoaCreateOrConnectWithoutUsuarioInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutUsuarioInput, pessoaUncheckedCreateWithoutUsuarioInput>
  }

  export type usuario_x_perfilCreateWithoutUsuarioInput = {
    senha: string
    usuario_perfil_tipo: usuario_perfil_tipoCreateNestedOneWithoutUsuario_x_perfilInput
  }

  export type usuario_x_perfilUncheckedCreateWithoutUsuarioInput = {
    id?: number
    senha: string
    usuario_perfil_id: number
  }

  export type usuario_x_perfilCreateOrConnectWithoutUsuarioInput = {
    where: usuario_x_perfilWhereUniqueInput
    create: XOR<usuario_x_perfilCreateWithoutUsuarioInput, usuario_x_perfilUncheckedCreateWithoutUsuarioInput>
  }

  export type usuario_x_perfilCreateManyUsuarioInputEnvelope = {
    data: Enumerable<usuario_x_perfilCreateManyUsuarioInput>
    skipDuplicates?: boolean
  }

  export type auditoriaUpsertWithWhereUniqueWithoutUsuario_auditoriaTousuarioInput = {
    where: auditoriaWhereUniqueInput
    update: XOR<auditoriaUpdateWithoutUsuario_auditoriaTousuarioInput, auditoriaUncheckedUpdateWithoutUsuario_auditoriaTousuarioInput>
    create: XOR<auditoriaCreateWithoutUsuario_auditoriaTousuarioInput, auditoriaUncheckedCreateWithoutUsuario_auditoriaTousuarioInput>
  }

  export type auditoriaUpdateWithWhereUniqueWithoutUsuario_auditoriaTousuarioInput = {
    where: auditoriaWhereUniqueInput
    data: XOR<auditoriaUpdateWithoutUsuario_auditoriaTousuarioInput, auditoriaUncheckedUpdateWithoutUsuario_auditoriaTousuarioInput>
  }

  export type auditoriaUpdateManyWithWhereWithoutUsuario_auditoriaTousuarioInput = {
    where: auditoriaScalarWhereInput
    data: XOR<auditoriaUpdateManyMutationInput, auditoriaUncheckedUpdateManyWithoutAuditoriaInput>
  }

  export type auditoriaScalarWhereInput = {
    AND?: Enumerable<auditoriaScalarWhereInput>
    OR?: Enumerable<auditoriaScalarWhereInput>
    NOT?: Enumerable<auditoriaScalarWhereInput>
    action?: StringNullableFilter | string | null
    usuario?: IntNullableFilter | number | null
    data?: DateTimeNullableFilter | Date | string | null
    modulo?: StringNullableFilter | string | null
    id?: IntFilter | number
  }

  export type checagemUpsertWithWhereUniqueWithoutUsuario_checagemTousuarioInput = {
    where: checagemWhereUniqueInput
    update: XOR<checagemUpdateWithoutUsuario_checagemTousuarioInput, checagemUncheckedUpdateWithoutUsuario_checagemTousuarioInput>
    create: XOR<checagemCreateWithoutUsuario_checagemTousuarioInput, checagemUncheckedCreateWithoutUsuario_checagemTousuarioInput>
  }

  export type checagemUpdateWithWhereUniqueWithoutUsuario_checagemTousuarioInput = {
    where: checagemWhereUniqueInput
    data: XOR<checagemUpdateWithoutUsuario_checagemTousuarioInput, checagemUncheckedUpdateWithoutUsuario_checagemTousuarioInput>
  }

  export type checagemUpdateManyWithWhereWithoutUsuario_checagemTousuarioInput = {
    where: checagemScalarWhereInput
    data: XOR<checagemUpdateManyMutationInput, checagemUncheckedUpdateManyWithoutChecagemInput>
  }

  export type checagemScalarWhereInput = {
    AND?: Enumerable<checagemScalarWhereInput>
    OR?: Enumerable<checagemScalarWhereInput>
    NOT?: Enumerable<checagemScalarWhereInput>
    id?: IntFilter | number
    nf?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    usuario?: IntNullableFilter | number | null
    titulos?: StringNullableFilter | string | null
  }

  export type fidic_fundo_x_usuarioUpsertWithWhereUniqueWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput = {
    where: fidic_fundo_x_usuarioWhereUniqueInput
    update: XOR<fidic_fundo_x_usuarioUpdateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput, fidic_fundo_x_usuarioUncheckedUpdateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>
    create: XOR<fidic_fundo_x_usuarioCreateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput, fidic_fundo_x_usuarioUncheckedCreateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>
  }

  export type fidic_fundo_x_usuarioUpdateWithWhereUniqueWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput = {
    where: fidic_fundo_x_usuarioWhereUniqueInput
    data: XOR<fidic_fundo_x_usuarioUpdateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput, fidic_fundo_x_usuarioUncheckedUpdateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput>
  }

  export type fidic_fundo_x_usuarioUpdateManyWithWhereWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput = {
    where: fidic_fundo_x_usuarioScalarWhereInput
    data: XOR<fidic_fundo_x_usuarioUpdateManyMutationInput, fidic_fundo_x_usuarioUncheckedUpdateManyWithoutFidic_fundo_x_usuarioInput>
  }

  export type titulos_x_usuarioUpsertWithWhereUniqueWithoutUsuario_titulos_x_usuarioTousuarioInput = {
    where: titulos_x_usuarioWhereUniqueInput
    update: XOR<titulos_x_usuarioUpdateWithoutUsuario_titulos_x_usuarioTousuarioInput, titulos_x_usuarioUncheckedUpdateWithoutUsuario_titulos_x_usuarioTousuarioInput>
    create: XOR<titulos_x_usuarioCreateWithoutUsuario_titulos_x_usuarioTousuarioInput, titulos_x_usuarioUncheckedCreateWithoutUsuario_titulos_x_usuarioTousuarioInput>
  }

  export type titulos_x_usuarioUpdateWithWhereUniqueWithoutUsuario_titulos_x_usuarioTousuarioInput = {
    where: titulos_x_usuarioWhereUniqueInput
    data: XOR<titulos_x_usuarioUpdateWithoutUsuario_titulos_x_usuarioTousuarioInput, titulos_x_usuarioUncheckedUpdateWithoutUsuario_titulos_x_usuarioTousuarioInput>
  }

  export type titulos_x_usuarioUpdateManyWithWhereWithoutUsuario_titulos_x_usuarioTousuarioInput = {
    where: titulos_x_usuarioScalarWhereInput
    data: XOR<titulos_x_usuarioUpdateManyMutationInput, titulos_x_usuarioUncheckedUpdateManyWithoutTitulos_x_usuarioInput>
  }

  export type pessoaUpsertWithoutUsuarioInput = {
    update: XOR<pessoaUpdateWithoutUsuarioInput, pessoaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<pessoaCreateWithoutUsuarioInput, pessoaUncheckedCreateWithoutUsuarioInput>
  }

  export type pessoaUpdateWithoutUsuarioInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pessoaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuario_x_perfilUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: usuario_x_perfilWhereUniqueInput
    update: XOR<usuario_x_perfilUpdateWithoutUsuarioInput, usuario_x_perfilUncheckedUpdateWithoutUsuarioInput>
    create: XOR<usuario_x_perfilCreateWithoutUsuarioInput, usuario_x_perfilUncheckedCreateWithoutUsuarioInput>
  }

  export type usuario_x_perfilUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: usuario_x_perfilWhereUniqueInput
    data: XOR<usuario_x_perfilUpdateWithoutUsuarioInput, usuario_x_perfilUncheckedUpdateWithoutUsuarioInput>
  }

  export type usuario_x_perfilUpdateManyWithWhereWithoutUsuarioInput = {
    where: usuario_x_perfilScalarWhereInput
    data: XOR<usuario_x_perfilUpdateManyMutationInput, usuario_x_perfilUncheckedUpdateManyWithoutUsuario_x_perfilInput>
  }

  export type usuario_x_perfilScalarWhereInput = {
    AND?: Enumerable<usuario_x_perfilScalarWhereInput>
    OR?: Enumerable<usuario_x_perfilScalarWhereInput>
    NOT?: Enumerable<usuario_x_perfilScalarWhereInput>
    id?: IntFilter | number
    senha?: StringFilter | string
    usuario_id?: IntFilter | number
    usuario_perfil_id?: IntFilter | number
  }

  export type usuario_x_perfilCreateWithoutUsuario_perfil_tipoInput = {
    senha: string
    usuario: usuarioCreateNestedOneWithoutUsuario_x_perfilInput
  }

  export type usuario_x_perfilUncheckedCreateWithoutUsuario_perfil_tipoInput = {
    id?: number
    senha: string
    usuario_id: number
  }

  export type usuario_x_perfilCreateOrConnectWithoutUsuario_perfil_tipoInput = {
    where: usuario_x_perfilWhereUniqueInput
    create: XOR<usuario_x_perfilCreateWithoutUsuario_perfil_tipoInput, usuario_x_perfilUncheckedCreateWithoutUsuario_perfil_tipoInput>
  }

  export type usuario_x_perfilCreateManyUsuario_perfil_tipoInputEnvelope = {
    data: Enumerable<usuario_x_perfilCreateManyUsuario_perfil_tipoInput>
    skipDuplicates?: boolean
  }

  export type usuario_x_perfilUpsertWithWhereUniqueWithoutUsuario_perfil_tipoInput = {
    where: usuario_x_perfilWhereUniqueInput
    update: XOR<usuario_x_perfilUpdateWithoutUsuario_perfil_tipoInput, usuario_x_perfilUncheckedUpdateWithoutUsuario_perfil_tipoInput>
    create: XOR<usuario_x_perfilCreateWithoutUsuario_perfil_tipoInput, usuario_x_perfilUncheckedCreateWithoutUsuario_perfil_tipoInput>
  }

  export type usuario_x_perfilUpdateWithWhereUniqueWithoutUsuario_perfil_tipoInput = {
    where: usuario_x_perfilWhereUniqueInput
    data: XOR<usuario_x_perfilUpdateWithoutUsuario_perfil_tipoInput, usuario_x_perfilUncheckedUpdateWithoutUsuario_perfil_tipoInput>
  }

  export type usuario_x_perfilUpdateManyWithWhereWithoutUsuario_perfil_tipoInput = {
    where: usuario_x_perfilScalarWhereInput
    data: XOR<usuario_x_perfilUpdateManyMutationInput, usuario_x_perfilUncheckedUpdateManyWithoutUsuario_x_perfilInput>
  }

  export type usuarioCreateWithoutUsuario_x_perfilInput = {
    email: string
    senha: string
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    auditoria?: auditoriaCreateNestedManyWithoutUsuario_auditoriaTousuarioInput
    checagem?: checagemCreateNestedManyWithoutUsuario_checagemTousuarioInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioCreateNestedManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput
    titulos_x_usuario?: titulos_x_usuarioCreateNestedManyWithoutUsuario_titulos_x_usuarioTousuarioInput
    pessoa: pessoaCreateNestedOneWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutUsuario_x_perfilInput = {
    id?: number
    email: string
    senha: string
    pessoa_id: number
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    auditoria?: auditoriaUncheckedCreateNestedManyWithoutUsuario_auditoriaTousuarioInput
    checagem?: checagemUncheckedCreateNestedManyWithoutUsuario_checagemTousuarioInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedCreateNestedManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput
    titulos_x_usuario?: titulos_x_usuarioUncheckedCreateNestedManyWithoutUsuario_titulos_x_usuarioTousuarioInput
  }

  export type usuarioCreateOrConnectWithoutUsuario_x_perfilInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutUsuario_x_perfilInput, usuarioUncheckedCreateWithoutUsuario_x_perfilInput>
  }

  export type usuario_perfil_tipoCreateWithoutUsuario_x_perfilInput = {
    nome: string
  }

  export type usuario_perfil_tipoUncheckedCreateWithoutUsuario_x_perfilInput = {
    id?: number
    nome: string
  }

  export type usuario_perfil_tipoCreateOrConnectWithoutUsuario_x_perfilInput = {
    where: usuario_perfil_tipoWhereUniqueInput
    create: XOR<usuario_perfil_tipoCreateWithoutUsuario_x_perfilInput, usuario_perfil_tipoUncheckedCreateWithoutUsuario_x_perfilInput>
  }

  export type usuarioUpsertWithoutUsuario_x_perfilInput = {
    update: XOR<usuarioUpdateWithoutUsuario_x_perfilInput, usuarioUncheckedUpdateWithoutUsuario_x_perfilInput>
    create: XOR<usuarioCreateWithoutUsuario_x_perfilInput, usuarioUncheckedCreateWithoutUsuario_x_perfilInput>
  }

  export type usuarioUpdateWithoutUsuario_x_perfilInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditoria?: auditoriaUpdateManyWithoutUsuario_auditoriaTousuarioNestedInput
    checagem?: checagemUpdateManyWithoutUsuario_checagemTousuarioNestedInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUpdateManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioNestedInput
    titulos_x_usuario?: titulos_x_usuarioUpdateManyWithoutUsuario_titulos_x_usuarioTousuarioNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutUsuario_x_perfilInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    pessoa_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuario_auditoriaTousuarioNestedInput
    checagem?: checagemUncheckedUpdateManyWithoutUsuario_checagemTousuarioNestedInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedUpdateManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioNestedInput
    titulos_x_usuario?: titulos_x_usuarioUncheckedUpdateManyWithoutUsuario_titulos_x_usuarioTousuarioNestedInput
  }

  export type usuario_perfil_tipoUpsertWithoutUsuario_x_perfilInput = {
    update: XOR<usuario_perfil_tipoUpdateWithoutUsuario_x_perfilInput, usuario_perfil_tipoUncheckedUpdateWithoutUsuario_x_perfilInput>
    create: XOR<usuario_perfil_tipoCreateWithoutUsuario_x_perfilInput, usuario_perfil_tipoUncheckedCreateWithoutUsuario_x_perfilInput>
  }

  export type usuario_perfil_tipoUpdateWithoutUsuario_x_perfilInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type usuario_perfil_tipoUncheckedUpdateWithoutUsuario_x_perfilInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type tituloCreateManyBorderoInput = {
    id?: number
    titulo_tipo_id: number
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
  }

  export type titulos_x_usuarioCreateManyBordero_borderoTotitulos_x_usuarioInput = {
    id?: number
    usuario?: number | null
    status?: string | null
  }

  export type tituloUpdateWithoutBorderoInput = {
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    titulo_tipo?: titulo_tipoUpdateOneRequiredWithoutTituloNestedInput
  }

  export type tituloUncheckedUpdateWithoutBorderoInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo_tipo_id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tituloUncheckedUpdateManyWithoutTituloInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo_tipo_id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type titulos_x_usuarioUpdateWithoutBordero_borderoTotitulos_x_usuarioInput = {
    status?: NullableStringFieldUpdateOperationsInput | string | null
    usuario_titulos_x_usuarioTousuario?: usuarioUpdateOneWithoutTitulos_x_usuarioNestedInput
  }

  export type titulos_x_usuarioUncheckedUpdateWithoutBordero_borderoTotitulos_x_usuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type titulos_x_usuarioUncheckedUpdateManyWithoutTitulos_x_usuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cedente_analiseCreateManyCedente_cedenteTocedente_analiseInput = {
    id?: number
    status?: string | null
  }

  export type cedente_n_sacadosCreateManyCedente_cedenteTocedente_n_sacadosInput = {
    id?: number
    sacado?: number | null
  }

  export type titulo_x_cedenteCreateManyCedente_cedenteTotitulo_x_cedenteInput = {
    id?: number
  }

  export type cedente_analiseUpdateWithoutCedente_cedenteTocedente_analiseInput = {
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cedente_analiseUncheckedUpdateWithoutCedente_cedenteTocedente_analiseInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cedente_analiseUncheckedUpdateManyWithoutCedente_analiseInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cedente_n_sacadosUpdateWithoutCedente_cedenteTocedente_n_sacadosInput = {
    sacado_cedente_n_sacadosTosacado?: sacadoUpdateOneWithoutCedente_n_sacadosNestedInput
  }

  export type cedente_n_sacadosUncheckedUpdateWithoutCedente_cedenteTocedente_n_sacadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    sacado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cedente_n_sacadosUncheckedUpdateManyWithoutCedente_n_sacadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    sacado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type titulo_x_cedenteUpdateWithoutCedente_cedenteTotitulo_x_cedenteInput = {

  }

  export type titulo_x_cedenteUncheckedUpdateWithoutCedente_cedenteTotitulo_x_cedenteInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type titulo_x_cedenteUncheckedUpdateManyWithoutTitulo_x_cedenteInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type carteiraCreateManyFidic_fundoInput = {
    id?: number
  }

  export type fidic_fundo_x_usuarioCreateManyFidic_fundoInput = {
    id?: number
    usuario?: number | null
  }

  export type carteiraUpdateWithoutFidic_fundoInput = {

  }

  export type carteiraUncheckedUpdateWithoutFidic_fundoInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type carteiraUncheckedUpdateManyWithoutCarteiraInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type fidic_fundo_x_usuarioUpdateWithoutFidic_fundoInput = {
    usuario_fidic_fundo_x_usuarioTousuario?: usuarioUpdateOneWithoutFidic_fundo_x_usuarioNestedInput
  }

  export type fidic_fundo_x_usuarioUncheckedUpdateWithoutFidic_fundoInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type fidic_fundo_x_usuarioUncheckedUpdateManyWithoutFidic_fundo_x_usuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type usuarioCreateManyPessoaInput = {
    id?: number
    email: string
    senha: string
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type usuarioUpdateWithoutPessoaInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditoria?: auditoriaUpdateManyWithoutUsuario_auditoriaTousuarioNestedInput
    checagem?: checagemUpdateManyWithoutUsuario_checagemTousuarioNestedInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUpdateManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioNestedInput
    titulos_x_usuario?: titulos_x_usuarioUpdateManyWithoutUsuario_titulos_x_usuarioTousuarioNestedInput
    usuario_x_perfil?: usuario_x_perfilUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutPessoaInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditoria?: auditoriaUncheckedUpdateManyWithoutUsuario_auditoriaTousuarioNestedInput
    checagem?: checagemUncheckedUpdateManyWithoutUsuario_checagemTousuarioNestedInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedUpdateManyWithoutUsuario_fidic_fundo_x_usuarioTousuarioNestedInput
    titulos_x_usuario?: titulos_x_usuarioUncheckedUpdateManyWithoutUsuario_titulos_x_usuarioTousuarioNestedInput
    usuario_x_perfil?: usuario_x_perfilUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cedente_n_sacadosCreateManySacado_cedente_n_sacadosTosacadoInput = {
    id?: number
    cedente?: number | null
  }

  export type cedente_n_sacadosUpdateWithoutSacado_cedente_n_sacadosTosacadoInput = {
    cedente_cedenteTocedente_n_sacados?: cedenteUpdateOneWithoutCedente_n_sacadosNestedInput
  }

  export type cedente_n_sacadosUncheckedUpdateWithoutSacado_cedente_n_sacadosTosacadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedente?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tituloCreateManyTitulo_tipoInput = {
    id?: number
    bordero_id: number
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
  }

  export type tituloUpdateWithoutTitulo_tipoInput = {
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    bordero?: borderoUpdateOneRequiredWithoutTituloNestedInput
  }

  export type tituloUncheckedUpdateWithoutTitulo_tipoInput = {
    id?: IntFieldUpdateOperationsInput | number
    bordero_id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditoriaCreateManyUsuario_auditoriaTousuarioInput = {
    action?: string | null
    data?: Date | string | null
    modulo?: string | null
    id?: number
  }

  export type checagemCreateManyUsuario_checagemTousuarioInput = {
    id?: number
    nf?: string | null
    status?: string | null
    titulos?: string | null
  }

  export type fidic_fundo_x_usuarioCreateManyUsuario_fidic_fundo_x_usuarioTousuarioInput = {
    id?: number
    fidic: number
  }

  export type titulos_x_usuarioCreateManyUsuario_titulos_x_usuarioTousuarioInput = {
    id?: number
    bordero?: number | null
    status?: string | null
  }

  export type usuario_x_perfilCreateManyUsuarioInput = {
    id?: number
    senha: string
    usuario_perfil_id: number
  }

  export type auditoriaUpdateWithoutUsuario_auditoriaTousuarioInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modulo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditoriaUncheckedUpdateWithoutUsuario_auditoriaTousuarioInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modulo?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type auditoriaUncheckedUpdateManyWithoutAuditoriaInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modulo?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type checagemUpdateWithoutUsuario_checagemTousuarioInput = {
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    titulos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type checagemUncheckedUpdateWithoutUsuario_checagemTousuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    titulos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type checagemUncheckedUpdateManyWithoutChecagemInput = {
    id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    titulos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fidic_fundo_x_usuarioUpdateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput = {
    fidic_fundo?: fidic_fundoUpdateOneRequiredWithoutFidic_fundo_x_usuarioNestedInput
  }

  export type fidic_fundo_x_usuarioUncheckedUpdateWithoutUsuario_fidic_fundo_x_usuarioTousuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    fidic?: IntFieldUpdateOperationsInput | number
  }

  export type titulos_x_usuarioUpdateWithoutUsuario_titulos_x_usuarioTousuarioInput = {
    status?: NullableStringFieldUpdateOperationsInput | string | null
    bordero_borderoTotitulos_x_usuario?: borderoUpdateOneWithoutTitulos_x_usuarioNestedInput
  }

  export type titulos_x_usuarioUncheckedUpdateWithoutUsuario_titulos_x_usuarioTousuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    bordero?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuario_x_perfilUpdateWithoutUsuarioInput = {
    senha?: StringFieldUpdateOperationsInput | string
    usuario_perfil_tipo?: usuario_perfil_tipoUpdateOneRequiredWithoutUsuario_x_perfilNestedInput
  }

  export type usuario_x_perfilUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    usuario_perfil_id?: IntFieldUpdateOperationsInput | number
  }

  export type usuario_x_perfilUncheckedUpdateManyWithoutUsuario_x_perfilInput = {
    id?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    usuario_perfil_id?: IntFieldUpdateOperationsInput | number
  }

  export type usuario_x_perfilCreateManyUsuario_perfil_tipoInput = {
    id?: number
    senha: string
    usuario_id: number
  }

  export type usuario_x_perfilUpdateWithoutUsuario_perfil_tipoInput = {
    senha?: StringFieldUpdateOperationsInput | string
    usuario?: usuarioUpdateOneRequiredWithoutUsuario_x_perfilNestedInput
  }

  export type usuario_x_perfilUncheckedUpdateWithoutUsuario_perfil_tipoInput = {
    id?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    usuario_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}