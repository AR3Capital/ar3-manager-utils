
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model auditoria
 * 
 */
export type auditoria = {
  action: string | null
  usuario: number | null
  data: Date | null
  modulo: string | null
  id: number
}

/**
 * Model bordero
 * 
 */
export type bordero = {
  id: number
  carteira_id: number
}

/**
 * Model carteira
 * 
 */
export type carteira = {
  id: number
  fiduc_fundo_id: number
}

/**
 * Model cedente
 * 
 */
export type cedente = {
  id: number
  pessoa_id: number
  razao_social: string
  nome_fantasia: string | null
  abertura: Date | null
  cnpj: string | null
  endereco: string | null
  numero: string | null
  cep: string | null
  bairro: string | null
  cidade: string | null
  uf: string | null
  telefone: string | null
}

/**
 * Model cedente_analise
 * 
 */
export type cedente_analise = {
  id: number
  status: string | null
  cedente: number | null
}

/**
 * Model cedente_n_sacados
 * 
 */
export type cedente_n_sacados = {
  id: number
  cedente: number | null
  sacado: number | null
}

/**
 * Model checagem
 * 
 */
export type checagem = {
  id: number
  nf: string | null
  status: string | null
  usuario: number | null
  titulos: string | null
}

/**
 * Model fidic_fundo
 * 
 */
export type fidic_fundo = {
  id: number
  pessoa_id: number
  razao_social: string
  nome_fantasia: string | null
  abertura: Date | null
  cnpj: string | null
}

/**
 * Model fidic_fundo_x_usuario
 * 
 */
export type fidic_fundo_x_usuario = {
  id: number
  usuario: number | null
  fidic: number
}

/**
 * Model organograma
 * 
 */
export type organograma = {
  id: number
  organograma_id: number
}

/**
 * Model organograma_tipo
 * 
 */
export type organograma_tipo = {
  id: number
  nome: string
}

/**
 * Model organograma_x_regiao_atuacao
 * 
 */
export type organograma_x_regiao_atuacao = {
  id: number
  organograma_id: number
  regiao_atuacao_id: number
}

/**
 * Model pessoa
 * 
 */
export type pessoa = {
  id: number
  nome: string
  sobrenome: string
  sexo: string | null
  nascimento: Date | null
  cpf: string | null
  rg: string | null
}

/**
 * Model plataforma
 * 
 */
export type plataforma = {
  id: number
  nome: string | null
  plataforma_papel_tipo_id: number
}

/**
 * Model plataforma_papel_tipo
 * 
 */
export type plataforma_papel_tipo = {
  id: number
}

/**
 * Model plataforma_x_regiao_atuacao
 * 
 */
export type plataforma_x_regiao_atuacao = {
  id: number
  plataforma_id: number
  regiao_atuacao_id: number
}

/**
 * Model regiao_atuacao
 * 
 */
export type regiao_atuacao = {
  id: number
  nome: string
  regiao_atuacao_tipo_id: number
}

/**
 * Model regiao_atuacao_tipo
 * 
 */
export type regiao_atuacao_tipo = {
  id: number
  nome: string
}

/**
 * Model sacado
 * 
 */
export type sacado = {
  id: number
  pessoa_id: number
  razao_social: string
  nome_fantasia: string | null
  abertura: Date | null
  cnpj: string | null
}

/**
 * Model titulo
 * 
 */
export type titulo = {
  id: number
  titulo_tipo_id: number
  bordero_id: number
  nf: string | null
  valor: number | null
  vencimento: Date | null
  numero: string | null
  emissao: Date | null
  parcela: string | null
}

/**
 * Model titulo_tipo
 * 
 */
export type titulo_tipo = {
  id: number
  nome: string | null
}

/**
 * Model usuario
 * 
 */
export type usuario = {
  id: number
  email: string
  senha: string
  pessoa_id: number
  status: string | null
  primeiro_acesso: boolean | null
  confirmou_cadastro: boolean | null
  codigo_confirma_cadastro: string | null
  codigo_reset_senha: string | null
  codigo_data_expiracao: Date | null
  created_at: Date
  updated_at: Date | null
}

/**
 * Model usuario_perfil_tipo
 * 
 */
export type usuario_perfil_tipo = {
  id: number
  nome: string
}

/**
 * Model carteira_n_cedentes
 * 
 */
export type carteira_n_cedentes = {
  id: number
  carteira_id: number
  cedente_id: number
}

/**
 * Model organograma_x_usuario
 * 
 */
export type organograma_x_usuario = {
  id: number
  organograma_id: number
  usuario_id: number
}

/**
 * Model plataforma_x_usuario
 * 
 */
export type plataforma_x_usuario = {
  id: number
  plataforma_id: number
  usuario_id: number
}

/**
 * Model titulo_itens
 * 
 */
export type titulo_itens = {
  id: number
  titulo_id: number
}

/**
 * Model usuario_perfil
 * 
 */
export type usuario_perfil = {
  id: number
  senha: string
  usuario_id: number
  usuario_perfil_tipo_id: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Auditorias
 * const auditorias = await prisma.auditoria.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Auditorias
   * const auditorias = await prisma.auditoria.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.auditoria`: Exposes CRUD operations for the **auditoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Auditorias
    * const auditorias = await prisma.auditoria.findMany()
    * ```
    */
  get auditoria(): Prisma.auditoriaDelegate<GlobalReject>;

  /**
   * `prisma.bordero`: Exposes CRUD operations for the **bordero** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Borderos
    * const borderos = await prisma.bordero.findMany()
    * ```
    */
  get bordero(): Prisma.borderoDelegate<GlobalReject>;

  /**
   * `prisma.carteira`: Exposes CRUD operations for the **carteira** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carteiras
    * const carteiras = await prisma.carteira.findMany()
    * ```
    */
  get carteira(): Prisma.carteiraDelegate<GlobalReject>;

  /**
   * `prisma.cedente`: Exposes CRUD operations for the **cedente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cedentes
    * const cedentes = await prisma.cedente.findMany()
    * ```
    */
  get cedente(): Prisma.cedenteDelegate<GlobalReject>;

  /**
   * `prisma.cedente_analise`: Exposes CRUD operations for the **cedente_analise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cedente_analises
    * const cedente_analises = await prisma.cedente_analise.findMany()
    * ```
    */
  get cedente_analise(): Prisma.cedente_analiseDelegate<GlobalReject>;

  /**
   * `prisma.cedente_n_sacados`: Exposes CRUD operations for the **cedente_n_sacados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cedente_n_sacados
    * const cedente_n_sacados = await prisma.cedente_n_sacados.findMany()
    * ```
    */
  get cedente_n_sacados(): Prisma.cedente_n_sacadosDelegate<GlobalReject>;

  /**
   * `prisma.checagem`: Exposes CRUD operations for the **checagem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Checagems
    * const checagems = await prisma.checagem.findMany()
    * ```
    */
  get checagem(): Prisma.checagemDelegate<GlobalReject>;

  /**
   * `prisma.fidic_fundo`: Exposes CRUD operations for the **fidic_fundo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fidic_fundos
    * const fidic_fundos = await prisma.fidic_fundo.findMany()
    * ```
    */
  get fidic_fundo(): Prisma.fidic_fundoDelegate<GlobalReject>;

  /**
   * `prisma.fidic_fundo_x_usuario`: Exposes CRUD operations for the **fidic_fundo_x_usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fidic_fundo_x_usuarios
    * const fidic_fundo_x_usuarios = await prisma.fidic_fundo_x_usuario.findMany()
    * ```
    */
  get fidic_fundo_x_usuario(): Prisma.fidic_fundo_x_usuarioDelegate<GlobalReject>;

  /**
   * `prisma.organograma`: Exposes CRUD operations for the **organograma** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organogramas
    * const organogramas = await prisma.organograma.findMany()
    * ```
    */
  get organograma(): Prisma.organogramaDelegate<GlobalReject>;

  /**
   * `prisma.organograma_tipo`: Exposes CRUD operations for the **organograma_tipo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organograma_tipos
    * const organograma_tipos = await prisma.organograma_tipo.findMany()
    * ```
    */
  get organograma_tipo(): Prisma.organograma_tipoDelegate<GlobalReject>;

  /**
   * `prisma.organograma_x_regiao_atuacao`: Exposes CRUD operations for the **organograma_x_regiao_atuacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organograma_x_regiao_atuacaos
    * const organograma_x_regiao_atuacaos = await prisma.organograma_x_regiao_atuacao.findMany()
    * ```
    */
  get organograma_x_regiao_atuacao(): Prisma.organograma_x_regiao_atuacaoDelegate<GlobalReject>;

  /**
   * `prisma.pessoa`: Exposes CRUD operations for the **pessoa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pessoas
    * const pessoas = await prisma.pessoa.findMany()
    * ```
    */
  get pessoa(): Prisma.pessoaDelegate<GlobalReject>;

  /**
   * `prisma.plataforma`: Exposes CRUD operations for the **plataforma** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plataformas
    * const plataformas = await prisma.plataforma.findMany()
    * ```
    */
  get plataforma(): Prisma.plataformaDelegate<GlobalReject>;

  /**
   * `prisma.plataforma_papel_tipo`: Exposes CRUD operations for the **plataforma_papel_tipo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plataforma_papel_tipos
    * const plataforma_papel_tipos = await prisma.plataforma_papel_tipo.findMany()
    * ```
    */
  get plataforma_papel_tipo(): Prisma.plataforma_papel_tipoDelegate<GlobalReject>;

  /**
   * `prisma.plataforma_x_regiao_atuacao`: Exposes CRUD operations for the **plataforma_x_regiao_atuacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plataforma_x_regiao_atuacaos
    * const plataforma_x_regiao_atuacaos = await prisma.plataforma_x_regiao_atuacao.findMany()
    * ```
    */
  get plataforma_x_regiao_atuacao(): Prisma.plataforma_x_regiao_atuacaoDelegate<GlobalReject>;

  /**
   * `prisma.regiao_atuacao`: Exposes CRUD operations for the **regiao_atuacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regiao_atuacaos
    * const regiao_atuacaos = await prisma.regiao_atuacao.findMany()
    * ```
    */
  get regiao_atuacao(): Prisma.regiao_atuacaoDelegate<GlobalReject>;

  /**
   * `prisma.regiao_atuacao_tipo`: Exposes CRUD operations for the **regiao_atuacao_tipo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regiao_atuacao_tipos
    * const regiao_atuacao_tipos = await prisma.regiao_atuacao_tipo.findMany()
    * ```
    */
  get regiao_atuacao_tipo(): Prisma.regiao_atuacao_tipoDelegate<GlobalReject>;

  /**
   * `prisma.sacado`: Exposes CRUD operations for the **sacado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sacados
    * const sacados = await prisma.sacado.findMany()
    * ```
    */
  get sacado(): Prisma.sacadoDelegate<GlobalReject>;

  /**
   * `prisma.titulo`: Exposes CRUD operations for the **titulo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Titulos
    * const titulos = await prisma.titulo.findMany()
    * ```
    */
  get titulo(): Prisma.tituloDelegate<GlobalReject>;

  /**
   * `prisma.titulo_tipo`: Exposes CRUD operations for the **titulo_tipo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Titulo_tipos
    * const titulo_tipos = await prisma.titulo_tipo.findMany()
    * ```
    */
  get titulo_tipo(): Prisma.titulo_tipoDelegate<GlobalReject>;

  /**
   * `prisma.usuario`: Exposes CRUD operations for the **usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.usuarioDelegate<GlobalReject>;

  /**
   * `prisma.usuario_perfil_tipo`: Exposes CRUD operations for the **usuario_perfil_tipo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuario_perfil_tipos
    * const usuario_perfil_tipos = await prisma.usuario_perfil_tipo.findMany()
    * ```
    */
  get usuario_perfil_tipo(): Prisma.usuario_perfil_tipoDelegate<GlobalReject>;

  /**
   * `prisma.carteira_n_cedentes`: Exposes CRUD operations for the **carteira_n_cedentes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carteira_n_cedentes
    * const carteira_n_cedentes = await prisma.carteira_n_cedentes.findMany()
    * ```
    */
  get carteira_n_cedentes(): Prisma.carteira_n_cedentesDelegate<GlobalReject>;

  /**
   * `prisma.organograma_x_usuario`: Exposes CRUD operations for the **organograma_x_usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organograma_x_usuarios
    * const organograma_x_usuarios = await prisma.organograma_x_usuario.findMany()
    * ```
    */
  get organograma_x_usuario(): Prisma.organograma_x_usuarioDelegate<GlobalReject>;

  /**
   * `prisma.plataforma_x_usuario`: Exposes CRUD operations for the **plataforma_x_usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plataforma_x_usuarios
    * const plataforma_x_usuarios = await prisma.plataforma_x_usuario.findMany()
    * ```
    */
  get plataforma_x_usuario(): Prisma.plataforma_x_usuarioDelegate<GlobalReject>;

  /**
   * `prisma.titulo_itens`: Exposes CRUD operations for the **titulo_itens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Titulo_itens
    * const titulo_itens = await prisma.titulo_itens.findMany()
    * ```
    */
  get titulo_itens(): Prisma.titulo_itensDelegate<GlobalReject>;

  /**
   * `prisma.usuario_perfil`: Exposes CRUD operations for the **usuario_perfil** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuario_perfils
    * const usuario_perfils = await prisma.usuario_perfil.findMany()
    * ```
    */
  get usuario_perfil(): Prisma.usuario_perfilDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.6.1
   * Query Engine version: 694eea289a8462c80264df36757e4fdc129b1b32
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    auditoria: 'auditoria',
    bordero: 'bordero',
    carteira: 'carteira',
    cedente: 'cedente',
    cedente_analise: 'cedente_analise',
    cedente_n_sacados: 'cedente_n_sacados',
    checagem: 'checagem',
    fidic_fundo: 'fidic_fundo',
    fidic_fundo_x_usuario: 'fidic_fundo_x_usuario',
    organograma: 'organograma',
    organograma_tipo: 'organograma_tipo',
    organograma_x_regiao_atuacao: 'organograma_x_regiao_atuacao',
    pessoa: 'pessoa',
    plataforma: 'plataforma',
    plataforma_papel_tipo: 'plataforma_papel_tipo',
    plataforma_x_regiao_atuacao: 'plataforma_x_regiao_atuacao',
    regiao_atuacao: 'regiao_atuacao',
    regiao_atuacao_tipo: 'regiao_atuacao_tipo',
    sacado: 'sacado',
    titulo: 'titulo',
    titulo_tipo: 'titulo_tipo',
    usuario: 'usuario',
    usuario_perfil_tipo: 'usuario_perfil_tipo',
    carteira_n_cedentes: 'carteira_n_cedentes',
    organograma_x_usuario: 'organograma_x_usuario',
    plataforma_x_usuario: 'plataforma_x_usuario',
    titulo_itens: 'titulo_itens',
    usuario_perfil: 'usuario_perfil'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BorderoCountOutputType
   */


  export type BorderoCountOutputType = {
    titulo: number
  }

  export type BorderoCountOutputTypeSelect = {
    titulo?: boolean
  }

  export type BorderoCountOutputTypeGetPayload<S extends boolean | null | undefined | BorderoCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? BorderoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (BorderoCountOutputTypeArgs)
    ? BorderoCountOutputType 
    : S extends { select: any } & (BorderoCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof BorderoCountOutputType ? BorderoCountOutputType[P] : never
  } 
      : BorderoCountOutputType




  // Custom InputTypes

  /**
   * BorderoCountOutputType without action
   */
  export type BorderoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the BorderoCountOutputType
     * 
    **/
    select?: BorderoCountOutputTypeSelect | null
  }



  /**
   * Count Type CarteiraCountOutputType
   */


  export type CarteiraCountOutputType = {
    bordero: number
    carteira_n_cedentes: number
  }

  export type CarteiraCountOutputTypeSelect = {
    bordero?: boolean
    carteira_n_cedentes?: boolean
  }

  export type CarteiraCountOutputTypeGetPayload<S extends boolean | null | undefined | CarteiraCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CarteiraCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CarteiraCountOutputTypeArgs)
    ? CarteiraCountOutputType 
    : S extends { select: any } & (CarteiraCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CarteiraCountOutputType ? CarteiraCountOutputType[P] : never
  } 
      : CarteiraCountOutputType




  // Custom InputTypes

  /**
   * CarteiraCountOutputType without action
   */
  export type CarteiraCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CarteiraCountOutputType
     * 
    **/
    select?: CarteiraCountOutputTypeSelect | null
  }



  /**
   * Count Type CedenteCountOutputType
   */


  export type CedenteCountOutputType = {
    carteira_n_cedentes: number
    cedente_analise: number
    cedente_n_sacados: number
  }

  export type CedenteCountOutputTypeSelect = {
    carteira_n_cedentes?: boolean
    cedente_analise?: boolean
    cedente_n_sacados?: boolean
  }

  export type CedenteCountOutputTypeGetPayload<S extends boolean | null | undefined | CedenteCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CedenteCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CedenteCountOutputTypeArgs)
    ? CedenteCountOutputType 
    : S extends { select: any } & (CedenteCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CedenteCountOutputType ? CedenteCountOutputType[P] : never
  } 
      : CedenteCountOutputType




  // Custom InputTypes

  /**
   * CedenteCountOutputType without action
   */
  export type CedenteCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CedenteCountOutputType
     * 
    **/
    select?: CedenteCountOutputTypeSelect | null
  }



  /**
   * Count Type Fidic_fundoCountOutputType
   */


  export type Fidic_fundoCountOutputType = {
    carteira: number
    fidic_fundo_x_usuario: number
  }

  export type Fidic_fundoCountOutputTypeSelect = {
    carteira?: boolean
    fidic_fundo_x_usuario?: boolean
  }

  export type Fidic_fundoCountOutputTypeGetPayload<S extends boolean | null | undefined | Fidic_fundoCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Fidic_fundoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Fidic_fundoCountOutputTypeArgs)
    ? Fidic_fundoCountOutputType 
    : S extends { select: any } & (Fidic_fundoCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Fidic_fundoCountOutputType ? Fidic_fundoCountOutputType[P] : never
  } 
      : Fidic_fundoCountOutputType




  // Custom InputTypes

  /**
   * Fidic_fundoCountOutputType without action
   */
  export type Fidic_fundoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Fidic_fundoCountOutputType
     * 
    **/
    select?: Fidic_fundoCountOutputTypeSelect | null
  }



  /**
   * Count Type OrganogramaCountOutputType
   */


  export type OrganogramaCountOutputType = {
    organograma_x_regiao_atuacao: number
    organograma_x_usuario: number
  }

  export type OrganogramaCountOutputTypeSelect = {
    organograma_x_regiao_atuacao?: boolean
    organograma_x_usuario?: boolean
  }

  export type OrganogramaCountOutputTypeGetPayload<S extends boolean | null | undefined | OrganogramaCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OrganogramaCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OrganogramaCountOutputTypeArgs)
    ? OrganogramaCountOutputType 
    : S extends { select: any } & (OrganogramaCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OrganogramaCountOutputType ? OrganogramaCountOutputType[P] : never
  } 
      : OrganogramaCountOutputType




  // Custom InputTypes

  /**
   * OrganogramaCountOutputType without action
   */
  export type OrganogramaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrganogramaCountOutputType
     * 
    **/
    select?: OrganogramaCountOutputTypeSelect | null
  }



  /**
   * Count Type Organograma_tipoCountOutputType
   */


  export type Organograma_tipoCountOutputType = {
    organograma: number
  }

  export type Organograma_tipoCountOutputTypeSelect = {
    organograma?: boolean
  }

  export type Organograma_tipoCountOutputTypeGetPayload<S extends boolean | null | undefined | Organograma_tipoCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Organograma_tipoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Organograma_tipoCountOutputTypeArgs)
    ? Organograma_tipoCountOutputType 
    : S extends { select: any } & (Organograma_tipoCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Organograma_tipoCountOutputType ? Organograma_tipoCountOutputType[P] : never
  } 
      : Organograma_tipoCountOutputType




  // Custom InputTypes

  /**
   * Organograma_tipoCountOutputType without action
   */
  export type Organograma_tipoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Organograma_tipoCountOutputType
     * 
    **/
    select?: Organograma_tipoCountOutputTypeSelect | null
  }



  /**
   * Count Type PessoaCountOutputType
   */


  export type PessoaCountOutputType = {
    usuario: number
  }

  export type PessoaCountOutputTypeSelect = {
    usuario?: boolean
  }

  export type PessoaCountOutputTypeGetPayload<S extends boolean | null | undefined | PessoaCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PessoaCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PessoaCountOutputTypeArgs)
    ? PessoaCountOutputType 
    : S extends { select: any } & (PessoaCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PessoaCountOutputType ? PessoaCountOutputType[P] : never
  } 
      : PessoaCountOutputType




  // Custom InputTypes

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PessoaCountOutputType
     * 
    **/
    select?: PessoaCountOutputTypeSelect | null
  }



  /**
   * Count Type PlataformaCountOutputType
   */


  export type PlataformaCountOutputType = {
    plataforma_x_regiao_atuacao: number
    plataforma_x_usuario: number
  }

  export type PlataformaCountOutputTypeSelect = {
    plataforma_x_regiao_atuacao?: boolean
    plataforma_x_usuario?: boolean
  }

  export type PlataformaCountOutputTypeGetPayload<S extends boolean | null | undefined | PlataformaCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PlataformaCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PlataformaCountOutputTypeArgs)
    ? PlataformaCountOutputType 
    : S extends { select: any } & (PlataformaCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PlataformaCountOutputType ? PlataformaCountOutputType[P] : never
  } 
      : PlataformaCountOutputType




  // Custom InputTypes

  /**
   * PlataformaCountOutputType without action
   */
  export type PlataformaCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PlataformaCountOutputType
     * 
    **/
    select?: PlataformaCountOutputTypeSelect | null
  }



  /**
   * Count Type Plataforma_papel_tipoCountOutputType
   */


  export type Plataforma_papel_tipoCountOutputType = {
    plataforma: number
  }

  export type Plataforma_papel_tipoCountOutputTypeSelect = {
    plataforma?: boolean
  }

  export type Plataforma_papel_tipoCountOutputTypeGetPayload<S extends boolean | null | undefined | Plataforma_papel_tipoCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Plataforma_papel_tipoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Plataforma_papel_tipoCountOutputTypeArgs)
    ? Plataforma_papel_tipoCountOutputType 
    : S extends { select: any } & (Plataforma_papel_tipoCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Plataforma_papel_tipoCountOutputType ? Plataforma_papel_tipoCountOutputType[P] : never
  } 
      : Plataforma_papel_tipoCountOutputType




  // Custom InputTypes

  /**
   * Plataforma_papel_tipoCountOutputType without action
   */
  export type Plataforma_papel_tipoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Plataforma_papel_tipoCountOutputType
     * 
    **/
    select?: Plataforma_papel_tipoCountOutputTypeSelect | null
  }



  /**
   * Count Type Regiao_atuacaoCountOutputType
   */


  export type Regiao_atuacaoCountOutputType = {
    organograma_x_regiao_atuacao: number
    plataforma_x_regiao_atuacao: number
  }

  export type Regiao_atuacaoCountOutputTypeSelect = {
    organograma_x_regiao_atuacao?: boolean
    plataforma_x_regiao_atuacao?: boolean
  }

  export type Regiao_atuacaoCountOutputTypeGetPayload<S extends boolean | null | undefined | Regiao_atuacaoCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Regiao_atuacaoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Regiao_atuacaoCountOutputTypeArgs)
    ? Regiao_atuacaoCountOutputType 
    : S extends { select: any } & (Regiao_atuacaoCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Regiao_atuacaoCountOutputType ? Regiao_atuacaoCountOutputType[P] : never
  } 
      : Regiao_atuacaoCountOutputType




  // Custom InputTypes

  /**
   * Regiao_atuacaoCountOutputType without action
   */
  export type Regiao_atuacaoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Regiao_atuacaoCountOutputType
     * 
    **/
    select?: Regiao_atuacaoCountOutputTypeSelect | null
  }



  /**
   * Count Type Regiao_atuacao_tipoCountOutputType
   */


  export type Regiao_atuacao_tipoCountOutputType = {
    regiao_atuacao: number
  }

  export type Regiao_atuacao_tipoCountOutputTypeSelect = {
    regiao_atuacao?: boolean
  }

  export type Regiao_atuacao_tipoCountOutputTypeGetPayload<S extends boolean | null | undefined | Regiao_atuacao_tipoCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Regiao_atuacao_tipoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Regiao_atuacao_tipoCountOutputTypeArgs)
    ? Regiao_atuacao_tipoCountOutputType 
    : S extends { select: any } & (Regiao_atuacao_tipoCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Regiao_atuacao_tipoCountOutputType ? Regiao_atuacao_tipoCountOutputType[P] : never
  } 
      : Regiao_atuacao_tipoCountOutputType




  // Custom InputTypes

  /**
   * Regiao_atuacao_tipoCountOutputType without action
   */
  export type Regiao_atuacao_tipoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Regiao_atuacao_tipoCountOutputType
     * 
    **/
    select?: Regiao_atuacao_tipoCountOutputTypeSelect | null
  }



  /**
   * Count Type SacadoCountOutputType
   */


  export type SacadoCountOutputType = {
    cedente_n_sacados: number
  }

  export type SacadoCountOutputTypeSelect = {
    cedente_n_sacados?: boolean
  }

  export type SacadoCountOutputTypeGetPayload<S extends boolean | null | undefined | SacadoCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SacadoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SacadoCountOutputTypeArgs)
    ? SacadoCountOutputType 
    : S extends { select: any } & (SacadoCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SacadoCountOutputType ? SacadoCountOutputType[P] : never
  } 
      : SacadoCountOutputType




  // Custom InputTypes

  /**
   * SacadoCountOutputType without action
   */
  export type SacadoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SacadoCountOutputType
     * 
    **/
    select?: SacadoCountOutputTypeSelect | null
  }



  /**
   * Count Type TituloCountOutputType
   */


  export type TituloCountOutputType = {
    titulo_itens: number
  }

  export type TituloCountOutputTypeSelect = {
    titulo_itens?: boolean
  }

  export type TituloCountOutputTypeGetPayload<S extends boolean | null | undefined | TituloCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TituloCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TituloCountOutputTypeArgs)
    ? TituloCountOutputType 
    : S extends { select: any } & (TituloCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof TituloCountOutputType ? TituloCountOutputType[P] : never
  } 
      : TituloCountOutputType




  // Custom InputTypes

  /**
   * TituloCountOutputType without action
   */
  export type TituloCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TituloCountOutputType
     * 
    **/
    select?: TituloCountOutputTypeSelect | null
  }



  /**
   * Count Type Titulo_tipoCountOutputType
   */


  export type Titulo_tipoCountOutputType = {
    titulo: number
  }

  export type Titulo_tipoCountOutputTypeSelect = {
    titulo?: boolean
  }

  export type Titulo_tipoCountOutputTypeGetPayload<S extends boolean | null | undefined | Titulo_tipoCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Titulo_tipoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Titulo_tipoCountOutputTypeArgs)
    ? Titulo_tipoCountOutputType 
    : S extends { select: any } & (Titulo_tipoCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Titulo_tipoCountOutputType ? Titulo_tipoCountOutputType[P] : never
  } 
      : Titulo_tipoCountOutputType




  // Custom InputTypes

  /**
   * Titulo_tipoCountOutputType without action
   */
  export type Titulo_tipoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Titulo_tipoCountOutputType
     * 
    **/
    select?: Titulo_tipoCountOutputTypeSelect | null
  }



  /**
   * Count Type Usuario_perfil_tipoCountOutputType
   */


  export type Usuario_perfil_tipoCountOutputType = {
    usuario_perfil: number
  }

  export type Usuario_perfil_tipoCountOutputTypeSelect = {
    usuario_perfil?: boolean
  }

  export type Usuario_perfil_tipoCountOutputTypeGetPayload<S extends boolean | null | undefined | Usuario_perfil_tipoCountOutputTypeArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Usuario_perfil_tipoCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Usuario_perfil_tipoCountOutputTypeArgs)
    ? Usuario_perfil_tipoCountOutputType 
    : S extends { select: any } & (Usuario_perfil_tipoCountOutputTypeArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Usuario_perfil_tipoCountOutputType ? Usuario_perfil_tipoCountOutputType[P] : never
  } 
      : Usuario_perfil_tipoCountOutputType




  // Custom InputTypes

  /**
   * Usuario_perfil_tipoCountOutputType without action
   */
  export type Usuario_perfil_tipoCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Usuario_perfil_tipoCountOutputType
     * 
    **/
    select?: Usuario_perfil_tipoCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model auditoria
   */


  export type AggregateAuditoria = {
    _count: AuditoriaCountAggregateOutputType | null
    _avg: AuditoriaAvgAggregateOutputType | null
    _sum: AuditoriaSumAggregateOutputType | null
    _min: AuditoriaMinAggregateOutputType | null
    _max: AuditoriaMaxAggregateOutputType | null
  }

  export type AuditoriaAvgAggregateOutputType = {
    usuario: number | null
    id: number | null
  }

  export type AuditoriaSumAggregateOutputType = {
    usuario: number | null
    id: number | null
  }

  export type AuditoriaMinAggregateOutputType = {
    action: string | null
    usuario: number | null
    data: Date | null
    modulo: string | null
    id: number | null
  }

  export type AuditoriaMaxAggregateOutputType = {
    action: string | null
    usuario: number | null
    data: Date | null
    modulo: string | null
    id: number | null
  }

  export type AuditoriaCountAggregateOutputType = {
    action: number
    usuario: number
    data: number
    modulo: number
    id: number
    _all: number
  }


  export type AuditoriaAvgAggregateInputType = {
    usuario?: true
    id?: true
  }

  export type AuditoriaSumAggregateInputType = {
    usuario?: true
    id?: true
  }

  export type AuditoriaMinAggregateInputType = {
    action?: true
    usuario?: true
    data?: true
    modulo?: true
    id?: true
  }

  export type AuditoriaMaxAggregateInputType = {
    action?: true
    usuario?: true
    data?: true
    modulo?: true
    id?: true
  }

  export type AuditoriaCountAggregateInputType = {
    action?: true
    usuario?: true
    data?: true
    modulo?: true
    id?: true
    _all?: true
  }

  export type AuditoriaAggregateArgs = {
    /**
     * Filter which auditoria to aggregate.
     * 
    **/
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     * 
    **/
    orderBy?: Enumerable<auditoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned auditorias
    **/
    _count?: true | AuditoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditoriaMaxAggregateInputType
  }

  export type GetAuditoriaAggregateType<T extends AuditoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditoria[P]>
      : GetScalarType<T[P], AggregateAuditoria[P]>
  }




  export type AuditoriaGroupByArgs = {
    where?: auditoriaWhereInput
    orderBy?: Enumerable<auditoriaOrderByWithAggregationInput>
    by: Array<AuditoriaScalarFieldEnum>
    having?: auditoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditoriaCountAggregateInputType | true
    _avg?: AuditoriaAvgAggregateInputType
    _sum?: AuditoriaSumAggregateInputType
    _min?: AuditoriaMinAggregateInputType
    _max?: AuditoriaMaxAggregateInputType
  }


  export type AuditoriaGroupByOutputType = {
    action: string | null
    usuario: number | null
    data: Date | null
    modulo: string | null
    id: number
    _count: AuditoriaCountAggregateOutputType | null
    _avg: AuditoriaAvgAggregateOutputType | null
    _sum: AuditoriaSumAggregateOutputType | null
    _min: AuditoriaMinAggregateOutputType | null
    _max: AuditoriaMaxAggregateOutputType | null
  }

  type GetAuditoriaGroupByPayload<T extends AuditoriaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AuditoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditoriaGroupByOutputType[P]>
            : GetScalarType<T[P], AuditoriaGroupByOutputType[P]>
        }
      >
    >


  export type auditoriaSelect = {
    action?: boolean
    usuario?: boolean
    data?: boolean
    modulo?: boolean
    id?: boolean
  }


  export type auditoriaGetPayload<S extends boolean | null | undefined | auditoriaArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? auditoria :
    S extends undefined ? never :
    S extends { include: any } & (auditoriaArgs | auditoriaFindManyArgs)
    ? auditoria 
    : S extends { select: any } & (auditoriaArgs | auditoriaFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof auditoria ? auditoria[P] : never
  } 
      : auditoria


  type auditoriaCountArgs = Merge<
    Omit<auditoriaFindManyArgs, 'select' | 'include'> & {
      select?: AuditoriaCountAggregateInputType | true
    }
  >

  export interface auditoriaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Auditoria that matches the filter.
     * @param {auditoriaFindUniqueArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends auditoriaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, auditoriaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'auditoria'> extends True ? Prisma__auditoriaClient<auditoriaGetPayload<T>> : Prisma__auditoriaClient<auditoriaGetPayload<T> | null, null>

    /**
     * Find the first Auditoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaFindFirstArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends auditoriaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, auditoriaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'auditoria'> extends True ? Prisma__auditoriaClient<auditoriaGetPayload<T>> : Prisma__auditoriaClient<auditoriaGetPayload<T> | null, null>

    /**
     * Find zero or more Auditorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Auditorias
     * const auditorias = await prisma.auditoria.findMany()
     * 
     * // Get first 10 Auditorias
     * const auditorias = await prisma.auditoria.findMany({ take: 10 })
     * 
     * // Only select the `action`
     * const auditoriaWithActionOnly = await prisma.auditoria.findMany({ select: { action: true } })
     * 
    **/
    findMany<T extends auditoriaFindManyArgs>(
      args?: SelectSubset<T, auditoriaFindManyArgs>
    ): PrismaPromise<Array<auditoriaGetPayload<T>>>

    /**
     * Create a Auditoria.
     * @param {auditoriaCreateArgs} args - Arguments to create a Auditoria.
     * @example
     * // Create one Auditoria
     * const Auditoria = await prisma.auditoria.create({
     *   data: {
     *     // ... data to create a Auditoria
     *   }
     * })
     * 
    **/
    create<T extends auditoriaCreateArgs>(
      args: SelectSubset<T, auditoriaCreateArgs>
    ): Prisma__auditoriaClient<auditoriaGetPayload<T>>

    /**
     * Create many Auditorias.
     *     @param {auditoriaCreateManyArgs} args - Arguments to create many Auditorias.
     *     @example
     *     // Create many Auditorias
     *     const auditoria = await prisma.auditoria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends auditoriaCreateManyArgs>(
      args?: SelectSubset<T, auditoriaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Auditoria.
     * @param {auditoriaDeleteArgs} args - Arguments to delete one Auditoria.
     * @example
     * // Delete one Auditoria
     * const Auditoria = await prisma.auditoria.delete({
     *   where: {
     *     // ... filter to delete one Auditoria
     *   }
     * })
     * 
    **/
    delete<T extends auditoriaDeleteArgs>(
      args: SelectSubset<T, auditoriaDeleteArgs>
    ): Prisma__auditoriaClient<auditoriaGetPayload<T>>

    /**
     * Update one Auditoria.
     * @param {auditoriaUpdateArgs} args - Arguments to update one Auditoria.
     * @example
     * // Update one Auditoria
     * const auditoria = await prisma.auditoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends auditoriaUpdateArgs>(
      args: SelectSubset<T, auditoriaUpdateArgs>
    ): Prisma__auditoriaClient<auditoriaGetPayload<T>>

    /**
     * Delete zero or more Auditorias.
     * @param {auditoriaDeleteManyArgs} args - Arguments to filter Auditorias to delete.
     * @example
     * // Delete a few Auditorias
     * const { count } = await prisma.auditoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends auditoriaDeleteManyArgs>(
      args?: SelectSubset<T, auditoriaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Auditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Auditorias
     * const auditoria = await prisma.auditoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends auditoriaUpdateManyArgs>(
      args: SelectSubset<T, auditoriaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Auditoria.
     * @param {auditoriaUpsertArgs} args - Arguments to update or create a Auditoria.
     * @example
     * // Update or create a Auditoria
     * const auditoria = await prisma.auditoria.upsert({
     *   create: {
     *     // ... data to create a Auditoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Auditoria we want to update
     *   }
     * })
    **/
    upsert<T extends auditoriaUpsertArgs>(
      args: SelectSubset<T, auditoriaUpsertArgs>
    ): Prisma__auditoriaClient<auditoriaGetPayload<T>>

    /**
     * Find one Auditoria that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {auditoriaFindUniqueOrThrowArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends auditoriaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, auditoriaFindUniqueOrThrowArgs>
    ): Prisma__auditoriaClient<auditoriaGetPayload<T>>

    /**
     * Find the first Auditoria that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaFindFirstOrThrowArgs} args - Arguments to find a Auditoria
     * @example
     * // Get one Auditoria
     * const auditoria = await prisma.auditoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends auditoriaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, auditoriaFindFirstOrThrowArgs>
    ): Prisma__auditoriaClient<auditoriaGetPayload<T>>

    /**
     * Count the number of Auditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {auditoriaCountArgs} args - Arguments to filter Auditorias to count.
     * @example
     * // Count the number of Auditorias
     * const count = await prisma.auditoria.count({
     *   where: {
     *     // ... the filter for the Auditorias we want to count
     *   }
     * })
    **/
    count<T extends auditoriaCountArgs>(
      args?: Subset<T, auditoriaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Auditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditoriaAggregateArgs>(args: Subset<T, AuditoriaAggregateArgs>): PrismaPromise<GetAuditoriaAggregateType<T>>

    /**
     * Group by Auditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditoriaGroupByArgs['orderBy'] }
        : { orderBy?: AuditoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditoriaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for auditoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__auditoriaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * auditoria base type for findUnique actions
   */
  export type auditoriaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the auditoria
     * 
    **/
    select?: auditoriaSelect | null
    /**
     * Filter, which auditoria to fetch.
     * 
    **/
    where: auditoriaWhereUniqueInput
  }

  /**
   * auditoria: findUnique
   */
  export interface auditoriaFindUniqueArgs extends auditoriaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auditoria base type for findFirst actions
   */
  export type auditoriaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the auditoria
     * 
    **/
    select?: auditoriaSelect | null
    /**
     * Filter, which auditoria to fetch.
     * 
    **/
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     * 
    **/
    orderBy?: Enumerable<auditoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for auditorias.
     * 
    **/
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of auditorias.
     * 
    **/
    distinct?: Enumerable<AuditoriaScalarFieldEnum>
  }

  /**
   * auditoria: findFirst
   */
  export interface auditoriaFindFirstArgs extends auditoriaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * auditoria findMany
   */
  export type auditoriaFindManyArgs = {
    /**
     * Select specific fields to fetch from the auditoria
     * 
    **/
    select?: auditoriaSelect | null
    /**
     * Filter, which auditorias to fetch.
     * 
    **/
    where?: auditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of auditorias to fetch.
     * 
    **/
    orderBy?: Enumerable<auditoriaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing auditorias.
     * 
    **/
    cursor?: auditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` auditorias from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` auditorias.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AuditoriaScalarFieldEnum>
  }


  /**
   * auditoria create
   */
  export type auditoriaCreateArgs = {
    /**
     * Select specific fields to fetch from the auditoria
     * 
    **/
    select?: auditoriaSelect | null
    /**
     * The data needed to create a auditoria.
     * 
    **/
    data: XOR<auditoriaCreateInput, auditoriaUncheckedCreateInput>
  }


  /**
   * auditoria createMany
   */
  export type auditoriaCreateManyArgs = {
    /**
     * The data used to create many auditorias.
     * 
    **/
    data: Enumerable<auditoriaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * auditoria update
   */
  export type auditoriaUpdateArgs = {
    /**
     * Select specific fields to fetch from the auditoria
     * 
    **/
    select?: auditoriaSelect | null
    /**
     * The data needed to update a auditoria.
     * 
    **/
    data: XOR<auditoriaUpdateInput, auditoriaUncheckedUpdateInput>
    /**
     * Choose, which auditoria to update.
     * 
    **/
    where: auditoriaWhereUniqueInput
  }


  /**
   * auditoria updateMany
   */
  export type auditoriaUpdateManyArgs = {
    /**
     * The data used to update auditorias.
     * 
    **/
    data: XOR<auditoriaUpdateManyMutationInput, auditoriaUncheckedUpdateManyInput>
    /**
     * Filter which auditorias to update
     * 
    **/
    where?: auditoriaWhereInput
  }


  /**
   * auditoria upsert
   */
  export type auditoriaUpsertArgs = {
    /**
     * Select specific fields to fetch from the auditoria
     * 
    **/
    select?: auditoriaSelect | null
    /**
     * The filter to search for the auditoria to update in case it exists.
     * 
    **/
    where: auditoriaWhereUniqueInput
    /**
     * In case the auditoria found by the `where` argument doesn't exist, create a new auditoria with this data.
     * 
    **/
    create: XOR<auditoriaCreateInput, auditoriaUncheckedCreateInput>
    /**
     * In case the auditoria was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<auditoriaUpdateInput, auditoriaUncheckedUpdateInput>
  }


  /**
   * auditoria delete
   */
  export type auditoriaDeleteArgs = {
    /**
     * Select specific fields to fetch from the auditoria
     * 
    **/
    select?: auditoriaSelect | null
    /**
     * Filter which auditoria to delete.
     * 
    **/
    where: auditoriaWhereUniqueInput
  }


  /**
   * auditoria deleteMany
   */
  export type auditoriaDeleteManyArgs = {
    /**
     * Filter which auditorias to delete
     * 
    **/
    where?: auditoriaWhereInput
  }


  /**
   * auditoria: findUniqueOrThrow
   */
  export type auditoriaFindUniqueOrThrowArgs = auditoriaFindUniqueArgsBase
      

  /**
   * auditoria: findFirstOrThrow
   */
  export type auditoriaFindFirstOrThrowArgs = auditoriaFindFirstArgsBase
      

  /**
   * auditoria without action
   */
  export type auditoriaArgs = {
    /**
     * Select specific fields to fetch from the auditoria
     * 
    **/
    select?: auditoriaSelect | null
  }



  /**
   * Model bordero
   */


  export type AggregateBordero = {
    _count: BorderoCountAggregateOutputType | null
    _avg: BorderoAvgAggregateOutputType | null
    _sum: BorderoSumAggregateOutputType | null
    _min: BorderoMinAggregateOutputType | null
    _max: BorderoMaxAggregateOutputType | null
  }

  export type BorderoAvgAggregateOutputType = {
    id: number | null
    carteira_id: number | null
  }

  export type BorderoSumAggregateOutputType = {
    id: number | null
    carteira_id: number | null
  }

  export type BorderoMinAggregateOutputType = {
    id: number | null
    carteira_id: number | null
  }

  export type BorderoMaxAggregateOutputType = {
    id: number | null
    carteira_id: number | null
  }

  export type BorderoCountAggregateOutputType = {
    id: number
    carteira_id: number
    _all: number
  }


  export type BorderoAvgAggregateInputType = {
    id?: true
    carteira_id?: true
  }

  export type BorderoSumAggregateInputType = {
    id?: true
    carteira_id?: true
  }

  export type BorderoMinAggregateInputType = {
    id?: true
    carteira_id?: true
  }

  export type BorderoMaxAggregateInputType = {
    id?: true
    carteira_id?: true
  }

  export type BorderoCountAggregateInputType = {
    id?: true
    carteira_id?: true
    _all?: true
  }

  export type BorderoAggregateArgs = {
    /**
     * Filter which bordero to aggregate.
     * 
    **/
    where?: borderoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of borderos to fetch.
     * 
    **/
    orderBy?: Enumerable<borderoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: borderoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` borderos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` borderos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned borderos
    **/
    _count?: true | BorderoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BorderoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BorderoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BorderoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BorderoMaxAggregateInputType
  }

  export type GetBorderoAggregateType<T extends BorderoAggregateArgs> = {
        [P in keyof T & keyof AggregateBordero]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBordero[P]>
      : GetScalarType<T[P], AggregateBordero[P]>
  }




  export type BorderoGroupByArgs = {
    where?: borderoWhereInput
    orderBy?: Enumerable<borderoOrderByWithAggregationInput>
    by: Array<BorderoScalarFieldEnum>
    having?: borderoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BorderoCountAggregateInputType | true
    _avg?: BorderoAvgAggregateInputType
    _sum?: BorderoSumAggregateInputType
    _min?: BorderoMinAggregateInputType
    _max?: BorderoMaxAggregateInputType
  }


  export type BorderoGroupByOutputType = {
    id: number
    carteira_id: number
    _count: BorderoCountAggregateOutputType | null
    _avg: BorderoAvgAggregateOutputType | null
    _sum: BorderoSumAggregateOutputType | null
    _min: BorderoMinAggregateOutputType | null
    _max: BorderoMaxAggregateOutputType | null
  }

  type GetBorderoGroupByPayload<T extends BorderoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BorderoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BorderoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BorderoGroupByOutputType[P]>
            : GetScalarType<T[P], BorderoGroupByOutputType[P]>
        }
      >
    >


  export type borderoSelect = {
    id?: boolean
    carteira_id?: boolean
    carteira?: boolean | carteiraArgs
    titulo?: boolean | tituloFindManyArgs
    _count?: boolean | BorderoCountOutputTypeArgs
  }


  export type borderoInclude = {
    carteira?: boolean | carteiraArgs
    titulo?: boolean | tituloFindManyArgs
    _count?: boolean | BorderoCountOutputTypeArgs
  } 

  export type borderoGetPayload<S extends boolean | null | undefined | borderoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? bordero :
    S extends undefined ? never :
    S extends { include: any } & (borderoArgs | borderoFindManyArgs)
    ? bordero  & {
    [P in TrueKeys<S['include']>]:
        P extends 'carteira' ? carteiraGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'titulo' ? Array < tituloGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? BorderoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (borderoArgs | borderoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'carteira' ? carteiraGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'titulo' ? Array < tituloGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? BorderoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof bordero ? bordero[P] : never
  } 
      : bordero


  type borderoCountArgs = Merge<
    Omit<borderoFindManyArgs, 'select' | 'include'> & {
      select?: BorderoCountAggregateInputType | true
    }
  >

  export interface borderoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Bordero that matches the filter.
     * @param {borderoFindUniqueArgs} args - Arguments to find a Bordero
     * @example
     * // Get one Bordero
     * const bordero = await prisma.bordero.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends borderoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, borderoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'bordero'> extends True ? Prisma__borderoClient<borderoGetPayload<T>> : Prisma__borderoClient<borderoGetPayload<T> | null, null>

    /**
     * Find the first Bordero that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {borderoFindFirstArgs} args - Arguments to find a Bordero
     * @example
     * // Get one Bordero
     * const bordero = await prisma.bordero.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends borderoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, borderoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'bordero'> extends True ? Prisma__borderoClient<borderoGetPayload<T>> : Prisma__borderoClient<borderoGetPayload<T> | null, null>

    /**
     * Find zero or more Borderos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {borderoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Borderos
     * const borderos = await prisma.bordero.findMany()
     * 
     * // Get first 10 Borderos
     * const borderos = await prisma.bordero.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const borderoWithIdOnly = await prisma.bordero.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends borderoFindManyArgs>(
      args?: SelectSubset<T, borderoFindManyArgs>
    ): PrismaPromise<Array<borderoGetPayload<T>>>

    /**
     * Create a Bordero.
     * @param {borderoCreateArgs} args - Arguments to create a Bordero.
     * @example
     * // Create one Bordero
     * const Bordero = await prisma.bordero.create({
     *   data: {
     *     // ... data to create a Bordero
     *   }
     * })
     * 
    **/
    create<T extends borderoCreateArgs>(
      args: SelectSubset<T, borderoCreateArgs>
    ): Prisma__borderoClient<borderoGetPayload<T>>

    /**
     * Create many Borderos.
     *     @param {borderoCreateManyArgs} args - Arguments to create many Borderos.
     *     @example
     *     // Create many Borderos
     *     const bordero = await prisma.bordero.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends borderoCreateManyArgs>(
      args?: SelectSubset<T, borderoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Bordero.
     * @param {borderoDeleteArgs} args - Arguments to delete one Bordero.
     * @example
     * // Delete one Bordero
     * const Bordero = await prisma.bordero.delete({
     *   where: {
     *     // ... filter to delete one Bordero
     *   }
     * })
     * 
    **/
    delete<T extends borderoDeleteArgs>(
      args: SelectSubset<T, borderoDeleteArgs>
    ): Prisma__borderoClient<borderoGetPayload<T>>

    /**
     * Update one Bordero.
     * @param {borderoUpdateArgs} args - Arguments to update one Bordero.
     * @example
     * // Update one Bordero
     * const bordero = await prisma.bordero.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends borderoUpdateArgs>(
      args: SelectSubset<T, borderoUpdateArgs>
    ): Prisma__borderoClient<borderoGetPayload<T>>

    /**
     * Delete zero or more Borderos.
     * @param {borderoDeleteManyArgs} args - Arguments to filter Borderos to delete.
     * @example
     * // Delete a few Borderos
     * const { count } = await prisma.bordero.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends borderoDeleteManyArgs>(
      args?: SelectSubset<T, borderoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Borderos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {borderoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Borderos
     * const bordero = await prisma.bordero.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends borderoUpdateManyArgs>(
      args: SelectSubset<T, borderoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Bordero.
     * @param {borderoUpsertArgs} args - Arguments to update or create a Bordero.
     * @example
     * // Update or create a Bordero
     * const bordero = await prisma.bordero.upsert({
     *   create: {
     *     // ... data to create a Bordero
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bordero we want to update
     *   }
     * })
    **/
    upsert<T extends borderoUpsertArgs>(
      args: SelectSubset<T, borderoUpsertArgs>
    ): Prisma__borderoClient<borderoGetPayload<T>>

    /**
     * Find one Bordero that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {borderoFindUniqueOrThrowArgs} args - Arguments to find a Bordero
     * @example
     * // Get one Bordero
     * const bordero = await prisma.bordero.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends borderoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, borderoFindUniqueOrThrowArgs>
    ): Prisma__borderoClient<borderoGetPayload<T>>

    /**
     * Find the first Bordero that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {borderoFindFirstOrThrowArgs} args - Arguments to find a Bordero
     * @example
     * // Get one Bordero
     * const bordero = await prisma.bordero.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends borderoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, borderoFindFirstOrThrowArgs>
    ): Prisma__borderoClient<borderoGetPayload<T>>

    /**
     * Count the number of Borderos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {borderoCountArgs} args - Arguments to filter Borderos to count.
     * @example
     * // Count the number of Borderos
     * const count = await prisma.bordero.count({
     *   where: {
     *     // ... the filter for the Borderos we want to count
     *   }
     * })
    **/
    count<T extends borderoCountArgs>(
      args?: Subset<T, borderoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BorderoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bordero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorderoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BorderoAggregateArgs>(args: Subset<T, BorderoAggregateArgs>): PrismaPromise<GetBorderoAggregateType<T>>

    /**
     * Group by Bordero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BorderoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BorderoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BorderoGroupByArgs['orderBy'] }
        : { orderBy?: BorderoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BorderoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBorderoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for bordero.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__borderoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    carteira<T extends carteiraArgs= {}>(args?: Subset<T, carteiraArgs>): Prisma__carteiraClient<carteiraGetPayload<T> | Null>;

    titulo<T extends tituloFindManyArgs= {}>(args?: Subset<T, tituloFindManyArgs>): PrismaPromise<Array<tituloGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * bordero base type for findUnique actions
   */
  export type borderoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the bordero
     * 
    **/
    select?: borderoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: borderoInclude | null
    /**
     * Filter, which bordero to fetch.
     * 
    **/
    where: borderoWhereUniqueInput
  }

  /**
   * bordero: findUnique
   */
  export interface borderoFindUniqueArgs extends borderoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * bordero base type for findFirst actions
   */
  export type borderoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the bordero
     * 
    **/
    select?: borderoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: borderoInclude | null
    /**
     * Filter, which bordero to fetch.
     * 
    **/
    where?: borderoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of borderos to fetch.
     * 
    **/
    orderBy?: Enumerable<borderoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for borderos.
     * 
    **/
    cursor?: borderoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` borderos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` borderos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of borderos.
     * 
    **/
    distinct?: Enumerable<BorderoScalarFieldEnum>
  }

  /**
   * bordero: findFirst
   */
  export interface borderoFindFirstArgs extends borderoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * bordero findMany
   */
  export type borderoFindManyArgs = {
    /**
     * Select specific fields to fetch from the bordero
     * 
    **/
    select?: borderoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: borderoInclude | null
    /**
     * Filter, which borderos to fetch.
     * 
    **/
    where?: borderoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of borderos to fetch.
     * 
    **/
    orderBy?: Enumerable<borderoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing borderos.
     * 
    **/
    cursor?: borderoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` borderos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` borderos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BorderoScalarFieldEnum>
  }


  /**
   * bordero create
   */
  export type borderoCreateArgs = {
    /**
     * Select specific fields to fetch from the bordero
     * 
    **/
    select?: borderoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: borderoInclude | null
    /**
     * The data needed to create a bordero.
     * 
    **/
    data: XOR<borderoCreateInput, borderoUncheckedCreateInput>
  }


  /**
   * bordero createMany
   */
  export type borderoCreateManyArgs = {
    /**
     * The data used to create many borderos.
     * 
    **/
    data: Enumerable<borderoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * bordero update
   */
  export type borderoUpdateArgs = {
    /**
     * Select specific fields to fetch from the bordero
     * 
    **/
    select?: borderoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: borderoInclude | null
    /**
     * The data needed to update a bordero.
     * 
    **/
    data: XOR<borderoUpdateInput, borderoUncheckedUpdateInput>
    /**
     * Choose, which bordero to update.
     * 
    **/
    where: borderoWhereUniqueInput
  }


  /**
   * bordero updateMany
   */
  export type borderoUpdateManyArgs = {
    /**
     * The data used to update borderos.
     * 
    **/
    data: XOR<borderoUpdateManyMutationInput, borderoUncheckedUpdateManyInput>
    /**
     * Filter which borderos to update
     * 
    **/
    where?: borderoWhereInput
  }


  /**
   * bordero upsert
   */
  export type borderoUpsertArgs = {
    /**
     * Select specific fields to fetch from the bordero
     * 
    **/
    select?: borderoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: borderoInclude | null
    /**
     * The filter to search for the bordero to update in case it exists.
     * 
    **/
    where: borderoWhereUniqueInput
    /**
     * In case the bordero found by the `where` argument doesn't exist, create a new bordero with this data.
     * 
    **/
    create: XOR<borderoCreateInput, borderoUncheckedCreateInput>
    /**
     * In case the bordero was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<borderoUpdateInput, borderoUncheckedUpdateInput>
  }


  /**
   * bordero delete
   */
  export type borderoDeleteArgs = {
    /**
     * Select specific fields to fetch from the bordero
     * 
    **/
    select?: borderoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: borderoInclude | null
    /**
     * Filter which bordero to delete.
     * 
    **/
    where: borderoWhereUniqueInput
  }


  /**
   * bordero deleteMany
   */
  export type borderoDeleteManyArgs = {
    /**
     * Filter which borderos to delete
     * 
    **/
    where?: borderoWhereInput
  }


  /**
   * bordero: findUniqueOrThrow
   */
  export type borderoFindUniqueOrThrowArgs = borderoFindUniqueArgsBase
      

  /**
   * bordero: findFirstOrThrow
   */
  export type borderoFindFirstOrThrowArgs = borderoFindFirstArgsBase
      

  /**
   * bordero without action
   */
  export type borderoArgs = {
    /**
     * Select specific fields to fetch from the bordero
     * 
    **/
    select?: borderoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: borderoInclude | null
  }



  /**
   * Model carteira
   */


  export type AggregateCarteira = {
    _count: CarteiraCountAggregateOutputType | null
    _avg: CarteiraAvgAggregateOutputType | null
    _sum: CarteiraSumAggregateOutputType | null
    _min: CarteiraMinAggregateOutputType | null
    _max: CarteiraMaxAggregateOutputType | null
  }

  export type CarteiraAvgAggregateOutputType = {
    id: number | null
    fiduc_fundo_id: number | null
  }

  export type CarteiraSumAggregateOutputType = {
    id: number | null
    fiduc_fundo_id: number | null
  }

  export type CarteiraMinAggregateOutputType = {
    id: number | null
    fiduc_fundo_id: number | null
  }

  export type CarteiraMaxAggregateOutputType = {
    id: number | null
    fiduc_fundo_id: number | null
  }

  export type CarteiraCountAggregateOutputType = {
    id: number
    fiduc_fundo_id: number
    _all: number
  }


  export type CarteiraAvgAggregateInputType = {
    id?: true
    fiduc_fundo_id?: true
  }

  export type CarteiraSumAggregateInputType = {
    id?: true
    fiduc_fundo_id?: true
  }

  export type CarteiraMinAggregateInputType = {
    id?: true
    fiduc_fundo_id?: true
  }

  export type CarteiraMaxAggregateInputType = {
    id?: true
    fiduc_fundo_id?: true
  }

  export type CarteiraCountAggregateInputType = {
    id?: true
    fiduc_fundo_id?: true
    _all?: true
  }

  export type CarteiraAggregateArgs = {
    /**
     * Filter which carteira to aggregate.
     * 
    **/
    where?: carteiraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteiras to fetch.
     * 
    **/
    orderBy?: Enumerable<carteiraOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: carteiraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteiras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteiras.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned carteiras
    **/
    _count?: true | CarteiraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarteiraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarteiraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarteiraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarteiraMaxAggregateInputType
  }

  export type GetCarteiraAggregateType<T extends CarteiraAggregateArgs> = {
        [P in keyof T & keyof AggregateCarteira]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarteira[P]>
      : GetScalarType<T[P], AggregateCarteira[P]>
  }




  export type CarteiraGroupByArgs = {
    where?: carteiraWhereInput
    orderBy?: Enumerable<carteiraOrderByWithAggregationInput>
    by: Array<CarteiraScalarFieldEnum>
    having?: carteiraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarteiraCountAggregateInputType | true
    _avg?: CarteiraAvgAggregateInputType
    _sum?: CarteiraSumAggregateInputType
    _min?: CarteiraMinAggregateInputType
    _max?: CarteiraMaxAggregateInputType
  }


  export type CarteiraGroupByOutputType = {
    id: number
    fiduc_fundo_id: number
    _count: CarteiraCountAggregateOutputType | null
    _avg: CarteiraAvgAggregateOutputType | null
    _sum: CarteiraSumAggregateOutputType | null
    _min: CarteiraMinAggregateOutputType | null
    _max: CarteiraMaxAggregateOutputType | null
  }

  type GetCarteiraGroupByPayload<T extends CarteiraGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CarteiraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarteiraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarteiraGroupByOutputType[P]>
            : GetScalarType<T[P], CarteiraGroupByOutputType[P]>
        }
      >
    >


  export type carteiraSelect = {
    id?: boolean
    fiduc_fundo_id?: boolean
    fidic_fundo?: boolean | fidic_fundoArgs
    bordero?: boolean | borderoFindManyArgs
    carteira_n_cedentes?: boolean | carteira_n_cedentesFindManyArgs
    _count?: boolean | CarteiraCountOutputTypeArgs
  }


  export type carteiraInclude = {
    fidic_fundo?: boolean | fidic_fundoArgs
    bordero?: boolean | borderoFindManyArgs
    carteira_n_cedentes?: boolean | carteira_n_cedentesFindManyArgs
    _count?: boolean | CarteiraCountOutputTypeArgs
  } 

  export type carteiraGetPayload<S extends boolean | null | undefined | carteiraArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? carteira :
    S extends undefined ? never :
    S extends { include: any } & (carteiraArgs | carteiraFindManyArgs)
    ? carteira  & {
    [P in TrueKeys<S['include']>]:
        P extends 'fidic_fundo' ? fidic_fundoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'bordero' ? Array < borderoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'carteira_n_cedentes' ? Array < carteira_n_cedentesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CarteiraCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (carteiraArgs | carteiraFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'fidic_fundo' ? fidic_fundoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'bordero' ? Array < borderoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'carteira_n_cedentes' ? Array < carteira_n_cedentesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CarteiraCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof carteira ? carteira[P] : never
  } 
      : carteira


  type carteiraCountArgs = Merge<
    Omit<carteiraFindManyArgs, 'select' | 'include'> & {
      select?: CarteiraCountAggregateInputType | true
    }
  >

  export interface carteiraDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Carteira that matches the filter.
     * @param {carteiraFindUniqueArgs} args - Arguments to find a Carteira
     * @example
     * // Get one Carteira
     * const carteira = await prisma.carteira.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends carteiraFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, carteiraFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'carteira'> extends True ? Prisma__carteiraClient<carteiraGetPayload<T>> : Prisma__carteiraClient<carteiraGetPayload<T> | null, null>

    /**
     * Find the first Carteira that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteiraFindFirstArgs} args - Arguments to find a Carteira
     * @example
     * // Get one Carteira
     * const carteira = await prisma.carteira.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends carteiraFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, carteiraFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'carteira'> extends True ? Prisma__carteiraClient<carteiraGetPayload<T>> : Prisma__carteiraClient<carteiraGetPayload<T> | null, null>

    /**
     * Find zero or more Carteiras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteiraFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carteiras
     * const carteiras = await prisma.carteira.findMany()
     * 
     * // Get first 10 Carteiras
     * const carteiras = await prisma.carteira.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carteiraWithIdOnly = await prisma.carteira.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends carteiraFindManyArgs>(
      args?: SelectSubset<T, carteiraFindManyArgs>
    ): PrismaPromise<Array<carteiraGetPayload<T>>>

    /**
     * Create a Carteira.
     * @param {carteiraCreateArgs} args - Arguments to create a Carteira.
     * @example
     * // Create one Carteira
     * const Carteira = await prisma.carteira.create({
     *   data: {
     *     // ... data to create a Carteira
     *   }
     * })
     * 
    **/
    create<T extends carteiraCreateArgs>(
      args: SelectSubset<T, carteiraCreateArgs>
    ): Prisma__carteiraClient<carteiraGetPayload<T>>

    /**
     * Create many Carteiras.
     *     @param {carteiraCreateManyArgs} args - Arguments to create many Carteiras.
     *     @example
     *     // Create many Carteiras
     *     const carteira = await prisma.carteira.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends carteiraCreateManyArgs>(
      args?: SelectSubset<T, carteiraCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Carteira.
     * @param {carteiraDeleteArgs} args - Arguments to delete one Carteira.
     * @example
     * // Delete one Carteira
     * const Carteira = await prisma.carteira.delete({
     *   where: {
     *     // ... filter to delete one Carteira
     *   }
     * })
     * 
    **/
    delete<T extends carteiraDeleteArgs>(
      args: SelectSubset<T, carteiraDeleteArgs>
    ): Prisma__carteiraClient<carteiraGetPayload<T>>

    /**
     * Update one Carteira.
     * @param {carteiraUpdateArgs} args - Arguments to update one Carteira.
     * @example
     * // Update one Carteira
     * const carteira = await prisma.carteira.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends carteiraUpdateArgs>(
      args: SelectSubset<T, carteiraUpdateArgs>
    ): Prisma__carteiraClient<carteiraGetPayload<T>>

    /**
     * Delete zero or more Carteiras.
     * @param {carteiraDeleteManyArgs} args - Arguments to filter Carteiras to delete.
     * @example
     * // Delete a few Carteiras
     * const { count } = await prisma.carteira.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends carteiraDeleteManyArgs>(
      args?: SelectSubset<T, carteiraDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carteiras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteiraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carteiras
     * const carteira = await prisma.carteira.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends carteiraUpdateManyArgs>(
      args: SelectSubset<T, carteiraUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Carteira.
     * @param {carteiraUpsertArgs} args - Arguments to update or create a Carteira.
     * @example
     * // Update or create a Carteira
     * const carteira = await prisma.carteira.upsert({
     *   create: {
     *     // ... data to create a Carteira
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carteira we want to update
     *   }
     * })
    **/
    upsert<T extends carteiraUpsertArgs>(
      args: SelectSubset<T, carteiraUpsertArgs>
    ): Prisma__carteiraClient<carteiraGetPayload<T>>

    /**
     * Find one Carteira that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {carteiraFindUniqueOrThrowArgs} args - Arguments to find a Carteira
     * @example
     * // Get one Carteira
     * const carteira = await prisma.carteira.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends carteiraFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, carteiraFindUniqueOrThrowArgs>
    ): Prisma__carteiraClient<carteiraGetPayload<T>>

    /**
     * Find the first Carteira that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteiraFindFirstOrThrowArgs} args - Arguments to find a Carteira
     * @example
     * // Get one Carteira
     * const carteira = await prisma.carteira.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends carteiraFindFirstOrThrowArgs>(
      args?: SelectSubset<T, carteiraFindFirstOrThrowArgs>
    ): Prisma__carteiraClient<carteiraGetPayload<T>>

    /**
     * Count the number of Carteiras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteiraCountArgs} args - Arguments to filter Carteiras to count.
     * @example
     * // Count the number of Carteiras
     * const count = await prisma.carteira.count({
     *   where: {
     *     // ... the filter for the Carteiras we want to count
     *   }
     * })
    **/
    count<T extends carteiraCountArgs>(
      args?: Subset<T, carteiraCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarteiraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Carteira.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteiraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarteiraAggregateArgs>(args: Subset<T, CarteiraAggregateArgs>): PrismaPromise<GetCarteiraAggregateType<T>>

    /**
     * Group by Carteira.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarteiraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarteiraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarteiraGroupByArgs['orderBy'] }
        : { orderBy?: CarteiraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarteiraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarteiraGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for carteira.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__carteiraClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    fidic_fundo<T extends fidic_fundoArgs= {}>(args?: Subset<T, fidic_fundoArgs>): Prisma__fidic_fundoClient<fidic_fundoGetPayload<T> | Null>;

    bordero<T extends borderoFindManyArgs= {}>(args?: Subset<T, borderoFindManyArgs>): PrismaPromise<Array<borderoGetPayload<T>>| Null>;

    carteira_n_cedentes<T extends carteira_n_cedentesFindManyArgs= {}>(args?: Subset<T, carteira_n_cedentesFindManyArgs>): PrismaPromise<Array<carteira_n_cedentesGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * carteira base type for findUnique actions
   */
  export type carteiraFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the carteira
     * 
    **/
    select?: carteiraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteiraInclude | null
    /**
     * Filter, which carteira to fetch.
     * 
    **/
    where: carteiraWhereUniqueInput
  }

  /**
   * carteira: findUnique
   */
  export interface carteiraFindUniqueArgs extends carteiraFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * carteira base type for findFirst actions
   */
  export type carteiraFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the carteira
     * 
    **/
    select?: carteiraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteiraInclude | null
    /**
     * Filter, which carteira to fetch.
     * 
    **/
    where?: carteiraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteiras to fetch.
     * 
    **/
    orderBy?: Enumerable<carteiraOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for carteiras.
     * 
    **/
    cursor?: carteiraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteiras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteiras.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of carteiras.
     * 
    **/
    distinct?: Enumerable<CarteiraScalarFieldEnum>
  }

  /**
   * carteira: findFirst
   */
  export interface carteiraFindFirstArgs extends carteiraFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * carteira findMany
   */
  export type carteiraFindManyArgs = {
    /**
     * Select specific fields to fetch from the carteira
     * 
    **/
    select?: carteiraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteiraInclude | null
    /**
     * Filter, which carteiras to fetch.
     * 
    **/
    where?: carteiraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteiras to fetch.
     * 
    **/
    orderBy?: Enumerable<carteiraOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing carteiras.
     * 
    **/
    cursor?: carteiraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteiras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteiras.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CarteiraScalarFieldEnum>
  }


  /**
   * carteira create
   */
  export type carteiraCreateArgs = {
    /**
     * Select specific fields to fetch from the carteira
     * 
    **/
    select?: carteiraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteiraInclude | null
    /**
     * The data needed to create a carteira.
     * 
    **/
    data: XOR<carteiraCreateInput, carteiraUncheckedCreateInput>
  }


  /**
   * carteira createMany
   */
  export type carteiraCreateManyArgs = {
    /**
     * The data used to create many carteiras.
     * 
    **/
    data: Enumerable<carteiraCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * carteira update
   */
  export type carteiraUpdateArgs = {
    /**
     * Select specific fields to fetch from the carteira
     * 
    **/
    select?: carteiraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteiraInclude | null
    /**
     * The data needed to update a carteira.
     * 
    **/
    data: XOR<carteiraUpdateInput, carteiraUncheckedUpdateInput>
    /**
     * Choose, which carteira to update.
     * 
    **/
    where: carteiraWhereUniqueInput
  }


  /**
   * carteira updateMany
   */
  export type carteiraUpdateManyArgs = {
    /**
     * The data used to update carteiras.
     * 
    **/
    data: XOR<carteiraUpdateManyMutationInput, carteiraUncheckedUpdateManyInput>
    /**
     * Filter which carteiras to update
     * 
    **/
    where?: carteiraWhereInput
  }


  /**
   * carteira upsert
   */
  export type carteiraUpsertArgs = {
    /**
     * Select specific fields to fetch from the carteira
     * 
    **/
    select?: carteiraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteiraInclude | null
    /**
     * The filter to search for the carteira to update in case it exists.
     * 
    **/
    where: carteiraWhereUniqueInput
    /**
     * In case the carteira found by the `where` argument doesn't exist, create a new carteira with this data.
     * 
    **/
    create: XOR<carteiraCreateInput, carteiraUncheckedCreateInput>
    /**
     * In case the carteira was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<carteiraUpdateInput, carteiraUncheckedUpdateInput>
  }


  /**
   * carteira delete
   */
  export type carteiraDeleteArgs = {
    /**
     * Select specific fields to fetch from the carteira
     * 
    **/
    select?: carteiraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteiraInclude | null
    /**
     * Filter which carteira to delete.
     * 
    **/
    where: carteiraWhereUniqueInput
  }


  /**
   * carteira deleteMany
   */
  export type carteiraDeleteManyArgs = {
    /**
     * Filter which carteiras to delete
     * 
    **/
    where?: carteiraWhereInput
  }


  /**
   * carteira: findUniqueOrThrow
   */
  export type carteiraFindUniqueOrThrowArgs = carteiraFindUniqueArgsBase
      

  /**
   * carteira: findFirstOrThrow
   */
  export type carteiraFindFirstOrThrowArgs = carteiraFindFirstArgsBase
      

  /**
   * carteira without action
   */
  export type carteiraArgs = {
    /**
     * Select specific fields to fetch from the carteira
     * 
    **/
    select?: carteiraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteiraInclude | null
  }



  /**
   * Model cedente
   */


  export type AggregateCedente = {
    _count: CedenteCountAggregateOutputType | null
    _avg: CedenteAvgAggregateOutputType | null
    _sum: CedenteSumAggregateOutputType | null
    _min: CedenteMinAggregateOutputType | null
    _max: CedenteMaxAggregateOutputType | null
  }

  export type CedenteAvgAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
  }

  export type CedenteSumAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
  }

  export type CedenteMinAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
    razao_social: string | null
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
    endereco: string | null
    numero: string | null
    cep: string | null
    bairro: string | null
    cidade: string | null
    uf: string | null
    telefone: string | null
  }

  export type CedenteMaxAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
    razao_social: string | null
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
    endereco: string | null
    numero: string | null
    cep: string | null
    bairro: string | null
    cidade: string | null
    uf: string | null
    telefone: string | null
  }

  export type CedenteCountAggregateOutputType = {
    id: number
    pessoa_id: number
    razao_social: number
    nome_fantasia: number
    abertura: number
    cnpj: number
    endereco: number
    numero: number
    cep: number
    bairro: number
    cidade: number
    uf: number
    telefone: number
    _all: number
  }


  export type CedenteAvgAggregateInputType = {
    id?: true
    pessoa_id?: true
  }

  export type CedenteSumAggregateInputType = {
    id?: true
    pessoa_id?: true
  }

  export type CedenteMinAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
    endereco?: true
    numero?: true
    cep?: true
    bairro?: true
    cidade?: true
    uf?: true
    telefone?: true
  }

  export type CedenteMaxAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
    endereco?: true
    numero?: true
    cep?: true
    bairro?: true
    cidade?: true
    uf?: true
    telefone?: true
  }

  export type CedenteCountAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
    endereco?: true
    numero?: true
    cep?: true
    bairro?: true
    cidade?: true
    uf?: true
    telefone?: true
    _all?: true
  }

  export type CedenteAggregateArgs = {
    /**
     * Filter which cedente to aggregate.
     * 
    **/
    where?: cedenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedentes to fetch.
     * 
    **/
    orderBy?: Enumerable<cedenteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: cedenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedentes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedentes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cedentes
    **/
    _count?: true | CedenteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CedenteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CedenteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CedenteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CedenteMaxAggregateInputType
  }

  export type GetCedenteAggregateType<T extends CedenteAggregateArgs> = {
        [P in keyof T & keyof AggregateCedente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCedente[P]>
      : GetScalarType<T[P], AggregateCedente[P]>
  }




  export type CedenteGroupByArgs = {
    where?: cedenteWhereInput
    orderBy?: Enumerable<cedenteOrderByWithAggregationInput>
    by: Array<CedenteScalarFieldEnum>
    having?: cedenteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CedenteCountAggregateInputType | true
    _avg?: CedenteAvgAggregateInputType
    _sum?: CedenteSumAggregateInputType
    _min?: CedenteMinAggregateInputType
    _max?: CedenteMaxAggregateInputType
  }


  export type CedenteGroupByOutputType = {
    id: number
    pessoa_id: number
    razao_social: string
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
    endereco: string | null
    numero: string | null
    cep: string | null
    bairro: string | null
    cidade: string | null
    uf: string | null
    telefone: string | null
    _count: CedenteCountAggregateOutputType | null
    _avg: CedenteAvgAggregateOutputType | null
    _sum: CedenteSumAggregateOutputType | null
    _min: CedenteMinAggregateOutputType | null
    _max: CedenteMaxAggregateOutputType | null
  }

  type GetCedenteGroupByPayload<T extends CedenteGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CedenteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CedenteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CedenteGroupByOutputType[P]>
            : GetScalarType<T[P], CedenteGroupByOutputType[P]>
        }
      >
    >


  export type cedenteSelect = {
    id?: boolean
    pessoa_id?: boolean
    razao_social?: boolean
    nome_fantasia?: boolean
    abertura?: boolean
    cnpj?: boolean
    endereco?: boolean
    numero?: boolean
    cep?: boolean
    bairro?: boolean
    cidade?: boolean
    uf?: boolean
    telefone?: boolean
    carteira_n_cedentes?: boolean | carteira_n_cedentesFindManyArgs
    cedente_analise?: boolean | cedente_analiseFindManyArgs
    cedente_n_sacados?: boolean | cedente_n_sacadosFindManyArgs
    _count?: boolean | CedenteCountOutputTypeArgs
  }


  export type cedenteInclude = {
    carteira_n_cedentes?: boolean | carteira_n_cedentesFindManyArgs
    cedente_analise?: boolean | cedente_analiseFindManyArgs
    cedente_n_sacados?: boolean | cedente_n_sacadosFindManyArgs
    _count?: boolean | CedenteCountOutputTypeArgs
  } 

  export type cedenteGetPayload<S extends boolean | null | undefined | cedenteArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? cedente :
    S extends undefined ? never :
    S extends { include: any } & (cedenteArgs | cedenteFindManyArgs)
    ? cedente  & {
    [P in TrueKeys<S['include']>]:
        P extends 'carteira_n_cedentes' ? Array < carteira_n_cedentesGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'cedente_analise' ? Array < cedente_analiseGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'cedente_n_sacados' ? Array < cedente_n_sacadosGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? CedenteCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (cedenteArgs | cedenteFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'carteira_n_cedentes' ? Array < carteira_n_cedentesGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'cedente_analise' ? Array < cedente_analiseGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'cedente_n_sacados' ? Array < cedente_n_sacadosGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? CedenteCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof cedente ? cedente[P] : never
  } 
      : cedente


  type cedenteCountArgs = Merge<
    Omit<cedenteFindManyArgs, 'select' | 'include'> & {
      select?: CedenteCountAggregateInputType | true
    }
  >

  export interface cedenteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Cedente that matches the filter.
     * @param {cedenteFindUniqueArgs} args - Arguments to find a Cedente
     * @example
     * // Get one Cedente
     * const cedente = await prisma.cedente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cedenteFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, cedenteFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'cedente'> extends True ? Prisma__cedenteClient<cedenteGetPayload<T>> : Prisma__cedenteClient<cedenteGetPayload<T> | null, null>

    /**
     * Find the first Cedente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedenteFindFirstArgs} args - Arguments to find a Cedente
     * @example
     * // Get one Cedente
     * const cedente = await prisma.cedente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cedenteFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, cedenteFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'cedente'> extends True ? Prisma__cedenteClient<cedenteGetPayload<T>> : Prisma__cedenteClient<cedenteGetPayload<T> | null, null>

    /**
     * Find zero or more Cedentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedenteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cedentes
     * const cedentes = await prisma.cedente.findMany()
     * 
     * // Get first 10 Cedentes
     * const cedentes = await prisma.cedente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cedenteWithIdOnly = await prisma.cedente.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends cedenteFindManyArgs>(
      args?: SelectSubset<T, cedenteFindManyArgs>
    ): PrismaPromise<Array<cedenteGetPayload<T>>>

    /**
     * Create a Cedente.
     * @param {cedenteCreateArgs} args - Arguments to create a Cedente.
     * @example
     * // Create one Cedente
     * const Cedente = await prisma.cedente.create({
     *   data: {
     *     // ... data to create a Cedente
     *   }
     * })
     * 
    **/
    create<T extends cedenteCreateArgs>(
      args: SelectSubset<T, cedenteCreateArgs>
    ): Prisma__cedenteClient<cedenteGetPayload<T>>

    /**
     * Create many Cedentes.
     *     @param {cedenteCreateManyArgs} args - Arguments to create many Cedentes.
     *     @example
     *     // Create many Cedentes
     *     const cedente = await prisma.cedente.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cedenteCreateManyArgs>(
      args?: SelectSubset<T, cedenteCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Cedente.
     * @param {cedenteDeleteArgs} args - Arguments to delete one Cedente.
     * @example
     * // Delete one Cedente
     * const Cedente = await prisma.cedente.delete({
     *   where: {
     *     // ... filter to delete one Cedente
     *   }
     * })
     * 
    **/
    delete<T extends cedenteDeleteArgs>(
      args: SelectSubset<T, cedenteDeleteArgs>
    ): Prisma__cedenteClient<cedenteGetPayload<T>>

    /**
     * Update one Cedente.
     * @param {cedenteUpdateArgs} args - Arguments to update one Cedente.
     * @example
     * // Update one Cedente
     * const cedente = await prisma.cedente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cedenteUpdateArgs>(
      args: SelectSubset<T, cedenteUpdateArgs>
    ): Prisma__cedenteClient<cedenteGetPayload<T>>

    /**
     * Delete zero or more Cedentes.
     * @param {cedenteDeleteManyArgs} args - Arguments to filter Cedentes to delete.
     * @example
     * // Delete a few Cedentes
     * const { count } = await prisma.cedente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cedenteDeleteManyArgs>(
      args?: SelectSubset<T, cedenteDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cedentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedenteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cedentes
     * const cedente = await prisma.cedente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cedenteUpdateManyArgs>(
      args: SelectSubset<T, cedenteUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Cedente.
     * @param {cedenteUpsertArgs} args - Arguments to update or create a Cedente.
     * @example
     * // Update or create a Cedente
     * const cedente = await prisma.cedente.upsert({
     *   create: {
     *     // ... data to create a Cedente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cedente we want to update
     *   }
     * })
    **/
    upsert<T extends cedenteUpsertArgs>(
      args: SelectSubset<T, cedenteUpsertArgs>
    ): Prisma__cedenteClient<cedenteGetPayload<T>>

    /**
     * Find one Cedente that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {cedenteFindUniqueOrThrowArgs} args - Arguments to find a Cedente
     * @example
     * // Get one Cedente
     * const cedente = await prisma.cedente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cedenteFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, cedenteFindUniqueOrThrowArgs>
    ): Prisma__cedenteClient<cedenteGetPayload<T>>

    /**
     * Find the first Cedente that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedenteFindFirstOrThrowArgs} args - Arguments to find a Cedente
     * @example
     * // Get one Cedente
     * const cedente = await prisma.cedente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cedenteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, cedenteFindFirstOrThrowArgs>
    ): Prisma__cedenteClient<cedenteGetPayload<T>>

    /**
     * Count the number of Cedentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedenteCountArgs} args - Arguments to filter Cedentes to count.
     * @example
     * // Count the number of Cedentes
     * const count = await prisma.cedente.count({
     *   where: {
     *     // ... the filter for the Cedentes we want to count
     *   }
     * })
    **/
    count<T extends cedenteCountArgs>(
      args?: Subset<T, cedenteCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CedenteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cedente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CedenteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CedenteAggregateArgs>(args: Subset<T, CedenteAggregateArgs>): PrismaPromise<GetCedenteAggregateType<T>>

    /**
     * Group by Cedente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CedenteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CedenteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CedenteGroupByArgs['orderBy'] }
        : { orderBy?: CedenteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CedenteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCedenteGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for cedente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cedenteClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    carteira_n_cedentes<T extends carteira_n_cedentesFindManyArgs= {}>(args?: Subset<T, carteira_n_cedentesFindManyArgs>): PrismaPromise<Array<carteira_n_cedentesGetPayload<T>>| Null>;

    cedente_analise<T extends cedente_analiseFindManyArgs= {}>(args?: Subset<T, cedente_analiseFindManyArgs>): PrismaPromise<Array<cedente_analiseGetPayload<T>>| Null>;

    cedente_n_sacados<T extends cedente_n_sacadosFindManyArgs= {}>(args?: Subset<T, cedente_n_sacadosFindManyArgs>): PrismaPromise<Array<cedente_n_sacadosGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * cedente base type for findUnique actions
   */
  export type cedenteFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the cedente
     * 
    **/
    select?: cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedenteInclude | null
    /**
     * Filter, which cedente to fetch.
     * 
    **/
    where: cedenteWhereUniqueInput
  }

  /**
   * cedente: findUnique
   */
  export interface cedenteFindUniqueArgs extends cedenteFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cedente base type for findFirst actions
   */
  export type cedenteFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the cedente
     * 
    **/
    select?: cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedenteInclude | null
    /**
     * Filter, which cedente to fetch.
     * 
    **/
    where?: cedenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedentes to fetch.
     * 
    **/
    orderBy?: Enumerable<cedenteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cedentes.
     * 
    **/
    cursor?: cedenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedentes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedentes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cedentes.
     * 
    **/
    distinct?: Enumerable<CedenteScalarFieldEnum>
  }

  /**
   * cedente: findFirst
   */
  export interface cedenteFindFirstArgs extends cedenteFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cedente findMany
   */
  export type cedenteFindManyArgs = {
    /**
     * Select specific fields to fetch from the cedente
     * 
    **/
    select?: cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedenteInclude | null
    /**
     * Filter, which cedentes to fetch.
     * 
    **/
    where?: cedenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedentes to fetch.
     * 
    **/
    orderBy?: Enumerable<cedenteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cedentes.
     * 
    **/
    cursor?: cedenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedentes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedentes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CedenteScalarFieldEnum>
  }


  /**
   * cedente create
   */
  export type cedenteCreateArgs = {
    /**
     * Select specific fields to fetch from the cedente
     * 
    **/
    select?: cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedenteInclude | null
    /**
     * The data needed to create a cedente.
     * 
    **/
    data: XOR<cedenteCreateInput, cedenteUncheckedCreateInput>
  }


  /**
   * cedente createMany
   */
  export type cedenteCreateManyArgs = {
    /**
     * The data used to create many cedentes.
     * 
    **/
    data: Enumerable<cedenteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * cedente update
   */
  export type cedenteUpdateArgs = {
    /**
     * Select specific fields to fetch from the cedente
     * 
    **/
    select?: cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedenteInclude | null
    /**
     * The data needed to update a cedente.
     * 
    **/
    data: XOR<cedenteUpdateInput, cedenteUncheckedUpdateInput>
    /**
     * Choose, which cedente to update.
     * 
    **/
    where: cedenteWhereUniqueInput
  }


  /**
   * cedente updateMany
   */
  export type cedenteUpdateManyArgs = {
    /**
     * The data used to update cedentes.
     * 
    **/
    data: XOR<cedenteUpdateManyMutationInput, cedenteUncheckedUpdateManyInput>
    /**
     * Filter which cedentes to update
     * 
    **/
    where?: cedenteWhereInput
  }


  /**
   * cedente upsert
   */
  export type cedenteUpsertArgs = {
    /**
     * Select specific fields to fetch from the cedente
     * 
    **/
    select?: cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedenteInclude | null
    /**
     * The filter to search for the cedente to update in case it exists.
     * 
    **/
    where: cedenteWhereUniqueInput
    /**
     * In case the cedente found by the `where` argument doesn't exist, create a new cedente with this data.
     * 
    **/
    create: XOR<cedenteCreateInput, cedenteUncheckedCreateInput>
    /**
     * In case the cedente was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<cedenteUpdateInput, cedenteUncheckedUpdateInput>
  }


  /**
   * cedente delete
   */
  export type cedenteDeleteArgs = {
    /**
     * Select specific fields to fetch from the cedente
     * 
    **/
    select?: cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedenteInclude | null
    /**
     * Filter which cedente to delete.
     * 
    **/
    where: cedenteWhereUniqueInput
  }


  /**
   * cedente deleteMany
   */
  export type cedenteDeleteManyArgs = {
    /**
     * Filter which cedentes to delete
     * 
    **/
    where?: cedenteWhereInput
  }


  /**
   * cedente: findUniqueOrThrow
   */
  export type cedenteFindUniqueOrThrowArgs = cedenteFindUniqueArgsBase
      

  /**
   * cedente: findFirstOrThrow
   */
  export type cedenteFindFirstOrThrowArgs = cedenteFindFirstArgsBase
      

  /**
   * cedente without action
   */
  export type cedenteArgs = {
    /**
     * Select specific fields to fetch from the cedente
     * 
    **/
    select?: cedenteSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedenteInclude | null
  }



  /**
   * Model cedente_analise
   */


  export type AggregateCedente_analise = {
    _count: Cedente_analiseCountAggregateOutputType | null
    _avg: Cedente_analiseAvgAggregateOutputType | null
    _sum: Cedente_analiseSumAggregateOutputType | null
    _min: Cedente_analiseMinAggregateOutputType | null
    _max: Cedente_analiseMaxAggregateOutputType | null
  }

  export type Cedente_analiseAvgAggregateOutputType = {
    id: number | null
    cedente: number | null
  }

  export type Cedente_analiseSumAggregateOutputType = {
    id: number | null
    cedente: number | null
  }

  export type Cedente_analiseMinAggregateOutputType = {
    id: number | null
    status: string | null
    cedente: number | null
  }

  export type Cedente_analiseMaxAggregateOutputType = {
    id: number | null
    status: string | null
    cedente: number | null
  }

  export type Cedente_analiseCountAggregateOutputType = {
    id: number
    status: number
    cedente: number
    _all: number
  }


  export type Cedente_analiseAvgAggregateInputType = {
    id?: true
    cedente?: true
  }

  export type Cedente_analiseSumAggregateInputType = {
    id?: true
    cedente?: true
  }

  export type Cedente_analiseMinAggregateInputType = {
    id?: true
    status?: true
    cedente?: true
  }

  export type Cedente_analiseMaxAggregateInputType = {
    id?: true
    status?: true
    cedente?: true
  }

  export type Cedente_analiseCountAggregateInputType = {
    id?: true
    status?: true
    cedente?: true
    _all?: true
  }

  export type Cedente_analiseAggregateArgs = {
    /**
     * Filter which cedente_analise to aggregate.
     * 
    **/
    where?: cedente_analiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedente_analises to fetch.
     * 
    **/
    orderBy?: Enumerable<cedente_analiseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: cedente_analiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedente_analises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedente_analises.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cedente_analises
    **/
    _count?: true | Cedente_analiseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cedente_analiseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cedente_analiseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cedente_analiseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cedente_analiseMaxAggregateInputType
  }

  export type GetCedente_analiseAggregateType<T extends Cedente_analiseAggregateArgs> = {
        [P in keyof T & keyof AggregateCedente_analise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCedente_analise[P]>
      : GetScalarType<T[P], AggregateCedente_analise[P]>
  }




  export type Cedente_analiseGroupByArgs = {
    where?: cedente_analiseWhereInput
    orderBy?: Enumerable<cedente_analiseOrderByWithAggregationInput>
    by: Array<Cedente_analiseScalarFieldEnum>
    having?: cedente_analiseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cedente_analiseCountAggregateInputType | true
    _avg?: Cedente_analiseAvgAggregateInputType
    _sum?: Cedente_analiseSumAggregateInputType
    _min?: Cedente_analiseMinAggregateInputType
    _max?: Cedente_analiseMaxAggregateInputType
  }


  export type Cedente_analiseGroupByOutputType = {
    id: number
    status: string | null
    cedente: number | null
    _count: Cedente_analiseCountAggregateOutputType | null
    _avg: Cedente_analiseAvgAggregateOutputType | null
    _sum: Cedente_analiseSumAggregateOutputType | null
    _min: Cedente_analiseMinAggregateOutputType | null
    _max: Cedente_analiseMaxAggregateOutputType | null
  }

  type GetCedente_analiseGroupByPayload<T extends Cedente_analiseGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Cedente_analiseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cedente_analiseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cedente_analiseGroupByOutputType[P]>
            : GetScalarType<T[P], Cedente_analiseGroupByOutputType[P]>
        }
      >
    >


  export type cedente_analiseSelect = {
    id?: boolean
    status?: boolean
    cedente?: boolean
    cedente_cedenteTocedente_analise?: boolean | cedenteArgs
  }


  export type cedente_analiseInclude = {
    cedente_cedenteTocedente_analise?: boolean | cedenteArgs
  } 

  export type cedente_analiseGetPayload<S extends boolean | null | undefined | cedente_analiseArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? cedente_analise :
    S extends undefined ? never :
    S extends { include: any } & (cedente_analiseArgs | cedente_analiseFindManyArgs)
    ? cedente_analise  & {
    [P in TrueKeys<S['include']>]:
        P extends 'cedente_cedenteTocedente_analise' ? cedenteGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : S extends { select: any } & (cedente_analiseArgs | cedente_analiseFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'cedente_cedenteTocedente_analise' ? cedenteGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof cedente_analise ? cedente_analise[P] : never
  } 
      : cedente_analise


  type cedente_analiseCountArgs = Merge<
    Omit<cedente_analiseFindManyArgs, 'select' | 'include'> & {
      select?: Cedente_analiseCountAggregateInputType | true
    }
  >

  export interface cedente_analiseDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Cedente_analise that matches the filter.
     * @param {cedente_analiseFindUniqueArgs} args - Arguments to find a Cedente_analise
     * @example
     * // Get one Cedente_analise
     * const cedente_analise = await prisma.cedente_analise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cedente_analiseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, cedente_analiseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'cedente_analise'> extends True ? Prisma__cedente_analiseClient<cedente_analiseGetPayload<T>> : Prisma__cedente_analiseClient<cedente_analiseGetPayload<T> | null, null>

    /**
     * Find the first Cedente_analise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_analiseFindFirstArgs} args - Arguments to find a Cedente_analise
     * @example
     * // Get one Cedente_analise
     * const cedente_analise = await prisma.cedente_analise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cedente_analiseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, cedente_analiseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'cedente_analise'> extends True ? Prisma__cedente_analiseClient<cedente_analiseGetPayload<T>> : Prisma__cedente_analiseClient<cedente_analiseGetPayload<T> | null, null>

    /**
     * Find zero or more Cedente_analises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_analiseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cedente_analises
     * const cedente_analises = await prisma.cedente_analise.findMany()
     * 
     * // Get first 10 Cedente_analises
     * const cedente_analises = await prisma.cedente_analise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cedente_analiseWithIdOnly = await prisma.cedente_analise.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends cedente_analiseFindManyArgs>(
      args?: SelectSubset<T, cedente_analiseFindManyArgs>
    ): PrismaPromise<Array<cedente_analiseGetPayload<T>>>

    /**
     * Create a Cedente_analise.
     * @param {cedente_analiseCreateArgs} args - Arguments to create a Cedente_analise.
     * @example
     * // Create one Cedente_analise
     * const Cedente_analise = await prisma.cedente_analise.create({
     *   data: {
     *     // ... data to create a Cedente_analise
     *   }
     * })
     * 
    **/
    create<T extends cedente_analiseCreateArgs>(
      args: SelectSubset<T, cedente_analiseCreateArgs>
    ): Prisma__cedente_analiseClient<cedente_analiseGetPayload<T>>

    /**
     * Create many Cedente_analises.
     *     @param {cedente_analiseCreateManyArgs} args - Arguments to create many Cedente_analises.
     *     @example
     *     // Create many Cedente_analises
     *     const cedente_analise = await prisma.cedente_analise.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cedente_analiseCreateManyArgs>(
      args?: SelectSubset<T, cedente_analiseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Cedente_analise.
     * @param {cedente_analiseDeleteArgs} args - Arguments to delete one Cedente_analise.
     * @example
     * // Delete one Cedente_analise
     * const Cedente_analise = await prisma.cedente_analise.delete({
     *   where: {
     *     // ... filter to delete one Cedente_analise
     *   }
     * })
     * 
    **/
    delete<T extends cedente_analiseDeleteArgs>(
      args: SelectSubset<T, cedente_analiseDeleteArgs>
    ): Prisma__cedente_analiseClient<cedente_analiseGetPayload<T>>

    /**
     * Update one Cedente_analise.
     * @param {cedente_analiseUpdateArgs} args - Arguments to update one Cedente_analise.
     * @example
     * // Update one Cedente_analise
     * const cedente_analise = await prisma.cedente_analise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cedente_analiseUpdateArgs>(
      args: SelectSubset<T, cedente_analiseUpdateArgs>
    ): Prisma__cedente_analiseClient<cedente_analiseGetPayload<T>>

    /**
     * Delete zero or more Cedente_analises.
     * @param {cedente_analiseDeleteManyArgs} args - Arguments to filter Cedente_analises to delete.
     * @example
     * // Delete a few Cedente_analises
     * const { count } = await prisma.cedente_analise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cedente_analiseDeleteManyArgs>(
      args?: SelectSubset<T, cedente_analiseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cedente_analises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_analiseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cedente_analises
     * const cedente_analise = await prisma.cedente_analise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cedente_analiseUpdateManyArgs>(
      args: SelectSubset<T, cedente_analiseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Cedente_analise.
     * @param {cedente_analiseUpsertArgs} args - Arguments to update or create a Cedente_analise.
     * @example
     * // Update or create a Cedente_analise
     * const cedente_analise = await prisma.cedente_analise.upsert({
     *   create: {
     *     // ... data to create a Cedente_analise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cedente_analise we want to update
     *   }
     * })
    **/
    upsert<T extends cedente_analiseUpsertArgs>(
      args: SelectSubset<T, cedente_analiseUpsertArgs>
    ): Prisma__cedente_analiseClient<cedente_analiseGetPayload<T>>

    /**
     * Find one Cedente_analise that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {cedente_analiseFindUniqueOrThrowArgs} args - Arguments to find a Cedente_analise
     * @example
     * // Get one Cedente_analise
     * const cedente_analise = await prisma.cedente_analise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cedente_analiseFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, cedente_analiseFindUniqueOrThrowArgs>
    ): Prisma__cedente_analiseClient<cedente_analiseGetPayload<T>>

    /**
     * Find the first Cedente_analise that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_analiseFindFirstOrThrowArgs} args - Arguments to find a Cedente_analise
     * @example
     * // Get one Cedente_analise
     * const cedente_analise = await prisma.cedente_analise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cedente_analiseFindFirstOrThrowArgs>(
      args?: SelectSubset<T, cedente_analiseFindFirstOrThrowArgs>
    ): Prisma__cedente_analiseClient<cedente_analiseGetPayload<T>>

    /**
     * Count the number of Cedente_analises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_analiseCountArgs} args - Arguments to filter Cedente_analises to count.
     * @example
     * // Count the number of Cedente_analises
     * const count = await prisma.cedente_analise.count({
     *   where: {
     *     // ... the filter for the Cedente_analises we want to count
     *   }
     * })
    **/
    count<T extends cedente_analiseCountArgs>(
      args?: Subset<T, cedente_analiseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cedente_analiseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cedente_analise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cedente_analiseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cedente_analiseAggregateArgs>(args: Subset<T, Cedente_analiseAggregateArgs>): PrismaPromise<GetCedente_analiseAggregateType<T>>

    /**
     * Group by Cedente_analise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cedente_analiseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Cedente_analiseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Cedente_analiseGroupByArgs['orderBy'] }
        : { orderBy?: Cedente_analiseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Cedente_analiseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCedente_analiseGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for cedente_analise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cedente_analiseClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cedente_cedenteTocedente_analise<T extends cedenteArgs= {}>(args?: Subset<T, cedenteArgs>): Prisma__cedenteClient<cedenteGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * cedente_analise base type for findUnique actions
   */
  export type cedente_analiseFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the cedente_analise
     * 
    **/
    select?: cedente_analiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_analiseInclude | null
    /**
     * Filter, which cedente_analise to fetch.
     * 
    **/
    where: cedente_analiseWhereUniqueInput
  }

  /**
   * cedente_analise: findUnique
   */
  export interface cedente_analiseFindUniqueArgs extends cedente_analiseFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cedente_analise base type for findFirst actions
   */
  export type cedente_analiseFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the cedente_analise
     * 
    **/
    select?: cedente_analiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_analiseInclude | null
    /**
     * Filter, which cedente_analise to fetch.
     * 
    **/
    where?: cedente_analiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedente_analises to fetch.
     * 
    **/
    orderBy?: Enumerable<cedente_analiseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cedente_analises.
     * 
    **/
    cursor?: cedente_analiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedente_analises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedente_analises.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cedente_analises.
     * 
    **/
    distinct?: Enumerable<Cedente_analiseScalarFieldEnum>
  }

  /**
   * cedente_analise: findFirst
   */
  export interface cedente_analiseFindFirstArgs extends cedente_analiseFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cedente_analise findMany
   */
  export type cedente_analiseFindManyArgs = {
    /**
     * Select specific fields to fetch from the cedente_analise
     * 
    **/
    select?: cedente_analiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_analiseInclude | null
    /**
     * Filter, which cedente_analises to fetch.
     * 
    **/
    where?: cedente_analiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedente_analises to fetch.
     * 
    **/
    orderBy?: Enumerable<cedente_analiseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cedente_analises.
     * 
    **/
    cursor?: cedente_analiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedente_analises from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedente_analises.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Cedente_analiseScalarFieldEnum>
  }


  /**
   * cedente_analise create
   */
  export type cedente_analiseCreateArgs = {
    /**
     * Select specific fields to fetch from the cedente_analise
     * 
    **/
    select?: cedente_analiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_analiseInclude | null
    /**
     * The data needed to create a cedente_analise.
     * 
    **/
    data: XOR<cedente_analiseCreateInput, cedente_analiseUncheckedCreateInput>
  }


  /**
   * cedente_analise createMany
   */
  export type cedente_analiseCreateManyArgs = {
    /**
     * The data used to create many cedente_analises.
     * 
    **/
    data: Enumerable<cedente_analiseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * cedente_analise update
   */
  export type cedente_analiseUpdateArgs = {
    /**
     * Select specific fields to fetch from the cedente_analise
     * 
    **/
    select?: cedente_analiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_analiseInclude | null
    /**
     * The data needed to update a cedente_analise.
     * 
    **/
    data: XOR<cedente_analiseUpdateInput, cedente_analiseUncheckedUpdateInput>
    /**
     * Choose, which cedente_analise to update.
     * 
    **/
    where: cedente_analiseWhereUniqueInput
  }


  /**
   * cedente_analise updateMany
   */
  export type cedente_analiseUpdateManyArgs = {
    /**
     * The data used to update cedente_analises.
     * 
    **/
    data: XOR<cedente_analiseUpdateManyMutationInput, cedente_analiseUncheckedUpdateManyInput>
    /**
     * Filter which cedente_analises to update
     * 
    **/
    where?: cedente_analiseWhereInput
  }


  /**
   * cedente_analise upsert
   */
  export type cedente_analiseUpsertArgs = {
    /**
     * Select specific fields to fetch from the cedente_analise
     * 
    **/
    select?: cedente_analiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_analiseInclude | null
    /**
     * The filter to search for the cedente_analise to update in case it exists.
     * 
    **/
    where: cedente_analiseWhereUniqueInput
    /**
     * In case the cedente_analise found by the `where` argument doesn't exist, create a new cedente_analise with this data.
     * 
    **/
    create: XOR<cedente_analiseCreateInput, cedente_analiseUncheckedCreateInput>
    /**
     * In case the cedente_analise was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<cedente_analiseUpdateInput, cedente_analiseUncheckedUpdateInput>
  }


  /**
   * cedente_analise delete
   */
  export type cedente_analiseDeleteArgs = {
    /**
     * Select specific fields to fetch from the cedente_analise
     * 
    **/
    select?: cedente_analiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_analiseInclude | null
    /**
     * Filter which cedente_analise to delete.
     * 
    **/
    where: cedente_analiseWhereUniqueInput
  }


  /**
   * cedente_analise deleteMany
   */
  export type cedente_analiseDeleteManyArgs = {
    /**
     * Filter which cedente_analises to delete
     * 
    **/
    where?: cedente_analiseWhereInput
  }


  /**
   * cedente_analise: findUniqueOrThrow
   */
  export type cedente_analiseFindUniqueOrThrowArgs = cedente_analiseFindUniqueArgsBase
      

  /**
   * cedente_analise: findFirstOrThrow
   */
  export type cedente_analiseFindFirstOrThrowArgs = cedente_analiseFindFirstArgsBase
      

  /**
   * cedente_analise without action
   */
  export type cedente_analiseArgs = {
    /**
     * Select specific fields to fetch from the cedente_analise
     * 
    **/
    select?: cedente_analiseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_analiseInclude | null
  }



  /**
   * Model cedente_n_sacados
   */


  export type AggregateCedente_n_sacados = {
    _count: Cedente_n_sacadosCountAggregateOutputType | null
    _avg: Cedente_n_sacadosAvgAggregateOutputType | null
    _sum: Cedente_n_sacadosSumAggregateOutputType | null
    _min: Cedente_n_sacadosMinAggregateOutputType | null
    _max: Cedente_n_sacadosMaxAggregateOutputType | null
  }

  export type Cedente_n_sacadosAvgAggregateOutputType = {
    id: number | null
    cedente: number | null
    sacado: number | null
  }

  export type Cedente_n_sacadosSumAggregateOutputType = {
    id: number | null
    cedente: number | null
    sacado: number | null
  }

  export type Cedente_n_sacadosMinAggregateOutputType = {
    id: number | null
    cedente: number | null
    sacado: number | null
  }

  export type Cedente_n_sacadosMaxAggregateOutputType = {
    id: number | null
    cedente: number | null
    sacado: number | null
  }

  export type Cedente_n_sacadosCountAggregateOutputType = {
    id: number
    cedente: number
    sacado: number
    _all: number
  }


  export type Cedente_n_sacadosAvgAggregateInputType = {
    id?: true
    cedente?: true
    sacado?: true
  }

  export type Cedente_n_sacadosSumAggregateInputType = {
    id?: true
    cedente?: true
    sacado?: true
  }

  export type Cedente_n_sacadosMinAggregateInputType = {
    id?: true
    cedente?: true
    sacado?: true
  }

  export type Cedente_n_sacadosMaxAggregateInputType = {
    id?: true
    cedente?: true
    sacado?: true
  }

  export type Cedente_n_sacadosCountAggregateInputType = {
    id?: true
    cedente?: true
    sacado?: true
    _all?: true
  }

  export type Cedente_n_sacadosAggregateArgs = {
    /**
     * Filter which cedente_n_sacados to aggregate.
     * 
    **/
    where?: cedente_n_sacadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedente_n_sacados to fetch.
     * 
    **/
    orderBy?: Enumerable<cedente_n_sacadosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: cedente_n_sacadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedente_n_sacados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedente_n_sacados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cedente_n_sacados
    **/
    _count?: true | Cedente_n_sacadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cedente_n_sacadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cedente_n_sacadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cedente_n_sacadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cedente_n_sacadosMaxAggregateInputType
  }

  export type GetCedente_n_sacadosAggregateType<T extends Cedente_n_sacadosAggregateArgs> = {
        [P in keyof T & keyof AggregateCedente_n_sacados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCedente_n_sacados[P]>
      : GetScalarType<T[P], AggregateCedente_n_sacados[P]>
  }




  export type Cedente_n_sacadosGroupByArgs = {
    where?: cedente_n_sacadosWhereInput
    orderBy?: Enumerable<cedente_n_sacadosOrderByWithAggregationInput>
    by: Array<Cedente_n_sacadosScalarFieldEnum>
    having?: cedente_n_sacadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cedente_n_sacadosCountAggregateInputType | true
    _avg?: Cedente_n_sacadosAvgAggregateInputType
    _sum?: Cedente_n_sacadosSumAggregateInputType
    _min?: Cedente_n_sacadosMinAggregateInputType
    _max?: Cedente_n_sacadosMaxAggregateInputType
  }


  export type Cedente_n_sacadosGroupByOutputType = {
    id: number
    cedente: number | null
    sacado: number | null
    _count: Cedente_n_sacadosCountAggregateOutputType | null
    _avg: Cedente_n_sacadosAvgAggregateOutputType | null
    _sum: Cedente_n_sacadosSumAggregateOutputType | null
    _min: Cedente_n_sacadosMinAggregateOutputType | null
    _max: Cedente_n_sacadosMaxAggregateOutputType | null
  }

  type GetCedente_n_sacadosGroupByPayload<T extends Cedente_n_sacadosGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Cedente_n_sacadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cedente_n_sacadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cedente_n_sacadosGroupByOutputType[P]>
            : GetScalarType<T[P], Cedente_n_sacadosGroupByOutputType[P]>
        }
      >
    >


  export type cedente_n_sacadosSelect = {
    id?: boolean
    cedente?: boolean
    sacado?: boolean
    cedente_cedenteTocedente_n_sacados?: boolean | cedenteArgs
    sacado_cedente_n_sacadosTosacado?: boolean | sacadoArgs
  }


  export type cedente_n_sacadosInclude = {
    cedente_cedenteTocedente_n_sacados?: boolean | cedenteArgs
    sacado_cedente_n_sacadosTosacado?: boolean | sacadoArgs
  } 

  export type cedente_n_sacadosGetPayload<S extends boolean | null | undefined | cedente_n_sacadosArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? cedente_n_sacados :
    S extends undefined ? never :
    S extends { include: any } & (cedente_n_sacadosArgs | cedente_n_sacadosFindManyArgs)
    ? cedente_n_sacados  & {
    [P in TrueKeys<S['include']>]:
        P extends 'cedente_cedenteTocedente_n_sacados' ? cedenteGetPayload<Exclude<S['include'], undefined | null>[P]> | null :
        P extends 'sacado_cedente_n_sacadosTosacado' ? sacadoGetPayload<Exclude<S['include'], undefined | null>[P]> | null :  never
  } 
    : S extends { select: any } & (cedente_n_sacadosArgs | cedente_n_sacadosFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'cedente_cedenteTocedente_n_sacados' ? cedenteGetPayload<Exclude<S['select'], undefined | null>[P]> | null :
        P extends 'sacado_cedente_n_sacadosTosacado' ? sacadoGetPayload<Exclude<S['select'], undefined | null>[P]> | null :  P extends keyof cedente_n_sacados ? cedente_n_sacados[P] : never
  } 
      : cedente_n_sacados


  type cedente_n_sacadosCountArgs = Merge<
    Omit<cedente_n_sacadosFindManyArgs, 'select' | 'include'> & {
      select?: Cedente_n_sacadosCountAggregateInputType | true
    }
  >

  export interface cedente_n_sacadosDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Cedente_n_sacados that matches the filter.
     * @param {cedente_n_sacadosFindUniqueArgs} args - Arguments to find a Cedente_n_sacados
     * @example
     * // Get one Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cedente_n_sacadosFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, cedente_n_sacadosFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'cedente_n_sacados'> extends True ? Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T>> : Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T> | null, null>

    /**
     * Find the first Cedente_n_sacados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_n_sacadosFindFirstArgs} args - Arguments to find a Cedente_n_sacados
     * @example
     * // Get one Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cedente_n_sacadosFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, cedente_n_sacadosFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'cedente_n_sacados'> extends True ? Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T>> : Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T> | null, null>

    /**
     * Find zero or more Cedente_n_sacados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_n_sacadosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.findMany()
     * 
     * // Get first 10 Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cedente_n_sacadosWithIdOnly = await prisma.cedente_n_sacados.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends cedente_n_sacadosFindManyArgs>(
      args?: SelectSubset<T, cedente_n_sacadosFindManyArgs>
    ): PrismaPromise<Array<cedente_n_sacadosGetPayload<T>>>

    /**
     * Create a Cedente_n_sacados.
     * @param {cedente_n_sacadosCreateArgs} args - Arguments to create a Cedente_n_sacados.
     * @example
     * // Create one Cedente_n_sacados
     * const Cedente_n_sacados = await prisma.cedente_n_sacados.create({
     *   data: {
     *     // ... data to create a Cedente_n_sacados
     *   }
     * })
     * 
    **/
    create<T extends cedente_n_sacadosCreateArgs>(
      args: SelectSubset<T, cedente_n_sacadosCreateArgs>
    ): Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T>>

    /**
     * Create many Cedente_n_sacados.
     *     @param {cedente_n_sacadosCreateManyArgs} args - Arguments to create many Cedente_n_sacados.
     *     @example
     *     // Create many Cedente_n_sacados
     *     const cedente_n_sacados = await prisma.cedente_n_sacados.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cedente_n_sacadosCreateManyArgs>(
      args?: SelectSubset<T, cedente_n_sacadosCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Cedente_n_sacados.
     * @param {cedente_n_sacadosDeleteArgs} args - Arguments to delete one Cedente_n_sacados.
     * @example
     * // Delete one Cedente_n_sacados
     * const Cedente_n_sacados = await prisma.cedente_n_sacados.delete({
     *   where: {
     *     // ... filter to delete one Cedente_n_sacados
     *   }
     * })
     * 
    **/
    delete<T extends cedente_n_sacadosDeleteArgs>(
      args: SelectSubset<T, cedente_n_sacadosDeleteArgs>
    ): Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T>>

    /**
     * Update one Cedente_n_sacados.
     * @param {cedente_n_sacadosUpdateArgs} args - Arguments to update one Cedente_n_sacados.
     * @example
     * // Update one Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cedente_n_sacadosUpdateArgs>(
      args: SelectSubset<T, cedente_n_sacadosUpdateArgs>
    ): Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T>>

    /**
     * Delete zero or more Cedente_n_sacados.
     * @param {cedente_n_sacadosDeleteManyArgs} args - Arguments to filter Cedente_n_sacados to delete.
     * @example
     * // Delete a few Cedente_n_sacados
     * const { count } = await prisma.cedente_n_sacados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cedente_n_sacadosDeleteManyArgs>(
      args?: SelectSubset<T, cedente_n_sacadosDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cedente_n_sacados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_n_sacadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cedente_n_sacadosUpdateManyArgs>(
      args: SelectSubset<T, cedente_n_sacadosUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Cedente_n_sacados.
     * @param {cedente_n_sacadosUpsertArgs} args - Arguments to update or create a Cedente_n_sacados.
     * @example
     * // Update or create a Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.upsert({
     *   create: {
     *     // ... data to create a Cedente_n_sacados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cedente_n_sacados we want to update
     *   }
     * })
    **/
    upsert<T extends cedente_n_sacadosUpsertArgs>(
      args: SelectSubset<T, cedente_n_sacadosUpsertArgs>
    ): Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T>>

    /**
     * Find one Cedente_n_sacados that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {cedente_n_sacadosFindUniqueOrThrowArgs} args - Arguments to find a Cedente_n_sacados
     * @example
     * // Get one Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cedente_n_sacadosFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, cedente_n_sacadosFindUniqueOrThrowArgs>
    ): Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T>>

    /**
     * Find the first Cedente_n_sacados that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_n_sacadosFindFirstOrThrowArgs} args - Arguments to find a Cedente_n_sacados
     * @example
     * // Get one Cedente_n_sacados
     * const cedente_n_sacados = await prisma.cedente_n_sacados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cedente_n_sacadosFindFirstOrThrowArgs>(
      args?: SelectSubset<T, cedente_n_sacadosFindFirstOrThrowArgs>
    ): Prisma__cedente_n_sacadosClient<cedente_n_sacadosGetPayload<T>>

    /**
     * Count the number of Cedente_n_sacados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cedente_n_sacadosCountArgs} args - Arguments to filter Cedente_n_sacados to count.
     * @example
     * // Count the number of Cedente_n_sacados
     * const count = await prisma.cedente_n_sacados.count({
     *   where: {
     *     // ... the filter for the Cedente_n_sacados we want to count
     *   }
     * })
    **/
    count<T extends cedente_n_sacadosCountArgs>(
      args?: Subset<T, cedente_n_sacadosCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cedente_n_sacadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cedente_n_sacados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cedente_n_sacadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cedente_n_sacadosAggregateArgs>(args: Subset<T, Cedente_n_sacadosAggregateArgs>): PrismaPromise<GetCedente_n_sacadosAggregateType<T>>

    /**
     * Group by Cedente_n_sacados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cedente_n_sacadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Cedente_n_sacadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Cedente_n_sacadosGroupByArgs['orderBy'] }
        : { orderBy?: Cedente_n_sacadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Cedente_n_sacadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCedente_n_sacadosGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for cedente_n_sacados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__cedente_n_sacadosClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cedente_cedenteTocedente_n_sacados<T extends cedenteArgs= {}>(args?: Subset<T, cedenteArgs>): Prisma__cedenteClient<cedenteGetPayload<T> | Null>;

    sacado_cedente_n_sacadosTosacado<T extends sacadoArgs= {}>(args?: Subset<T, sacadoArgs>): Prisma__sacadoClient<sacadoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * cedente_n_sacados base type for findUnique actions
   */
  export type cedente_n_sacadosFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the cedente_n_sacados
     * 
    **/
    select?: cedente_n_sacadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_n_sacadosInclude | null
    /**
     * Filter, which cedente_n_sacados to fetch.
     * 
    **/
    where: cedente_n_sacadosWhereUniqueInput
  }

  /**
   * cedente_n_sacados: findUnique
   */
  export interface cedente_n_sacadosFindUniqueArgs extends cedente_n_sacadosFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cedente_n_sacados base type for findFirst actions
   */
  export type cedente_n_sacadosFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the cedente_n_sacados
     * 
    **/
    select?: cedente_n_sacadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_n_sacadosInclude | null
    /**
     * Filter, which cedente_n_sacados to fetch.
     * 
    **/
    where?: cedente_n_sacadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedente_n_sacados to fetch.
     * 
    **/
    orderBy?: Enumerable<cedente_n_sacadosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cedente_n_sacados.
     * 
    **/
    cursor?: cedente_n_sacadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedente_n_sacados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedente_n_sacados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cedente_n_sacados.
     * 
    **/
    distinct?: Enumerable<Cedente_n_sacadosScalarFieldEnum>
  }

  /**
   * cedente_n_sacados: findFirst
   */
  export interface cedente_n_sacadosFindFirstArgs extends cedente_n_sacadosFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * cedente_n_sacados findMany
   */
  export type cedente_n_sacadosFindManyArgs = {
    /**
     * Select specific fields to fetch from the cedente_n_sacados
     * 
    **/
    select?: cedente_n_sacadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_n_sacadosInclude | null
    /**
     * Filter, which cedente_n_sacados to fetch.
     * 
    **/
    where?: cedente_n_sacadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cedente_n_sacados to fetch.
     * 
    **/
    orderBy?: Enumerable<cedente_n_sacadosOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cedente_n_sacados.
     * 
    **/
    cursor?: cedente_n_sacadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cedente_n_sacados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cedente_n_sacados.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Cedente_n_sacadosScalarFieldEnum>
  }


  /**
   * cedente_n_sacados create
   */
  export type cedente_n_sacadosCreateArgs = {
    /**
     * Select specific fields to fetch from the cedente_n_sacados
     * 
    **/
    select?: cedente_n_sacadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_n_sacadosInclude | null
    /**
     * The data needed to create a cedente_n_sacados.
     * 
    **/
    data: XOR<cedente_n_sacadosCreateInput, cedente_n_sacadosUncheckedCreateInput>
  }


  /**
   * cedente_n_sacados createMany
   */
  export type cedente_n_sacadosCreateManyArgs = {
    /**
     * The data used to create many cedente_n_sacados.
     * 
    **/
    data: Enumerable<cedente_n_sacadosCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * cedente_n_sacados update
   */
  export type cedente_n_sacadosUpdateArgs = {
    /**
     * Select specific fields to fetch from the cedente_n_sacados
     * 
    **/
    select?: cedente_n_sacadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_n_sacadosInclude | null
    /**
     * The data needed to update a cedente_n_sacados.
     * 
    **/
    data: XOR<cedente_n_sacadosUpdateInput, cedente_n_sacadosUncheckedUpdateInput>
    /**
     * Choose, which cedente_n_sacados to update.
     * 
    **/
    where: cedente_n_sacadosWhereUniqueInput
  }


  /**
   * cedente_n_sacados updateMany
   */
  export type cedente_n_sacadosUpdateManyArgs = {
    /**
     * The data used to update cedente_n_sacados.
     * 
    **/
    data: XOR<cedente_n_sacadosUpdateManyMutationInput, cedente_n_sacadosUncheckedUpdateManyInput>
    /**
     * Filter which cedente_n_sacados to update
     * 
    **/
    where?: cedente_n_sacadosWhereInput
  }


  /**
   * cedente_n_sacados upsert
   */
  export type cedente_n_sacadosUpsertArgs = {
    /**
     * Select specific fields to fetch from the cedente_n_sacados
     * 
    **/
    select?: cedente_n_sacadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_n_sacadosInclude | null
    /**
     * The filter to search for the cedente_n_sacados to update in case it exists.
     * 
    **/
    where: cedente_n_sacadosWhereUniqueInput
    /**
     * In case the cedente_n_sacados found by the `where` argument doesn't exist, create a new cedente_n_sacados with this data.
     * 
    **/
    create: XOR<cedente_n_sacadosCreateInput, cedente_n_sacadosUncheckedCreateInput>
    /**
     * In case the cedente_n_sacados was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<cedente_n_sacadosUpdateInput, cedente_n_sacadosUncheckedUpdateInput>
  }


  /**
   * cedente_n_sacados delete
   */
  export type cedente_n_sacadosDeleteArgs = {
    /**
     * Select specific fields to fetch from the cedente_n_sacados
     * 
    **/
    select?: cedente_n_sacadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_n_sacadosInclude | null
    /**
     * Filter which cedente_n_sacados to delete.
     * 
    **/
    where: cedente_n_sacadosWhereUniqueInput
  }


  /**
   * cedente_n_sacados deleteMany
   */
  export type cedente_n_sacadosDeleteManyArgs = {
    /**
     * Filter which cedente_n_sacados to delete
     * 
    **/
    where?: cedente_n_sacadosWhereInput
  }


  /**
   * cedente_n_sacados: findUniqueOrThrow
   */
  export type cedente_n_sacadosFindUniqueOrThrowArgs = cedente_n_sacadosFindUniqueArgsBase
      

  /**
   * cedente_n_sacados: findFirstOrThrow
   */
  export type cedente_n_sacadosFindFirstOrThrowArgs = cedente_n_sacadosFindFirstArgsBase
      

  /**
   * cedente_n_sacados without action
   */
  export type cedente_n_sacadosArgs = {
    /**
     * Select specific fields to fetch from the cedente_n_sacados
     * 
    **/
    select?: cedente_n_sacadosSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: cedente_n_sacadosInclude | null
  }



  /**
   * Model checagem
   */


  export type AggregateChecagem = {
    _count: ChecagemCountAggregateOutputType | null
    _avg: ChecagemAvgAggregateOutputType | null
    _sum: ChecagemSumAggregateOutputType | null
    _min: ChecagemMinAggregateOutputType | null
    _max: ChecagemMaxAggregateOutputType | null
  }

  export type ChecagemAvgAggregateOutputType = {
    id: number | null
    usuario: number | null
  }

  export type ChecagemSumAggregateOutputType = {
    id: number | null
    usuario: number | null
  }

  export type ChecagemMinAggregateOutputType = {
    id: number | null
    nf: string | null
    status: string | null
    usuario: number | null
    titulos: string | null
  }

  export type ChecagemMaxAggregateOutputType = {
    id: number | null
    nf: string | null
    status: string | null
    usuario: number | null
    titulos: string | null
  }

  export type ChecagemCountAggregateOutputType = {
    id: number
    nf: number
    status: number
    usuario: number
    titulos: number
    _all: number
  }


  export type ChecagemAvgAggregateInputType = {
    id?: true
    usuario?: true
  }

  export type ChecagemSumAggregateInputType = {
    id?: true
    usuario?: true
  }

  export type ChecagemMinAggregateInputType = {
    id?: true
    nf?: true
    status?: true
    usuario?: true
    titulos?: true
  }

  export type ChecagemMaxAggregateInputType = {
    id?: true
    nf?: true
    status?: true
    usuario?: true
    titulos?: true
  }

  export type ChecagemCountAggregateInputType = {
    id?: true
    nf?: true
    status?: true
    usuario?: true
    titulos?: true
    _all?: true
  }

  export type ChecagemAggregateArgs = {
    /**
     * Filter which checagem to aggregate.
     * 
    **/
    where?: checagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checagems to fetch.
     * 
    **/
    orderBy?: Enumerable<checagemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: checagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checagems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checagems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned checagems
    **/
    _count?: true | ChecagemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChecagemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChecagemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChecagemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChecagemMaxAggregateInputType
  }

  export type GetChecagemAggregateType<T extends ChecagemAggregateArgs> = {
        [P in keyof T & keyof AggregateChecagem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChecagem[P]>
      : GetScalarType<T[P], AggregateChecagem[P]>
  }




  export type ChecagemGroupByArgs = {
    where?: checagemWhereInput
    orderBy?: Enumerable<checagemOrderByWithAggregationInput>
    by: Array<ChecagemScalarFieldEnum>
    having?: checagemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChecagemCountAggregateInputType | true
    _avg?: ChecagemAvgAggregateInputType
    _sum?: ChecagemSumAggregateInputType
    _min?: ChecagemMinAggregateInputType
    _max?: ChecagemMaxAggregateInputType
  }


  export type ChecagemGroupByOutputType = {
    id: number
    nf: string | null
    status: string | null
    usuario: number | null
    titulos: string | null
    _count: ChecagemCountAggregateOutputType | null
    _avg: ChecagemAvgAggregateOutputType | null
    _sum: ChecagemSumAggregateOutputType | null
    _min: ChecagemMinAggregateOutputType | null
    _max: ChecagemMaxAggregateOutputType | null
  }

  type GetChecagemGroupByPayload<T extends ChecagemGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ChecagemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChecagemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChecagemGroupByOutputType[P]>
            : GetScalarType<T[P], ChecagemGroupByOutputType[P]>
        }
      >
    >


  export type checagemSelect = {
    id?: boolean
    nf?: boolean
    status?: boolean
    usuario?: boolean
    titulos?: boolean
  }


  export type checagemGetPayload<S extends boolean | null | undefined | checagemArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? checagem :
    S extends undefined ? never :
    S extends { include: any } & (checagemArgs | checagemFindManyArgs)
    ? checagem 
    : S extends { select: any } & (checagemArgs | checagemFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof checagem ? checagem[P] : never
  } 
      : checagem


  type checagemCountArgs = Merge<
    Omit<checagemFindManyArgs, 'select' | 'include'> & {
      select?: ChecagemCountAggregateInputType | true
    }
  >

  export interface checagemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Checagem that matches the filter.
     * @param {checagemFindUniqueArgs} args - Arguments to find a Checagem
     * @example
     * // Get one Checagem
     * const checagem = await prisma.checagem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends checagemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, checagemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'checagem'> extends True ? Prisma__checagemClient<checagemGetPayload<T>> : Prisma__checagemClient<checagemGetPayload<T> | null, null>

    /**
     * Find the first Checagem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checagemFindFirstArgs} args - Arguments to find a Checagem
     * @example
     * // Get one Checagem
     * const checagem = await prisma.checagem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends checagemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, checagemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'checagem'> extends True ? Prisma__checagemClient<checagemGetPayload<T>> : Prisma__checagemClient<checagemGetPayload<T> | null, null>

    /**
     * Find zero or more Checagems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checagemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Checagems
     * const checagems = await prisma.checagem.findMany()
     * 
     * // Get first 10 Checagems
     * const checagems = await prisma.checagem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checagemWithIdOnly = await prisma.checagem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends checagemFindManyArgs>(
      args?: SelectSubset<T, checagemFindManyArgs>
    ): PrismaPromise<Array<checagemGetPayload<T>>>

    /**
     * Create a Checagem.
     * @param {checagemCreateArgs} args - Arguments to create a Checagem.
     * @example
     * // Create one Checagem
     * const Checagem = await prisma.checagem.create({
     *   data: {
     *     // ... data to create a Checagem
     *   }
     * })
     * 
    **/
    create<T extends checagemCreateArgs>(
      args: SelectSubset<T, checagemCreateArgs>
    ): Prisma__checagemClient<checagemGetPayload<T>>

    /**
     * Create many Checagems.
     *     @param {checagemCreateManyArgs} args - Arguments to create many Checagems.
     *     @example
     *     // Create many Checagems
     *     const checagem = await prisma.checagem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends checagemCreateManyArgs>(
      args?: SelectSubset<T, checagemCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Checagem.
     * @param {checagemDeleteArgs} args - Arguments to delete one Checagem.
     * @example
     * // Delete one Checagem
     * const Checagem = await prisma.checagem.delete({
     *   where: {
     *     // ... filter to delete one Checagem
     *   }
     * })
     * 
    **/
    delete<T extends checagemDeleteArgs>(
      args: SelectSubset<T, checagemDeleteArgs>
    ): Prisma__checagemClient<checagemGetPayload<T>>

    /**
     * Update one Checagem.
     * @param {checagemUpdateArgs} args - Arguments to update one Checagem.
     * @example
     * // Update one Checagem
     * const checagem = await prisma.checagem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends checagemUpdateArgs>(
      args: SelectSubset<T, checagemUpdateArgs>
    ): Prisma__checagemClient<checagemGetPayload<T>>

    /**
     * Delete zero or more Checagems.
     * @param {checagemDeleteManyArgs} args - Arguments to filter Checagems to delete.
     * @example
     * // Delete a few Checagems
     * const { count } = await prisma.checagem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends checagemDeleteManyArgs>(
      args?: SelectSubset<T, checagemDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checagems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checagemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Checagems
     * const checagem = await prisma.checagem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends checagemUpdateManyArgs>(
      args: SelectSubset<T, checagemUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Checagem.
     * @param {checagemUpsertArgs} args - Arguments to update or create a Checagem.
     * @example
     * // Update or create a Checagem
     * const checagem = await prisma.checagem.upsert({
     *   create: {
     *     // ... data to create a Checagem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Checagem we want to update
     *   }
     * })
    **/
    upsert<T extends checagemUpsertArgs>(
      args: SelectSubset<T, checagemUpsertArgs>
    ): Prisma__checagemClient<checagemGetPayload<T>>

    /**
     * Find one Checagem that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {checagemFindUniqueOrThrowArgs} args - Arguments to find a Checagem
     * @example
     * // Get one Checagem
     * const checagem = await prisma.checagem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends checagemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, checagemFindUniqueOrThrowArgs>
    ): Prisma__checagemClient<checagemGetPayload<T>>

    /**
     * Find the first Checagem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checagemFindFirstOrThrowArgs} args - Arguments to find a Checagem
     * @example
     * // Get one Checagem
     * const checagem = await prisma.checagem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends checagemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, checagemFindFirstOrThrowArgs>
    ): Prisma__checagemClient<checagemGetPayload<T>>

    /**
     * Count the number of Checagems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checagemCountArgs} args - Arguments to filter Checagems to count.
     * @example
     * // Count the number of Checagems
     * const count = await prisma.checagem.count({
     *   where: {
     *     // ... the filter for the Checagems we want to count
     *   }
     * })
    **/
    count<T extends checagemCountArgs>(
      args?: Subset<T, checagemCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChecagemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Checagem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecagemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChecagemAggregateArgs>(args: Subset<T, ChecagemAggregateArgs>): PrismaPromise<GetChecagemAggregateType<T>>

    /**
     * Group by Checagem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecagemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChecagemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChecagemGroupByArgs['orderBy'] }
        : { orderBy?: ChecagemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChecagemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChecagemGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for checagem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__checagemClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * checagem base type for findUnique actions
   */
  export type checagemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the checagem
     * 
    **/
    select?: checagemSelect | null
    /**
     * Filter, which checagem to fetch.
     * 
    **/
    where: checagemWhereUniqueInput
  }

  /**
   * checagem: findUnique
   */
  export interface checagemFindUniqueArgs extends checagemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * checagem base type for findFirst actions
   */
  export type checagemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the checagem
     * 
    **/
    select?: checagemSelect | null
    /**
     * Filter, which checagem to fetch.
     * 
    **/
    where?: checagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checagems to fetch.
     * 
    **/
    orderBy?: Enumerable<checagemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for checagems.
     * 
    **/
    cursor?: checagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checagems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checagems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of checagems.
     * 
    **/
    distinct?: Enumerable<ChecagemScalarFieldEnum>
  }

  /**
   * checagem: findFirst
   */
  export interface checagemFindFirstArgs extends checagemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * checagem findMany
   */
  export type checagemFindManyArgs = {
    /**
     * Select specific fields to fetch from the checagem
     * 
    **/
    select?: checagemSelect | null
    /**
     * Filter, which checagems to fetch.
     * 
    **/
    where?: checagemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checagems to fetch.
     * 
    **/
    orderBy?: Enumerable<checagemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing checagems.
     * 
    **/
    cursor?: checagemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checagems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checagems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ChecagemScalarFieldEnum>
  }


  /**
   * checagem create
   */
  export type checagemCreateArgs = {
    /**
     * Select specific fields to fetch from the checagem
     * 
    **/
    select?: checagemSelect | null
    /**
     * The data needed to create a checagem.
     * 
    **/
    data: XOR<checagemCreateInput, checagemUncheckedCreateInput>
  }


  /**
   * checagem createMany
   */
  export type checagemCreateManyArgs = {
    /**
     * The data used to create many checagems.
     * 
    **/
    data: Enumerable<checagemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * checagem update
   */
  export type checagemUpdateArgs = {
    /**
     * Select specific fields to fetch from the checagem
     * 
    **/
    select?: checagemSelect | null
    /**
     * The data needed to update a checagem.
     * 
    **/
    data: XOR<checagemUpdateInput, checagemUncheckedUpdateInput>
    /**
     * Choose, which checagem to update.
     * 
    **/
    where: checagemWhereUniqueInput
  }


  /**
   * checagem updateMany
   */
  export type checagemUpdateManyArgs = {
    /**
     * The data used to update checagems.
     * 
    **/
    data: XOR<checagemUpdateManyMutationInput, checagemUncheckedUpdateManyInput>
    /**
     * Filter which checagems to update
     * 
    **/
    where?: checagemWhereInput
  }


  /**
   * checagem upsert
   */
  export type checagemUpsertArgs = {
    /**
     * Select specific fields to fetch from the checagem
     * 
    **/
    select?: checagemSelect | null
    /**
     * The filter to search for the checagem to update in case it exists.
     * 
    **/
    where: checagemWhereUniqueInput
    /**
     * In case the checagem found by the `where` argument doesn't exist, create a new checagem with this data.
     * 
    **/
    create: XOR<checagemCreateInput, checagemUncheckedCreateInput>
    /**
     * In case the checagem was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<checagemUpdateInput, checagemUncheckedUpdateInput>
  }


  /**
   * checagem delete
   */
  export type checagemDeleteArgs = {
    /**
     * Select specific fields to fetch from the checagem
     * 
    **/
    select?: checagemSelect | null
    /**
     * Filter which checagem to delete.
     * 
    **/
    where: checagemWhereUniqueInput
  }


  /**
   * checagem deleteMany
   */
  export type checagemDeleteManyArgs = {
    /**
     * Filter which checagems to delete
     * 
    **/
    where?: checagemWhereInput
  }


  /**
   * checagem: findUniqueOrThrow
   */
  export type checagemFindUniqueOrThrowArgs = checagemFindUniqueArgsBase
      

  /**
   * checagem: findFirstOrThrow
   */
  export type checagemFindFirstOrThrowArgs = checagemFindFirstArgsBase
      

  /**
   * checagem without action
   */
  export type checagemArgs = {
    /**
     * Select specific fields to fetch from the checagem
     * 
    **/
    select?: checagemSelect | null
  }



  /**
   * Model fidic_fundo
   */


  export type AggregateFidic_fundo = {
    _count: Fidic_fundoCountAggregateOutputType | null
    _avg: Fidic_fundoAvgAggregateOutputType | null
    _sum: Fidic_fundoSumAggregateOutputType | null
    _min: Fidic_fundoMinAggregateOutputType | null
    _max: Fidic_fundoMaxAggregateOutputType | null
  }

  export type Fidic_fundoAvgAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
  }

  export type Fidic_fundoSumAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
  }

  export type Fidic_fundoMinAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
    razao_social: string | null
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
  }

  export type Fidic_fundoMaxAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
    razao_social: string | null
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
  }

  export type Fidic_fundoCountAggregateOutputType = {
    id: number
    pessoa_id: number
    razao_social: number
    nome_fantasia: number
    abertura: number
    cnpj: number
    _all: number
  }


  export type Fidic_fundoAvgAggregateInputType = {
    id?: true
    pessoa_id?: true
  }

  export type Fidic_fundoSumAggregateInputType = {
    id?: true
    pessoa_id?: true
  }

  export type Fidic_fundoMinAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
  }

  export type Fidic_fundoMaxAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
  }

  export type Fidic_fundoCountAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
    _all?: true
  }

  export type Fidic_fundoAggregateArgs = {
    /**
     * Filter which fidic_fundo to aggregate.
     * 
    **/
    where?: fidic_fundoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fidic_fundos to fetch.
     * 
    **/
    orderBy?: Enumerable<fidic_fundoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: fidic_fundoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fidic_fundos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fidic_fundos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fidic_fundos
    **/
    _count?: true | Fidic_fundoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fidic_fundoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fidic_fundoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fidic_fundoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fidic_fundoMaxAggregateInputType
  }

  export type GetFidic_fundoAggregateType<T extends Fidic_fundoAggregateArgs> = {
        [P in keyof T & keyof AggregateFidic_fundo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFidic_fundo[P]>
      : GetScalarType<T[P], AggregateFidic_fundo[P]>
  }




  export type Fidic_fundoGroupByArgs = {
    where?: fidic_fundoWhereInput
    orderBy?: Enumerable<fidic_fundoOrderByWithAggregationInput>
    by: Array<Fidic_fundoScalarFieldEnum>
    having?: fidic_fundoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fidic_fundoCountAggregateInputType | true
    _avg?: Fidic_fundoAvgAggregateInputType
    _sum?: Fidic_fundoSumAggregateInputType
    _min?: Fidic_fundoMinAggregateInputType
    _max?: Fidic_fundoMaxAggregateInputType
  }


  export type Fidic_fundoGroupByOutputType = {
    id: number
    pessoa_id: number
    razao_social: string
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
    _count: Fidic_fundoCountAggregateOutputType | null
    _avg: Fidic_fundoAvgAggregateOutputType | null
    _sum: Fidic_fundoSumAggregateOutputType | null
    _min: Fidic_fundoMinAggregateOutputType | null
    _max: Fidic_fundoMaxAggregateOutputType | null
  }

  type GetFidic_fundoGroupByPayload<T extends Fidic_fundoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Fidic_fundoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fidic_fundoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fidic_fundoGroupByOutputType[P]>
            : GetScalarType<T[P], Fidic_fundoGroupByOutputType[P]>
        }
      >
    >


  export type fidic_fundoSelect = {
    id?: boolean
    pessoa_id?: boolean
    razao_social?: boolean
    nome_fantasia?: boolean
    abertura?: boolean
    cnpj?: boolean
    carteira?: boolean | carteiraFindManyArgs
    fidic_fundo_x_usuario?: boolean | fidic_fundo_x_usuarioFindManyArgs
    _count?: boolean | Fidic_fundoCountOutputTypeArgs
  }


  export type fidic_fundoInclude = {
    carteira?: boolean | carteiraFindManyArgs
    fidic_fundo_x_usuario?: boolean | fidic_fundo_x_usuarioFindManyArgs
    _count?: boolean | Fidic_fundoCountOutputTypeArgs
  } 

  export type fidic_fundoGetPayload<S extends boolean | null | undefined | fidic_fundoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? fidic_fundo :
    S extends undefined ? never :
    S extends { include: any } & (fidic_fundoArgs | fidic_fundoFindManyArgs)
    ? fidic_fundo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'carteira' ? Array < carteiraGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'fidic_fundo_x_usuario' ? Array < fidic_fundo_x_usuarioGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Fidic_fundoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (fidic_fundoArgs | fidic_fundoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'carteira' ? Array < carteiraGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'fidic_fundo_x_usuario' ? Array < fidic_fundo_x_usuarioGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Fidic_fundoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof fidic_fundo ? fidic_fundo[P] : never
  } 
      : fidic_fundo


  type fidic_fundoCountArgs = Merge<
    Omit<fidic_fundoFindManyArgs, 'select' | 'include'> & {
      select?: Fidic_fundoCountAggregateInputType | true
    }
  >

  export interface fidic_fundoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Fidic_fundo that matches the filter.
     * @param {fidic_fundoFindUniqueArgs} args - Arguments to find a Fidic_fundo
     * @example
     * // Get one Fidic_fundo
     * const fidic_fundo = await prisma.fidic_fundo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fidic_fundoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fidic_fundoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fidic_fundo'> extends True ? Prisma__fidic_fundoClient<fidic_fundoGetPayload<T>> : Prisma__fidic_fundoClient<fidic_fundoGetPayload<T> | null, null>

    /**
     * Find the first Fidic_fundo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundoFindFirstArgs} args - Arguments to find a Fidic_fundo
     * @example
     * // Get one Fidic_fundo
     * const fidic_fundo = await prisma.fidic_fundo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fidic_fundoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fidic_fundoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fidic_fundo'> extends True ? Prisma__fidic_fundoClient<fidic_fundoGetPayload<T>> : Prisma__fidic_fundoClient<fidic_fundoGetPayload<T> | null, null>

    /**
     * Find zero or more Fidic_fundos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fidic_fundos
     * const fidic_fundos = await prisma.fidic_fundo.findMany()
     * 
     * // Get first 10 Fidic_fundos
     * const fidic_fundos = await prisma.fidic_fundo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fidic_fundoWithIdOnly = await prisma.fidic_fundo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fidic_fundoFindManyArgs>(
      args?: SelectSubset<T, fidic_fundoFindManyArgs>
    ): PrismaPromise<Array<fidic_fundoGetPayload<T>>>

    /**
     * Create a Fidic_fundo.
     * @param {fidic_fundoCreateArgs} args - Arguments to create a Fidic_fundo.
     * @example
     * // Create one Fidic_fundo
     * const Fidic_fundo = await prisma.fidic_fundo.create({
     *   data: {
     *     // ... data to create a Fidic_fundo
     *   }
     * })
     * 
    **/
    create<T extends fidic_fundoCreateArgs>(
      args: SelectSubset<T, fidic_fundoCreateArgs>
    ): Prisma__fidic_fundoClient<fidic_fundoGetPayload<T>>

    /**
     * Create many Fidic_fundos.
     *     @param {fidic_fundoCreateManyArgs} args - Arguments to create many Fidic_fundos.
     *     @example
     *     // Create many Fidic_fundos
     *     const fidic_fundo = await prisma.fidic_fundo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fidic_fundoCreateManyArgs>(
      args?: SelectSubset<T, fidic_fundoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Fidic_fundo.
     * @param {fidic_fundoDeleteArgs} args - Arguments to delete one Fidic_fundo.
     * @example
     * // Delete one Fidic_fundo
     * const Fidic_fundo = await prisma.fidic_fundo.delete({
     *   where: {
     *     // ... filter to delete one Fidic_fundo
     *   }
     * })
     * 
    **/
    delete<T extends fidic_fundoDeleteArgs>(
      args: SelectSubset<T, fidic_fundoDeleteArgs>
    ): Prisma__fidic_fundoClient<fidic_fundoGetPayload<T>>

    /**
     * Update one Fidic_fundo.
     * @param {fidic_fundoUpdateArgs} args - Arguments to update one Fidic_fundo.
     * @example
     * // Update one Fidic_fundo
     * const fidic_fundo = await prisma.fidic_fundo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fidic_fundoUpdateArgs>(
      args: SelectSubset<T, fidic_fundoUpdateArgs>
    ): Prisma__fidic_fundoClient<fidic_fundoGetPayload<T>>

    /**
     * Delete zero or more Fidic_fundos.
     * @param {fidic_fundoDeleteManyArgs} args - Arguments to filter Fidic_fundos to delete.
     * @example
     * // Delete a few Fidic_fundos
     * const { count } = await prisma.fidic_fundo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fidic_fundoDeleteManyArgs>(
      args?: SelectSubset<T, fidic_fundoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fidic_fundos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fidic_fundos
     * const fidic_fundo = await prisma.fidic_fundo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fidic_fundoUpdateManyArgs>(
      args: SelectSubset<T, fidic_fundoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Fidic_fundo.
     * @param {fidic_fundoUpsertArgs} args - Arguments to update or create a Fidic_fundo.
     * @example
     * // Update or create a Fidic_fundo
     * const fidic_fundo = await prisma.fidic_fundo.upsert({
     *   create: {
     *     // ... data to create a Fidic_fundo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fidic_fundo we want to update
     *   }
     * })
    **/
    upsert<T extends fidic_fundoUpsertArgs>(
      args: SelectSubset<T, fidic_fundoUpsertArgs>
    ): Prisma__fidic_fundoClient<fidic_fundoGetPayload<T>>

    /**
     * Find one Fidic_fundo that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {fidic_fundoFindUniqueOrThrowArgs} args - Arguments to find a Fidic_fundo
     * @example
     * // Get one Fidic_fundo
     * const fidic_fundo = await prisma.fidic_fundo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fidic_fundoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, fidic_fundoFindUniqueOrThrowArgs>
    ): Prisma__fidic_fundoClient<fidic_fundoGetPayload<T>>

    /**
     * Find the first Fidic_fundo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundoFindFirstOrThrowArgs} args - Arguments to find a Fidic_fundo
     * @example
     * // Get one Fidic_fundo
     * const fidic_fundo = await prisma.fidic_fundo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fidic_fundoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, fidic_fundoFindFirstOrThrowArgs>
    ): Prisma__fidic_fundoClient<fidic_fundoGetPayload<T>>

    /**
     * Count the number of Fidic_fundos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundoCountArgs} args - Arguments to filter Fidic_fundos to count.
     * @example
     * // Count the number of Fidic_fundos
     * const count = await prisma.fidic_fundo.count({
     *   where: {
     *     // ... the filter for the Fidic_fundos we want to count
     *   }
     * })
    **/
    count<T extends fidic_fundoCountArgs>(
      args?: Subset<T, fidic_fundoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fidic_fundoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fidic_fundo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fidic_fundoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fidic_fundoAggregateArgs>(args: Subset<T, Fidic_fundoAggregateArgs>): PrismaPromise<GetFidic_fundoAggregateType<T>>

    /**
     * Group by Fidic_fundo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fidic_fundoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Fidic_fundoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Fidic_fundoGroupByArgs['orderBy'] }
        : { orderBy?: Fidic_fundoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Fidic_fundoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFidic_fundoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fidic_fundo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fidic_fundoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    carteira<T extends carteiraFindManyArgs= {}>(args?: Subset<T, carteiraFindManyArgs>): PrismaPromise<Array<carteiraGetPayload<T>>| Null>;

    fidic_fundo_x_usuario<T extends fidic_fundo_x_usuarioFindManyArgs= {}>(args?: Subset<T, fidic_fundo_x_usuarioFindManyArgs>): PrismaPromise<Array<fidic_fundo_x_usuarioGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fidic_fundo base type for findUnique actions
   */
  export type fidic_fundoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the fidic_fundo
     * 
    **/
    select?: fidic_fundoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundoInclude | null
    /**
     * Filter, which fidic_fundo to fetch.
     * 
    **/
    where: fidic_fundoWhereUniqueInput
  }

  /**
   * fidic_fundo: findUnique
   */
  export interface fidic_fundoFindUniqueArgs extends fidic_fundoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fidic_fundo base type for findFirst actions
   */
  export type fidic_fundoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the fidic_fundo
     * 
    **/
    select?: fidic_fundoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundoInclude | null
    /**
     * Filter, which fidic_fundo to fetch.
     * 
    **/
    where?: fidic_fundoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fidic_fundos to fetch.
     * 
    **/
    orderBy?: Enumerable<fidic_fundoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fidic_fundos.
     * 
    **/
    cursor?: fidic_fundoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fidic_fundos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fidic_fundos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fidic_fundos.
     * 
    **/
    distinct?: Enumerable<Fidic_fundoScalarFieldEnum>
  }

  /**
   * fidic_fundo: findFirst
   */
  export interface fidic_fundoFindFirstArgs extends fidic_fundoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fidic_fundo findMany
   */
  export type fidic_fundoFindManyArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo
     * 
    **/
    select?: fidic_fundoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundoInclude | null
    /**
     * Filter, which fidic_fundos to fetch.
     * 
    **/
    where?: fidic_fundoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fidic_fundos to fetch.
     * 
    **/
    orderBy?: Enumerable<fidic_fundoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fidic_fundos.
     * 
    **/
    cursor?: fidic_fundoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fidic_fundos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fidic_fundos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Fidic_fundoScalarFieldEnum>
  }


  /**
   * fidic_fundo create
   */
  export type fidic_fundoCreateArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo
     * 
    **/
    select?: fidic_fundoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundoInclude | null
    /**
     * The data needed to create a fidic_fundo.
     * 
    **/
    data: XOR<fidic_fundoCreateInput, fidic_fundoUncheckedCreateInput>
  }


  /**
   * fidic_fundo createMany
   */
  export type fidic_fundoCreateManyArgs = {
    /**
     * The data used to create many fidic_fundos.
     * 
    **/
    data: Enumerable<fidic_fundoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * fidic_fundo update
   */
  export type fidic_fundoUpdateArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo
     * 
    **/
    select?: fidic_fundoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundoInclude | null
    /**
     * The data needed to update a fidic_fundo.
     * 
    **/
    data: XOR<fidic_fundoUpdateInput, fidic_fundoUncheckedUpdateInput>
    /**
     * Choose, which fidic_fundo to update.
     * 
    **/
    where: fidic_fundoWhereUniqueInput
  }


  /**
   * fidic_fundo updateMany
   */
  export type fidic_fundoUpdateManyArgs = {
    /**
     * The data used to update fidic_fundos.
     * 
    **/
    data: XOR<fidic_fundoUpdateManyMutationInput, fidic_fundoUncheckedUpdateManyInput>
    /**
     * Filter which fidic_fundos to update
     * 
    **/
    where?: fidic_fundoWhereInput
  }


  /**
   * fidic_fundo upsert
   */
  export type fidic_fundoUpsertArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo
     * 
    **/
    select?: fidic_fundoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundoInclude | null
    /**
     * The filter to search for the fidic_fundo to update in case it exists.
     * 
    **/
    where: fidic_fundoWhereUniqueInput
    /**
     * In case the fidic_fundo found by the `where` argument doesn't exist, create a new fidic_fundo with this data.
     * 
    **/
    create: XOR<fidic_fundoCreateInput, fidic_fundoUncheckedCreateInput>
    /**
     * In case the fidic_fundo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<fidic_fundoUpdateInput, fidic_fundoUncheckedUpdateInput>
  }


  /**
   * fidic_fundo delete
   */
  export type fidic_fundoDeleteArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo
     * 
    **/
    select?: fidic_fundoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundoInclude | null
    /**
     * Filter which fidic_fundo to delete.
     * 
    **/
    where: fidic_fundoWhereUniqueInput
  }


  /**
   * fidic_fundo deleteMany
   */
  export type fidic_fundoDeleteManyArgs = {
    /**
     * Filter which fidic_fundos to delete
     * 
    **/
    where?: fidic_fundoWhereInput
  }


  /**
   * fidic_fundo: findUniqueOrThrow
   */
  export type fidic_fundoFindUniqueOrThrowArgs = fidic_fundoFindUniqueArgsBase
      

  /**
   * fidic_fundo: findFirstOrThrow
   */
  export type fidic_fundoFindFirstOrThrowArgs = fidic_fundoFindFirstArgsBase
      

  /**
   * fidic_fundo without action
   */
  export type fidic_fundoArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo
     * 
    **/
    select?: fidic_fundoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundoInclude | null
  }



  /**
   * Model fidic_fundo_x_usuario
   */


  export type AggregateFidic_fundo_x_usuario = {
    _count: Fidic_fundo_x_usuarioCountAggregateOutputType | null
    _avg: Fidic_fundo_x_usuarioAvgAggregateOutputType | null
    _sum: Fidic_fundo_x_usuarioSumAggregateOutputType | null
    _min: Fidic_fundo_x_usuarioMinAggregateOutputType | null
    _max: Fidic_fundo_x_usuarioMaxAggregateOutputType | null
  }

  export type Fidic_fundo_x_usuarioAvgAggregateOutputType = {
    id: number | null
    usuario: number | null
    fidic: number | null
  }

  export type Fidic_fundo_x_usuarioSumAggregateOutputType = {
    id: number | null
    usuario: number | null
    fidic: number | null
  }

  export type Fidic_fundo_x_usuarioMinAggregateOutputType = {
    id: number | null
    usuario: number | null
    fidic: number | null
  }

  export type Fidic_fundo_x_usuarioMaxAggregateOutputType = {
    id: number | null
    usuario: number | null
    fidic: number | null
  }

  export type Fidic_fundo_x_usuarioCountAggregateOutputType = {
    id: number
    usuario: number
    fidic: number
    _all: number
  }


  export type Fidic_fundo_x_usuarioAvgAggregateInputType = {
    id?: true
    usuario?: true
    fidic?: true
  }

  export type Fidic_fundo_x_usuarioSumAggregateInputType = {
    id?: true
    usuario?: true
    fidic?: true
  }

  export type Fidic_fundo_x_usuarioMinAggregateInputType = {
    id?: true
    usuario?: true
    fidic?: true
  }

  export type Fidic_fundo_x_usuarioMaxAggregateInputType = {
    id?: true
    usuario?: true
    fidic?: true
  }

  export type Fidic_fundo_x_usuarioCountAggregateInputType = {
    id?: true
    usuario?: true
    fidic?: true
    _all?: true
  }

  export type Fidic_fundo_x_usuarioAggregateArgs = {
    /**
     * Filter which fidic_fundo_x_usuario to aggregate.
     * 
    **/
    where?: fidic_fundo_x_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fidic_fundo_x_usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<fidic_fundo_x_usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: fidic_fundo_x_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fidic_fundo_x_usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fidic_fundo_x_usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fidic_fundo_x_usuarios
    **/
    _count?: true | Fidic_fundo_x_usuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fidic_fundo_x_usuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fidic_fundo_x_usuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fidic_fundo_x_usuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fidic_fundo_x_usuarioMaxAggregateInputType
  }

  export type GetFidic_fundo_x_usuarioAggregateType<T extends Fidic_fundo_x_usuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateFidic_fundo_x_usuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFidic_fundo_x_usuario[P]>
      : GetScalarType<T[P], AggregateFidic_fundo_x_usuario[P]>
  }




  export type Fidic_fundo_x_usuarioGroupByArgs = {
    where?: fidic_fundo_x_usuarioWhereInput
    orderBy?: Enumerable<fidic_fundo_x_usuarioOrderByWithAggregationInput>
    by: Array<Fidic_fundo_x_usuarioScalarFieldEnum>
    having?: fidic_fundo_x_usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fidic_fundo_x_usuarioCountAggregateInputType | true
    _avg?: Fidic_fundo_x_usuarioAvgAggregateInputType
    _sum?: Fidic_fundo_x_usuarioSumAggregateInputType
    _min?: Fidic_fundo_x_usuarioMinAggregateInputType
    _max?: Fidic_fundo_x_usuarioMaxAggregateInputType
  }


  export type Fidic_fundo_x_usuarioGroupByOutputType = {
    id: number
    usuario: number | null
    fidic: number
    _count: Fidic_fundo_x_usuarioCountAggregateOutputType | null
    _avg: Fidic_fundo_x_usuarioAvgAggregateOutputType | null
    _sum: Fidic_fundo_x_usuarioSumAggregateOutputType | null
    _min: Fidic_fundo_x_usuarioMinAggregateOutputType | null
    _max: Fidic_fundo_x_usuarioMaxAggregateOutputType | null
  }

  type GetFidic_fundo_x_usuarioGroupByPayload<T extends Fidic_fundo_x_usuarioGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Fidic_fundo_x_usuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fidic_fundo_x_usuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fidic_fundo_x_usuarioGroupByOutputType[P]>
            : GetScalarType<T[P], Fidic_fundo_x_usuarioGroupByOutputType[P]>
        }
      >
    >


  export type fidic_fundo_x_usuarioSelect = {
    id?: boolean
    usuario?: boolean
    fidic?: boolean
    fidic_fundo?: boolean | fidic_fundoArgs
  }


  export type fidic_fundo_x_usuarioInclude = {
    fidic_fundo?: boolean | fidic_fundoArgs
  } 

  export type fidic_fundo_x_usuarioGetPayload<S extends boolean | null | undefined | fidic_fundo_x_usuarioArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? fidic_fundo_x_usuario :
    S extends undefined ? never :
    S extends { include: any } & (fidic_fundo_x_usuarioArgs | fidic_fundo_x_usuarioFindManyArgs)
    ? fidic_fundo_x_usuario  & {
    [P in TrueKeys<S['include']>]:
        P extends 'fidic_fundo' ? fidic_fundoGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (fidic_fundo_x_usuarioArgs | fidic_fundo_x_usuarioFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'fidic_fundo' ? fidic_fundoGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof fidic_fundo_x_usuario ? fidic_fundo_x_usuario[P] : never
  } 
      : fidic_fundo_x_usuario


  type fidic_fundo_x_usuarioCountArgs = Merge<
    Omit<fidic_fundo_x_usuarioFindManyArgs, 'select' | 'include'> & {
      select?: Fidic_fundo_x_usuarioCountAggregateInputType | true
    }
  >

  export interface fidic_fundo_x_usuarioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Fidic_fundo_x_usuario that matches the filter.
     * @param {fidic_fundo_x_usuarioFindUniqueArgs} args - Arguments to find a Fidic_fundo_x_usuario
     * @example
     * // Get one Fidic_fundo_x_usuario
     * const fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fidic_fundo_x_usuarioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fidic_fundo_x_usuarioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'fidic_fundo_x_usuario'> extends True ? Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T>> : Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T> | null, null>

    /**
     * Find the first Fidic_fundo_x_usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundo_x_usuarioFindFirstArgs} args - Arguments to find a Fidic_fundo_x_usuario
     * @example
     * // Get one Fidic_fundo_x_usuario
     * const fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fidic_fundo_x_usuarioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fidic_fundo_x_usuarioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'fidic_fundo_x_usuario'> extends True ? Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T>> : Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T> | null, null>

    /**
     * Find zero or more Fidic_fundo_x_usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundo_x_usuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fidic_fundo_x_usuarios
     * const fidic_fundo_x_usuarios = await prisma.fidic_fundo_x_usuario.findMany()
     * 
     * // Get first 10 Fidic_fundo_x_usuarios
     * const fidic_fundo_x_usuarios = await prisma.fidic_fundo_x_usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fidic_fundo_x_usuarioWithIdOnly = await prisma.fidic_fundo_x_usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fidic_fundo_x_usuarioFindManyArgs>(
      args?: SelectSubset<T, fidic_fundo_x_usuarioFindManyArgs>
    ): PrismaPromise<Array<fidic_fundo_x_usuarioGetPayload<T>>>

    /**
     * Create a Fidic_fundo_x_usuario.
     * @param {fidic_fundo_x_usuarioCreateArgs} args - Arguments to create a Fidic_fundo_x_usuario.
     * @example
     * // Create one Fidic_fundo_x_usuario
     * const Fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.create({
     *   data: {
     *     // ... data to create a Fidic_fundo_x_usuario
     *   }
     * })
     * 
    **/
    create<T extends fidic_fundo_x_usuarioCreateArgs>(
      args: SelectSubset<T, fidic_fundo_x_usuarioCreateArgs>
    ): Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T>>

    /**
     * Create many Fidic_fundo_x_usuarios.
     *     @param {fidic_fundo_x_usuarioCreateManyArgs} args - Arguments to create many Fidic_fundo_x_usuarios.
     *     @example
     *     // Create many Fidic_fundo_x_usuarios
     *     const fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends fidic_fundo_x_usuarioCreateManyArgs>(
      args?: SelectSubset<T, fidic_fundo_x_usuarioCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Fidic_fundo_x_usuario.
     * @param {fidic_fundo_x_usuarioDeleteArgs} args - Arguments to delete one Fidic_fundo_x_usuario.
     * @example
     * // Delete one Fidic_fundo_x_usuario
     * const Fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.delete({
     *   where: {
     *     // ... filter to delete one Fidic_fundo_x_usuario
     *   }
     * })
     * 
    **/
    delete<T extends fidic_fundo_x_usuarioDeleteArgs>(
      args: SelectSubset<T, fidic_fundo_x_usuarioDeleteArgs>
    ): Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T>>

    /**
     * Update one Fidic_fundo_x_usuario.
     * @param {fidic_fundo_x_usuarioUpdateArgs} args - Arguments to update one Fidic_fundo_x_usuario.
     * @example
     * // Update one Fidic_fundo_x_usuario
     * const fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fidic_fundo_x_usuarioUpdateArgs>(
      args: SelectSubset<T, fidic_fundo_x_usuarioUpdateArgs>
    ): Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T>>

    /**
     * Delete zero or more Fidic_fundo_x_usuarios.
     * @param {fidic_fundo_x_usuarioDeleteManyArgs} args - Arguments to filter Fidic_fundo_x_usuarios to delete.
     * @example
     * // Delete a few Fidic_fundo_x_usuarios
     * const { count } = await prisma.fidic_fundo_x_usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fidic_fundo_x_usuarioDeleteManyArgs>(
      args?: SelectSubset<T, fidic_fundo_x_usuarioDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fidic_fundo_x_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundo_x_usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fidic_fundo_x_usuarios
     * const fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fidic_fundo_x_usuarioUpdateManyArgs>(
      args: SelectSubset<T, fidic_fundo_x_usuarioUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Fidic_fundo_x_usuario.
     * @param {fidic_fundo_x_usuarioUpsertArgs} args - Arguments to update or create a Fidic_fundo_x_usuario.
     * @example
     * // Update or create a Fidic_fundo_x_usuario
     * const fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.upsert({
     *   create: {
     *     // ... data to create a Fidic_fundo_x_usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fidic_fundo_x_usuario we want to update
     *   }
     * })
    **/
    upsert<T extends fidic_fundo_x_usuarioUpsertArgs>(
      args: SelectSubset<T, fidic_fundo_x_usuarioUpsertArgs>
    ): Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T>>

    /**
     * Find one Fidic_fundo_x_usuario that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {fidic_fundo_x_usuarioFindUniqueOrThrowArgs} args - Arguments to find a Fidic_fundo_x_usuario
     * @example
     * // Get one Fidic_fundo_x_usuario
     * const fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fidic_fundo_x_usuarioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, fidic_fundo_x_usuarioFindUniqueOrThrowArgs>
    ): Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T>>

    /**
     * Find the first Fidic_fundo_x_usuario that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundo_x_usuarioFindFirstOrThrowArgs} args - Arguments to find a Fidic_fundo_x_usuario
     * @example
     * // Get one Fidic_fundo_x_usuario
     * const fidic_fundo_x_usuario = await prisma.fidic_fundo_x_usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fidic_fundo_x_usuarioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, fidic_fundo_x_usuarioFindFirstOrThrowArgs>
    ): Prisma__fidic_fundo_x_usuarioClient<fidic_fundo_x_usuarioGetPayload<T>>

    /**
     * Count the number of Fidic_fundo_x_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fidic_fundo_x_usuarioCountArgs} args - Arguments to filter Fidic_fundo_x_usuarios to count.
     * @example
     * // Count the number of Fidic_fundo_x_usuarios
     * const count = await prisma.fidic_fundo_x_usuario.count({
     *   where: {
     *     // ... the filter for the Fidic_fundo_x_usuarios we want to count
     *   }
     * })
    **/
    count<T extends fidic_fundo_x_usuarioCountArgs>(
      args?: Subset<T, fidic_fundo_x_usuarioCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fidic_fundo_x_usuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fidic_fundo_x_usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fidic_fundo_x_usuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fidic_fundo_x_usuarioAggregateArgs>(args: Subset<T, Fidic_fundo_x_usuarioAggregateArgs>): PrismaPromise<GetFidic_fundo_x_usuarioAggregateType<T>>

    /**
     * Group by Fidic_fundo_x_usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fidic_fundo_x_usuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Fidic_fundo_x_usuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Fidic_fundo_x_usuarioGroupByArgs['orderBy'] }
        : { orderBy?: Fidic_fundo_x_usuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Fidic_fundo_x_usuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFidic_fundo_x_usuarioGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for fidic_fundo_x_usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fidic_fundo_x_usuarioClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    fidic_fundo<T extends fidic_fundoArgs= {}>(args?: Subset<T, fidic_fundoArgs>): Prisma__fidic_fundoClient<fidic_fundoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * fidic_fundo_x_usuario base type for findUnique actions
   */
  export type fidic_fundo_x_usuarioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the fidic_fundo_x_usuario
     * 
    **/
    select?: fidic_fundo_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundo_x_usuarioInclude | null
    /**
     * Filter, which fidic_fundo_x_usuario to fetch.
     * 
    **/
    where: fidic_fundo_x_usuarioWhereUniqueInput
  }

  /**
   * fidic_fundo_x_usuario: findUnique
   */
  export interface fidic_fundo_x_usuarioFindUniqueArgs extends fidic_fundo_x_usuarioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fidic_fundo_x_usuario base type for findFirst actions
   */
  export type fidic_fundo_x_usuarioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the fidic_fundo_x_usuario
     * 
    **/
    select?: fidic_fundo_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundo_x_usuarioInclude | null
    /**
     * Filter, which fidic_fundo_x_usuario to fetch.
     * 
    **/
    where?: fidic_fundo_x_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fidic_fundo_x_usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<fidic_fundo_x_usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fidic_fundo_x_usuarios.
     * 
    **/
    cursor?: fidic_fundo_x_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fidic_fundo_x_usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fidic_fundo_x_usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fidic_fundo_x_usuarios.
     * 
    **/
    distinct?: Enumerable<Fidic_fundo_x_usuarioScalarFieldEnum>
  }

  /**
   * fidic_fundo_x_usuario: findFirst
   */
  export interface fidic_fundo_x_usuarioFindFirstArgs extends fidic_fundo_x_usuarioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * fidic_fundo_x_usuario findMany
   */
  export type fidic_fundo_x_usuarioFindManyArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_x_usuario
     * 
    **/
    select?: fidic_fundo_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundo_x_usuarioInclude | null
    /**
     * Filter, which fidic_fundo_x_usuarios to fetch.
     * 
    **/
    where?: fidic_fundo_x_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fidic_fundo_x_usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<fidic_fundo_x_usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fidic_fundo_x_usuarios.
     * 
    **/
    cursor?: fidic_fundo_x_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fidic_fundo_x_usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fidic_fundo_x_usuarios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Fidic_fundo_x_usuarioScalarFieldEnum>
  }


  /**
   * fidic_fundo_x_usuario create
   */
  export type fidic_fundo_x_usuarioCreateArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_x_usuario
     * 
    **/
    select?: fidic_fundo_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundo_x_usuarioInclude | null
    /**
     * The data needed to create a fidic_fundo_x_usuario.
     * 
    **/
    data: XOR<fidic_fundo_x_usuarioCreateInput, fidic_fundo_x_usuarioUncheckedCreateInput>
  }


  /**
   * fidic_fundo_x_usuario createMany
   */
  export type fidic_fundo_x_usuarioCreateManyArgs = {
    /**
     * The data used to create many fidic_fundo_x_usuarios.
     * 
    **/
    data: Enumerable<fidic_fundo_x_usuarioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * fidic_fundo_x_usuario update
   */
  export type fidic_fundo_x_usuarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_x_usuario
     * 
    **/
    select?: fidic_fundo_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundo_x_usuarioInclude | null
    /**
     * The data needed to update a fidic_fundo_x_usuario.
     * 
    **/
    data: XOR<fidic_fundo_x_usuarioUpdateInput, fidic_fundo_x_usuarioUncheckedUpdateInput>
    /**
     * Choose, which fidic_fundo_x_usuario to update.
     * 
    **/
    where: fidic_fundo_x_usuarioWhereUniqueInput
  }


  /**
   * fidic_fundo_x_usuario updateMany
   */
  export type fidic_fundo_x_usuarioUpdateManyArgs = {
    /**
     * The data used to update fidic_fundo_x_usuarios.
     * 
    **/
    data: XOR<fidic_fundo_x_usuarioUpdateManyMutationInput, fidic_fundo_x_usuarioUncheckedUpdateManyInput>
    /**
     * Filter which fidic_fundo_x_usuarios to update
     * 
    **/
    where?: fidic_fundo_x_usuarioWhereInput
  }


  /**
   * fidic_fundo_x_usuario upsert
   */
  export type fidic_fundo_x_usuarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_x_usuario
     * 
    **/
    select?: fidic_fundo_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundo_x_usuarioInclude | null
    /**
     * The filter to search for the fidic_fundo_x_usuario to update in case it exists.
     * 
    **/
    where: fidic_fundo_x_usuarioWhereUniqueInput
    /**
     * In case the fidic_fundo_x_usuario found by the `where` argument doesn't exist, create a new fidic_fundo_x_usuario with this data.
     * 
    **/
    create: XOR<fidic_fundo_x_usuarioCreateInput, fidic_fundo_x_usuarioUncheckedCreateInput>
    /**
     * In case the fidic_fundo_x_usuario was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<fidic_fundo_x_usuarioUpdateInput, fidic_fundo_x_usuarioUncheckedUpdateInput>
  }


  /**
   * fidic_fundo_x_usuario delete
   */
  export type fidic_fundo_x_usuarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_x_usuario
     * 
    **/
    select?: fidic_fundo_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundo_x_usuarioInclude | null
    /**
     * Filter which fidic_fundo_x_usuario to delete.
     * 
    **/
    where: fidic_fundo_x_usuarioWhereUniqueInput
  }


  /**
   * fidic_fundo_x_usuario deleteMany
   */
  export type fidic_fundo_x_usuarioDeleteManyArgs = {
    /**
     * Filter which fidic_fundo_x_usuarios to delete
     * 
    **/
    where?: fidic_fundo_x_usuarioWhereInput
  }


  /**
   * fidic_fundo_x_usuario: findUniqueOrThrow
   */
  export type fidic_fundo_x_usuarioFindUniqueOrThrowArgs = fidic_fundo_x_usuarioFindUniqueArgsBase
      

  /**
   * fidic_fundo_x_usuario: findFirstOrThrow
   */
  export type fidic_fundo_x_usuarioFindFirstOrThrowArgs = fidic_fundo_x_usuarioFindFirstArgsBase
      

  /**
   * fidic_fundo_x_usuario without action
   */
  export type fidic_fundo_x_usuarioArgs = {
    /**
     * Select specific fields to fetch from the fidic_fundo_x_usuario
     * 
    **/
    select?: fidic_fundo_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: fidic_fundo_x_usuarioInclude | null
  }



  /**
   * Model organograma
   */


  export type AggregateOrganograma = {
    _count: OrganogramaCountAggregateOutputType | null
    _avg: OrganogramaAvgAggregateOutputType | null
    _sum: OrganogramaSumAggregateOutputType | null
    _min: OrganogramaMinAggregateOutputType | null
    _max: OrganogramaMaxAggregateOutputType | null
  }

  export type OrganogramaAvgAggregateOutputType = {
    id: number | null
    organograma_id: number | null
  }

  export type OrganogramaSumAggregateOutputType = {
    id: number | null
    organograma_id: number | null
  }

  export type OrganogramaMinAggregateOutputType = {
    id: number | null
    organograma_id: number | null
  }

  export type OrganogramaMaxAggregateOutputType = {
    id: number | null
    organograma_id: number | null
  }

  export type OrganogramaCountAggregateOutputType = {
    id: number
    organograma_id: number
    _all: number
  }


  export type OrganogramaAvgAggregateInputType = {
    id?: true
    organograma_id?: true
  }

  export type OrganogramaSumAggregateInputType = {
    id?: true
    organograma_id?: true
  }

  export type OrganogramaMinAggregateInputType = {
    id?: true
    organograma_id?: true
  }

  export type OrganogramaMaxAggregateInputType = {
    id?: true
    organograma_id?: true
  }

  export type OrganogramaCountAggregateInputType = {
    id?: true
    organograma_id?: true
    _all?: true
  }

  export type OrganogramaAggregateArgs = {
    /**
     * Filter which organograma to aggregate.
     * 
    **/
    where?: organogramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organogramas to fetch.
     * 
    **/
    orderBy?: Enumerable<organogramaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: organogramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organogramas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organogramas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organogramas
    **/
    _count?: true | OrganogramaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganogramaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganogramaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganogramaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganogramaMaxAggregateInputType
  }

  export type GetOrganogramaAggregateType<T extends OrganogramaAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganograma]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganograma[P]>
      : GetScalarType<T[P], AggregateOrganograma[P]>
  }




  export type OrganogramaGroupByArgs = {
    where?: organogramaWhereInput
    orderBy?: Enumerable<organogramaOrderByWithAggregationInput>
    by: Array<OrganogramaScalarFieldEnum>
    having?: organogramaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganogramaCountAggregateInputType | true
    _avg?: OrganogramaAvgAggregateInputType
    _sum?: OrganogramaSumAggregateInputType
    _min?: OrganogramaMinAggregateInputType
    _max?: OrganogramaMaxAggregateInputType
  }


  export type OrganogramaGroupByOutputType = {
    id: number
    organograma_id: number
    _count: OrganogramaCountAggregateOutputType | null
    _avg: OrganogramaAvgAggregateOutputType | null
    _sum: OrganogramaSumAggregateOutputType | null
    _min: OrganogramaMinAggregateOutputType | null
    _max: OrganogramaMaxAggregateOutputType | null
  }

  type GetOrganogramaGroupByPayload<T extends OrganogramaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrganogramaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganogramaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganogramaGroupByOutputType[P]>
            : GetScalarType<T[P], OrganogramaGroupByOutputType[P]>
        }
      >
    >


  export type organogramaSelect = {
    id?: boolean
    organograma_id?: boolean
    organograma_tipo?: boolean | organograma_tipoArgs
    organograma_x_regiao_atuacao?: boolean | organograma_x_regiao_atuacaoFindManyArgs
    organograma_x_usuario?: boolean | organograma_x_usuarioFindManyArgs
    _count?: boolean | OrganogramaCountOutputTypeArgs
  }


  export type organogramaInclude = {
    organograma_tipo?: boolean | organograma_tipoArgs
    organograma_x_regiao_atuacao?: boolean | organograma_x_regiao_atuacaoFindManyArgs
    organograma_x_usuario?: boolean | organograma_x_usuarioFindManyArgs
    _count?: boolean | OrganogramaCountOutputTypeArgs
  } 

  export type organogramaGetPayload<S extends boolean | null | undefined | organogramaArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? organograma :
    S extends undefined ? never :
    S extends { include: any } & (organogramaArgs | organogramaFindManyArgs)
    ? organograma  & {
    [P in TrueKeys<S['include']>]:
        P extends 'organograma_tipo' ? organograma_tipoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'organograma_x_regiao_atuacao' ? Array < organograma_x_regiao_atuacaoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'organograma_x_usuario' ? Array < organograma_x_usuarioGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? OrganogramaCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (organogramaArgs | organogramaFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'organograma_tipo' ? organograma_tipoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'organograma_x_regiao_atuacao' ? Array < organograma_x_regiao_atuacaoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'organograma_x_usuario' ? Array < organograma_x_usuarioGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? OrganogramaCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof organograma ? organograma[P] : never
  } 
      : organograma


  type organogramaCountArgs = Merge<
    Omit<organogramaFindManyArgs, 'select' | 'include'> & {
      select?: OrganogramaCountAggregateInputType | true
    }
  >

  export interface organogramaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Organograma that matches the filter.
     * @param {organogramaFindUniqueArgs} args - Arguments to find a Organograma
     * @example
     * // Get one Organograma
     * const organograma = await prisma.organograma.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends organogramaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, organogramaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'organograma'> extends True ? Prisma__organogramaClient<organogramaGetPayload<T>> : Prisma__organogramaClient<organogramaGetPayload<T> | null, null>

    /**
     * Find the first Organograma that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organogramaFindFirstArgs} args - Arguments to find a Organograma
     * @example
     * // Get one Organograma
     * const organograma = await prisma.organograma.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends organogramaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, organogramaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'organograma'> extends True ? Prisma__organogramaClient<organogramaGetPayload<T>> : Prisma__organogramaClient<organogramaGetPayload<T> | null, null>

    /**
     * Find zero or more Organogramas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organogramaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organogramas
     * const organogramas = await prisma.organograma.findMany()
     * 
     * // Get first 10 Organogramas
     * const organogramas = await prisma.organograma.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organogramaWithIdOnly = await prisma.organograma.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends organogramaFindManyArgs>(
      args?: SelectSubset<T, organogramaFindManyArgs>
    ): PrismaPromise<Array<organogramaGetPayload<T>>>

    /**
     * Create a Organograma.
     * @param {organogramaCreateArgs} args - Arguments to create a Organograma.
     * @example
     * // Create one Organograma
     * const Organograma = await prisma.organograma.create({
     *   data: {
     *     // ... data to create a Organograma
     *   }
     * })
     * 
    **/
    create<T extends organogramaCreateArgs>(
      args: SelectSubset<T, organogramaCreateArgs>
    ): Prisma__organogramaClient<organogramaGetPayload<T>>

    /**
     * Create many Organogramas.
     *     @param {organogramaCreateManyArgs} args - Arguments to create many Organogramas.
     *     @example
     *     // Create many Organogramas
     *     const organograma = await prisma.organograma.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends organogramaCreateManyArgs>(
      args?: SelectSubset<T, organogramaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Organograma.
     * @param {organogramaDeleteArgs} args - Arguments to delete one Organograma.
     * @example
     * // Delete one Organograma
     * const Organograma = await prisma.organograma.delete({
     *   where: {
     *     // ... filter to delete one Organograma
     *   }
     * })
     * 
    **/
    delete<T extends organogramaDeleteArgs>(
      args: SelectSubset<T, organogramaDeleteArgs>
    ): Prisma__organogramaClient<organogramaGetPayload<T>>

    /**
     * Update one Organograma.
     * @param {organogramaUpdateArgs} args - Arguments to update one Organograma.
     * @example
     * // Update one Organograma
     * const organograma = await prisma.organograma.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends organogramaUpdateArgs>(
      args: SelectSubset<T, organogramaUpdateArgs>
    ): Prisma__organogramaClient<organogramaGetPayload<T>>

    /**
     * Delete zero or more Organogramas.
     * @param {organogramaDeleteManyArgs} args - Arguments to filter Organogramas to delete.
     * @example
     * // Delete a few Organogramas
     * const { count } = await prisma.organograma.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends organogramaDeleteManyArgs>(
      args?: SelectSubset<T, organogramaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organogramas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organogramaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organogramas
     * const organograma = await prisma.organograma.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends organogramaUpdateManyArgs>(
      args: SelectSubset<T, organogramaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Organograma.
     * @param {organogramaUpsertArgs} args - Arguments to update or create a Organograma.
     * @example
     * // Update or create a Organograma
     * const organograma = await prisma.organograma.upsert({
     *   create: {
     *     // ... data to create a Organograma
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organograma we want to update
     *   }
     * })
    **/
    upsert<T extends organogramaUpsertArgs>(
      args: SelectSubset<T, organogramaUpsertArgs>
    ): Prisma__organogramaClient<organogramaGetPayload<T>>

    /**
     * Find one Organograma that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {organogramaFindUniqueOrThrowArgs} args - Arguments to find a Organograma
     * @example
     * // Get one Organograma
     * const organograma = await prisma.organograma.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends organogramaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, organogramaFindUniqueOrThrowArgs>
    ): Prisma__organogramaClient<organogramaGetPayload<T>>

    /**
     * Find the first Organograma that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organogramaFindFirstOrThrowArgs} args - Arguments to find a Organograma
     * @example
     * // Get one Organograma
     * const organograma = await prisma.organograma.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends organogramaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, organogramaFindFirstOrThrowArgs>
    ): Prisma__organogramaClient<organogramaGetPayload<T>>

    /**
     * Count the number of Organogramas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organogramaCountArgs} args - Arguments to filter Organogramas to count.
     * @example
     * // Count the number of Organogramas
     * const count = await prisma.organograma.count({
     *   where: {
     *     // ... the filter for the Organogramas we want to count
     *   }
     * })
    **/
    count<T extends organogramaCountArgs>(
      args?: Subset<T, organogramaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganogramaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organograma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganogramaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganogramaAggregateArgs>(args: Subset<T, OrganogramaAggregateArgs>): PrismaPromise<GetOrganogramaAggregateType<T>>

    /**
     * Group by Organograma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganogramaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganogramaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganogramaGroupByArgs['orderBy'] }
        : { orderBy?: OrganogramaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganogramaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganogramaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for organograma.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__organogramaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organograma_tipo<T extends organograma_tipoArgs= {}>(args?: Subset<T, organograma_tipoArgs>): Prisma__organograma_tipoClient<organograma_tipoGetPayload<T> | Null>;

    organograma_x_regiao_atuacao<T extends organograma_x_regiao_atuacaoFindManyArgs= {}>(args?: Subset<T, organograma_x_regiao_atuacaoFindManyArgs>): PrismaPromise<Array<organograma_x_regiao_atuacaoGetPayload<T>>| Null>;

    organograma_x_usuario<T extends organograma_x_usuarioFindManyArgs= {}>(args?: Subset<T, organograma_x_usuarioFindManyArgs>): PrismaPromise<Array<organograma_x_usuarioGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * organograma base type for findUnique actions
   */
  export type organogramaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the organograma
     * 
    **/
    select?: organogramaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organogramaInclude | null
    /**
     * Filter, which organograma to fetch.
     * 
    **/
    where: organogramaWhereUniqueInput
  }

  /**
   * organograma: findUnique
   */
  export interface organogramaFindUniqueArgs extends organogramaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organograma base type for findFirst actions
   */
  export type organogramaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the organograma
     * 
    **/
    select?: organogramaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organogramaInclude | null
    /**
     * Filter, which organograma to fetch.
     * 
    **/
    where?: organogramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organogramas to fetch.
     * 
    **/
    orderBy?: Enumerable<organogramaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organogramas.
     * 
    **/
    cursor?: organogramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organogramas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organogramas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organogramas.
     * 
    **/
    distinct?: Enumerable<OrganogramaScalarFieldEnum>
  }

  /**
   * organograma: findFirst
   */
  export interface organogramaFindFirstArgs extends organogramaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organograma findMany
   */
  export type organogramaFindManyArgs = {
    /**
     * Select specific fields to fetch from the organograma
     * 
    **/
    select?: organogramaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organogramaInclude | null
    /**
     * Filter, which organogramas to fetch.
     * 
    **/
    where?: organogramaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organogramas to fetch.
     * 
    **/
    orderBy?: Enumerable<organogramaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organogramas.
     * 
    **/
    cursor?: organogramaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organogramas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organogramas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrganogramaScalarFieldEnum>
  }


  /**
   * organograma create
   */
  export type organogramaCreateArgs = {
    /**
     * Select specific fields to fetch from the organograma
     * 
    **/
    select?: organogramaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organogramaInclude | null
    /**
     * The data needed to create a organograma.
     * 
    **/
    data: XOR<organogramaCreateInput, organogramaUncheckedCreateInput>
  }


  /**
   * organograma createMany
   */
  export type organogramaCreateManyArgs = {
    /**
     * The data used to create many organogramas.
     * 
    **/
    data: Enumerable<organogramaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * organograma update
   */
  export type organogramaUpdateArgs = {
    /**
     * Select specific fields to fetch from the organograma
     * 
    **/
    select?: organogramaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organogramaInclude | null
    /**
     * The data needed to update a organograma.
     * 
    **/
    data: XOR<organogramaUpdateInput, organogramaUncheckedUpdateInput>
    /**
     * Choose, which organograma to update.
     * 
    **/
    where: organogramaWhereUniqueInput
  }


  /**
   * organograma updateMany
   */
  export type organogramaUpdateManyArgs = {
    /**
     * The data used to update organogramas.
     * 
    **/
    data: XOR<organogramaUpdateManyMutationInput, organogramaUncheckedUpdateManyInput>
    /**
     * Filter which organogramas to update
     * 
    **/
    where?: organogramaWhereInput
  }


  /**
   * organograma upsert
   */
  export type organogramaUpsertArgs = {
    /**
     * Select specific fields to fetch from the organograma
     * 
    **/
    select?: organogramaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organogramaInclude | null
    /**
     * The filter to search for the organograma to update in case it exists.
     * 
    **/
    where: organogramaWhereUniqueInput
    /**
     * In case the organograma found by the `where` argument doesn't exist, create a new organograma with this data.
     * 
    **/
    create: XOR<organogramaCreateInput, organogramaUncheckedCreateInput>
    /**
     * In case the organograma was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<organogramaUpdateInput, organogramaUncheckedUpdateInput>
  }


  /**
   * organograma delete
   */
  export type organogramaDeleteArgs = {
    /**
     * Select specific fields to fetch from the organograma
     * 
    **/
    select?: organogramaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organogramaInclude | null
    /**
     * Filter which organograma to delete.
     * 
    **/
    where: organogramaWhereUniqueInput
  }


  /**
   * organograma deleteMany
   */
  export type organogramaDeleteManyArgs = {
    /**
     * Filter which organogramas to delete
     * 
    **/
    where?: organogramaWhereInput
  }


  /**
   * organograma: findUniqueOrThrow
   */
  export type organogramaFindUniqueOrThrowArgs = organogramaFindUniqueArgsBase
      

  /**
   * organograma: findFirstOrThrow
   */
  export type organogramaFindFirstOrThrowArgs = organogramaFindFirstArgsBase
      

  /**
   * organograma without action
   */
  export type organogramaArgs = {
    /**
     * Select specific fields to fetch from the organograma
     * 
    **/
    select?: organogramaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organogramaInclude | null
  }



  /**
   * Model organograma_tipo
   */


  export type AggregateOrganograma_tipo = {
    _count: Organograma_tipoCountAggregateOutputType | null
    _avg: Organograma_tipoAvgAggregateOutputType | null
    _sum: Organograma_tipoSumAggregateOutputType | null
    _min: Organograma_tipoMinAggregateOutputType | null
    _max: Organograma_tipoMaxAggregateOutputType | null
  }

  export type Organograma_tipoAvgAggregateOutputType = {
    id: number | null
  }

  export type Organograma_tipoSumAggregateOutputType = {
    id: number | null
  }

  export type Organograma_tipoMinAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Organograma_tipoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Organograma_tipoCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type Organograma_tipoAvgAggregateInputType = {
    id?: true
  }

  export type Organograma_tipoSumAggregateInputType = {
    id?: true
  }

  export type Organograma_tipoMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Organograma_tipoMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Organograma_tipoCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type Organograma_tipoAggregateArgs = {
    /**
     * Filter which organograma_tipo to aggregate.
     * 
    **/
    where?: organograma_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: organograma_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organograma_tipos
    **/
    _count?: true | Organograma_tipoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Organograma_tipoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Organograma_tipoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Organograma_tipoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Organograma_tipoMaxAggregateInputType
  }

  export type GetOrganograma_tipoAggregateType<T extends Organograma_tipoAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganograma_tipo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganograma_tipo[P]>
      : GetScalarType<T[P], AggregateOrganograma_tipo[P]>
  }




  export type Organograma_tipoGroupByArgs = {
    where?: organograma_tipoWhereInput
    orderBy?: Enumerable<organograma_tipoOrderByWithAggregationInput>
    by: Array<Organograma_tipoScalarFieldEnum>
    having?: organograma_tipoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Organograma_tipoCountAggregateInputType | true
    _avg?: Organograma_tipoAvgAggregateInputType
    _sum?: Organograma_tipoSumAggregateInputType
    _min?: Organograma_tipoMinAggregateInputType
    _max?: Organograma_tipoMaxAggregateInputType
  }


  export type Organograma_tipoGroupByOutputType = {
    id: number
    nome: string
    _count: Organograma_tipoCountAggregateOutputType | null
    _avg: Organograma_tipoAvgAggregateOutputType | null
    _sum: Organograma_tipoSumAggregateOutputType | null
    _min: Organograma_tipoMinAggregateOutputType | null
    _max: Organograma_tipoMaxAggregateOutputType | null
  }

  type GetOrganograma_tipoGroupByPayload<T extends Organograma_tipoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Organograma_tipoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Organograma_tipoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Organograma_tipoGroupByOutputType[P]>
            : GetScalarType<T[P], Organograma_tipoGroupByOutputType[P]>
        }
      >
    >


  export type organograma_tipoSelect = {
    id?: boolean
    nome?: boolean
    organograma?: boolean | organogramaFindManyArgs
    _count?: boolean | Organograma_tipoCountOutputTypeArgs
  }


  export type organograma_tipoInclude = {
    organograma?: boolean | organogramaFindManyArgs
    _count?: boolean | Organograma_tipoCountOutputTypeArgs
  } 

  export type organograma_tipoGetPayload<S extends boolean | null | undefined | organograma_tipoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? organograma_tipo :
    S extends undefined ? never :
    S extends { include: any } & (organograma_tipoArgs | organograma_tipoFindManyArgs)
    ? organograma_tipo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'organograma' ? Array < organogramaGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Organograma_tipoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (organograma_tipoArgs | organograma_tipoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'organograma' ? Array < organogramaGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Organograma_tipoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof organograma_tipo ? organograma_tipo[P] : never
  } 
      : organograma_tipo


  type organograma_tipoCountArgs = Merge<
    Omit<organograma_tipoFindManyArgs, 'select' | 'include'> & {
      select?: Organograma_tipoCountAggregateInputType | true
    }
  >

  export interface organograma_tipoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Organograma_tipo that matches the filter.
     * @param {organograma_tipoFindUniqueArgs} args - Arguments to find a Organograma_tipo
     * @example
     * // Get one Organograma_tipo
     * const organograma_tipo = await prisma.organograma_tipo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends organograma_tipoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, organograma_tipoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'organograma_tipo'> extends True ? Prisma__organograma_tipoClient<organograma_tipoGetPayload<T>> : Prisma__organograma_tipoClient<organograma_tipoGetPayload<T> | null, null>

    /**
     * Find the first Organograma_tipo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_tipoFindFirstArgs} args - Arguments to find a Organograma_tipo
     * @example
     * // Get one Organograma_tipo
     * const organograma_tipo = await prisma.organograma_tipo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends organograma_tipoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, organograma_tipoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'organograma_tipo'> extends True ? Prisma__organograma_tipoClient<organograma_tipoGetPayload<T>> : Prisma__organograma_tipoClient<organograma_tipoGetPayload<T> | null, null>

    /**
     * Find zero or more Organograma_tipos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_tipoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organograma_tipos
     * const organograma_tipos = await prisma.organograma_tipo.findMany()
     * 
     * // Get first 10 Organograma_tipos
     * const organograma_tipos = await prisma.organograma_tipo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organograma_tipoWithIdOnly = await prisma.organograma_tipo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends organograma_tipoFindManyArgs>(
      args?: SelectSubset<T, organograma_tipoFindManyArgs>
    ): PrismaPromise<Array<organograma_tipoGetPayload<T>>>

    /**
     * Create a Organograma_tipo.
     * @param {organograma_tipoCreateArgs} args - Arguments to create a Organograma_tipo.
     * @example
     * // Create one Organograma_tipo
     * const Organograma_tipo = await prisma.organograma_tipo.create({
     *   data: {
     *     // ... data to create a Organograma_tipo
     *   }
     * })
     * 
    **/
    create<T extends organograma_tipoCreateArgs>(
      args: SelectSubset<T, organograma_tipoCreateArgs>
    ): Prisma__organograma_tipoClient<organograma_tipoGetPayload<T>>

    /**
     * Create many Organograma_tipos.
     *     @param {organograma_tipoCreateManyArgs} args - Arguments to create many Organograma_tipos.
     *     @example
     *     // Create many Organograma_tipos
     *     const organograma_tipo = await prisma.organograma_tipo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends organograma_tipoCreateManyArgs>(
      args?: SelectSubset<T, organograma_tipoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Organograma_tipo.
     * @param {organograma_tipoDeleteArgs} args - Arguments to delete one Organograma_tipo.
     * @example
     * // Delete one Organograma_tipo
     * const Organograma_tipo = await prisma.organograma_tipo.delete({
     *   where: {
     *     // ... filter to delete one Organograma_tipo
     *   }
     * })
     * 
    **/
    delete<T extends organograma_tipoDeleteArgs>(
      args: SelectSubset<T, organograma_tipoDeleteArgs>
    ): Prisma__organograma_tipoClient<organograma_tipoGetPayload<T>>

    /**
     * Update one Organograma_tipo.
     * @param {organograma_tipoUpdateArgs} args - Arguments to update one Organograma_tipo.
     * @example
     * // Update one Organograma_tipo
     * const organograma_tipo = await prisma.organograma_tipo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends organograma_tipoUpdateArgs>(
      args: SelectSubset<T, organograma_tipoUpdateArgs>
    ): Prisma__organograma_tipoClient<organograma_tipoGetPayload<T>>

    /**
     * Delete zero or more Organograma_tipos.
     * @param {organograma_tipoDeleteManyArgs} args - Arguments to filter Organograma_tipos to delete.
     * @example
     * // Delete a few Organograma_tipos
     * const { count } = await prisma.organograma_tipo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends organograma_tipoDeleteManyArgs>(
      args?: SelectSubset<T, organograma_tipoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organograma_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_tipoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organograma_tipos
     * const organograma_tipo = await prisma.organograma_tipo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends organograma_tipoUpdateManyArgs>(
      args: SelectSubset<T, organograma_tipoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Organograma_tipo.
     * @param {organograma_tipoUpsertArgs} args - Arguments to update or create a Organograma_tipo.
     * @example
     * // Update or create a Organograma_tipo
     * const organograma_tipo = await prisma.organograma_tipo.upsert({
     *   create: {
     *     // ... data to create a Organograma_tipo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organograma_tipo we want to update
     *   }
     * })
    **/
    upsert<T extends organograma_tipoUpsertArgs>(
      args: SelectSubset<T, organograma_tipoUpsertArgs>
    ): Prisma__organograma_tipoClient<organograma_tipoGetPayload<T>>

    /**
     * Find one Organograma_tipo that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {organograma_tipoFindUniqueOrThrowArgs} args - Arguments to find a Organograma_tipo
     * @example
     * // Get one Organograma_tipo
     * const organograma_tipo = await prisma.organograma_tipo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends organograma_tipoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, organograma_tipoFindUniqueOrThrowArgs>
    ): Prisma__organograma_tipoClient<organograma_tipoGetPayload<T>>

    /**
     * Find the first Organograma_tipo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_tipoFindFirstOrThrowArgs} args - Arguments to find a Organograma_tipo
     * @example
     * // Get one Organograma_tipo
     * const organograma_tipo = await prisma.organograma_tipo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends organograma_tipoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, organograma_tipoFindFirstOrThrowArgs>
    ): Prisma__organograma_tipoClient<organograma_tipoGetPayload<T>>

    /**
     * Count the number of Organograma_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_tipoCountArgs} args - Arguments to filter Organograma_tipos to count.
     * @example
     * // Count the number of Organograma_tipos
     * const count = await prisma.organograma_tipo.count({
     *   where: {
     *     // ... the filter for the Organograma_tipos we want to count
     *   }
     * })
    **/
    count<T extends organograma_tipoCountArgs>(
      args?: Subset<T, organograma_tipoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Organograma_tipoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organograma_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Organograma_tipoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Organograma_tipoAggregateArgs>(args: Subset<T, Organograma_tipoAggregateArgs>): PrismaPromise<GetOrganograma_tipoAggregateType<T>>

    /**
     * Group by Organograma_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Organograma_tipoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Organograma_tipoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Organograma_tipoGroupByArgs['orderBy'] }
        : { orderBy?: Organograma_tipoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Organograma_tipoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganograma_tipoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for organograma_tipo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__organograma_tipoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organograma<T extends organogramaFindManyArgs= {}>(args?: Subset<T, organogramaFindManyArgs>): PrismaPromise<Array<organogramaGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * organograma_tipo base type for findUnique actions
   */
  export type organograma_tipoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the organograma_tipo
     * 
    **/
    select?: organograma_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_tipoInclude | null
    /**
     * Filter, which organograma_tipo to fetch.
     * 
    **/
    where: organograma_tipoWhereUniqueInput
  }

  /**
   * organograma_tipo: findUnique
   */
  export interface organograma_tipoFindUniqueArgs extends organograma_tipoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organograma_tipo base type for findFirst actions
   */
  export type organograma_tipoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the organograma_tipo
     * 
    **/
    select?: organograma_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_tipoInclude | null
    /**
     * Filter, which organograma_tipo to fetch.
     * 
    **/
    where?: organograma_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organograma_tipos.
     * 
    **/
    cursor?: organograma_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organograma_tipos.
     * 
    **/
    distinct?: Enumerable<Organograma_tipoScalarFieldEnum>
  }

  /**
   * organograma_tipo: findFirst
   */
  export interface organograma_tipoFindFirstArgs extends organograma_tipoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organograma_tipo findMany
   */
  export type organograma_tipoFindManyArgs = {
    /**
     * Select specific fields to fetch from the organograma_tipo
     * 
    **/
    select?: organograma_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_tipoInclude | null
    /**
     * Filter, which organograma_tipos to fetch.
     * 
    **/
    where?: organograma_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organograma_tipos.
     * 
    **/
    cursor?: organograma_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_tipos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Organograma_tipoScalarFieldEnum>
  }


  /**
   * organograma_tipo create
   */
  export type organograma_tipoCreateArgs = {
    /**
     * Select specific fields to fetch from the organograma_tipo
     * 
    **/
    select?: organograma_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_tipoInclude | null
    /**
     * The data needed to create a organograma_tipo.
     * 
    **/
    data: XOR<organograma_tipoCreateInput, organograma_tipoUncheckedCreateInput>
  }


  /**
   * organograma_tipo createMany
   */
  export type organograma_tipoCreateManyArgs = {
    /**
     * The data used to create many organograma_tipos.
     * 
    **/
    data: Enumerable<organograma_tipoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * organograma_tipo update
   */
  export type organograma_tipoUpdateArgs = {
    /**
     * Select specific fields to fetch from the organograma_tipo
     * 
    **/
    select?: organograma_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_tipoInclude | null
    /**
     * The data needed to update a organograma_tipo.
     * 
    **/
    data: XOR<organograma_tipoUpdateInput, organograma_tipoUncheckedUpdateInput>
    /**
     * Choose, which organograma_tipo to update.
     * 
    **/
    where: organograma_tipoWhereUniqueInput
  }


  /**
   * organograma_tipo updateMany
   */
  export type organograma_tipoUpdateManyArgs = {
    /**
     * The data used to update organograma_tipos.
     * 
    **/
    data: XOR<organograma_tipoUpdateManyMutationInput, organograma_tipoUncheckedUpdateManyInput>
    /**
     * Filter which organograma_tipos to update
     * 
    **/
    where?: organograma_tipoWhereInput
  }


  /**
   * organograma_tipo upsert
   */
  export type organograma_tipoUpsertArgs = {
    /**
     * Select specific fields to fetch from the organograma_tipo
     * 
    **/
    select?: organograma_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_tipoInclude | null
    /**
     * The filter to search for the organograma_tipo to update in case it exists.
     * 
    **/
    where: organograma_tipoWhereUniqueInput
    /**
     * In case the organograma_tipo found by the `where` argument doesn't exist, create a new organograma_tipo with this data.
     * 
    **/
    create: XOR<organograma_tipoCreateInput, organograma_tipoUncheckedCreateInput>
    /**
     * In case the organograma_tipo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<organograma_tipoUpdateInput, organograma_tipoUncheckedUpdateInput>
  }


  /**
   * organograma_tipo delete
   */
  export type organograma_tipoDeleteArgs = {
    /**
     * Select specific fields to fetch from the organograma_tipo
     * 
    **/
    select?: organograma_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_tipoInclude | null
    /**
     * Filter which organograma_tipo to delete.
     * 
    **/
    where: organograma_tipoWhereUniqueInput
  }


  /**
   * organograma_tipo deleteMany
   */
  export type organograma_tipoDeleteManyArgs = {
    /**
     * Filter which organograma_tipos to delete
     * 
    **/
    where?: organograma_tipoWhereInput
  }


  /**
   * organograma_tipo: findUniqueOrThrow
   */
  export type organograma_tipoFindUniqueOrThrowArgs = organograma_tipoFindUniqueArgsBase
      

  /**
   * organograma_tipo: findFirstOrThrow
   */
  export type organograma_tipoFindFirstOrThrowArgs = organograma_tipoFindFirstArgsBase
      

  /**
   * organograma_tipo without action
   */
  export type organograma_tipoArgs = {
    /**
     * Select specific fields to fetch from the organograma_tipo
     * 
    **/
    select?: organograma_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_tipoInclude | null
  }



  /**
   * Model organograma_x_regiao_atuacao
   */


  export type AggregateOrganograma_x_regiao_atuacao = {
    _count: Organograma_x_regiao_atuacaoCountAggregateOutputType | null
    _avg: Organograma_x_regiao_atuacaoAvgAggregateOutputType | null
    _sum: Organograma_x_regiao_atuacaoSumAggregateOutputType | null
    _min: Organograma_x_regiao_atuacaoMinAggregateOutputType | null
    _max: Organograma_x_regiao_atuacaoMaxAggregateOutputType | null
  }

  export type Organograma_x_regiao_atuacaoAvgAggregateOutputType = {
    id: number | null
    organograma_id: number | null
    regiao_atuacao_id: number | null
  }

  export type Organograma_x_regiao_atuacaoSumAggregateOutputType = {
    id: number | null
    organograma_id: number | null
    regiao_atuacao_id: number | null
  }

  export type Organograma_x_regiao_atuacaoMinAggregateOutputType = {
    id: number | null
    organograma_id: number | null
    regiao_atuacao_id: number | null
  }

  export type Organograma_x_regiao_atuacaoMaxAggregateOutputType = {
    id: number | null
    organograma_id: number | null
    regiao_atuacao_id: number | null
  }

  export type Organograma_x_regiao_atuacaoCountAggregateOutputType = {
    id: number
    organograma_id: number
    regiao_atuacao_id: number
    _all: number
  }


  export type Organograma_x_regiao_atuacaoAvgAggregateInputType = {
    id?: true
    organograma_id?: true
    regiao_atuacao_id?: true
  }

  export type Organograma_x_regiao_atuacaoSumAggregateInputType = {
    id?: true
    organograma_id?: true
    regiao_atuacao_id?: true
  }

  export type Organograma_x_regiao_atuacaoMinAggregateInputType = {
    id?: true
    organograma_id?: true
    regiao_atuacao_id?: true
  }

  export type Organograma_x_regiao_atuacaoMaxAggregateInputType = {
    id?: true
    organograma_id?: true
    regiao_atuacao_id?: true
  }

  export type Organograma_x_regiao_atuacaoCountAggregateInputType = {
    id?: true
    organograma_id?: true
    regiao_atuacao_id?: true
    _all?: true
  }

  export type Organograma_x_regiao_atuacaoAggregateArgs = {
    /**
     * Filter which organograma_x_regiao_atuacao to aggregate.
     * 
    **/
    where?: organograma_x_regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_x_regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_x_regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: organograma_x_regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_x_regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_x_regiao_atuacaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organograma_x_regiao_atuacaos
    **/
    _count?: true | Organograma_x_regiao_atuacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Organograma_x_regiao_atuacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Organograma_x_regiao_atuacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Organograma_x_regiao_atuacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Organograma_x_regiao_atuacaoMaxAggregateInputType
  }

  export type GetOrganograma_x_regiao_atuacaoAggregateType<T extends Organograma_x_regiao_atuacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganograma_x_regiao_atuacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganograma_x_regiao_atuacao[P]>
      : GetScalarType<T[P], AggregateOrganograma_x_regiao_atuacao[P]>
  }




  export type Organograma_x_regiao_atuacaoGroupByArgs = {
    where?: organograma_x_regiao_atuacaoWhereInput
    orderBy?: Enumerable<organograma_x_regiao_atuacaoOrderByWithAggregationInput>
    by: Array<Organograma_x_regiao_atuacaoScalarFieldEnum>
    having?: organograma_x_regiao_atuacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Organograma_x_regiao_atuacaoCountAggregateInputType | true
    _avg?: Organograma_x_regiao_atuacaoAvgAggregateInputType
    _sum?: Organograma_x_regiao_atuacaoSumAggregateInputType
    _min?: Organograma_x_regiao_atuacaoMinAggregateInputType
    _max?: Organograma_x_regiao_atuacaoMaxAggregateInputType
  }


  export type Organograma_x_regiao_atuacaoGroupByOutputType = {
    id: number
    organograma_id: number
    regiao_atuacao_id: number
    _count: Organograma_x_regiao_atuacaoCountAggregateOutputType | null
    _avg: Organograma_x_regiao_atuacaoAvgAggregateOutputType | null
    _sum: Organograma_x_regiao_atuacaoSumAggregateOutputType | null
    _min: Organograma_x_regiao_atuacaoMinAggregateOutputType | null
    _max: Organograma_x_regiao_atuacaoMaxAggregateOutputType | null
  }

  type GetOrganograma_x_regiao_atuacaoGroupByPayload<T extends Organograma_x_regiao_atuacaoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Organograma_x_regiao_atuacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Organograma_x_regiao_atuacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Organograma_x_regiao_atuacaoGroupByOutputType[P]>
            : GetScalarType<T[P], Organograma_x_regiao_atuacaoGroupByOutputType[P]>
        }
      >
    >


  export type organograma_x_regiao_atuacaoSelect = {
    id?: boolean
    organograma_id?: boolean
    regiao_atuacao_id?: boolean
    organograma?: boolean | organogramaArgs
    regiao_atuacao?: boolean | regiao_atuacaoArgs
  }


  export type organograma_x_regiao_atuacaoInclude = {
    organograma?: boolean | organogramaArgs
    regiao_atuacao?: boolean | regiao_atuacaoArgs
  } 

  export type organograma_x_regiao_atuacaoGetPayload<S extends boolean | null | undefined | organograma_x_regiao_atuacaoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? organograma_x_regiao_atuacao :
    S extends undefined ? never :
    S extends { include: any } & (organograma_x_regiao_atuacaoArgs | organograma_x_regiao_atuacaoFindManyArgs)
    ? organograma_x_regiao_atuacao  & {
    [P in TrueKeys<S['include']>]:
        P extends 'organograma' ? organogramaGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'regiao_atuacao' ? regiao_atuacaoGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (organograma_x_regiao_atuacaoArgs | organograma_x_regiao_atuacaoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'organograma' ? organogramaGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'regiao_atuacao' ? regiao_atuacaoGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof organograma_x_regiao_atuacao ? organograma_x_regiao_atuacao[P] : never
  } 
      : organograma_x_regiao_atuacao


  type organograma_x_regiao_atuacaoCountArgs = Merge<
    Omit<organograma_x_regiao_atuacaoFindManyArgs, 'select' | 'include'> & {
      select?: Organograma_x_regiao_atuacaoCountAggregateInputType | true
    }
  >

  export interface organograma_x_regiao_atuacaoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Organograma_x_regiao_atuacao that matches the filter.
     * @param {organograma_x_regiao_atuacaoFindUniqueArgs} args - Arguments to find a Organograma_x_regiao_atuacao
     * @example
     * // Get one Organograma_x_regiao_atuacao
     * const organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends organograma_x_regiao_atuacaoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, organograma_x_regiao_atuacaoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'organograma_x_regiao_atuacao'> extends True ? Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T>> : Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T> | null, null>

    /**
     * Find the first Organograma_x_regiao_atuacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_regiao_atuacaoFindFirstArgs} args - Arguments to find a Organograma_x_regiao_atuacao
     * @example
     * // Get one Organograma_x_regiao_atuacao
     * const organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends organograma_x_regiao_atuacaoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, organograma_x_regiao_atuacaoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'organograma_x_regiao_atuacao'> extends True ? Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T>> : Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T> | null, null>

    /**
     * Find zero or more Organograma_x_regiao_atuacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_regiao_atuacaoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organograma_x_regiao_atuacaos
     * const organograma_x_regiao_atuacaos = await prisma.organograma_x_regiao_atuacao.findMany()
     * 
     * // Get first 10 Organograma_x_regiao_atuacaos
     * const organograma_x_regiao_atuacaos = await prisma.organograma_x_regiao_atuacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organograma_x_regiao_atuacaoWithIdOnly = await prisma.organograma_x_regiao_atuacao.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends organograma_x_regiao_atuacaoFindManyArgs>(
      args?: SelectSubset<T, organograma_x_regiao_atuacaoFindManyArgs>
    ): PrismaPromise<Array<organograma_x_regiao_atuacaoGetPayload<T>>>

    /**
     * Create a Organograma_x_regiao_atuacao.
     * @param {organograma_x_regiao_atuacaoCreateArgs} args - Arguments to create a Organograma_x_regiao_atuacao.
     * @example
     * // Create one Organograma_x_regiao_atuacao
     * const Organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.create({
     *   data: {
     *     // ... data to create a Organograma_x_regiao_atuacao
     *   }
     * })
     * 
    **/
    create<T extends organograma_x_regiao_atuacaoCreateArgs>(
      args: SelectSubset<T, organograma_x_regiao_atuacaoCreateArgs>
    ): Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Create many Organograma_x_regiao_atuacaos.
     *     @param {organograma_x_regiao_atuacaoCreateManyArgs} args - Arguments to create many Organograma_x_regiao_atuacaos.
     *     @example
     *     // Create many Organograma_x_regiao_atuacaos
     *     const organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends organograma_x_regiao_atuacaoCreateManyArgs>(
      args?: SelectSubset<T, organograma_x_regiao_atuacaoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Organograma_x_regiao_atuacao.
     * @param {organograma_x_regiao_atuacaoDeleteArgs} args - Arguments to delete one Organograma_x_regiao_atuacao.
     * @example
     * // Delete one Organograma_x_regiao_atuacao
     * const Organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.delete({
     *   where: {
     *     // ... filter to delete one Organograma_x_regiao_atuacao
     *   }
     * })
     * 
    **/
    delete<T extends organograma_x_regiao_atuacaoDeleteArgs>(
      args: SelectSubset<T, organograma_x_regiao_atuacaoDeleteArgs>
    ): Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Update one Organograma_x_regiao_atuacao.
     * @param {organograma_x_regiao_atuacaoUpdateArgs} args - Arguments to update one Organograma_x_regiao_atuacao.
     * @example
     * // Update one Organograma_x_regiao_atuacao
     * const organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends organograma_x_regiao_atuacaoUpdateArgs>(
      args: SelectSubset<T, organograma_x_regiao_atuacaoUpdateArgs>
    ): Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Delete zero or more Organograma_x_regiao_atuacaos.
     * @param {organograma_x_regiao_atuacaoDeleteManyArgs} args - Arguments to filter Organograma_x_regiao_atuacaos to delete.
     * @example
     * // Delete a few Organograma_x_regiao_atuacaos
     * const { count } = await prisma.organograma_x_regiao_atuacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends organograma_x_regiao_atuacaoDeleteManyArgs>(
      args?: SelectSubset<T, organograma_x_regiao_atuacaoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organograma_x_regiao_atuacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_regiao_atuacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organograma_x_regiao_atuacaos
     * const organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends organograma_x_regiao_atuacaoUpdateManyArgs>(
      args: SelectSubset<T, organograma_x_regiao_atuacaoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Organograma_x_regiao_atuacao.
     * @param {organograma_x_regiao_atuacaoUpsertArgs} args - Arguments to update or create a Organograma_x_regiao_atuacao.
     * @example
     * // Update or create a Organograma_x_regiao_atuacao
     * const organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.upsert({
     *   create: {
     *     // ... data to create a Organograma_x_regiao_atuacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organograma_x_regiao_atuacao we want to update
     *   }
     * })
    **/
    upsert<T extends organograma_x_regiao_atuacaoUpsertArgs>(
      args: SelectSubset<T, organograma_x_regiao_atuacaoUpsertArgs>
    ): Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Find one Organograma_x_regiao_atuacao that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {organograma_x_regiao_atuacaoFindUniqueOrThrowArgs} args - Arguments to find a Organograma_x_regiao_atuacao
     * @example
     * // Get one Organograma_x_regiao_atuacao
     * const organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends organograma_x_regiao_atuacaoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, organograma_x_regiao_atuacaoFindUniqueOrThrowArgs>
    ): Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Find the first Organograma_x_regiao_atuacao that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_regiao_atuacaoFindFirstOrThrowArgs} args - Arguments to find a Organograma_x_regiao_atuacao
     * @example
     * // Get one Organograma_x_regiao_atuacao
     * const organograma_x_regiao_atuacao = await prisma.organograma_x_regiao_atuacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends organograma_x_regiao_atuacaoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, organograma_x_regiao_atuacaoFindFirstOrThrowArgs>
    ): Prisma__organograma_x_regiao_atuacaoClient<organograma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Count the number of Organograma_x_regiao_atuacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_regiao_atuacaoCountArgs} args - Arguments to filter Organograma_x_regiao_atuacaos to count.
     * @example
     * // Count the number of Organograma_x_regiao_atuacaos
     * const count = await prisma.organograma_x_regiao_atuacao.count({
     *   where: {
     *     // ... the filter for the Organograma_x_regiao_atuacaos we want to count
     *   }
     * })
    **/
    count<T extends organograma_x_regiao_atuacaoCountArgs>(
      args?: Subset<T, organograma_x_regiao_atuacaoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Organograma_x_regiao_atuacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organograma_x_regiao_atuacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Organograma_x_regiao_atuacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Organograma_x_regiao_atuacaoAggregateArgs>(args: Subset<T, Organograma_x_regiao_atuacaoAggregateArgs>): PrismaPromise<GetOrganograma_x_regiao_atuacaoAggregateType<T>>

    /**
     * Group by Organograma_x_regiao_atuacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Organograma_x_regiao_atuacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Organograma_x_regiao_atuacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Organograma_x_regiao_atuacaoGroupByArgs['orderBy'] }
        : { orderBy?: Organograma_x_regiao_atuacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Organograma_x_regiao_atuacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganograma_x_regiao_atuacaoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for organograma_x_regiao_atuacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__organograma_x_regiao_atuacaoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organograma<T extends organogramaArgs= {}>(args?: Subset<T, organogramaArgs>): Prisma__organogramaClient<organogramaGetPayload<T> | Null>;

    regiao_atuacao<T extends regiao_atuacaoArgs= {}>(args?: Subset<T, regiao_atuacaoArgs>): Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * organograma_x_regiao_atuacao base type for findUnique actions
   */
  export type organograma_x_regiao_atuacaoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao_atuacao
     * 
    **/
    select?: organograma_x_regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_x_regiao_atuacaoInclude | null
    /**
     * Filter, which organograma_x_regiao_atuacao to fetch.
     * 
    **/
    where: organograma_x_regiao_atuacaoWhereUniqueInput
  }

  /**
   * organograma_x_regiao_atuacao: findUnique
   */
  export interface organograma_x_regiao_atuacaoFindUniqueArgs extends organograma_x_regiao_atuacaoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organograma_x_regiao_atuacao base type for findFirst actions
   */
  export type organograma_x_regiao_atuacaoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao_atuacao
     * 
    **/
    select?: organograma_x_regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_x_regiao_atuacaoInclude | null
    /**
     * Filter, which organograma_x_regiao_atuacao to fetch.
     * 
    **/
    where?: organograma_x_regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_x_regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_x_regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organograma_x_regiao_atuacaos.
     * 
    **/
    cursor?: organograma_x_regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_x_regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_x_regiao_atuacaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organograma_x_regiao_atuacaos.
     * 
    **/
    distinct?: Enumerable<Organograma_x_regiao_atuacaoScalarFieldEnum>
  }

  /**
   * organograma_x_regiao_atuacao: findFirst
   */
  export interface organograma_x_regiao_atuacaoFindFirstArgs extends organograma_x_regiao_atuacaoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organograma_x_regiao_atuacao findMany
   */
  export type organograma_x_regiao_atuacaoFindManyArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao_atuacao
     * 
    **/
    select?: organograma_x_regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_x_regiao_atuacaoInclude | null
    /**
     * Filter, which organograma_x_regiao_atuacaos to fetch.
     * 
    **/
    where?: organograma_x_regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_x_regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_x_regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organograma_x_regiao_atuacaos.
     * 
    **/
    cursor?: organograma_x_regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_x_regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_x_regiao_atuacaos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Organograma_x_regiao_atuacaoScalarFieldEnum>
  }


  /**
   * organograma_x_regiao_atuacao create
   */
  export type organograma_x_regiao_atuacaoCreateArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao_atuacao
     * 
    **/
    select?: organograma_x_regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_x_regiao_atuacaoInclude | null
    /**
     * The data needed to create a organograma_x_regiao_atuacao.
     * 
    **/
    data: XOR<organograma_x_regiao_atuacaoCreateInput, organograma_x_regiao_atuacaoUncheckedCreateInput>
  }


  /**
   * organograma_x_regiao_atuacao createMany
   */
  export type organograma_x_regiao_atuacaoCreateManyArgs = {
    /**
     * The data used to create many organograma_x_regiao_atuacaos.
     * 
    **/
    data: Enumerable<organograma_x_regiao_atuacaoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * organograma_x_regiao_atuacao update
   */
  export type organograma_x_regiao_atuacaoUpdateArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao_atuacao
     * 
    **/
    select?: organograma_x_regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_x_regiao_atuacaoInclude | null
    /**
     * The data needed to update a organograma_x_regiao_atuacao.
     * 
    **/
    data: XOR<organograma_x_regiao_atuacaoUpdateInput, organograma_x_regiao_atuacaoUncheckedUpdateInput>
    /**
     * Choose, which organograma_x_regiao_atuacao to update.
     * 
    **/
    where: organograma_x_regiao_atuacaoWhereUniqueInput
  }


  /**
   * organograma_x_regiao_atuacao updateMany
   */
  export type organograma_x_regiao_atuacaoUpdateManyArgs = {
    /**
     * The data used to update organograma_x_regiao_atuacaos.
     * 
    **/
    data: XOR<organograma_x_regiao_atuacaoUpdateManyMutationInput, organograma_x_regiao_atuacaoUncheckedUpdateManyInput>
    /**
     * Filter which organograma_x_regiao_atuacaos to update
     * 
    **/
    where?: organograma_x_regiao_atuacaoWhereInput
  }


  /**
   * organograma_x_regiao_atuacao upsert
   */
  export type organograma_x_regiao_atuacaoUpsertArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao_atuacao
     * 
    **/
    select?: organograma_x_regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_x_regiao_atuacaoInclude | null
    /**
     * The filter to search for the organograma_x_regiao_atuacao to update in case it exists.
     * 
    **/
    where: organograma_x_regiao_atuacaoWhereUniqueInput
    /**
     * In case the organograma_x_regiao_atuacao found by the `where` argument doesn't exist, create a new organograma_x_regiao_atuacao with this data.
     * 
    **/
    create: XOR<organograma_x_regiao_atuacaoCreateInput, organograma_x_regiao_atuacaoUncheckedCreateInput>
    /**
     * In case the organograma_x_regiao_atuacao was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<organograma_x_regiao_atuacaoUpdateInput, organograma_x_regiao_atuacaoUncheckedUpdateInput>
  }


  /**
   * organograma_x_regiao_atuacao delete
   */
  export type organograma_x_regiao_atuacaoDeleteArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao_atuacao
     * 
    **/
    select?: organograma_x_regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_x_regiao_atuacaoInclude | null
    /**
     * Filter which organograma_x_regiao_atuacao to delete.
     * 
    **/
    where: organograma_x_regiao_atuacaoWhereUniqueInput
  }


  /**
   * organograma_x_regiao_atuacao deleteMany
   */
  export type organograma_x_regiao_atuacaoDeleteManyArgs = {
    /**
     * Filter which organograma_x_regiao_atuacaos to delete
     * 
    **/
    where?: organograma_x_regiao_atuacaoWhereInput
  }


  /**
   * organograma_x_regiao_atuacao: findUniqueOrThrow
   */
  export type organograma_x_regiao_atuacaoFindUniqueOrThrowArgs = organograma_x_regiao_atuacaoFindUniqueArgsBase
      

  /**
   * organograma_x_regiao_atuacao: findFirstOrThrow
   */
  export type organograma_x_regiao_atuacaoFindFirstOrThrowArgs = organograma_x_regiao_atuacaoFindFirstArgsBase
      

  /**
   * organograma_x_regiao_atuacao without action
   */
  export type organograma_x_regiao_atuacaoArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_regiao_atuacao
     * 
    **/
    select?: organograma_x_regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_x_regiao_atuacaoInclude | null
  }



  /**
   * Model pessoa
   */


  export type AggregatePessoa = {
    _count: PessoaCountAggregateOutputType | null
    _avg: PessoaAvgAggregateOutputType | null
    _sum: PessoaSumAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  export type PessoaAvgAggregateOutputType = {
    id: number | null
  }

  export type PessoaSumAggregateOutputType = {
    id: number | null
  }

  export type PessoaMinAggregateOutputType = {
    id: number | null
    nome: string | null
    sobrenome: string | null
    sexo: string | null
    nascimento: Date | null
    cpf: string | null
    rg: string | null
  }

  export type PessoaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    sobrenome: string | null
    sexo: string | null
    nascimento: Date | null
    cpf: string | null
    rg: string | null
  }

  export type PessoaCountAggregateOutputType = {
    id: number
    nome: number
    sobrenome: number
    sexo: number
    nascimento: number
    cpf: number
    rg: number
    _all: number
  }


  export type PessoaAvgAggregateInputType = {
    id?: true
  }

  export type PessoaSumAggregateInputType = {
    id?: true
  }

  export type PessoaMinAggregateInputType = {
    id?: true
    nome?: true
    sobrenome?: true
    sexo?: true
    nascimento?: true
    cpf?: true
    rg?: true
  }

  export type PessoaMaxAggregateInputType = {
    id?: true
    nome?: true
    sobrenome?: true
    sexo?: true
    nascimento?: true
    cpf?: true
    rg?: true
  }

  export type PessoaCountAggregateInputType = {
    id?: true
    nome?: true
    sobrenome?: true
    sexo?: true
    nascimento?: true
    cpf?: true
    rg?: true
    _all?: true
  }

  export type PessoaAggregateArgs = {
    /**
     * Filter which pessoa to aggregate.
     * 
    **/
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     * 
    **/
    orderBy?: Enumerable<pessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pessoas
    **/
    _count?: true | PessoaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PessoaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PessoaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PessoaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PessoaMaxAggregateInputType
  }

  export type GetPessoaAggregateType<T extends PessoaAggregateArgs> = {
        [P in keyof T & keyof AggregatePessoa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePessoa[P]>
      : GetScalarType<T[P], AggregatePessoa[P]>
  }




  export type PessoaGroupByArgs = {
    where?: pessoaWhereInput
    orderBy?: Enumerable<pessoaOrderByWithAggregationInput>
    by: Array<PessoaScalarFieldEnum>
    having?: pessoaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PessoaCountAggregateInputType | true
    _avg?: PessoaAvgAggregateInputType
    _sum?: PessoaSumAggregateInputType
    _min?: PessoaMinAggregateInputType
    _max?: PessoaMaxAggregateInputType
  }


  export type PessoaGroupByOutputType = {
    id: number
    nome: string
    sobrenome: string
    sexo: string | null
    nascimento: Date | null
    cpf: string | null
    rg: string | null
    _count: PessoaCountAggregateOutputType | null
    _avg: PessoaAvgAggregateOutputType | null
    _sum: PessoaSumAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  type GetPessoaGroupByPayload<T extends PessoaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PessoaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PessoaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PessoaGroupByOutputType[P]>
            : GetScalarType<T[P], PessoaGroupByOutputType[P]>
        }
      >
    >


  export type pessoaSelect = {
    id?: boolean
    nome?: boolean
    sobrenome?: boolean
    sexo?: boolean
    nascimento?: boolean
    cpf?: boolean
    rg?: boolean
    usuario?: boolean | usuarioFindManyArgs
    _count?: boolean | PessoaCountOutputTypeArgs
  }


  export type pessoaInclude = {
    usuario?: boolean | usuarioFindManyArgs
    _count?: boolean | PessoaCountOutputTypeArgs
  } 

  export type pessoaGetPayload<S extends boolean | null | undefined | pessoaArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? pessoa :
    S extends undefined ? never :
    S extends { include: any } & (pessoaArgs | pessoaFindManyArgs)
    ? pessoa  & {
    [P in TrueKeys<S['include']>]:
        P extends 'usuario' ? Array < usuarioGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? PessoaCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (pessoaArgs | pessoaFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'usuario' ? Array < usuarioGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? PessoaCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof pessoa ? pessoa[P] : never
  } 
      : pessoa


  type pessoaCountArgs = Merge<
    Omit<pessoaFindManyArgs, 'select' | 'include'> & {
      select?: PessoaCountAggregateInputType | true
    }
  >

  export interface pessoaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Pessoa that matches the filter.
     * @param {pessoaFindUniqueArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pessoaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pessoaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pessoa'> extends True ? Prisma__pessoaClient<pessoaGetPayload<T>> : Prisma__pessoaClient<pessoaGetPayload<T> | null, null>

    /**
     * Find the first Pessoa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaFindFirstArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pessoaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pessoaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pessoa'> extends True ? Prisma__pessoaClient<pessoaGetPayload<T>> : Prisma__pessoaClient<pessoaGetPayload<T> | null, null>

    /**
     * Find zero or more Pessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pessoas
     * const pessoas = await prisma.pessoa.findMany()
     * 
     * // Get first 10 Pessoas
     * const pessoas = await prisma.pessoa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pessoaWithIdOnly = await prisma.pessoa.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pessoaFindManyArgs>(
      args?: SelectSubset<T, pessoaFindManyArgs>
    ): PrismaPromise<Array<pessoaGetPayload<T>>>

    /**
     * Create a Pessoa.
     * @param {pessoaCreateArgs} args - Arguments to create a Pessoa.
     * @example
     * // Create one Pessoa
     * const Pessoa = await prisma.pessoa.create({
     *   data: {
     *     // ... data to create a Pessoa
     *   }
     * })
     * 
    **/
    create<T extends pessoaCreateArgs>(
      args: SelectSubset<T, pessoaCreateArgs>
    ): Prisma__pessoaClient<pessoaGetPayload<T>>

    /**
     * Create many Pessoas.
     *     @param {pessoaCreateManyArgs} args - Arguments to create many Pessoas.
     *     @example
     *     // Create many Pessoas
     *     const pessoa = await prisma.pessoa.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pessoaCreateManyArgs>(
      args?: SelectSubset<T, pessoaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pessoa.
     * @param {pessoaDeleteArgs} args - Arguments to delete one Pessoa.
     * @example
     * // Delete one Pessoa
     * const Pessoa = await prisma.pessoa.delete({
     *   where: {
     *     // ... filter to delete one Pessoa
     *   }
     * })
     * 
    **/
    delete<T extends pessoaDeleteArgs>(
      args: SelectSubset<T, pessoaDeleteArgs>
    ): Prisma__pessoaClient<pessoaGetPayload<T>>

    /**
     * Update one Pessoa.
     * @param {pessoaUpdateArgs} args - Arguments to update one Pessoa.
     * @example
     * // Update one Pessoa
     * const pessoa = await prisma.pessoa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pessoaUpdateArgs>(
      args: SelectSubset<T, pessoaUpdateArgs>
    ): Prisma__pessoaClient<pessoaGetPayload<T>>

    /**
     * Delete zero or more Pessoas.
     * @param {pessoaDeleteManyArgs} args - Arguments to filter Pessoas to delete.
     * @example
     * // Delete a few Pessoas
     * const { count } = await prisma.pessoa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pessoaDeleteManyArgs>(
      args?: SelectSubset<T, pessoaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pessoas
     * const pessoa = await prisma.pessoa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pessoaUpdateManyArgs>(
      args: SelectSubset<T, pessoaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pessoa.
     * @param {pessoaUpsertArgs} args - Arguments to update or create a Pessoa.
     * @example
     * // Update or create a Pessoa
     * const pessoa = await prisma.pessoa.upsert({
     *   create: {
     *     // ... data to create a Pessoa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pessoa we want to update
     *   }
     * })
    **/
    upsert<T extends pessoaUpsertArgs>(
      args: SelectSubset<T, pessoaUpsertArgs>
    ): Prisma__pessoaClient<pessoaGetPayload<T>>

    /**
     * Find one Pessoa that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {pessoaFindUniqueOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pessoaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, pessoaFindUniqueOrThrowArgs>
    ): Prisma__pessoaClient<pessoaGetPayload<T>>

    /**
     * Find the first Pessoa that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaFindFirstOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pessoaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, pessoaFindFirstOrThrowArgs>
    ): Prisma__pessoaClient<pessoaGetPayload<T>>

    /**
     * Count the number of Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCountArgs} args - Arguments to filter Pessoas to count.
     * @example
     * // Count the number of Pessoas
     * const count = await prisma.pessoa.count({
     *   where: {
     *     // ... the filter for the Pessoas we want to count
     *   }
     * })
    **/
    count<T extends pessoaCountArgs>(
      args?: Subset<T, pessoaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PessoaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PessoaAggregateArgs>(args: Subset<T, PessoaAggregateArgs>): PrismaPromise<GetPessoaAggregateType<T>>

    /**
     * Group by Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PessoaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PessoaGroupByArgs['orderBy'] }
        : { orderBy?: PessoaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PessoaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPessoaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for pessoa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pessoaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    usuario<T extends usuarioFindManyArgs= {}>(args?: Subset<T, usuarioFindManyArgs>): PrismaPromise<Array<usuarioGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * pessoa base type for findUnique actions
   */
  export type pessoaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the pessoa
     * 
    **/
    select?: pessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pessoaInclude | null
    /**
     * Filter, which pessoa to fetch.
     * 
    **/
    where: pessoaWhereUniqueInput
  }

  /**
   * pessoa: findUnique
   */
  export interface pessoaFindUniqueArgs extends pessoaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pessoa base type for findFirst actions
   */
  export type pessoaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the pessoa
     * 
    **/
    select?: pessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pessoaInclude | null
    /**
     * Filter, which pessoa to fetch.
     * 
    **/
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     * 
    **/
    orderBy?: Enumerable<pessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pessoas.
     * 
    **/
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pessoas.
     * 
    **/
    distinct?: Enumerable<PessoaScalarFieldEnum>
  }

  /**
   * pessoa: findFirst
   */
  export interface pessoaFindFirstArgs extends pessoaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pessoa findMany
   */
  export type pessoaFindManyArgs = {
    /**
     * Select specific fields to fetch from the pessoa
     * 
    **/
    select?: pessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pessoaInclude | null
    /**
     * Filter, which pessoas to fetch.
     * 
    **/
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     * 
    **/
    orderBy?: Enumerable<pessoaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pessoas.
     * 
    **/
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PessoaScalarFieldEnum>
  }


  /**
   * pessoa create
   */
  export type pessoaCreateArgs = {
    /**
     * Select specific fields to fetch from the pessoa
     * 
    **/
    select?: pessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pessoaInclude | null
    /**
     * The data needed to create a pessoa.
     * 
    **/
    data: XOR<pessoaCreateInput, pessoaUncheckedCreateInput>
  }


  /**
   * pessoa createMany
   */
  export type pessoaCreateManyArgs = {
    /**
     * The data used to create many pessoas.
     * 
    **/
    data: Enumerable<pessoaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pessoa update
   */
  export type pessoaUpdateArgs = {
    /**
     * Select specific fields to fetch from the pessoa
     * 
    **/
    select?: pessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pessoaInclude | null
    /**
     * The data needed to update a pessoa.
     * 
    **/
    data: XOR<pessoaUpdateInput, pessoaUncheckedUpdateInput>
    /**
     * Choose, which pessoa to update.
     * 
    **/
    where: pessoaWhereUniqueInput
  }


  /**
   * pessoa updateMany
   */
  export type pessoaUpdateManyArgs = {
    /**
     * The data used to update pessoas.
     * 
    **/
    data: XOR<pessoaUpdateManyMutationInput, pessoaUncheckedUpdateManyInput>
    /**
     * Filter which pessoas to update
     * 
    **/
    where?: pessoaWhereInput
  }


  /**
   * pessoa upsert
   */
  export type pessoaUpsertArgs = {
    /**
     * Select specific fields to fetch from the pessoa
     * 
    **/
    select?: pessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pessoaInclude | null
    /**
     * The filter to search for the pessoa to update in case it exists.
     * 
    **/
    where: pessoaWhereUniqueInput
    /**
     * In case the pessoa found by the `where` argument doesn't exist, create a new pessoa with this data.
     * 
    **/
    create: XOR<pessoaCreateInput, pessoaUncheckedCreateInput>
    /**
     * In case the pessoa was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<pessoaUpdateInput, pessoaUncheckedUpdateInput>
  }


  /**
   * pessoa delete
   */
  export type pessoaDeleteArgs = {
    /**
     * Select specific fields to fetch from the pessoa
     * 
    **/
    select?: pessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pessoaInclude | null
    /**
     * Filter which pessoa to delete.
     * 
    **/
    where: pessoaWhereUniqueInput
  }


  /**
   * pessoa deleteMany
   */
  export type pessoaDeleteManyArgs = {
    /**
     * Filter which pessoas to delete
     * 
    **/
    where?: pessoaWhereInput
  }


  /**
   * pessoa: findUniqueOrThrow
   */
  export type pessoaFindUniqueOrThrowArgs = pessoaFindUniqueArgsBase
      

  /**
   * pessoa: findFirstOrThrow
   */
  export type pessoaFindFirstOrThrowArgs = pessoaFindFirstArgsBase
      

  /**
   * pessoa without action
   */
  export type pessoaArgs = {
    /**
     * Select specific fields to fetch from the pessoa
     * 
    **/
    select?: pessoaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: pessoaInclude | null
  }



  /**
   * Model plataforma
   */


  export type AggregatePlataforma = {
    _count: PlataformaCountAggregateOutputType | null
    _avg: PlataformaAvgAggregateOutputType | null
    _sum: PlataformaSumAggregateOutputType | null
    _min: PlataformaMinAggregateOutputType | null
    _max: PlataformaMaxAggregateOutputType | null
  }

  export type PlataformaAvgAggregateOutputType = {
    id: number | null
    plataforma_papel_tipo_id: number | null
  }

  export type PlataformaSumAggregateOutputType = {
    id: number | null
    plataforma_papel_tipo_id: number | null
  }

  export type PlataformaMinAggregateOutputType = {
    id: number | null
    nome: string | null
    plataforma_papel_tipo_id: number | null
  }

  export type PlataformaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    plataforma_papel_tipo_id: number | null
  }

  export type PlataformaCountAggregateOutputType = {
    id: number
    nome: number
    plataforma_papel_tipo_id: number
    _all: number
  }


  export type PlataformaAvgAggregateInputType = {
    id?: true
    plataforma_papel_tipo_id?: true
  }

  export type PlataformaSumAggregateInputType = {
    id?: true
    plataforma_papel_tipo_id?: true
  }

  export type PlataformaMinAggregateInputType = {
    id?: true
    nome?: true
    plataforma_papel_tipo_id?: true
  }

  export type PlataformaMaxAggregateInputType = {
    id?: true
    nome?: true
    plataforma_papel_tipo_id?: true
  }

  export type PlataformaCountAggregateInputType = {
    id?: true
    nome?: true
    plataforma_papel_tipo_id?: true
    _all?: true
  }

  export type PlataformaAggregateArgs = {
    /**
     * Filter which plataforma to aggregate.
     * 
    **/
    where?: plataformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataformas to fetch.
     * 
    **/
    orderBy?: Enumerable<plataformaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: plataformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataformas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataformas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plataformas
    **/
    _count?: true | PlataformaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlataformaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlataformaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlataformaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlataformaMaxAggregateInputType
  }

  export type GetPlataformaAggregateType<T extends PlataformaAggregateArgs> = {
        [P in keyof T & keyof AggregatePlataforma]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlataforma[P]>
      : GetScalarType<T[P], AggregatePlataforma[P]>
  }




  export type PlataformaGroupByArgs = {
    where?: plataformaWhereInput
    orderBy?: Enumerable<plataformaOrderByWithAggregationInput>
    by: Array<PlataformaScalarFieldEnum>
    having?: plataformaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlataformaCountAggregateInputType | true
    _avg?: PlataformaAvgAggregateInputType
    _sum?: PlataformaSumAggregateInputType
    _min?: PlataformaMinAggregateInputType
    _max?: PlataformaMaxAggregateInputType
  }


  export type PlataformaGroupByOutputType = {
    id: number
    nome: string | null
    plataforma_papel_tipo_id: number
    _count: PlataformaCountAggregateOutputType | null
    _avg: PlataformaAvgAggregateOutputType | null
    _sum: PlataformaSumAggregateOutputType | null
    _min: PlataformaMinAggregateOutputType | null
    _max: PlataformaMaxAggregateOutputType | null
  }

  type GetPlataformaGroupByPayload<T extends PlataformaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PlataformaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlataformaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlataformaGroupByOutputType[P]>
            : GetScalarType<T[P], PlataformaGroupByOutputType[P]>
        }
      >
    >


  export type plataformaSelect = {
    id?: boolean
    nome?: boolean
    plataforma_papel_tipo_id?: boolean
    plataforma_papel_tipo?: boolean | plataforma_papel_tipoArgs
    plataforma_x_regiao_atuacao?: boolean | plataforma_x_regiao_atuacaoFindManyArgs
    plataforma_x_usuario?: boolean | plataforma_x_usuarioFindManyArgs
    _count?: boolean | PlataformaCountOutputTypeArgs
  }


  export type plataformaInclude = {
    plataforma_papel_tipo?: boolean | plataforma_papel_tipoArgs
    plataforma_x_regiao_atuacao?: boolean | plataforma_x_regiao_atuacaoFindManyArgs
    plataforma_x_usuario?: boolean | plataforma_x_usuarioFindManyArgs
    _count?: boolean | PlataformaCountOutputTypeArgs
  } 

  export type plataformaGetPayload<S extends boolean | null | undefined | plataformaArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? plataforma :
    S extends undefined ? never :
    S extends { include: any } & (plataformaArgs | plataformaFindManyArgs)
    ? plataforma  & {
    [P in TrueKeys<S['include']>]:
        P extends 'plataforma_papel_tipo' ? plataforma_papel_tipoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'plataforma_x_regiao_atuacao' ? Array < plataforma_x_regiao_atuacaoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'plataforma_x_usuario' ? Array < plataforma_x_usuarioGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? PlataformaCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (plataformaArgs | plataformaFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'plataforma_papel_tipo' ? plataforma_papel_tipoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'plataforma_x_regiao_atuacao' ? Array < plataforma_x_regiao_atuacaoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'plataforma_x_usuario' ? Array < plataforma_x_usuarioGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? PlataformaCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof plataforma ? plataforma[P] : never
  } 
      : plataforma


  type plataformaCountArgs = Merge<
    Omit<plataformaFindManyArgs, 'select' | 'include'> & {
      select?: PlataformaCountAggregateInputType | true
    }
  >

  export interface plataformaDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Plataforma that matches the filter.
     * @param {plataformaFindUniqueArgs} args - Arguments to find a Plataforma
     * @example
     * // Get one Plataforma
     * const plataforma = await prisma.plataforma.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends plataformaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, plataformaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'plataforma'> extends True ? Prisma__plataformaClient<plataformaGetPayload<T>> : Prisma__plataformaClient<plataformaGetPayload<T> | null, null>

    /**
     * Find the first Plataforma that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataformaFindFirstArgs} args - Arguments to find a Plataforma
     * @example
     * // Get one Plataforma
     * const plataforma = await prisma.plataforma.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends plataformaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, plataformaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'plataforma'> extends True ? Prisma__plataformaClient<plataformaGetPayload<T>> : Prisma__plataformaClient<plataformaGetPayload<T> | null, null>

    /**
     * Find zero or more Plataformas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataformaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plataformas
     * const plataformas = await prisma.plataforma.findMany()
     * 
     * // Get first 10 Plataformas
     * const plataformas = await prisma.plataforma.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plataformaWithIdOnly = await prisma.plataforma.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends plataformaFindManyArgs>(
      args?: SelectSubset<T, plataformaFindManyArgs>
    ): PrismaPromise<Array<plataformaGetPayload<T>>>

    /**
     * Create a Plataforma.
     * @param {plataformaCreateArgs} args - Arguments to create a Plataforma.
     * @example
     * // Create one Plataforma
     * const Plataforma = await prisma.plataforma.create({
     *   data: {
     *     // ... data to create a Plataforma
     *   }
     * })
     * 
    **/
    create<T extends plataformaCreateArgs>(
      args: SelectSubset<T, plataformaCreateArgs>
    ): Prisma__plataformaClient<plataformaGetPayload<T>>

    /**
     * Create many Plataformas.
     *     @param {plataformaCreateManyArgs} args - Arguments to create many Plataformas.
     *     @example
     *     // Create many Plataformas
     *     const plataforma = await prisma.plataforma.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends plataformaCreateManyArgs>(
      args?: SelectSubset<T, plataformaCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Plataforma.
     * @param {plataformaDeleteArgs} args - Arguments to delete one Plataforma.
     * @example
     * // Delete one Plataforma
     * const Plataforma = await prisma.plataforma.delete({
     *   where: {
     *     // ... filter to delete one Plataforma
     *   }
     * })
     * 
    **/
    delete<T extends plataformaDeleteArgs>(
      args: SelectSubset<T, plataformaDeleteArgs>
    ): Prisma__plataformaClient<plataformaGetPayload<T>>

    /**
     * Update one Plataforma.
     * @param {plataformaUpdateArgs} args - Arguments to update one Plataforma.
     * @example
     * // Update one Plataforma
     * const plataforma = await prisma.plataforma.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends plataformaUpdateArgs>(
      args: SelectSubset<T, plataformaUpdateArgs>
    ): Prisma__plataformaClient<plataformaGetPayload<T>>

    /**
     * Delete zero or more Plataformas.
     * @param {plataformaDeleteManyArgs} args - Arguments to filter Plataformas to delete.
     * @example
     * // Delete a few Plataformas
     * const { count } = await prisma.plataforma.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends plataformaDeleteManyArgs>(
      args?: SelectSubset<T, plataformaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plataformas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataformaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plataformas
     * const plataforma = await prisma.plataforma.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends plataformaUpdateManyArgs>(
      args: SelectSubset<T, plataformaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Plataforma.
     * @param {plataformaUpsertArgs} args - Arguments to update or create a Plataforma.
     * @example
     * // Update or create a Plataforma
     * const plataforma = await prisma.plataforma.upsert({
     *   create: {
     *     // ... data to create a Plataforma
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plataforma we want to update
     *   }
     * })
    **/
    upsert<T extends plataformaUpsertArgs>(
      args: SelectSubset<T, plataformaUpsertArgs>
    ): Prisma__plataformaClient<plataformaGetPayload<T>>

    /**
     * Find one Plataforma that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {plataformaFindUniqueOrThrowArgs} args - Arguments to find a Plataforma
     * @example
     * // Get one Plataforma
     * const plataforma = await prisma.plataforma.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends plataformaFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, plataformaFindUniqueOrThrowArgs>
    ): Prisma__plataformaClient<plataformaGetPayload<T>>

    /**
     * Find the first Plataforma that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataformaFindFirstOrThrowArgs} args - Arguments to find a Plataforma
     * @example
     * // Get one Plataforma
     * const plataforma = await prisma.plataforma.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends plataformaFindFirstOrThrowArgs>(
      args?: SelectSubset<T, plataformaFindFirstOrThrowArgs>
    ): Prisma__plataformaClient<plataformaGetPayload<T>>

    /**
     * Count the number of Plataformas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataformaCountArgs} args - Arguments to filter Plataformas to count.
     * @example
     * // Count the number of Plataformas
     * const count = await prisma.plataforma.count({
     *   where: {
     *     // ... the filter for the Plataformas we want to count
     *   }
     * })
    **/
    count<T extends plataformaCountArgs>(
      args?: Subset<T, plataformaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlataformaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plataforma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlataformaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlataformaAggregateArgs>(args: Subset<T, PlataformaAggregateArgs>): PrismaPromise<GetPlataformaAggregateType<T>>

    /**
     * Group by Plataforma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlataformaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlataformaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlataformaGroupByArgs['orderBy'] }
        : { orderBy?: PlataformaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlataformaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlataformaGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for plataforma.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__plataformaClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    plataforma_papel_tipo<T extends plataforma_papel_tipoArgs= {}>(args?: Subset<T, plataforma_papel_tipoArgs>): Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T> | Null>;

    plataforma_x_regiao_atuacao<T extends plataforma_x_regiao_atuacaoFindManyArgs= {}>(args?: Subset<T, plataforma_x_regiao_atuacaoFindManyArgs>): PrismaPromise<Array<plataforma_x_regiao_atuacaoGetPayload<T>>| Null>;

    plataforma_x_usuario<T extends plataforma_x_usuarioFindManyArgs= {}>(args?: Subset<T, plataforma_x_usuarioFindManyArgs>): PrismaPromise<Array<plataforma_x_usuarioGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * plataforma base type for findUnique actions
   */
  export type plataformaFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma
     * 
    **/
    select?: plataformaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataformaInclude | null
    /**
     * Filter, which plataforma to fetch.
     * 
    **/
    where: plataformaWhereUniqueInput
  }

  /**
   * plataforma: findUnique
   */
  export interface plataformaFindUniqueArgs extends plataformaFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma base type for findFirst actions
   */
  export type plataformaFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma
     * 
    **/
    select?: plataformaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataformaInclude | null
    /**
     * Filter, which plataforma to fetch.
     * 
    **/
    where?: plataformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataformas to fetch.
     * 
    **/
    orderBy?: Enumerable<plataformaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plataformas.
     * 
    **/
    cursor?: plataformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataformas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataformas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plataformas.
     * 
    **/
    distinct?: Enumerable<PlataformaScalarFieldEnum>
  }

  /**
   * plataforma: findFirst
   */
  export interface plataformaFindFirstArgs extends plataformaFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma findMany
   */
  export type plataformaFindManyArgs = {
    /**
     * Select specific fields to fetch from the plataforma
     * 
    **/
    select?: plataformaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataformaInclude | null
    /**
     * Filter, which plataformas to fetch.
     * 
    **/
    where?: plataformaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataformas to fetch.
     * 
    **/
    orderBy?: Enumerable<plataformaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plataformas.
     * 
    **/
    cursor?: plataformaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataformas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataformas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PlataformaScalarFieldEnum>
  }


  /**
   * plataforma create
   */
  export type plataformaCreateArgs = {
    /**
     * Select specific fields to fetch from the plataforma
     * 
    **/
    select?: plataformaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataformaInclude | null
    /**
     * The data needed to create a plataforma.
     * 
    **/
    data: XOR<plataformaCreateInput, plataformaUncheckedCreateInput>
  }


  /**
   * plataforma createMany
   */
  export type plataformaCreateManyArgs = {
    /**
     * The data used to create many plataformas.
     * 
    **/
    data: Enumerable<plataformaCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * plataforma update
   */
  export type plataformaUpdateArgs = {
    /**
     * Select specific fields to fetch from the plataforma
     * 
    **/
    select?: plataformaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataformaInclude | null
    /**
     * The data needed to update a plataforma.
     * 
    **/
    data: XOR<plataformaUpdateInput, plataformaUncheckedUpdateInput>
    /**
     * Choose, which plataforma to update.
     * 
    **/
    where: plataformaWhereUniqueInput
  }


  /**
   * plataforma updateMany
   */
  export type plataformaUpdateManyArgs = {
    /**
     * The data used to update plataformas.
     * 
    **/
    data: XOR<plataformaUpdateManyMutationInput, plataformaUncheckedUpdateManyInput>
    /**
     * Filter which plataformas to update
     * 
    **/
    where?: plataformaWhereInput
  }


  /**
   * plataforma upsert
   */
  export type plataformaUpsertArgs = {
    /**
     * Select specific fields to fetch from the plataforma
     * 
    **/
    select?: plataformaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataformaInclude | null
    /**
     * The filter to search for the plataforma to update in case it exists.
     * 
    **/
    where: plataformaWhereUniqueInput
    /**
     * In case the plataforma found by the `where` argument doesn't exist, create a new plataforma with this data.
     * 
    **/
    create: XOR<plataformaCreateInput, plataformaUncheckedCreateInput>
    /**
     * In case the plataforma was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<plataformaUpdateInput, plataformaUncheckedUpdateInput>
  }


  /**
   * plataforma delete
   */
  export type plataformaDeleteArgs = {
    /**
     * Select specific fields to fetch from the plataforma
     * 
    **/
    select?: plataformaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataformaInclude | null
    /**
     * Filter which plataforma to delete.
     * 
    **/
    where: plataformaWhereUniqueInput
  }


  /**
   * plataforma deleteMany
   */
  export type plataformaDeleteManyArgs = {
    /**
     * Filter which plataformas to delete
     * 
    **/
    where?: plataformaWhereInput
  }


  /**
   * plataforma: findUniqueOrThrow
   */
  export type plataformaFindUniqueOrThrowArgs = plataformaFindUniqueArgsBase
      

  /**
   * plataforma: findFirstOrThrow
   */
  export type plataformaFindFirstOrThrowArgs = plataformaFindFirstArgsBase
      

  /**
   * plataforma without action
   */
  export type plataformaArgs = {
    /**
     * Select specific fields to fetch from the plataforma
     * 
    **/
    select?: plataformaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataformaInclude | null
  }



  /**
   * Model plataforma_papel_tipo
   */


  export type AggregatePlataforma_papel_tipo = {
    _count: Plataforma_papel_tipoCountAggregateOutputType | null
    _avg: Plataforma_papel_tipoAvgAggregateOutputType | null
    _sum: Plataforma_papel_tipoSumAggregateOutputType | null
    _min: Plataforma_papel_tipoMinAggregateOutputType | null
    _max: Plataforma_papel_tipoMaxAggregateOutputType | null
  }

  export type Plataforma_papel_tipoAvgAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_papel_tipoSumAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_papel_tipoMinAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_papel_tipoMaxAggregateOutputType = {
    id: number | null
  }

  export type Plataforma_papel_tipoCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type Plataforma_papel_tipoAvgAggregateInputType = {
    id?: true
  }

  export type Plataforma_papel_tipoSumAggregateInputType = {
    id?: true
  }

  export type Plataforma_papel_tipoMinAggregateInputType = {
    id?: true
  }

  export type Plataforma_papel_tipoMaxAggregateInputType = {
    id?: true
  }

  export type Plataforma_papel_tipoCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type Plataforma_papel_tipoAggregateArgs = {
    /**
     * Filter which plataforma_papel_tipo to aggregate.
     * 
    **/
    where?: plataforma_papel_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_papel_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_papel_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: plataforma_papel_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_papel_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_papel_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plataforma_papel_tipos
    **/
    _count?: true | Plataforma_papel_tipoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plataforma_papel_tipoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plataforma_papel_tipoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plataforma_papel_tipoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plataforma_papel_tipoMaxAggregateInputType
  }

  export type GetPlataforma_papel_tipoAggregateType<T extends Plataforma_papel_tipoAggregateArgs> = {
        [P in keyof T & keyof AggregatePlataforma_papel_tipo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlataforma_papel_tipo[P]>
      : GetScalarType<T[P], AggregatePlataforma_papel_tipo[P]>
  }




  export type Plataforma_papel_tipoGroupByArgs = {
    where?: plataforma_papel_tipoWhereInput
    orderBy?: Enumerable<plataforma_papel_tipoOrderByWithAggregationInput>
    by: Array<Plataforma_papel_tipoScalarFieldEnum>
    having?: plataforma_papel_tipoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plataforma_papel_tipoCountAggregateInputType | true
    _avg?: Plataforma_papel_tipoAvgAggregateInputType
    _sum?: Plataforma_papel_tipoSumAggregateInputType
    _min?: Plataforma_papel_tipoMinAggregateInputType
    _max?: Plataforma_papel_tipoMaxAggregateInputType
  }


  export type Plataforma_papel_tipoGroupByOutputType = {
    id: number
    _count: Plataforma_papel_tipoCountAggregateOutputType | null
    _avg: Plataforma_papel_tipoAvgAggregateOutputType | null
    _sum: Plataforma_papel_tipoSumAggregateOutputType | null
    _min: Plataforma_papel_tipoMinAggregateOutputType | null
    _max: Plataforma_papel_tipoMaxAggregateOutputType | null
  }

  type GetPlataforma_papel_tipoGroupByPayload<T extends Plataforma_papel_tipoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Plataforma_papel_tipoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plataforma_papel_tipoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plataforma_papel_tipoGroupByOutputType[P]>
            : GetScalarType<T[P], Plataforma_papel_tipoGroupByOutputType[P]>
        }
      >
    >


  export type plataforma_papel_tipoSelect = {
    id?: boolean
    plataforma?: boolean | plataformaFindManyArgs
    _count?: boolean | Plataforma_papel_tipoCountOutputTypeArgs
  }


  export type plataforma_papel_tipoInclude = {
    plataforma?: boolean | plataformaFindManyArgs
    _count?: boolean | Plataforma_papel_tipoCountOutputTypeArgs
  } 

  export type plataforma_papel_tipoGetPayload<S extends boolean | null | undefined | plataforma_papel_tipoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? plataforma_papel_tipo :
    S extends undefined ? never :
    S extends { include: any } & (plataforma_papel_tipoArgs | plataforma_papel_tipoFindManyArgs)
    ? plataforma_papel_tipo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'plataforma' ? Array < plataformaGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Plataforma_papel_tipoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (plataforma_papel_tipoArgs | plataforma_papel_tipoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'plataforma' ? Array < plataformaGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Plataforma_papel_tipoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof plataforma_papel_tipo ? plataforma_papel_tipo[P] : never
  } 
      : plataforma_papel_tipo


  type plataforma_papel_tipoCountArgs = Merge<
    Omit<plataforma_papel_tipoFindManyArgs, 'select' | 'include'> & {
      select?: Plataforma_papel_tipoCountAggregateInputType | true
    }
  >

  export interface plataforma_papel_tipoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Plataforma_papel_tipo that matches the filter.
     * @param {plataforma_papel_tipoFindUniqueArgs} args - Arguments to find a Plataforma_papel_tipo
     * @example
     * // Get one Plataforma_papel_tipo
     * const plataforma_papel_tipo = await prisma.plataforma_papel_tipo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends plataforma_papel_tipoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, plataforma_papel_tipoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'plataforma_papel_tipo'> extends True ? Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T>> : Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T> | null, null>

    /**
     * Find the first Plataforma_papel_tipo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_papel_tipoFindFirstArgs} args - Arguments to find a Plataforma_papel_tipo
     * @example
     * // Get one Plataforma_papel_tipo
     * const plataforma_papel_tipo = await prisma.plataforma_papel_tipo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends plataforma_papel_tipoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, plataforma_papel_tipoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'plataforma_papel_tipo'> extends True ? Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T>> : Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T> | null, null>

    /**
     * Find zero or more Plataforma_papel_tipos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_papel_tipoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plataforma_papel_tipos
     * const plataforma_papel_tipos = await prisma.plataforma_papel_tipo.findMany()
     * 
     * // Get first 10 Plataforma_papel_tipos
     * const plataforma_papel_tipos = await prisma.plataforma_papel_tipo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plataforma_papel_tipoWithIdOnly = await prisma.plataforma_papel_tipo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends plataforma_papel_tipoFindManyArgs>(
      args?: SelectSubset<T, plataforma_papel_tipoFindManyArgs>
    ): PrismaPromise<Array<plataforma_papel_tipoGetPayload<T>>>

    /**
     * Create a Plataforma_papel_tipo.
     * @param {plataforma_papel_tipoCreateArgs} args - Arguments to create a Plataforma_papel_tipo.
     * @example
     * // Create one Plataforma_papel_tipo
     * const Plataforma_papel_tipo = await prisma.plataforma_papel_tipo.create({
     *   data: {
     *     // ... data to create a Plataforma_papel_tipo
     *   }
     * })
     * 
    **/
    create<T extends plataforma_papel_tipoCreateArgs>(
      args: SelectSubset<T, plataforma_papel_tipoCreateArgs>
    ): Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T>>

    /**
     * Create many Plataforma_papel_tipos.
     *     @param {plataforma_papel_tipoCreateManyArgs} args - Arguments to create many Plataforma_papel_tipos.
     *     @example
     *     // Create many Plataforma_papel_tipos
     *     const plataforma_papel_tipo = await prisma.plataforma_papel_tipo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends plataforma_papel_tipoCreateManyArgs>(
      args?: SelectSubset<T, plataforma_papel_tipoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Plataforma_papel_tipo.
     * @param {plataforma_papel_tipoDeleteArgs} args - Arguments to delete one Plataforma_papel_tipo.
     * @example
     * // Delete one Plataforma_papel_tipo
     * const Plataforma_papel_tipo = await prisma.plataforma_papel_tipo.delete({
     *   where: {
     *     // ... filter to delete one Plataforma_papel_tipo
     *   }
     * })
     * 
    **/
    delete<T extends plataforma_papel_tipoDeleteArgs>(
      args: SelectSubset<T, plataforma_papel_tipoDeleteArgs>
    ): Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T>>

    /**
     * Update one Plataforma_papel_tipo.
     * @param {plataforma_papel_tipoUpdateArgs} args - Arguments to update one Plataforma_papel_tipo.
     * @example
     * // Update one Plataforma_papel_tipo
     * const plataforma_papel_tipo = await prisma.plataforma_papel_tipo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends plataforma_papel_tipoUpdateArgs>(
      args: SelectSubset<T, plataforma_papel_tipoUpdateArgs>
    ): Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T>>

    /**
     * Delete zero or more Plataforma_papel_tipos.
     * @param {plataforma_papel_tipoDeleteManyArgs} args - Arguments to filter Plataforma_papel_tipos to delete.
     * @example
     * // Delete a few Plataforma_papel_tipos
     * const { count } = await prisma.plataforma_papel_tipo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends plataforma_papel_tipoDeleteManyArgs>(
      args?: SelectSubset<T, plataforma_papel_tipoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plataforma_papel_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_papel_tipoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plataforma_papel_tipos
     * const plataforma_papel_tipo = await prisma.plataforma_papel_tipo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends plataforma_papel_tipoUpdateManyArgs>(
      args: SelectSubset<T, plataforma_papel_tipoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Plataforma_papel_tipo.
     * @param {plataforma_papel_tipoUpsertArgs} args - Arguments to update or create a Plataforma_papel_tipo.
     * @example
     * // Update or create a Plataforma_papel_tipo
     * const plataforma_papel_tipo = await prisma.plataforma_papel_tipo.upsert({
     *   create: {
     *     // ... data to create a Plataforma_papel_tipo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plataforma_papel_tipo we want to update
     *   }
     * })
    **/
    upsert<T extends plataforma_papel_tipoUpsertArgs>(
      args: SelectSubset<T, plataforma_papel_tipoUpsertArgs>
    ): Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T>>

    /**
     * Find one Plataforma_papel_tipo that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {plataforma_papel_tipoFindUniqueOrThrowArgs} args - Arguments to find a Plataforma_papel_tipo
     * @example
     * // Get one Plataforma_papel_tipo
     * const plataforma_papel_tipo = await prisma.plataforma_papel_tipo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends plataforma_papel_tipoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, plataforma_papel_tipoFindUniqueOrThrowArgs>
    ): Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T>>

    /**
     * Find the first Plataforma_papel_tipo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_papel_tipoFindFirstOrThrowArgs} args - Arguments to find a Plataforma_papel_tipo
     * @example
     * // Get one Plataforma_papel_tipo
     * const plataforma_papel_tipo = await prisma.plataforma_papel_tipo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends plataforma_papel_tipoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, plataforma_papel_tipoFindFirstOrThrowArgs>
    ): Prisma__plataforma_papel_tipoClient<plataforma_papel_tipoGetPayload<T>>

    /**
     * Count the number of Plataforma_papel_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_papel_tipoCountArgs} args - Arguments to filter Plataforma_papel_tipos to count.
     * @example
     * // Count the number of Plataforma_papel_tipos
     * const count = await prisma.plataforma_papel_tipo.count({
     *   where: {
     *     // ... the filter for the Plataforma_papel_tipos we want to count
     *   }
     * })
    **/
    count<T extends plataforma_papel_tipoCountArgs>(
      args?: Subset<T, plataforma_papel_tipoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plataforma_papel_tipoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plataforma_papel_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plataforma_papel_tipoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plataforma_papel_tipoAggregateArgs>(args: Subset<T, Plataforma_papel_tipoAggregateArgs>): PrismaPromise<GetPlataforma_papel_tipoAggregateType<T>>

    /**
     * Group by Plataforma_papel_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plataforma_papel_tipoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Plataforma_papel_tipoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Plataforma_papel_tipoGroupByArgs['orderBy'] }
        : { orderBy?: Plataforma_papel_tipoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Plataforma_papel_tipoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlataforma_papel_tipoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for plataforma_papel_tipo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__plataforma_papel_tipoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    plataforma<T extends plataformaFindManyArgs= {}>(args?: Subset<T, plataformaFindManyArgs>): PrismaPromise<Array<plataformaGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * plataforma_papel_tipo base type for findUnique actions
   */
  export type plataforma_papel_tipoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma_papel_tipo
     * 
    **/
    select?: plataforma_papel_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_papel_tipoInclude | null
    /**
     * Filter, which plataforma_papel_tipo to fetch.
     * 
    **/
    where: plataforma_papel_tipoWhereUniqueInput
  }

  /**
   * plataforma_papel_tipo: findUnique
   */
  export interface plataforma_papel_tipoFindUniqueArgs extends plataforma_papel_tipoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma_papel_tipo base type for findFirst actions
   */
  export type plataforma_papel_tipoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma_papel_tipo
     * 
    **/
    select?: plataforma_papel_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_papel_tipoInclude | null
    /**
     * Filter, which plataforma_papel_tipo to fetch.
     * 
    **/
    where?: plataforma_papel_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_papel_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_papel_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plataforma_papel_tipos.
     * 
    **/
    cursor?: plataforma_papel_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_papel_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_papel_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plataforma_papel_tipos.
     * 
    **/
    distinct?: Enumerable<Plataforma_papel_tipoScalarFieldEnum>
  }

  /**
   * plataforma_papel_tipo: findFirst
   */
  export interface plataforma_papel_tipoFindFirstArgs extends plataforma_papel_tipoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma_papel_tipo findMany
   */
  export type plataforma_papel_tipoFindManyArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_tipo
     * 
    **/
    select?: plataforma_papel_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_papel_tipoInclude | null
    /**
     * Filter, which plataforma_papel_tipos to fetch.
     * 
    **/
    where?: plataforma_papel_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_papel_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_papel_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plataforma_papel_tipos.
     * 
    **/
    cursor?: plataforma_papel_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_papel_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_papel_tipos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Plataforma_papel_tipoScalarFieldEnum>
  }


  /**
   * plataforma_papel_tipo create
   */
  export type plataforma_papel_tipoCreateArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_tipo
     * 
    **/
    select?: plataforma_papel_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_papel_tipoInclude | null
    /**
     * The data needed to create a plataforma_papel_tipo.
     * 
    **/
    data: XOR<plataforma_papel_tipoCreateInput, plataforma_papel_tipoUncheckedCreateInput>
  }


  /**
   * plataforma_papel_tipo createMany
   */
  export type plataforma_papel_tipoCreateManyArgs = {
    /**
     * The data used to create many plataforma_papel_tipos.
     * 
    **/
    data: Enumerable<plataforma_papel_tipoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * plataforma_papel_tipo update
   */
  export type plataforma_papel_tipoUpdateArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_tipo
     * 
    **/
    select?: plataforma_papel_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_papel_tipoInclude | null
    /**
     * The data needed to update a plataforma_papel_tipo.
     * 
    **/
    data: XOR<plataforma_papel_tipoUpdateInput, plataforma_papel_tipoUncheckedUpdateInput>
    /**
     * Choose, which plataforma_papel_tipo to update.
     * 
    **/
    where: plataforma_papel_tipoWhereUniqueInput
  }


  /**
   * plataforma_papel_tipo updateMany
   */
  export type plataforma_papel_tipoUpdateManyArgs = {
    /**
     * The data used to update plataforma_papel_tipos.
     * 
    **/
    data: XOR<plataforma_papel_tipoUpdateManyMutationInput, plataforma_papel_tipoUncheckedUpdateManyInput>
    /**
     * Filter which plataforma_papel_tipos to update
     * 
    **/
    where?: plataforma_papel_tipoWhereInput
  }


  /**
   * plataforma_papel_tipo upsert
   */
  export type plataforma_papel_tipoUpsertArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_tipo
     * 
    **/
    select?: plataforma_papel_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_papel_tipoInclude | null
    /**
     * The filter to search for the plataforma_papel_tipo to update in case it exists.
     * 
    **/
    where: plataforma_papel_tipoWhereUniqueInput
    /**
     * In case the plataforma_papel_tipo found by the `where` argument doesn't exist, create a new plataforma_papel_tipo with this data.
     * 
    **/
    create: XOR<plataforma_papel_tipoCreateInput, plataforma_papel_tipoUncheckedCreateInput>
    /**
     * In case the plataforma_papel_tipo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<plataforma_papel_tipoUpdateInput, plataforma_papel_tipoUncheckedUpdateInput>
  }


  /**
   * plataforma_papel_tipo delete
   */
  export type plataforma_papel_tipoDeleteArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_tipo
     * 
    **/
    select?: plataforma_papel_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_papel_tipoInclude | null
    /**
     * Filter which plataforma_papel_tipo to delete.
     * 
    **/
    where: plataforma_papel_tipoWhereUniqueInput
  }


  /**
   * plataforma_papel_tipo deleteMany
   */
  export type plataforma_papel_tipoDeleteManyArgs = {
    /**
     * Filter which plataforma_papel_tipos to delete
     * 
    **/
    where?: plataforma_papel_tipoWhereInput
  }


  /**
   * plataforma_papel_tipo: findUniqueOrThrow
   */
  export type plataforma_papel_tipoFindUniqueOrThrowArgs = plataforma_papel_tipoFindUniqueArgsBase
      

  /**
   * plataforma_papel_tipo: findFirstOrThrow
   */
  export type plataforma_papel_tipoFindFirstOrThrowArgs = plataforma_papel_tipoFindFirstArgsBase
      

  /**
   * plataforma_papel_tipo without action
   */
  export type plataforma_papel_tipoArgs = {
    /**
     * Select specific fields to fetch from the plataforma_papel_tipo
     * 
    **/
    select?: plataforma_papel_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_papel_tipoInclude | null
  }



  /**
   * Model plataforma_x_regiao_atuacao
   */


  export type AggregatePlataforma_x_regiao_atuacao = {
    _count: Plataforma_x_regiao_atuacaoCountAggregateOutputType | null
    _avg: Plataforma_x_regiao_atuacaoAvgAggregateOutputType | null
    _sum: Plataforma_x_regiao_atuacaoSumAggregateOutputType | null
    _min: Plataforma_x_regiao_atuacaoMinAggregateOutputType | null
    _max: Plataforma_x_regiao_atuacaoMaxAggregateOutputType | null
  }

  export type Plataforma_x_regiao_atuacaoAvgAggregateOutputType = {
    id: number | null
    plataforma_id: number | null
    regiao_atuacao_id: number | null
  }

  export type Plataforma_x_regiao_atuacaoSumAggregateOutputType = {
    id: number | null
    plataforma_id: number | null
    regiao_atuacao_id: number | null
  }

  export type Plataforma_x_regiao_atuacaoMinAggregateOutputType = {
    id: number | null
    plataforma_id: number | null
    regiao_atuacao_id: number | null
  }

  export type Plataforma_x_regiao_atuacaoMaxAggregateOutputType = {
    id: number | null
    plataforma_id: number | null
    regiao_atuacao_id: number | null
  }

  export type Plataforma_x_regiao_atuacaoCountAggregateOutputType = {
    id: number
    plataforma_id: number
    regiao_atuacao_id: number
    _all: number
  }


  export type Plataforma_x_regiao_atuacaoAvgAggregateInputType = {
    id?: true
    plataforma_id?: true
    regiao_atuacao_id?: true
  }

  export type Plataforma_x_regiao_atuacaoSumAggregateInputType = {
    id?: true
    plataforma_id?: true
    regiao_atuacao_id?: true
  }

  export type Plataforma_x_regiao_atuacaoMinAggregateInputType = {
    id?: true
    plataforma_id?: true
    regiao_atuacao_id?: true
  }

  export type Plataforma_x_regiao_atuacaoMaxAggregateInputType = {
    id?: true
    plataforma_id?: true
    regiao_atuacao_id?: true
  }

  export type Plataforma_x_regiao_atuacaoCountAggregateInputType = {
    id?: true
    plataforma_id?: true
    regiao_atuacao_id?: true
    _all?: true
  }

  export type Plataforma_x_regiao_atuacaoAggregateArgs = {
    /**
     * Filter which plataforma_x_regiao_atuacao to aggregate.
     * 
    **/
    where?: plataforma_x_regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_x_regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_x_regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: plataforma_x_regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_x_regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_x_regiao_atuacaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plataforma_x_regiao_atuacaos
    **/
    _count?: true | Plataforma_x_regiao_atuacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plataforma_x_regiao_atuacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plataforma_x_regiao_atuacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plataforma_x_regiao_atuacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plataforma_x_regiao_atuacaoMaxAggregateInputType
  }

  export type GetPlataforma_x_regiao_atuacaoAggregateType<T extends Plataforma_x_regiao_atuacaoAggregateArgs> = {
        [P in keyof T & keyof AggregatePlataforma_x_regiao_atuacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlataforma_x_regiao_atuacao[P]>
      : GetScalarType<T[P], AggregatePlataforma_x_regiao_atuacao[P]>
  }




  export type Plataforma_x_regiao_atuacaoGroupByArgs = {
    where?: plataforma_x_regiao_atuacaoWhereInput
    orderBy?: Enumerable<plataforma_x_regiao_atuacaoOrderByWithAggregationInput>
    by: Array<Plataforma_x_regiao_atuacaoScalarFieldEnum>
    having?: plataforma_x_regiao_atuacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plataforma_x_regiao_atuacaoCountAggregateInputType | true
    _avg?: Plataforma_x_regiao_atuacaoAvgAggregateInputType
    _sum?: Plataforma_x_regiao_atuacaoSumAggregateInputType
    _min?: Plataforma_x_regiao_atuacaoMinAggregateInputType
    _max?: Plataforma_x_regiao_atuacaoMaxAggregateInputType
  }


  export type Plataforma_x_regiao_atuacaoGroupByOutputType = {
    id: number
    plataforma_id: number
    regiao_atuacao_id: number
    _count: Plataforma_x_regiao_atuacaoCountAggregateOutputType | null
    _avg: Plataforma_x_regiao_atuacaoAvgAggregateOutputType | null
    _sum: Plataforma_x_regiao_atuacaoSumAggregateOutputType | null
    _min: Plataforma_x_regiao_atuacaoMinAggregateOutputType | null
    _max: Plataforma_x_regiao_atuacaoMaxAggregateOutputType | null
  }

  type GetPlataforma_x_regiao_atuacaoGroupByPayload<T extends Plataforma_x_regiao_atuacaoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Plataforma_x_regiao_atuacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plataforma_x_regiao_atuacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plataforma_x_regiao_atuacaoGroupByOutputType[P]>
            : GetScalarType<T[P], Plataforma_x_regiao_atuacaoGroupByOutputType[P]>
        }
      >
    >


  export type plataforma_x_regiao_atuacaoSelect = {
    id?: boolean
    plataforma_id?: boolean
    regiao_atuacao_id?: boolean
    plataforma?: boolean | plataformaArgs
    regiao_atuacao?: boolean | regiao_atuacaoArgs
  }


  export type plataforma_x_regiao_atuacaoInclude = {
    plataforma?: boolean | plataformaArgs
    regiao_atuacao?: boolean | regiao_atuacaoArgs
  } 

  export type plataforma_x_regiao_atuacaoGetPayload<S extends boolean | null | undefined | plataforma_x_regiao_atuacaoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? plataforma_x_regiao_atuacao :
    S extends undefined ? never :
    S extends { include: any } & (plataforma_x_regiao_atuacaoArgs | plataforma_x_regiao_atuacaoFindManyArgs)
    ? plataforma_x_regiao_atuacao  & {
    [P in TrueKeys<S['include']>]:
        P extends 'plataforma' ? plataformaGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'regiao_atuacao' ? regiao_atuacaoGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (plataforma_x_regiao_atuacaoArgs | plataforma_x_regiao_atuacaoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'plataforma' ? plataformaGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'regiao_atuacao' ? regiao_atuacaoGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof plataforma_x_regiao_atuacao ? plataforma_x_regiao_atuacao[P] : never
  } 
      : plataforma_x_regiao_atuacao


  type plataforma_x_regiao_atuacaoCountArgs = Merge<
    Omit<plataforma_x_regiao_atuacaoFindManyArgs, 'select' | 'include'> & {
      select?: Plataforma_x_regiao_atuacaoCountAggregateInputType | true
    }
  >

  export interface plataforma_x_regiao_atuacaoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Plataforma_x_regiao_atuacao that matches the filter.
     * @param {plataforma_x_regiao_atuacaoFindUniqueArgs} args - Arguments to find a Plataforma_x_regiao_atuacao
     * @example
     * // Get one Plataforma_x_regiao_atuacao
     * const plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends plataforma_x_regiao_atuacaoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, plataforma_x_regiao_atuacaoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'plataforma_x_regiao_atuacao'> extends True ? Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T>> : Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T> | null, null>

    /**
     * Find the first Plataforma_x_regiao_atuacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_x_regiao_atuacaoFindFirstArgs} args - Arguments to find a Plataforma_x_regiao_atuacao
     * @example
     * // Get one Plataforma_x_regiao_atuacao
     * const plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends plataforma_x_regiao_atuacaoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, plataforma_x_regiao_atuacaoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'plataforma_x_regiao_atuacao'> extends True ? Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T>> : Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T> | null, null>

    /**
     * Find zero or more Plataforma_x_regiao_atuacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_x_regiao_atuacaoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plataforma_x_regiao_atuacaos
     * const plataforma_x_regiao_atuacaos = await prisma.plataforma_x_regiao_atuacao.findMany()
     * 
     * // Get first 10 Plataforma_x_regiao_atuacaos
     * const plataforma_x_regiao_atuacaos = await prisma.plataforma_x_regiao_atuacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plataforma_x_regiao_atuacaoWithIdOnly = await prisma.plataforma_x_regiao_atuacao.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends plataforma_x_regiao_atuacaoFindManyArgs>(
      args?: SelectSubset<T, plataforma_x_regiao_atuacaoFindManyArgs>
    ): PrismaPromise<Array<plataforma_x_regiao_atuacaoGetPayload<T>>>

    /**
     * Create a Plataforma_x_regiao_atuacao.
     * @param {plataforma_x_regiao_atuacaoCreateArgs} args - Arguments to create a Plataforma_x_regiao_atuacao.
     * @example
     * // Create one Plataforma_x_regiao_atuacao
     * const Plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.create({
     *   data: {
     *     // ... data to create a Plataforma_x_regiao_atuacao
     *   }
     * })
     * 
    **/
    create<T extends plataforma_x_regiao_atuacaoCreateArgs>(
      args: SelectSubset<T, plataforma_x_regiao_atuacaoCreateArgs>
    ): Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Create many Plataforma_x_regiao_atuacaos.
     *     @param {plataforma_x_regiao_atuacaoCreateManyArgs} args - Arguments to create many Plataforma_x_regiao_atuacaos.
     *     @example
     *     // Create many Plataforma_x_regiao_atuacaos
     *     const plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends plataforma_x_regiao_atuacaoCreateManyArgs>(
      args?: SelectSubset<T, plataforma_x_regiao_atuacaoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Plataforma_x_regiao_atuacao.
     * @param {plataforma_x_regiao_atuacaoDeleteArgs} args - Arguments to delete one Plataforma_x_regiao_atuacao.
     * @example
     * // Delete one Plataforma_x_regiao_atuacao
     * const Plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.delete({
     *   where: {
     *     // ... filter to delete one Plataforma_x_regiao_atuacao
     *   }
     * })
     * 
    **/
    delete<T extends plataforma_x_regiao_atuacaoDeleteArgs>(
      args: SelectSubset<T, plataforma_x_regiao_atuacaoDeleteArgs>
    ): Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Update one Plataforma_x_regiao_atuacao.
     * @param {plataforma_x_regiao_atuacaoUpdateArgs} args - Arguments to update one Plataforma_x_regiao_atuacao.
     * @example
     * // Update one Plataforma_x_regiao_atuacao
     * const plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends plataforma_x_regiao_atuacaoUpdateArgs>(
      args: SelectSubset<T, plataforma_x_regiao_atuacaoUpdateArgs>
    ): Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Delete zero or more Plataforma_x_regiao_atuacaos.
     * @param {plataforma_x_regiao_atuacaoDeleteManyArgs} args - Arguments to filter Plataforma_x_regiao_atuacaos to delete.
     * @example
     * // Delete a few Plataforma_x_regiao_atuacaos
     * const { count } = await prisma.plataforma_x_regiao_atuacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends plataforma_x_regiao_atuacaoDeleteManyArgs>(
      args?: SelectSubset<T, plataforma_x_regiao_atuacaoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plataforma_x_regiao_atuacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_x_regiao_atuacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plataforma_x_regiao_atuacaos
     * const plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends plataforma_x_regiao_atuacaoUpdateManyArgs>(
      args: SelectSubset<T, plataforma_x_regiao_atuacaoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Plataforma_x_regiao_atuacao.
     * @param {plataforma_x_regiao_atuacaoUpsertArgs} args - Arguments to update or create a Plataforma_x_regiao_atuacao.
     * @example
     * // Update or create a Plataforma_x_regiao_atuacao
     * const plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.upsert({
     *   create: {
     *     // ... data to create a Plataforma_x_regiao_atuacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plataforma_x_regiao_atuacao we want to update
     *   }
     * })
    **/
    upsert<T extends plataforma_x_regiao_atuacaoUpsertArgs>(
      args: SelectSubset<T, plataforma_x_regiao_atuacaoUpsertArgs>
    ): Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Find one Plataforma_x_regiao_atuacao that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {plataforma_x_regiao_atuacaoFindUniqueOrThrowArgs} args - Arguments to find a Plataforma_x_regiao_atuacao
     * @example
     * // Get one Plataforma_x_regiao_atuacao
     * const plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends plataforma_x_regiao_atuacaoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, plataforma_x_regiao_atuacaoFindUniqueOrThrowArgs>
    ): Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Find the first Plataforma_x_regiao_atuacao that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_x_regiao_atuacaoFindFirstOrThrowArgs} args - Arguments to find a Plataforma_x_regiao_atuacao
     * @example
     * // Get one Plataforma_x_regiao_atuacao
     * const plataforma_x_regiao_atuacao = await prisma.plataforma_x_regiao_atuacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends plataforma_x_regiao_atuacaoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, plataforma_x_regiao_atuacaoFindFirstOrThrowArgs>
    ): Prisma__plataforma_x_regiao_atuacaoClient<plataforma_x_regiao_atuacaoGetPayload<T>>

    /**
     * Count the number of Plataforma_x_regiao_atuacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_x_regiao_atuacaoCountArgs} args - Arguments to filter Plataforma_x_regiao_atuacaos to count.
     * @example
     * // Count the number of Plataforma_x_regiao_atuacaos
     * const count = await prisma.plataforma_x_regiao_atuacao.count({
     *   where: {
     *     // ... the filter for the Plataforma_x_regiao_atuacaos we want to count
     *   }
     * })
    **/
    count<T extends plataforma_x_regiao_atuacaoCountArgs>(
      args?: Subset<T, plataforma_x_regiao_atuacaoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plataforma_x_regiao_atuacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plataforma_x_regiao_atuacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plataforma_x_regiao_atuacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plataforma_x_regiao_atuacaoAggregateArgs>(args: Subset<T, Plataforma_x_regiao_atuacaoAggregateArgs>): PrismaPromise<GetPlataforma_x_regiao_atuacaoAggregateType<T>>

    /**
     * Group by Plataforma_x_regiao_atuacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plataforma_x_regiao_atuacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Plataforma_x_regiao_atuacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Plataforma_x_regiao_atuacaoGroupByArgs['orderBy'] }
        : { orderBy?: Plataforma_x_regiao_atuacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Plataforma_x_regiao_atuacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlataforma_x_regiao_atuacaoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for plataforma_x_regiao_atuacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__plataforma_x_regiao_atuacaoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    plataforma<T extends plataformaArgs= {}>(args?: Subset<T, plataformaArgs>): Prisma__plataformaClient<plataformaGetPayload<T> | Null>;

    regiao_atuacao<T extends regiao_atuacaoArgs= {}>(args?: Subset<T, regiao_atuacaoArgs>): Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * plataforma_x_regiao_atuacao base type for findUnique actions
   */
  export type plataforma_x_regiao_atuacaoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma_x_regiao_atuacao
     * 
    **/
    select?: plataforma_x_regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_x_regiao_atuacaoInclude | null
    /**
     * Filter, which plataforma_x_regiao_atuacao to fetch.
     * 
    **/
    where: plataforma_x_regiao_atuacaoWhereUniqueInput
  }

  /**
   * plataforma_x_regiao_atuacao: findUnique
   */
  export interface plataforma_x_regiao_atuacaoFindUniqueArgs extends plataforma_x_regiao_atuacaoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma_x_regiao_atuacao base type for findFirst actions
   */
  export type plataforma_x_regiao_atuacaoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma_x_regiao_atuacao
     * 
    **/
    select?: plataforma_x_regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_x_regiao_atuacaoInclude | null
    /**
     * Filter, which plataforma_x_regiao_atuacao to fetch.
     * 
    **/
    where?: plataforma_x_regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_x_regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_x_regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plataforma_x_regiao_atuacaos.
     * 
    **/
    cursor?: plataforma_x_regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_x_regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_x_regiao_atuacaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plataforma_x_regiao_atuacaos.
     * 
    **/
    distinct?: Enumerable<Plataforma_x_regiao_atuacaoScalarFieldEnum>
  }

  /**
   * plataforma_x_regiao_atuacao: findFirst
   */
  export interface plataforma_x_regiao_atuacaoFindFirstArgs extends plataforma_x_regiao_atuacaoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma_x_regiao_atuacao findMany
   */
  export type plataforma_x_regiao_atuacaoFindManyArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_regiao_atuacao
     * 
    **/
    select?: plataforma_x_regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_x_regiao_atuacaoInclude | null
    /**
     * Filter, which plataforma_x_regiao_atuacaos to fetch.
     * 
    **/
    where?: plataforma_x_regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_x_regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_x_regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plataforma_x_regiao_atuacaos.
     * 
    **/
    cursor?: plataforma_x_regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_x_regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_x_regiao_atuacaos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Plataforma_x_regiao_atuacaoScalarFieldEnum>
  }


  /**
   * plataforma_x_regiao_atuacao create
   */
  export type plataforma_x_regiao_atuacaoCreateArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_regiao_atuacao
     * 
    **/
    select?: plataforma_x_regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_x_regiao_atuacaoInclude | null
    /**
     * The data needed to create a plataforma_x_regiao_atuacao.
     * 
    **/
    data: XOR<plataforma_x_regiao_atuacaoCreateInput, plataforma_x_regiao_atuacaoUncheckedCreateInput>
  }


  /**
   * plataforma_x_regiao_atuacao createMany
   */
  export type plataforma_x_regiao_atuacaoCreateManyArgs = {
    /**
     * The data used to create many plataforma_x_regiao_atuacaos.
     * 
    **/
    data: Enumerable<plataforma_x_regiao_atuacaoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * plataforma_x_regiao_atuacao update
   */
  export type plataforma_x_regiao_atuacaoUpdateArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_regiao_atuacao
     * 
    **/
    select?: plataforma_x_regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_x_regiao_atuacaoInclude | null
    /**
     * The data needed to update a plataforma_x_regiao_atuacao.
     * 
    **/
    data: XOR<plataforma_x_regiao_atuacaoUpdateInput, plataforma_x_regiao_atuacaoUncheckedUpdateInput>
    /**
     * Choose, which plataforma_x_regiao_atuacao to update.
     * 
    **/
    where: plataforma_x_regiao_atuacaoWhereUniqueInput
  }


  /**
   * plataforma_x_regiao_atuacao updateMany
   */
  export type plataforma_x_regiao_atuacaoUpdateManyArgs = {
    /**
     * The data used to update plataforma_x_regiao_atuacaos.
     * 
    **/
    data: XOR<plataforma_x_regiao_atuacaoUpdateManyMutationInput, plataforma_x_regiao_atuacaoUncheckedUpdateManyInput>
    /**
     * Filter which plataforma_x_regiao_atuacaos to update
     * 
    **/
    where?: plataforma_x_regiao_atuacaoWhereInput
  }


  /**
   * plataforma_x_regiao_atuacao upsert
   */
  export type plataforma_x_regiao_atuacaoUpsertArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_regiao_atuacao
     * 
    **/
    select?: plataforma_x_regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_x_regiao_atuacaoInclude | null
    /**
     * The filter to search for the plataforma_x_regiao_atuacao to update in case it exists.
     * 
    **/
    where: plataforma_x_regiao_atuacaoWhereUniqueInput
    /**
     * In case the plataforma_x_regiao_atuacao found by the `where` argument doesn't exist, create a new plataforma_x_regiao_atuacao with this data.
     * 
    **/
    create: XOR<plataforma_x_regiao_atuacaoCreateInput, plataforma_x_regiao_atuacaoUncheckedCreateInput>
    /**
     * In case the plataforma_x_regiao_atuacao was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<plataforma_x_regiao_atuacaoUpdateInput, plataforma_x_regiao_atuacaoUncheckedUpdateInput>
  }


  /**
   * plataforma_x_regiao_atuacao delete
   */
  export type plataforma_x_regiao_atuacaoDeleteArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_regiao_atuacao
     * 
    **/
    select?: plataforma_x_regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_x_regiao_atuacaoInclude | null
    /**
     * Filter which plataforma_x_regiao_atuacao to delete.
     * 
    **/
    where: plataforma_x_regiao_atuacaoWhereUniqueInput
  }


  /**
   * plataforma_x_regiao_atuacao deleteMany
   */
  export type plataforma_x_regiao_atuacaoDeleteManyArgs = {
    /**
     * Filter which plataforma_x_regiao_atuacaos to delete
     * 
    **/
    where?: plataforma_x_regiao_atuacaoWhereInput
  }


  /**
   * plataforma_x_regiao_atuacao: findUniqueOrThrow
   */
  export type plataforma_x_regiao_atuacaoFindUniqueOrThrowArgs = plataforma_x_regiao_atuacaoFindUniqueArgsBase
      

  /**
   * plataforma_x_regiao_atuacao: findFirstOrThrow
   */
  export type plataforma_x_regiao_atuacaoFindFirstOrThrowArgs = plataforma_x_regiao_atuacaoFindFirstArgsBase
      

  /**
   * plataforma_x_regiao_atuacao without action
   */
  export type plataforma_x_regiao_atuacaoArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_regiao_atuacao
     * 
    **/
    select?: plataforma_x_regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_x_regiao_atuacaoInclude | null
  }



  /**
   * Model regiao_atuacao
   */


  export type AggregateRegiao_atuacao = {
    _count: Regiao_atuacaoCountAggregateOutputType | null
    _avg: Regiao_atuacaoAvgAggregateOutputType | null
    _sum: Regiao_atuacaoSumAggregateOutputType | null
    _min: Regiao_atuacaoMinAggregateOutputType | null
    _max: Regiao_atuacaoMaxAggregateOutputType | null
  }

  export type Regiao_atuacaoAvgAggregateOutputType = {
    id: number | null
    regiao_atuacao_tipo_id: number | null
  }

  export type Regiao_atuacaoSumAggregateOutputType = {
    id: number | null
    regiao_atuacao_tipo_id: number | null
  }

  export type Regiao_atuacaoMinAggregateOutputType = {
    id: number | null
    nome: string | null
    regiao_atuacao_tipo_id: number | null
  }

  export type Regiao_atuacaoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    regiao_atuacao_tipo_id: number | null
  }

  export type Regiao_atuacaoCountAggregateOutputType = {
    id: number
    nome: number
    regiao_atuacao_tipo_id: number
    _all: number
  }


  export type Regiao_atuacaoAvgAggregateInputType = {
    id?: true
    regiao_atuacao_tipo_id?: true
  }

  export type Regiao_atuacaoSumAggregateInputType = {
    id?: true
    regiao_atuacao_tipo_id?: true
  }

  export type Regiao_atuacaoMinAggregateInputType = {
    id?: true
    nome?: true
    regiao_atuacao_tipo_id?: true
  }

  export type Regiao_atuacaoMaxAggregateInputType = {
    id?: true
    nome?: true
    regiao_atuacao_tipo_id?: true
  }

  export type Regiao_atuacaoCountAggregateInputType = {
    id?: true
    nome?: true
    regiao_atuacao_tipo_id?: true
    _all?: true
  }

  export type Regiao_atuacaoAggregateArgs = {
    /**
     * Filter which regiao_atuacao to aggregate.
     * 
    **/
    where?: regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regiao_atuacaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned regiao_atuacaos
    **/
    _count?: true | Regiao_atuacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Regiao_atuacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Regiao_atuacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Regiao_atuacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Regiao_atuacaoMaxAggregateInputType
  }

  export type GetRegiao_atuacaoAggregateType<T extends Regiao_atuacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateRegiao_atuacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegiao_atuacao[P]>
      : GetScalarType<T[P], AggregateRegiao_atuacao[P]>
  }




  export type Regiao_atuacaoGroupByArgs = {
    where?: regiao_atuacaoWhereInput
    orderBy?: Enumerable<regiao_atuacaoOrderByWithAggregationInput>
    by: Array<Regiao_atuacaoScalarFieldEnum>
    having?: regiao_atuacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Regiao_atuacaoCountAggregateInputType | true
    _avg?: Regiao_atuacaoAvgAggregateInputType
    _sum?: Regiao_atuacaoSumAggregateInputType
    _min?: Regiao_atuacaoMinAggregateInputType
    _max?: Regiao_atuacaoMaxAggregateInputType
  }


  export type Regiao_atuacaoGroupByOutputType = {
    id: number
    nome: string
    regiao_atuacao_tipo_id: number
    _count: Regiao_atuacaoCountAggregateOutputType | null
    _avg: Regiao_atuacaoAvgAggregateOutputType | null
    _sum: Regiao_atuacaoSumAggregateOutputType | null
    _min: Regiao_atuacaoMinAggregateOutputType | null
    _max: Regiao_atuacaoMaxAggregateOutputType | null
  }

  type GetRegiao_atuacaoGroupByPayload<T extends Regiao_atuacaoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Regiao_atuacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Regiao_atuacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Regiao_atuacaoGroupByOutputType[P]>
            : GetScalarType<T[P], Regiao_atuacaoGroupByOutputType[P]>
        }
      >
    >


  export type regiao_atuacaoSelect = {
    id?: boolean
    nome?: boolean
    regiao_atuacao_tipo_id?: boolean
    regiao_atuacao_tipo?: boolean | regiao_atuacao_tipoArgs
    organograma_x_regiao_atuacao?: boolean | organograma_x_regiao_atuacaoFindManyArgs
    plataforma_x_regiao_atuacao?: boolean | plataforma_x_regiao_atuacaoFindManyArgs
    _count?: boolean | Regiao_atuacaoCountOutputTypeArgs
  }


  export type regiao_atuacaoInclude = {
    regiao_atuacao_tipo?: boolean | regiao_atuacao_tipoArgs
    organograma_x_regiao_atuacao?: boolean | organograma_x_regiao_atuacaoFindManyArgs
    plataforma_x_regiao_atuacao?: boolean | plataforma_x_regiao_atuacaoFindManyArgs
    _count?: boolean | Regiao_atuacaoCountOutputTypeArgs
  } 

  export type regiao_atuacaoGetPayload<S extends boolean | null | undefined | regiao_atuacaoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? regiao_atuacao :
    S extends undefined ? never :
    S extends { include: any } & (regiao_atuacaoArgs | regiao_atuacaoFindManyArgs)
    ? regiao_atuacao  & {
    [P in TrueKeys<S['include']>]:
        P extends 'regiao_atuacao_tipo' ? regiao_atuacao_tipoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'organograma_x_regiao_atuacao' ? Array < organograma_x_regiao_atuacaoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends 'plataforma_x_regiao_atuacao' ? Array < plataforma_x_regiao_atuacaoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Regiao_atuacaoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (regiao_atuacaoArgs | regiao_atuacaoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'regiao_atuacao_tipo' ? regiao_atuacao_tipoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'organograma_x_regiao_atuacao' ? Array < organograma_x_regiao_atuacaoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends 'plataforma_x_regiao_atuacao' ? Array < plataforma_x_regiao_atuacaoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Regiao_atuacaoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof regiao_atuacao ? regiao_atuacao[P] : never
  } 
      : regiao_atuacao


  type regiao_atuacaoCountArgs = Merge<
    Omit<regiao_atuacaoFindManyArgs, 'select' | 'include'> & {
      select?: Regiao_atuacaoCountAggregateInputType | true
    }
  >

  export interface regiao_atuacaoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Regiao_atuacao that matches the filter.
     * @param {regiao_atuacaoFindUniqueArgs} args - Arguments to find a Regiao_atuacao
     * @example
     * // Get one Regiao_atuacao
     * const regiao_atuacao = await prisma.regiao_atuacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends regiao_atuacaoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, regiao_atuacaoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'regiao_atuacao'> extends True ? Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T>> : Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T> | null, null>

    /**
     * Find the first Regiao_atuacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacaoFindFirstArgs} args - Arguments to find a Regiao_atuacao
     * @example
     * // Get one Regiao_atuacao
     * const regiao_atuacao = await prisma.regiao_atuacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends regiao_atuacaoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, regiao_atuacaoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'regiao_atuacao'> extends True ? Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T>> : Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T> | null, null>

    /**
     * Find zero or more Regiao_atuacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacaoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regiao_atuacaos
     * const regiao_atuacaos = await prisma.regiao_atuacao.findMany()
     * 
     * // Get first 10 Regiao_atuacaos
     * const regiao_atuacaos = await prisma.regiao_atuacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regiao_atuacaoWithIdOnly = await prisma.regiao_atuacao.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends regiao_atuacaoFindManyArgs>(
      args?: SelectSubset<T, regiao_atuacaoFindManyArgs>
    ): PrismaPromise<Array<regiao_atuacaoGetPayload<T>>>

    /**
     * Create a Regiao_atuacao.
     * @param {regiao_atuacaoCreateArgs} args - Arguments to create a Regiao_atuacao.
     * @example
     * // Create one Regiao_atuacao
     * const Regiao_atuacao = await prisma.regiao_atuacao.create({
     *   data: {
     *     // ... data to create a Regiao_atuacao
     *   }
     * })
     * 
    **/
    create<T extends regiao_atuacaoCreateArgs>(
      args: SelectSubset<T, regiao_atuacaoCreateArgs>
    ): Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T>>

    /**
     * Create many Regiao_atuacaos.
     *     @param {regiao_atuacaoCreateManyArgs} args - Arguments to create many Regiao_atuacaos.
     *     @example
     *     // Create many Regiao_atuacaos
     *     const regiao_atuacao = await prisma.regiao_atuacao.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends regiao_atuacaoCreateManyArgs>(
      args?: SelectSubset<T, regiao_atuacaoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Regiao_atuacao.
     * @param {regiao_atuacaoDeleteArgs} args - Arguments to delete one Regiao_atuacao.
     * @example
     * // Delete one Regiao_atuacao
     * const Regiao_atuacao = await prisma.regiao_atuacao.delete({
     *   where: {
     *     // ... filter to delete one Regiao_atuacao
     *   }
     * })
     * 
    **/
    delete<T extends regiao_atuacaoDeleteArgs>(
      args: SelectSubset<T, regiao_atuacaoDeleteArgs>
    ): Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T>>

    /**
     * Update one Regiao_atuacao.
     * @param {regiao_atuacaoUpdateArgs} args - Arguments to update one Regiao_atuacao.
     * @example
     * // Update one Regiao_atuacao
     * const regiao_atuacao = await prisma.regiao_atuacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends regiao_atuacaoUpdateArgs>(
      args: SelectSubset<T, regiao_atuacaoUpdateArgs>
    ): Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T>>

    /**
     * Delete zero or more Regiao_atuacaos.
     * @param {regiao_atuacaoDeleteManyArgs} args - Arguments to filter Regiao_atuacaos to delete.
     * @example
     * // Delete a few Regiao_atuacaos
     * const { count } = await prisma.regiao_atuacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends regiao_atuacaoDeleteManyArgs>(
      args?: SelectSubset<T, regiao_atuacaoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regiao_atuacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regiao_atuacaos
     * const regiao_atuacao = await prisma.regiao_atuacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends regiao_atuacaoUpdateManyArgs>(
      args: SelectSubset<T, regiao_atuacaoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Regiao_atuacao.
     * @param {regiao_atuacaoUpsertArgs} args - Arguments to update or create a Regiao_atuacao.
     * @example
     * // Update or create a Regiao_atuacao
     * const regiao_atuacao = await prisma.regiao_atuacao.upsert({
     *   create: {
     *     // ... data to create a Regiao_atuacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Regiao_atuacao we want to update
     *   }
     * })
    **/
    upsert<T extends regiao_atuacaoUpsertArgs>(
      args: SelectSubset<T, regiao_atuacaoUpsertArgs>
    ): Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T>>

    /**
     * Find one Regiao_atuacao that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {regiao_atuacaoFindUniqueOrThrowArgs} args - Arguments to find a Regiao_atuacao
     * @example
     * // Get one Regiao_atuacao
     * const regiao_atuacao = await prisma.regiao_atuacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends regiao_atuacaoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, regiao_atuacaoFindUniqueOrThrowArgs>
    ): Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T>>

    /**
     * Find the first Regiao_atuacao that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacaoFindFirstOrThrowArgs} args - Arguments to find a Regiao_atuacao
     * @example
     * // Get one Regiao_atuacao
     * const regiao_atuacao = await prisma.regiao_atuacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends regiao_atuacaoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, regiao_atuacaoFindFirstOrThrowArgs>
    ): Prisma__regiao_atuacaoClient<regiao_atuacaoGetPayload<T>>

    /**
     * Count the number of Regiao_atuacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacaoCountArgs} args - Arguments to filter Regiao_atuacaos to count.
     * @example
     * // Count the number of Regiao_atuacaos
     * const count = await prisma.regiao_atuacao.count({
     *   where: {
     *     // ... the filter for the Regiao_atuacaos we want to count
     *   }
     * })
    **/
    count<T extends regiao_atuacaoCountArgs>(
      args?: Subset<T, regiao_atuacaoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Regiao_atuacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Regiao_atuacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Regiao_atuacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Regiao_atuacaoAggregateArgs>(args: Subset<T, Regiao_atuacaoAggregateArgs>): PrismaPromise<GetRegiao_atuacaoAggregateType<T>>

    /**
     * Group by Regiao_atuacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Regiao_atuacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Regiao_atuacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Regiao_atuacaoGroupByArgs['orderBy'] }
        : { orderBy?: Regiao_atuacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Regiao_atuacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegiao_atuacaoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for regiao_atuacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__regiao_atuacaoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    regiao_atuacao_tipo<T extends regiao_atuacao_tipoArgs= {}>(args?: Subset<T, regiao_atuacao_tipoArgs>): Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T> | Null>;

    organograma_x_regiao_atuacao<T extends organograma_x_regiao_atuacaoFindManyArgs= {}>(args?: Subset<T, organograma_x_regiao_atuacaoFindManyArgs>): PrismaPromise<Array<organograma_x_regiao_atuacaoGetPayload<T>>| Null>;

    plataforma_x_regiao_atuacao<T extends plataforma_x_regiao_atuacaoFindManyArgs= {}>(args?: Subset<T, plataforma_x_regiao_atuacaoFindManyArgs>): PrismaPromise<Array<plataforma_x_regiao_atuacaoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * regiao_atuacao base type for findUnique actions
   */
  export type regiao_atuacaoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the regiao_atuacao
     * 
    **/
    select?: regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regiao_atuacaoInclude | null
    /**
     * Filter, which regiao_atuacao to fetch.
     * 
    **/
    where: regiao_atuacaoWhereUniqueInput
  }

  /**
   * regiao_atuacao: findUnique
   */
  export interface regiao_atuacaoFindUniqueArgs extends regiao_atuacaoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * regiao_atuacao base type for findFirst actions
   */
  export type regiao_atuacaoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the regiao_atuacao
     * 
    **/
    select?: regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regiao_atuacaoInclude | null
    /**
     * Filter, which regiao_atuacao to fetch.
     * 
    **/
    where?: regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for regiao_atuacaos.
     * 
    **/
    cursor?: regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regiao_atuacaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of regiao_atuacaos.
     * 
    **/
    distinct?: Enumerable<Regiao_atuacaoScalarFieldEnum>
  }

  /**
   * regiao_atuacao: findFirst
   */
  export interface regiao_atuacaoFindFirstArgs extends regiao_atuacaoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * regiao_atuacao findMany
   */
  export type regiao_atuacaoFindManyArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao
     * 
    **/
    select?: regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regiao_atuacaoInclude | null
    /**
     * Filter, which regiao_atuacaos to fetch.
     * 
    **/
    where?: regiao_atuacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regiao_atuacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<regiao_atuacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing regiao_atuacaos.
     * 
    **/
    cursor?: regiao_atuacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regiao_atuacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regiao_atuacaos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Regiao_atuacaoScalarFieldEnum>
  }


  /**
   * regiao_atuacao create
   */
  export type regiao_atuacaoCreateArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao
     * 
    **/
    select?: regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regiao_atuacaoInclude | null
    /**
     * The data needed to create a regiao_atuacao.
     * 
    **/
    data: XOR<regiao_atuacaoCreateInput, regiao_atuacaoUncheckedCreateInput>
  }


  /**
   * regiao_atuacao createMany
   */
  export type regiao_atuacaoCreateManyArgs = {
    /**
     * The data used to create many regiao_atuacaos.
     * 
    **/
    data: Enumerable<regiao_atuacaoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * regiao_atuacao update
   */
  export type regiao_atuacaoUpdateArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao
     * 
    **/
    select?: regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regiao_atuacaoInclude | null
    /**
     * The data needed to update a regiao_atuacao.
     * 
    **/
    data: XOR<regiao_atuacaoUpdateInput, regiao_atuacaoUncheckedUpdateInput>
    /**
     * Choose, which regiao_atuacao to update.
     * 
    **/
    where: regiao_atuacaoWhereUniqueInput
  }


  /**
   * regiao_atuacao updateMany
   */
  export type regiao_atuacaoUpdateManyArgs = {
    /**
     * The data used to update regiao_atuacaos.
     * 
    **/
    data: XOR<regiao_atuacaoUpdateManyMutationInput, regiao_atuacaoUncheckedUpdateManyInput>
    /**
     * Filter which regiao_atuacaos to update
     * 
    **/
    where?: regiao_atuacaoWhereInput
  }


  /**
   * regiao_atuacao upsert
   */
  export type regiao_atuacaoUpsertArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao
     * 
    **/
    select?: regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regiao_atuacaoInclude | null
    /**
     * The filter to search for the regiao_atuacao to update in case it exists.
     * 
    **/
    where: regiao_atuacaoWhereUniqueInput
    /**
     * In case the regiao_atuacao found by the `where` argument doesn't exist, create a new regiao_atuacao with this data.
     * 
    **/
    create: XOR<regiao_atuacaoCreateInput, regiao_atuacaoUncheckedCreateInput>
    /**
     * In case the regiao_atuacao was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<regiao_atuacaoUpdateInput, regiao_atuacaoUncheckedUpdateInput>
  }


  /**
   * regiao_atuacao delete
   */
  export type regiao_atuacaoDeleteArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao
     * 
    **/
    select?: regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regiao_atuacaoInclude | null
    /**
     * Filter which regiao_atuacao to delete.
     * 
    **/
    where: regiao_atuacaoWhereUniqueInput
  }


  /**
   * regiao_atuacao deleteMany
   */
  export type regiao_atuacaoDeleteManyArgs = {
    /**
     * Filter which regiao_atuacaos to delete
     * 
    **/
    where?: regiao_atuacaoWhereInput
  }


  /**
   * regiao_atuacao: findUniqueOrThrow
   */
  export type regiao_atuacaoFindUniqueOrThrowArgs = regiao_atuacaoFindUniqueArgsBase
      

  /**
   * regiao_atuacao: findFirstOrThrow
   */
  export type regiao_atuacaoFindFirstOrThrowArgs = regiao_atuacaoFindFirstArgsBase
      

  /**
   * regiao_atuacao without action
   */
  export type regiao_atuacaoArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao
     * 
    **/
    select?: regiao_atuacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regiao_atuacaoInclude | null
  }



  /**
   * Model regiao_atuacao_tipo
   */


  export type AggregateRegiao_atuacao_tipo = {
    _count: Regiao_atuacao_tipoCountAggregateOutputType | null
    _avg: Regiao_atuacao_tipoAvgAggregateOutputType | null
    _sum: Regiao_atuacao_tipoSumAggregateOutputType | null
    _min: Regiao_atuacao_tipoMinAggregateOutputType | null
    _max: Regiao_atuacao_tipoMaxAggregateOutputType | null
  }

  export type Regiao_atuacao_tipoAvgAggregateOutputType = {
    id: number | null
  }

  export type Regiao_atuacao_tipoSumAggregateOutputType = {
    id: number | null
  }

  export type Regiao_atuacao_tipoMinAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Regiao_atuacao_tipoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Regiao_atuacao_tipoCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type Regiao_atuacao_tipoAvgAggregateInputType = {
    id?: true
  }

  export type Regiao_atuacao_tipoSumAggregateInputType = {
    id?: true
  }

  export type Regiao_atuacao_tipoMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Regiao_atuacao_tipoMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Regiao_atuacao_tipoCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type Regiao_atuacao_tipoAggregateArgs = {
    /**
     * Filter which regiao_atuacao_tipo to aggregate.
     * 
    **/
    where?: regiao_atuacao_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regiao_atuacao_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<regiao_atuacao_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: regiao_atuacao_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regiao_atuacao_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regiao_atuacao_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned regiao_atuacao_tipos
    **/
    _count?: true | Regiao_atuacao_tipoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Regiao_atuacao_tipoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Regiao_atuacao_tipoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Regiao_atuacao_tipoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Regiao_atuacao_tipoMaxAggregateInputType
  }

  export type GetRegiao_atuacao_tipoAggregateType<T extends Regiao_atuacao_tipoAggregateArgs> = {
        [P in keyof T & keyof AggregateRegiao_atuacao_tipo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegiao_atuacao_tipo[P]>
      : GetScalarType<T[P], AggregateRegiao_atuacao_tipo[P]>
  }




  export type Regiao_atuacao_tipoGroupByArgs = {
    where?: regiao_atuacao_tipoWhereInput
    orderBy?: Enumerable<regiao_atuacao_tipoOrderByWithAggregationInput>
    by: Array<Regiao_atuacao_tipoScalarFieldEnum>
    having?: regiao_atuacao_tipoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Regiao_atuacao_tipoCountAggregateInputType | true
    _avg?: Regiao_atuacao_tipoAvgAggregateInputType
    _sum?: Regiao_atuacao_tipoSumAggregateInputType
    _min?: Regiao_atuacao_tipoMinAggregateInputType
    _max?: Regiao_atuacao_tipoMaxAggregateInputType
  }


  export type Regiao_atuacao_tipoGroupByOutputType = {
    id: number
    nome: string
    _count: Regiao_atuacao_tipoCountAggregateOutputType | null
    _avg: Regiao_atuacao_tipoAvgAggregateOutputType | null
    _sum: Regiao_atuacao_tipoSumAggregateOutputType | null
    _min: Regiao_atuacao_tipoMinAggregateOutputType | null
    _max: Regiao_atuacao_tipoMaxAggregateOutputType | null
  }

  type GetRegiao_atuacao_tipoGroupByPayload<T extends Regiao_atuacao_tipoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Regiao_atuacao_tipoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Regiao_atuacao_tipoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Regiao_atuacao_tipoGroupByOutputType[P]>
            : GetScalarType<T[P], Regiao_atuacao_tipoGroupByOutputType[P]>
        }
      >
    >


  export type regiao_atuacao_tipoSelect = {
    id?: boolean
    nome?: boolean
    regiao_atuacao?: boolean | regiao_atuacaoFindManyArgs
    _count?: boolean | Regiao_atuacao_tipoCountOutputTypeArgs
  }


  export type regiao_atuacao_tipoInclude = {
    regiao_atuacao?: boolean | regiao_atuacaoFindManyArgs
    _count?: boolean | Regiao_atuacao_tipoCountOutputTypeArgs
  } 

  export type regiao_atuacao_tipoGetPayload<S extends boolean | null | undefined | regiao_atuacao_tipoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? regiao_atuacao_tipo :
    S extends undefined ? never :
    S extends { include: any } & (regiao_atuacao_tipoArgs | regiao_atuacao_tipoFindManyArgs)
    ? regiao_atuacao_tipo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'regiao_atuacao' ? Array < regiao_atuacaoGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Regiao_atuacao_tipoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (regiao_atuacao_tipoArgs | regiao_atuacao_tipoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'regiao_atuacao' ? Array < regiao_atuacaoGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Regiao_atuacao_tipoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof regiao_atuacao_tipo ? regiao_atuacao_tipo[P] : never
  } 
      : regiao_atuacao_tipo


  type regiao_atuacao_tipoCountArgs = Merge<
    Omit<regiao_atuacao_tipoFindManyArgs, 'select' | 'include'> & {
      select?: Regiao_atuacao_tipoCountAggregateInputType | true
    }
  >

  export interface regiao_atuacao_tipoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Regiao_atuacao_tipo that matches the filter.
     * @param {regiao_atuacao_tipoFindUniqueArgs} args - Arguments to find a Regiao_atuacao_tipo
     * @example
     * // Get one Regiao_atuacao_tipo
     * const regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends regiao_atuacao_tipoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, regiao_atuacao_tipoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'regiao_atuacao_tipo'> extends True ? Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T>> : Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T> | null, null>

    /**
     * Find the first Regiao_atuacao_tipo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacao_tipoFindFirstArgs} args - Arguments to find a Regiao_atuacao_tipo
     * @example
     * // Get one Regiao_atuacao_tipo
     * const regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends regiao_atuacao_tipoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, regiao_atuacao_tipoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'regiao_atuacao_tipo'> extends True ? Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T>> : Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T> | null, null>

    /**
     * Find zero or more Regiao_atuacao_tipos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacao_tipoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regiao_atuacao_tipos
     * const regiao_atuacao_tipos = await prisma.regiao_atuacao_tipo.findMany()
     * 
     * // Get first 10 Regiao_atuacao_tipos
     * const regiao_atuacao_tipos = await prisma.regiao_atuacao_tipo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regiao_atuacao_tipoWithIdOnly = await prisma.regiao_atuacao_tipo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends regiao_atuacao_tipoFindManyArgs>(
      args?: SelectSubset<T, regiao_atuacao_tipoFindManyArgs>
    ): PrismaPromise<Array<regiao_atuacao_tipoGetPayload<T>>>

    /**
     * Create a Regiao_atuacao_tipo.
     * @param {regiao_atuacao_tipoCreateArgs} args - Arguments to create a Regiao_atuacao_tipo.
     * @example
     * // Create one Regiao_atuacao_tipo
     * const Regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.create({
     *   data: {
     *     // ... data to create a Regiao_atuacao_tipo
     *   }
     * })
     * 
    **/
    create<T extends regiao_atuacao_tipoCreateArgs>(
      args: SelectSubset<T, regiao_atuacao_tipoCreateArgs>
    ): Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T>>

    /**
     * Create many Regiao_atuacao_tipos.
     *     @param {regiao_atuacao_tipoCreateManyArgs} args - Arguments to create many Regiao_atuacao_tipos.
     *     @example
     *     // Create many Regiao_atuacao_tipos
     *     const regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends regiao_atuacao_tipoCreateManyArgs>(
      args?: SelectSubset<T, regiao_atuacao_tipoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Regiao_atuacao_tipo.
     * @param {regiao_atuacao_tipoDeleteArgs} args - Arguments to delete one Regiao_atuacao_tipo.
     * @example
     * // Delete one Regiao_atuacao_tipo
     * const Regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.delete({
     *   where: {
     *     // ... filter to delete one Regiao_atuacao_tipo
     *   }
     * })
     * 
    **/
    delete<T extends regiao_atuacao_tipoDeleteArgs>(
      args: SelectSubset<T, regiao_atuacao_tipoDeleteArgs>
    ): Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T>>

    /**
     * Update one Regiao_atuacao_tipo.
     * @param {regiao_atuacao_tipoUpdateArgs} args - Arguments to update one Regiao_atuacao_tipo.
     * @example
     * // Update one Regiao_atuacao_tipo
     * const regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends regiao_atuacao_tipoUpdateArgs>(
      args: SelectSubset<T, regiao_atuacao_tipoUpdateArgs>
    ): Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T>>

    /**
     * Delete zero or more Regiao_atuacao_tipos.
     * @param {regiao_atuacao_tipoDeleteManyArgs} args - Arguments to filter Regiao_atuacao_tipos to delete.
     * @example
     * // Delete a few Regiao_atuacao_tipos
     * const { count } = await prisma.regiao_atuacao_tipo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends regiao_atuacao_tipoDeleteManyArgs>(
      args?: SelectSubset<T, regiao_atuacao_tipoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regiao_atuacao_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacao_tipoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regiao_atuacao_tipos
     * const regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends regiao_atuacao_tipoUpdateManyArgs>(
      args: SelectSubset<T, regiao_atuacao_tipoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Regiao_atuacao_tipo.
     * @param {regiao_atuacao_tipoUpsertArgs} args - Arguments to update or create a Regiao_atuacao_tipo.
     * @example
     * // Update or create a Regiao_atuacao_tipo
     * const regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.upsert({
     *   create: {
     *     // ... data to create a Regiao_atuacao_tipo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Regiao_atuacao_tipo we want to update
     *   }
     * })
    **/
    upsert<T extends regiao_atuacao_tipoUpsertArgs>(
      args: SelectSubset<T, regiao_atuacao_tipoUpsertArgs>
    ): Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T>>

    /**
     * Find one Regiao_atuacao_tipo that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {regiao_atuacao_tipoFindUniqueOrThrowArgs} args - Arguments to find a Regiao_atuacao_tipo
     * @example
     * // Get one Regiao_atuacao_tipo
     * const regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends regiao_atuacao_tipoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, regiao_atuacao_tipoFindUniqueOrThrowArgs>
    ): Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T>>

    /**
     * Find the first Regiao_atuacao_tipo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacao_tipoFindFirstOrThrowArgs} args - Arguments to find a Regiao_atuacao_tipo
     * @example
     * // Get one Regiao_atuacao_tipo
     * const regiao_atuacao_tipo = await prisma.regiao_atuacao_tipo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends regiao_atuacao_tipoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, regiao_atuacao_tipoFindFirstOrThrowArgs>
    ): Prisma__regiao_atuacao_tipoClient<regiao_atuacao_tipoGetPayload<T>>

    /**
     * Count the number of Regiao_atuacao_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiao_atuacao_tipoCountArgs} args - Arguments to filter Regiao_atuacao_tipos to count.
     * @example
     * // Count the number of Regiao_atuacao_tipos
     * const count = await prisma.regiao_atuacao_tipo.count({
     *   where: {
     *     // ... the filter for the Regiao_atuacao_tipos we want to count
     *   }
     * })
    **/
    count<T extends regiao_atuacao_tipoCountArgs>(
      args?: Subset<T, regiao_atuacao_tipoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Regiao_atuacao_tipoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Regiao_atuacao_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Regiao_atuacao_tipoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Regiao_atuacao_tipoAggregateArgs>(args: Subset<T, Regiao_atuacao_tipoAggregateArgs>): PrismaPromise<GetRegiao_atuacao_tipoAggregateType<T>>

    /**
     * Group by Regiao_atuacao_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Regiao_atuacao_tipoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Regiao_atuacao_tipoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Regiao_atuacao_tipoGroupByArgs['orderBy'] }
        : { orderBy?: Regiao_atuacao_tipoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Regiao_atuacao_tipoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegiao_atuacao_tipoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for regiao_atuacao_tipo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__regiao_atuacao_tipoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    regiao_atuacao<T extends regiao_atuacaoFindManyArgs= {}>(args?: Subset<T, regiao_atuacaoFindManyArgs>): PrismaPromise<Array<regiao_atuacaoGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * regiao_atuacao_tipo base type for findUnique actions
   */
  export type regiao_atuacao_tipoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the regiao_atuacao_tipo
     * 
    **/
    select?: regiao_atuacao_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regiao_atuacao_tipoInclude | null
    /**
     * Filter, which regiao_atuacao_tipo to fetch.
     * 
    **/
    where: regiao_atuacao_tipoWhereUniqueInput
  }

  /**
   * regiao_atuacao_tipo: findUnique
   */
  export interface regiao_atuacao_tipoFindUniqueArgs extends regiao_atuacao_tipoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * regiao_atuacao_tipo base type for findFirst actions
   */
  export type regiao_atuacao_tipoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the regiao_atuacao_tipo
     * 
    **/
    select?: regiao_atuacao_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regiao_atuacao_tipoInclude | null
    /**
     * Filter, which regiao_atuacao_tipo to fetch.
     * 
    **/
    where?: regiao_atuacao_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regiao_atuacao_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<regiao_atuacao_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for regiao_atuacao_tipos.
     * 
    **/
    cursor?: regiao_atuacao_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regiao_atuacao_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regiao_atuacao_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of regiao_atuacao_tipos.
     * 
    **/
    distinct?: Enumerable<Regiao_atuacao_tipoScalarFieldEnum>
  }

  /**
   * regiao_atuacao_tipo: findFirst
   */
  export interface regiao_atuacao_tipoFindFirstArgs extends regiao_atuacao_tipoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * regiao_atuacao_tipo findMany
   */
  export type regiao_atuacao_tipoFindManyArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao_tipo
     * 
    **/
    select?: regiao_atuacao_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regiao_atuacao_tipoInclude | null
    /**
     * Filter, which regiao_atuacao_tipos to fetch.
     * 
    **/
    where?: regiao_atuacao_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regiao_atuacao_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<regiao_atuacao_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing regiao_atuacao_tipos.
     * 
    **/
    cursor?: regiao_atuacao_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regiao_atuacao_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regiao_atuacao_tipos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Regiao_atuacao_tipoScalarFieldEnum>
  }


  /**
   * regiao_atuacao_tipo create
   */
  export type regiao_atuacao_tipoCreateArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao_tipo
     * 
    **/
    select?: regiao_atuacao_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regiao_atuacao_tipoInclude | null
    /**
     * The data needed to create a regiao_atuacao_tipo.
     * 
    **/
    data: XOR<regiao_atuacao_tipoCreateInput, regiao_atuacao_tipoUncheckedCreateInput>
  }


  /**
   * regiao_atuacao_tipo createMany
   */
  export type regiao_atuacao_tipoCreateManyArgs = {
    /**
     * The data used to create many regiao_atuacao_tipos.
     * 
    **/
    data: Enumerable<regiao_atuacao_tipoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * regiao_atuacao_tipo update
   */
  export type regiao_atuacao_tipoUpdateArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao_tipo
     * 
    **/
    select?: regiao_atuacao_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regiao_atuacao_tipoInclude | null
    /**
     * The data needed to update a regiao_atuacao_tipo.
     * 
    **/
    data: XOR<regiao_atuacao_tipoUpdateInput, regiao_atuacao_tipoUncheckedUpdateInput>
    /**
     * Choose, which regiao_atuacao_tipo to update.
     * 
    **/
    where: regiao_atuacao_tipoWhereUniqueInput
  }


  /**
   * regiao_atuacao_tipo updateMany
   */
  export type regiao_atuacao_tipoUpdateManyArgs = {
    /**
     * The data used to update regiao_atuacao_tipos.
     * 
    **/
    data: XOR<regiao_atuacao_tipoUpdateManyMutationInput, regiao_atuacao_tipoUncheckedUpdateManyInput>
    /**
     * Filter which regiao_atuacao_tipos to update
     * 
    **/
    where?: regiao_atuacao_tipoWhereInput
  }


  /**
   * regiao_atuacao_tipo upsert
   */
  export type regiao_atuacao_tipoUpsertArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao_tipo
     * 
    **/
    select?: regiao_atuacao_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regiao_atuacao_tipoInclude | null
    /**
     * The filter to search for the regiao_atuacao_tipo to update in case it exists.
     * 
    **/
    where: regiao_atuacao_tipoWhereUniqueInput
    /**
     * In case the regiao_atuacao_tipo found by the `where` argument doesn't exist, create a new regiao_atuacao_tipo with this data.
     * 
    **/
    create: XOR<regiao_atuacao_tipoCreateInput, regiao_atuacao_tipoUncheckedCreateInput>
    /**
     * In case the regiao_atuacao_tipo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<regiao_atuacao_tipoUpdateInput, regiao_atuacao_tipoUncheckedUpdateInput>
  }


  /**
   * regiao_atuacao_tipo delete
   */
  export type regiao_atuacao_tipoDeleteArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao_tipo
     * 
    **/
    select?: regiao_atuacao_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regiao_atuacao_tipoInclude | null
    /**
     * Filter which regiao_atuacao_tipo to delete.
     * 
    **/
    where: regiao_atuacao_tipoWhereUniqueInput
  }


  /**
   * regiao_atuacao_tipo deleteMany
   */
  export type regiao_atuacao_tipoDeleteManyArgs = {
    /**
     * Filter which regiao_atuacao_tipos to delete
     * 
    **/
    where?: regiao_atuacao_tipoWhereInput
  }


  /**
   * regiao_atuacao_tipo: findUniqueOrThrow
   */
  export type regiao_atuacao_tipoFindUniqueOrThrowArgs = regiao_atuacao_tipoFindUniqueArgsBase
      

  /**
   * regiao_atuacao_tipo: findFirstOrThrow
   */
  export type regiao_atuacao_tipoFindFirstOrThrowArgs = regiao_atuacao_tipoFindFirstArgsBase
      

  /**
   * regiao_atuacao_tipo without action
   */
  export type regiao_atuacao_tipoArgs = {
    /**
     * Select specific fields to fetch from the regiao_atuacao_tipo
     * 
    **/
    select?: regiao_atuacao_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: regiao_atuacao_tipoInclude | null
  }



  /**
   * Model sacado
   */


  export type AggregateSacado = {
    _count: SacadoCountAggregateOutputType | null
    _avg: SacadoAvgAggregateOutputType | null
    _sum: SacadoSumAggregateOutputType | null
    _min: SacadoMinAggregateOutputType | null
    _max: SacadoMaxAggregateOutputType | null
  }

  export type SacadoAvgAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
  }

  export type SacadoSumAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
  }

  export type SacadoMinAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
    razao_social: string | null
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
  }

  export type SacadoMaxAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
    razao_social: string | null
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
  }

  export type SacadoCountAggregateOutputType = {
    id: number
    pessoa_id: number
    razao_social: number
    nome_fantasia: number
    abertura: number
    cnpj: number
    _all: number
  }


  export type SacadoAvgAggregateInputType = {
    id?: true
    pessoa_id?: true
  }

  export type SacadoSumAggregateInputType = {
    id?: true
    pessoa_id?: true
  }

  export type SacadoMinAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
  }

  export type SacadoMaxAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
  }

  export type SacadoCountAggregateInputType = {
    id?: true
    pessoa_id?: true
    razao_social?: true
    nome_fantasia?: true
    abertura?: true
    cnpj?: true
    _all?: true
  }

  export type SacadoAggregateArgs = {
    /**
     * Filter which sacado to aggregate.
     * 
    **/
    where?: sacadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sacados to fetch.
     * 
    **/
    orderBy?: Enumerable<sacadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: sacadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sacados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sacados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sacados
    **/
    _count?: true | SacadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SacadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SacadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SacadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SacadoMaxAggregateInputType
  }

  export type GetSacadoAggregateType<T extends SacadoAggregateArgs> = {
        [P in keyof T & keyof AggregateSacado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSacado[P]>
      : GetScalarType<T[P], AggregateSacado[P]>
  }




  export type SacadoGroupByArgs = {
    where?: sacadoWhereInput
    orderBy?: Enumerable<sacadoOrderByWithAggregationInput>
    by: Array<SacadoScalarFieldEnum>
    having?: sacadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SacadoCountAggregateInputType | true
    _avg?: SacadoAvgAggregateInputType
    _sum?: SacadoSumAggregateInputType
    _min?: SacadoMinAggregateInputType
    _max?: SacadoMaxAggregateInputType
  }


  export type SacadoGroupByOutputType = {
    id: number
    pessoa_id: number
    razao_social: string
    nome_fantasia: string | null
    abertura: Date | null
    cnpj: string | null
    _count: SacadoCountAggregateOutputType | null
    _avg: SacadoAvgAggregateOutputType | null
    _sum: SacadoSumAggregateOutputType | null
    _min: SacadoMinAggregateOutputType | null
    _max: SacadoMaxAggregateOutputType | null
  }

  type GetSacadoGroupByPayload<T extends SacadoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SacadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SacadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SacadoGroupByOutputType[P]>
            : GetScalarType<T[P], SacadoGroupByOutputType[P]>
        }
      >
    >


  export type sacadoSelect = {
    id?: boolean
    pessoa_id?: boolean
    razao_social?: boolean
    nome_fantasia?: boolean
    abertura?: boolean
    cnpj?: boolean
    cedente_n_sacados?: boolean | cedente_n_sacadosFindManyArgs
    _count?: boolean | SacadoCountOutputTypeArgs
  }


  export type sacadoInclude = {
    cedente_n_sacados?: boolean | cedente_n_sacadosFindManyArgs
    _count?: boolean | SacadoCountOutputTypeArgs
  } 

  export type sacadoGetPayload<S extends boolean | null | undefined | sacadoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? sacado :
    S extends undefined ? never :
    S extends { include: any } & (sacadoArgs | sacadoFindManyArgs)
    ? sacado  & {
    [P in TrueKeys<S['include']>]:
        P extends 'cedente_n_sacados' ? Array < cedente_n_sacadosGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? SacadoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (sacadoArgs | sacadoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'cedente_n_sacados' ? Array < cedente_n_sacadosGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? SacadoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof sacado ? sacado[P] : never
  } 
      : sacado


  type sacadoCountArgs = Merge<
    Omit<sacadoFindManyArgs, 'select' | 'include'> & {
      select?: SacadoCountAggregateInputType | true
    }
  >

  export interface sacadoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Sacado that matches the filter.
     * @param {sacadoFindUniqueArgs} args - Arguments to find a Sacado
     * @example
     * // Get one Sacado
     * const sacado = await prisma.sacado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sacadoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, sacadoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'sacado'> extends True ? Prisma__sacadoClient<sacadoGetPayload<T>> : Prisma__sacadoClient<sacadoGetPayload<T> | null, null>

    /**
     * Find the first Sacado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sacadoFindFirstArgs} args - Arguments to find a Sacado
     * @example
     * // Get one Sacado
     * const sacado = await prisma.sacado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sacadoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, sacadoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'sacado'> extends True ? Prisma__sacadoClient<sacadoGetPayload<T>> : Prisma__sacadoClient<sacadoGetPayload<T> | null, null>

    /**
     * Find zero or more Sacados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sacadoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sacados
     * const sacados = await prisma.sacado.findMany()
     * 
     * // Get first 10 Sacados
     * const sacados = await prisma.sacado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sacadoWithIdOnly = await prisma.sacado.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends sacadoFindManyArgs>(
      args?: SelectSubset<T, sacadoFindManyArgs>
    ): PrismaPromise<Array<sacadoGetPayload<T>>>

    /**
     * Create a Sacado.
     * @param {sacadoCreateArgs} args - Arguments to create a Sacado.
     * @example
     * // Create one Sacado
     * const Sacado = await prisma.sacado.create({
     *   data: {
     *     // ... data to create a Sacado
     *   }
     * })
     * 
    **/
    create<T extends sacadoCreateArgs>(
      args: SelectSubset<T, sacadoCreateArgs>
    ): Prisma__sacadoClient<sacadoGetPayload<T>>

    /**
     * Create many Sacados.
     *     @param {sacadoCreateManyArgs} args - Arguments to create many Sacados.
     *     @example
     *     // Create many Sacados
     *     const sacado = await prisma.sacado.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sacadoCreateManyArgs>(
      args?: SelectSubset<T, sacadoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Sacado.
     * @param {sacadoDeleteArgs} args - Arguments to delete one Sacado.
     * @example
     * // Delete one Sacado
     * const Sacado = await prisma.sacado.delete({
     *   where: {
     *     // ... filter to delete one Sacado
     *   }
     * })
     * 
    **/
    delete<T extends sacadoDeleteArgs>(
      args: SelectSubset<T, sacadoDeleteArgs>
    ): Prisma__sacadoClient<sacadoGetPayload<T>>

    /**
     * Update one Sacado.
     * @param {sacadoUpdateArgs} args - Arguments to update one Sacado.
     * @example
     * // Update one Sacado
     * const sacado = await prisma.sacado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sacadoUpdateArgs>(
      args: SelectSubset<T, sacadoUpdateArgs>
    ): Prisma__sacadoClient<sacadoGetPayload<T>>

    /**
     * Delete zero or more Sacados.
     * @param {sacadoDeleteManyArgs} args - Arguments to filter Sacados to delete.
     * @example
     * // Delete a few Sacados
     * const { count } = await prisma.sacado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sacadoDeleteManyArgs>(
      args?: SelectSubset<T, sacadoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sacados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sacadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sacados
     * const sacado = await prisma.sacado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sacadoUpdateManyArgs>(
      args: SelectSubset<T, sacadoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Sacado.
     * @param {sacadoUpsertArgs} args - Arguments to update or create a Sacado.
     * @example
     * // Update or create a Sacado
     * const sacado = await prisma.sacado.upsert({
     *   create: {
     *     // ... data to create a Sacado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sacado we want to update
     *   }
     * })
    **/
    upsert<T extends sacadoUpsertArgs>(
      args: SelectSubset<T, sacadoUpsertArgs>
    ): Prisma__sacadoClient<sacadoGetPayload<T>>

    /**
     * Find one Sacado that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {sacadoFindUniqueOrThrowArgs} args - Arguments to find a Sacado
     * @example
     * // Get one Sacado
     * const sacado = await prisma.sacado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sacadoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, sacadoFindUniqueOrThrowArgs>
    ): Prisma__sacadoClient<sacadoGetPayload<T>>

    /**
     * Find the first Sacado that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sacadoFindFirstOrThrowArgs} args - Arguments to find a Sacado
     * @example
     * // Get one Sacado
     * const sacado = await prisma.sacado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sacadoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, sacadoFindFirstOrThrowArgs>
    ): Prisma__sacadoClient<sacadoGetPayload<T>>

    /**
     * Count the number of Sacados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sacadoCountArgs} args - Arguments to filter Sacados to count.
     * @example
     * // Count the number of Sacados
     * const count = await prisma.sacado.count({
     *   where: {
     *     // ... the filter for the Sacados we want to count
     *   }
     * })
    **/
    count<T extends sacadoCountArgs>(
      args?: Subset<T, sacadoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SacadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sacado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SacadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SacadoAggregateArgs>(args: Subset<T, SacadoAggregateArgs>): PrismaPromise<GetSacadoAggregateType<T>>

    /**
     * Group by Sacado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SacadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SacadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SacadoGroupByArgs['orderBy'] }
        : { orderBy?: SacadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SacadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSacadoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for sacado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__sacadoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    cedente_n_sacados<T extends cedente_n_sacadosFindManyArgs= {}>(args?: Subset<T, cedente_n_sacadosFindManyArgs>): PrismaPromise<Array<cedente_n_sacadosGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * sacado base type for findUnique actions
   */
  export type sacadoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the sacado
     * 
    **/
    select?: sacadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sacadoInclude | null
    /**
     * Filter, which sacado to fetch.
     * 
    **/
    where: sacadoWhereUniqueInput
  }

  /**
   * sacado: findUnique
   */
  export interface sacadoFindUniqueArgs extends sacadoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sacado base type for findFirst actions
   */
  export type sacadoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the sacado
     * 
    **/
    select?: sacadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sacadoInclude | null
    /**
     * Filter, which sacado to fetch.
     * 
    **/
    where?: sacadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sacados to fetch.
     * 
    **/
    orderBy?: Enumerable<sacadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sacados.
     * 
    **/
    cursor?: sacadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sacados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sacados.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sacados.
     * 
    **/
    distinct?: Enumerable<SacadoScalarFieldEnum>
  }

  /**
   * sacado: findFirst
   */
  export interface sacadoFindFirstArgs extends sacadoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * sacado findMany
   */
  export type sacadoFindManyArgs = {
    /**
     * Select specific fields to fetch from the sacado
     * 
    **/
    select?: sacadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sacadoInclude | null
    /**
     * Filter, which sacados to fetch.
     * 
    **/
    where?: sacadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sacados to fetch.
     * 
    **/
    orderBy?: Enumerable<sacadoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sacados.
     * 
    **/
    cursor?: sacadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sacados from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sacados.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SacadoScalarFieldEnum>
  }


  /**
   * sacado create
   */
  export type sacadoCreateArgs = {
    /**
     * Select specific fields to fetch from the sacado
     * 
    **/
    select?: sacadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sacadoInclude | null
    /**
     * The data needed to create a sacado.
     * 
    **/
    data: XOR<sacadoCreateInput, sacadoUncheckedCreateInput>
  }


  /**
   * sacado createMany
   */
  export type sacadoCreateManyArgs = {
    /**
     * The data used to create many sacados.
     * 
    **/
    data: Enumerable<sacadoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * sacado update
   */
  export type sacadoUpdateArgs = {
    /**
     * Select specific fields to fetch from the sacado
     * 
    **/
    select?: sacadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sacadoInclude | null
    /**
     * The data needed to update a sacado.
     * 
    **/
    data: XOR<sacadoUpdateInput, sacadoUncheckedUpdateInput>
    /**
     * Choose, which sacado to update.
     * 
    **/
    where: sacadoWhereUniqueInput
  }


  /**
   * sacado updateMany
   */
  export type sacadoUpdateManyArgs = {
    /**
     * The data used to update sacados.
     * 
    **/
    data: XOR<sacadoUpdateManyMutationInput, sacadoUncheckedUpdateManyInput>
    /**
     * Filter which sacados to update
     * 
    **/
    where?: sacadoWhereInput
  }


  /**
   * sacado upsert
   */
  export type sacadoUpsertArgs = {
    /**
     * Select specific fields to fetch from the sacado
     * 
    **/
    select?: sacadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sacadoInclude | null
    /**
     * The filter to search for the sacado to update in case it exists.
     * 
    **/
    where: sacadoWhereUniqueInput
    /**
     * In case the sacado found by the `where` argument doesn't exist, create a new sacado with this data.
     * 
    **/
    create: XOR<sacadoCreateInput, sacadoUncheckedCreateInput>
    /**
     * In case the sacado was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<sacadoUpdateInput, sacadoUncheckedUpdateInput>
  }


  /**
   * sacado delete
   */
  export type sacadoDeleteArgs = {
    /**
     * Select specific fields to fetch from the sacado
     * 
    **/
    select?: sacadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sacadoInclude | null
    /**
     * Filter which sacado to delete.
     * 
    **/
    where: sacadoWhereUniqueInput
  }


  /**
   * sacado deleteMany
   */
  export type sacadoDeleteManyArgs = {
    /**
     * Filter which sacados to delete
     * 
    **/
    where?: sacadoWhereInput
  }


  /**
   * sacado: findUniqueOrThrow
   */
  export type sacadoFindUniqueOrThrowArgs = sacadoFindUniqueArgsBase
      

  /**
   * sacado: findFirstOrThrow
   */
  export type sacadoFindFirstOrThrowArgs = sacadoFindFirstArgsBase
      

  /**
   * sacado without action
   */
  export type sacadoArgs = {
    /**
     * Select specific fields to fetch from the sacado
     * 
    **/
    select?: sacadoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: sacadoInclude | null
  }



  /**
   * Model titulo
   */


  export type AggregateTitulo = {
    _count: TituloCountAggregateOutputType | null
    _avg: TituloAvgAggregateOutputType | null
    _sum: TituloSumAggregateOutputType | null
    _min: TituloMinAggregateOutputType | null
    _max: TituloMaxAggregateOutputType | null
  }

  export type TituloAvgAggregateOutputType = {
    id: number | null
    titulo_tipo_id: number | null
    bordero_id: number | null
    valor: number | null
  }

  export type TituloSumAggregateOutputType = {
    id: number | null
    titulo_tipo_id: number | null
    bordero_id: number | null
    valor: number | null
  }

  export type TituloMinAggregateOutputType = {
    id: number | null
    titulo_tipo_id: number | null
    bordero_id: number | null
    nf: string | null
    valor: number | null
    vencimento: Date | null
    numero: string | null
    emissao: Date | null
    parcela: string | null
  }

  export type TituloMaxAggregateOutputType = {
    id: number | null
    titulo_tipo_id: number | null
    bordero_id: number | null
    nf: string | null
    valor: number | null
    vencimento: Date | null
    numero: string | null
    emissao: Date | null
    parcela: string | null
  }

  export type TituloCountAggregateOutputType = {
    id: number
    titulo_tipo_id: number
    bordero_id: number
    nf: number
    valor: number
    vencimento: number
    numero: number
    emissao: number
    parcela: number
    _all: number
  }


  export type TituloAvgAggregateInputType = {
    id?: true
    titulo_tipo_id?: true
    bordero_id?: true
    valor?: true
  }

  export type TituloSumAggregateInputType = {
    id?: true
    titulo_tipo_id?: true
    bordero_id?: true
    valor?: true
  }

  export type TituloMinAggregateInputType = {
    id?: true
    titulo_tipo_id?: true
    bordero_id?: true
    nf?: true
    valor?: true
    vencimento?: true
    numero?: true
    emissao?: true
    parcela?: true
  }

  export type TituloMaxAggregateInputType = {
    id?: true
    titulo_tipo_id?: true
    bordero_id?: true
    nf?: true
    valor?: true
    vencimento?: true
    numero?: true
    emissao?: true
    parcela?: true
  }

  export type TituloCountAggregateInputType = {
    id?: true
    titulo_tipo_id?: true
    bordero_id?: true
    nf?: true
    valor?: true
    vencimento?: true
    numero?: true
    emissao?: true
    parcela?: true
    _all?: true
  }

  export type TituloAggregateArgs = {
    /**
     * Filter which titulo to aggregate.
     * 
    **/
    where?: tituloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulos to fetch.
     * 
    **/
    orderBy?: Enumerable<tituloOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: tituloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned titulos
    **/
    _count?: true | TituloCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TituloAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TituloSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TituloMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TituloMaxAggregateInputType
  }

  export type GetTituloAggregateType<T extends TituloAggregateArgs> = {
        [P in keyof T & keyof AggregateTitulo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTitulo[P]>
      : GetScalarType<T[P], AggregateTitulo[P]>
  }




  export type TituloGroupByArgs = {
    where?: tituloWhereInput
    orderBy?: Enumerable<tituloOrderByWithAggregationInput>
    by: Array<TituloScalarFieldEnum>
    having?: tituloScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TituloCountAggregateInputType | true
    _avg?: TituloAvgAggregateInputType
    _sum?: TituloSumAggregateInputType
    _min?: TituloMinAggregateInputType
    _max?: TituloMaxAggregateInputType
  }


  export type TituloGroupByOutputType = {
    id: number
    titulo_tipo_id: number
    bordero_id: number
    nf: string | null
    valor: number | null
    vencimento: Date | null
    numero: string | null
    emissao: Date | null
    parcela: string | null
    _count: TituloCountAggregateOutputType | null
    _avg: TituloAvgAggregateOutputType | null
    _sum: TituloSumAggregateOutputType | null
    _min: TituloMinAggregateOutputType | null
    _max: TituloMaxAggregateOutputType | null
  }

  type GetTituloGroupByPayload<T extends TituloGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TituloGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TituloGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TituloGroupByOutputType[P]>
            : GetScalarType<T[P], TituloGroupByOutputType[P]>
        }
      >
    >


  export type tituloSelect = {
    id?: boolean
    titulo_tipo_id?: boolean
    bordero_id?: boolean
    nf?: boolean
    valor?: boolean
    vencimento?: boolean
    numero?: boolean
    emissao?: boolean
    parcela?: boolean
    titulo_tipo?: boolean | titulo_tipoArgs
    bordero?: boolean | borderoArgs
    titulo_itens?: boolean | titulo_itensFindManyArgs
    _count?: boolean | TituloCountOutputTypeArgs
  }


  export type tituloInclude = {
    titulo_tipo?: boolean | titulo_tipoArgs
    bordero?: boolean | borderoArgs
    titulo_itens?: boolean | titulo_itensFindManyArgs
    _count?: boolean | TituloCountOutputTypeArgs
  } 

  export type tituloGetPayload<S extends boolean | null | undefined | tituloArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? titulo :
    S extends undefined ? never :
    S extends { include: any } & (tituloArgs | tituloFindManyArgs)
    ? titulo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'titulo_tipo' ? titulo_tipoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'bordero' ? borderoGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'titulo_itens' ? Array < titulo_itensGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? TituloCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (tituloArgs | tituloFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'titulo_tipo' ? titulo_tipoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'bordero' ? borderoGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'titulo_itens' ? Array < titulo_itensGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? TituloCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof titulo ? titulo[P] : never
  } 
      : titulo


  type tituloCountArgs = Merge<
    Omit<tituloFindManyArgs, 'select' | 'include'> & {
      select?: TituloCountAggregateInputType | true
    }
  >

  export interface tituloDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Titulo that matches the filter.
     * @param {tituloFindUniqueArgs} args - Arguments to find a Titulo
     * @example
     * // Get one Titulo
     * const titulo = await prisma.titulo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tituloFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tituloFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'titulo'> extends True ? Prisma__tituloClient<tituloGetPayload<T>> : Prisma__tituloClient<tituloGetPayload<T> | null, null>

    /**
     * Find the first Titulo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tituloFindFirstArgs} args - Arguments to find a Titulo
     * @example
     * // Get one Titulo
     * const titulo = await prisma.titulo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tituloFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tituloFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'titulo'> extends True ? Prisma__tituloClient<tituloGetPayload<T>> : Prisma__tituloClient<tituloGetPayload<T> | null, null>

    /**
     * Find zero or more Titulos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tituloFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Titulos
     * const titulos = await prisma.titulo.findMany()
     * 
     * // Get first 10 Titulos
     * const titulos = await prisma.titulo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tituloWithIdOnly = await prisma.titulo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tituloFindManyArgs>(
      args?: SelectSubset<T, tituloFindManyArgs>
    ): PrismaPromise<Array<tituloGetPayload<T>>>

    /**
     * Create a Titulo.
     * @param {tituloCreateArgs} args - Arguments to create a Titulo.
     * @example
     * // Create one Titulo
     * const Titulo = await prisma.titulo.create({
     *   data: {
     *     // ... data to create a Titulo
     *   }
     * })
     * 
    **/
    create<T extends tituloCreateArgs>(
      args: SelectSubset<T, tituloCreateArgs>
    ): Prisma__tituloClient<tituloGetPayload<T>>

    /**
     * Create many Titulos.
     *     @param {tituloCreateManyArgs} args - Arguments to create many Titulos.
     *     @example
     *     // Create many Titulos
     *     const titulo = await prisma.titulo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends tituloCreateManyArgs>(
      args?: SelectSubset<T, tituloCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Titulo.
     * @param {tituloDeleteArgs} args - Arguments to delete one Titulo.
     * @example
     * // Delete one Titulo
     * const Titulo = await prisma.titulo.delete({
     *   where: {
     *     // ... filter to delete one Titulo
     *   }
     * })
     * 
    **/
    delete<T extends tituloDeleteArgs>(
      args: SelectSubset<T, tituloDeleteArgs>
    ): Prisma__tituloClient<tituloGetPayload<T>>

    /**
     * Update one Titulo.
     * @param {tituloUpdateArgs} args - Arguments to update one Titulo.
     * @example
     * // Update one Titulo
     * const titulo = await prisma.titulo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tituloUpdateArgs>(
      args: SelectSubset<T, tituloUpdateArgs>
    ): Prisma__tituloClient<tituloGetPayload<T>>

    /**
     * Delete zero or more Titulos.
     * @param {tituloDeleteManyArgs} args - Arguments to filter Titulos to delete.
     * @example
     * // Delete a few Titulos
     * const { count } = await prisma.titulo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tituloDeleteManyArgs>(
      args?: SelectSubset<T, tituloDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Titulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tituloUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Titulos
     * const titulo = await prisma.titulo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tituloUpdateManyArgs>(
      args: SelectSubset<T, tituloUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Titulo.
     * @param {tituloUpsertArgs} args - Arguments to update or create a Titulo.
     * @example
     * // Update or create a Titulo
     * const titulo = await prisma.titulo.upsert({
     *   create: {
     *     // ... data to create a Titulo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Titulo we want to update
     *   }
     * })
    **/
    upsert<T extends tituloUpsertArgs>(
      args: SelectSubset<T, tituloUpsertArgs>
    ): Prisma__tituloClient<tituloGetPayload<T>>

    /**
     * Find one Titulo that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {tituloFindUniqueOrThrowArgs} args - Arguments to find a Titulo
     * @example
     * // Get one Titulo
     * const titulo = await prisma.titulo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tituloFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tituloFindUniqueOrThrowArgs>
    ): Prisma__tituloClient<tituloGetPayload<T>>

    /**
     * Find the first Titulo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tituloFindFirstOrThrowArgs} args - Arguments to find a Titulo
     * @example
     * // Get one Titulo
     * const titulo = await prisma.titulo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tituloFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tituloFindFirstOrThrowArgs>
    ): Prisma__tituloClient<tituloGetPayload<T>>

    /**
     * Count the number of Titulos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tituloCountArgs} args - Arguments to filter Titulos to count.
     * @example
     * // Count the number of Titulos
     * const count = await prisma.titulo.count({
     *   where: {
     *     // ... the filter for the Titulos we want to count
     *   }
     * })
    **/
    count<T extends tituloCountArgs>(
      args?: Subset<T, tituloCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TituloCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Titulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TituloAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TituloAggregateArgs>(args: Subset<T, TituloAggregateArgs>): PrismaPromise<GetTituloAggregateType<T>>

    /**
     * Group by Titulo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TituloGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TituloGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TituloGroupByArgs['orderBy'] }
        : { orderBy?: TituloGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TituloGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTituloGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for titulo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tituloClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    titulo_tipo<T extends titulo_tipoArgs= {}>(args?: Subset<T, titulo_tipoArgs>): Prisma__titulo_tipoClient<titulo_tipoGetPayload<T> | Null>;

    bordero<T extends borderoArgs= {}>(args?: Subset<T, borderoArgs>): Prisma__borderoClient<borderoGetPayload<T> | Null>;

    titulo_itens<T extends titulo_itensFindManyArgs= {}>(args?: Subset<T, titulo_itensFindManyArgs>): PrismaPromise<Array<titulo_itensGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * titulo base type for findUnique actions
   */
  export type tituloFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the titulo
     * 
    **/
    select?: tituloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: tituloInclude | null
    /**
     * Filter, which titulo to fetch.
     * 
    **/
    where: tituloWhereUniqueInput
  }

  /**
   * titulo: findUnique
   */
  export interface tituloFindUniqueArgs extends tituloFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulo base type for findFirst actions
   */
  export type tituloFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the titulo
     * 
    **/
    select?: tituloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: tituloInclude | null
    /**
     * Filter, which titulo to fetch.
     * 
    **/
    where?: tituloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulos to fetch.
     * 
    **/
    orderBy?: Enumerable<tituloOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for titulos.
     * 
    **/
    cursor?: tituloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of titulos.
     * 
    **/
    distinct?: Enumerable<TituloScalarFieldEnum>
  }

  /**
   * titulo: findFirst
   */
  export interface tituloFindFirstArgs extends tituloFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulo findMany
   */
  export type tituloFindManyArgs = {
    /**
     * Select specific fields to fetch from the titulo
     * 
    **/
    select?: tituloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: tituloInclude | null
    /**
     * Filter, which titulos to fetch.
     * 
    **/
    where?: tituloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulos to fetch.
     * 
    **/
    orderBy?: Enumerable<tituloOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing titulos.
     * 
    **/
    cursor?: tituloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TituloScalarFieldEnum>
  }


  /**
   * titulo create
   */
  export type tituloCreateArgs = {
    /**
     * Select specific fields to fetch from the titulo
     * 
    **/
    select?: tituloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: tituloInclude | null
    /**
     * The data needed to create a titulo.
     * 
    **/
    data: XOR<tituloCreateInput, tituloUncheckedCreateInput>
  }


  /**
   * titulo createMany
   */
  export type tituloCreateManyArgs = {
    /**
     * The data used to create many titulos.
     * 
    **/
    data: Enumerable<tituloCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * titulo update
   */
  export type tituloUpdateArgs = {
    /**
     * Select specific fields to fetch from the titulo
     * 
    **/
    select?: tituloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: tituloInclude | null
    /**
     * The data needed to update a titulo.
     * 
    **/
    data: XOR<tituloUpdateInput, tituloUncheckedUpdateInput>
    /**
     * Choose, which titulo to update.
     * 
    **/
    where: tituloWhereUniqueInput
  }


  /**
   * titulo updateMany
   */
  export type tituloUpdateManyArgs = {
    /**
     * The data used to update titulos.
     * 
    **/
    data: XOR<tituloUpdateManyMutationInput, tituloUncheckedUpdateManyInput>
    /**
     * Filter which titulos to update
     * 
    **/
    where?: tituloWhereInput
  }


  /**
   * titulo upsert
   */
  export type tituloUpsertArgs = {
    /**
     * Select specific fields to fetch from the titulo
     * 
    **/
    select?: tituloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: tituloInclude | null
    /**
     * The filter to search for the titulo to update in case it exists.
     * 
    **/
    where: tituloWhereUniqueInput
    /**
     * In case the titulo found by the `where` argument doesn't exist, create a new titulo with this data.
     * 
    **/
    create: XOR<tituloCreateInput, tituloUncheckedCreateInput>
    /**
     * In case the titulo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<tituloUpdateInput, tituloUncheckedUpdateInput>
  }


  /**
   * titulo delete
   */
  export type tituloDeleteArgs = {
    /**
     * Select specific fields to fetch from the titulo
     * 
    **/
    select?: tituloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: tituloInclude | null
    /**
     * Filter which titulo to delete.
     * 
    **/
    where: tituloWhereUniqueInput
  }


  /**
   * titulo deleteMany
   */
  export type tituloDeleteManyArgs = {
    /**
     * Filter which titulos to delete
     * 
    **/
    where?: tituloWhereInput
  }


  /**
   * titulo: findUniqueOrThrow
   */
  export type tituloFindUniqueOrThrowArgs = tituloFindUniqueArgsBase
      

  /**
   * titulo: findFirstOrThrow
   */
  export type tituloFindFirstOrThrowArgs = tituloFindFirstArgsBase
      

  /**
   * titulo without action
   */
  export type tituloArgs = {
    /**
     * Select specific fields to fetch from the titulo
     * 
    **/
    select?: tituloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: tituloInclude | null
  }



  /**
   * Model titulo_tipo
   */


  export type AggregateTitulo_tipo = {
    _count: Titulo_tipoCountAggregateOutputType | null
    _avg: Titulo_tipoAvgAggregateOutputType | null
    _sum: Titulo_tipoSumAggregateOutputType | null
    _min: Titulo_tipoMinAggregateOutputType | null
    _max: Titulo_tipoMaxAggregateOutputType | null
  }

  export type Titulo_tipoAvgAggregateOutputType = {
    id: number | null
  }

  export type Titulo_tipoSumAggregateOutputType = {
    id: number | null
  }

  export type Titulo_tipoMinAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Titulo_tipoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Titulo_tipoCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type Titulo_tipoAvgAggregateInputType = {
    id?: true
  }

  export type Titulo_tipoSumAggregateInputType = {
    id?: true
  }

  export type Titulo_tipoMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Titulo_tipoMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Titulo_tipoCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type Titulo_tipoAggregateArgs = {
    /**
     * Filter which titulo_tipo to aggregate.
     * 
    **/
    where?: titulo_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: titulo_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned titulo_tipos
    **/
    _count?: true | Titulo_tipoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Titulo_tipoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Titulo_tipoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Titulo_tipoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Titulo_tipoMaxAggregateInputType
  }

  export type GetTitulo_tipoAggregateType<T extends Titulo_tipoAggregateArgs> = {
        [P in keyof T & keyof AggregateTitulo_tipo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTitulo_tipo[P]>
      : GetScalarType<T[P], AggregateTitulo_tipo[P]>
  }




  export type Titulo_tipoGroupByArgs = {
    where?: titulo_tipoWhereInput
    orderBy?: Enumerable<titulo_tipoOrderByWithAggregationInput>
    by: Array<Titulo_tipoScalarFieldEnum>
    having?: titulo_tipoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Titulo_tipoCountAggregateInputType | true
    _avg?: Titulo_tipoAvgAggregateInputType
    _sum?: Titulo_tipoSumAggregateInputType
    _min?: Titulo_tipoMinAggregateInputType
    _max?: Titulo_tipoMaxAggregateInputType
  }


  export type Titulo_tipoGroupByOutputType = {
    id: number
    nome: string | null
    _count: Titulo_tipoCountAggregateOutputType | null
    _avg: Titulo_tipoAvgAggregateOutputType | null
    _sum: Titulo_tipoSumAggregateOutputType | null
    _min: Titulo_tipoMinAggregateOutputType | null
    _max: Titulo_tipoMaxAggregateOutputType | null
  }

  type GetTitulo_tipoGroupByPayload<T extends Titulo_tipoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Titulo_tipoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Titulo_tipoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Titulo_tipoGroupByOutputType[P]>
            : GetScalarType<T[P], Titulo_tipoGroupByOutputType[P]>
        }
      >
    >


  export type titulo_tipoSelect = {
    id?: boolean
    nome?: boolean
    titulo?: boolean | tituloFindManyArgs
    _count?: boolean | Titulo_tipoCountOutputTypeArgs
  }


  export type titulo_tipoInclude = {
    titulo?: boolean | tituloFindManyArgs
    _count?: boolean | Titulo_tipoCountOutputTypeArgs
  } 

  export type titulo_tipoGetPayload<S extends boolean | null | undefined | titulo_tipoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? titulo_tipo :
    S extends undefined ? never :
    S extends { include: any } & (titulo_tipoArgs | titulo_tipoFindManyArgs)
    ? titulo_tipo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'titulo' ? Array < tituloGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Titulo_tipoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (titulo_tipoArgs | titulo_tipoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'titulo' ? Array < tituloGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Titulo_tipoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof titulo_tipo ? titulo_tipo[P] : never
  } 
      : titulo_tipo


  type titulo_tipoCountArgs = Merge<
    Omit<titulo_tipoFindManyArgs, 'select' | 'include'> & {
      select?: Titulo_tipoCountAggregateInputType | true
    }
  >

  export interface titulo_tipoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Titulo_tipo that matches the filter.
     * @param {titulo_tipoFindUniqueArgs} args - Arguments to find a Titulo_tipo
     * @example
     * // Get one Titulo_tipo
     * const titulo_tipo = await prisma.titulo_tipo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends titulo_tipoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, titulo_tipoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'titulo_tipo'> extends True ? Prisma__titulo_tipoClient<titulo_tipoGetPayload<T>> : Prisma__titulo_tipoClient<titulo_tipoGetPayload<T> | null, null>

    /**
     * Find the first Titulo_tipo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_tipoFindFirstArgs} args - Arguments to find a Titulo_tipo
     * @example
     * // Get one Titulo_tipo
     * const titulo_tipo = await prisma.titulo_tipo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends titulo_tipoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, titulo_tipoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'titulo_tipo'> extends True ? Prisma__titulo_tipoClient<titulo_tipoGetPayload<T>> : Prisma__titulo_tipoClient<titulo_tipoGetPayload<T> | null, null>

    /**
     * Find zero or more Titulo_tipos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_tipoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Titulo_tipos
     * const titulo_tipos = await prisma.titulo_tipo.findMany()
     * 
     * // Get first 10 Titulo_tipos
     * const titulo_tipos = await prisma.titulo_tipo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const titulo_tipoWithIdOnly = await prisma.titulo_tipo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends titulo_tipoFindManyArgs>(
      args?: SelectSubset<T, titulo_tipoFindManyArgs>
    ): PrismaPromise<Array<titulo_tipoGetPayload<T>>>

    /**
     * Create a Titulo_tipo.
     * @param {titulo_tipoCreateArgs} args - Arguments to create a Titulo_tipo.
     * @example
     * // Create one Titulo_tipo
     * const Titulo_tipo = await prisma.titulo_tipo.create({
     *   data: {
     *     // ... data to create a Titulo_tipo
     *   }
     * })
     * 
    **/
    create<T extends titulo_tipoCreateArgs>(
      args: SelectSubset<T, titulo_tipoCreateArgs>
    ): Prisma__titulo_tipoClient<titulo_tipoGetPayload<T>>

    /**
     * Create many Titulo_tipos.
     *     @param {titulo_tipoCreateManyArgs} args - Arguments to create many Titulo_tipos.
     *     @example
     *     // Create many Titulo_tipos
     *     const titulo_tipo = await prisma.titulo_tipo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends titulo_tipoCreateManyArgs>(
      args?: SelectSubset<T, titulo_tipoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Titulo_tipo.
     * @param {titulo_tipoDeleteArgs} args - Arguments to delete one Titulo_tipo.
     * @example
     * // Delete one Titulo_tipo
     * const Titulo_tipo = await prisma.titulo_tipo.delete({
     *   where: {
     *     // ... filter to delete one Titulo_tipo
     *   }
     * })
     * 
    **/
    delete<T extends titulo_tipoDeleteArgs>(
      args: SelectSubset<T, titulo_tipoDeleteArgs>
    ): Prisma__titulo_tipoClient<titulo_tipoGetPayload<T>>

    /**
     * Update one Titulo_tipo.
     * @param {titulo_tipoUpdateArgs} args - Arguments to update one Titulo_tipo.
     * @example
     * // Update one Titulo_tipo
     * const titulo_tipo = await prisma.titulo_tipo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends titulo_tipoUpdateArgs>(
      args: SelectSubset<T, titulo_tipoUpdateArgs>
    ): Prisma__titulo_tipoClient<titulo_tipoGetPayload<T>>

    /**
     * Delete zero or more Titulo_tipos.
     * @param {titulo_tipoDeleteManyArgs} args - Arguments to filter Titulo_tipos to delete.
     * @example
     * // Delete a few Titulo_tipos
     * const { count } = await prisma.titulo_tipo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends titulo_tipoDeleteManyArgs>(
      args?: SelectSubset<T, titulo_tipoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Titulo_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_tipoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Titulo_tipos
     * const titulo_tipo = await prisma.titulo_tipo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends titulo_tipoUpdateManyArgs>(
      args: SelectSubset<T, titulo_tipoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Titulo_tipo.
     * @param {titulo_tipoUpsertArgs} args - Arguments to update or create a Titulo_tipo.
     * @example
     * // Update or create a Titulo_tipo
     * const titulo_tipo = await prisma.titulo_tipo.upsert({
     *   create: {
     *     // ... data to create a Titulo_tipo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Titulo_tipo we want to update
     *   }
     * })
    **/
    upsert<T extends titulo_tipoUpsertArgs>(
      args: SelectSubset<T, titulo_tipoUpsertArgs>
    ): Prisma__titulo_tipoClient<titulo_tipoGetPayload<T>>

    /**
     * Find one Titulo_tipo that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {titulo_tipoFindUniqueOrThrowArgs} args - Arguments to find a Titulo_tipo
     * @example
     * // Get one Titulo_tipo
     * const titulo_tipo = await prisma.titulo_tipo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends titulo_tipoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, titulo_tipoFindUniqueOrThrowArgs>
    ): Prisma__titulo_tipoClient<titulo_tipoGetPayload<T>>

    /**
     * Find the first Titulo_tipo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_tipoFindFirstOrThrowArgs} args - Arguments to find a Titulo_tipo
     * @example
     * // Get one Titulo_tipo
     * const titulo_tipo = await prisma.titulo_tipo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends titulo_tipoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, titulo_tipoFindFirstOrThrowArgs>
    ): Prisma__titulo_tipoClient<titulo_tipoGetPayload<T>>

    /**
     * Count the number of Titulo_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_tipoCountArgs} args - Arguments to filter Titulo_tipos to count.
     * @example
     * // Count the number of Titulo_tipos
     * const count = await prisma.titulo_tipo.count({
     *   where: {
     *     // ... the filter for the Titulo_tipos we want to count
     *   }
     * })
    **/
    count<T extends titulo_tipoCountArgs>(
      args?: Subset<T, titulo_tipoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Titulo_tipoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Titulo_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Titulo_tipoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Titulo_tipoAggregateArgs>(args: Subset<T, Titulo_tipoAggregateArgs>): PrismaPromise<GetTitulo_tipoAggregateType<T>>

    /**
     * Group by Titulo_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Titulo_tipoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Titulo_tipoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Titulo_tipoGroupByArgs['orderBy'] }
        : { orderBy?: Titulo_tipoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Titulo_tipoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTitulo_tipoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for titulo_tipo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__titulo_tipoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    titulo<T extends tituloFindManyArgs= {}>(args?: Subset<T, tituloFindManyArgs>): PrismaPromise<Array<tituloGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * titulo_tipo base type for findUnique actions
   */
  export type titulo_tipoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the titulo_tipo
     * 
    **/
    select?: titulo_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_tipoInclude | null
    /**
     * Filter, which titulo_tipo to fetch.
     * 
    **/
    where: titulo_tipoWhereUniqueInput
  }

  /**
   * titulo_tipo: findUnique
   */
  export interface titulo_tipoFindUniqueArgs extends titulo_tipoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulo_tipo base type for findFirst actions
   */
  export type titulo_tipoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the titulo_tipo
     * 
    **/
    select?: titulo_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_tipoInclude | null
    /**
     * Filter, which titulo_tipo to fetch.
     * 
    **/
    where?: titulo_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for titulo_tipos.
     * 
    **/
    cursor?: titulo_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of titulo_tipos.
     * 
    **/
    distinct?: Enumerable<Titulo_tipoScalarFieldEnum>
  }

  /**
   * titulo_tipo: findFirst
   */
  export interface titulo_tipoFindFirstArgs extends titulo_tipoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulo_tipo findMany
   */
  export type titulo_tipoFindManyArgs = {
    /**
     * Select specific fields to fetch from the titulo_tipo
     * 
    **/
    select?: titulo_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_tipoInclude | null
    /**
     * Filter, which titulo_tipos to fetch.
     * 
    **/
    where?: titulo_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing titulo_tipos.
     * 
    **/
    cursor?: titulo_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_tipos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Titulo_tipoScalarFieldEnum>
  }


  /**
   * titulo_tipo create
   */
  export type titulo_tipoCreateArgs = {
    /**
     * Select specific fields to fetch from the titulo_tipo
     * 
    **/
    select?: titulo_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_tipoInclude | null
    /**
     * The data needed to create a titulo_tipo.
     * 
    **/
    data: XOR<titulo_tipoCreateInput, titulo_tipoUncheckedCreateInput>
  }


  /**
   * titulo_tipo createMany
   */
  export type titulo_tipoCreateManyArgs = {
    /**
     * The data used to create many titulo_tipos.
     * 
    **/
    data: Enumerable<titulo_tipoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * titulo_tipo update
   */
  export type titulo_tipoUpdateArgs = {
    /**
     * Select specific fields to fetch from the titulo_tipo
     * 
    **/
    select?: titulo_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_tipoInclude | null
    /**
     * The data needed to update a titulo_tipo.
     * 
    **/
    data: XOR<titulo_tipoUpdateInput, titulo_tipoUncheckedUpdateInput>
    /**
     * Choose, which titulo_tipo to update.
     * 
    **/
    where: titulo_tipoWhereUniqueInput
  }


  /**
   * titulo_tipo updateMany
   */
  export type titulo_tipoUpdateManyArgs = {
    /**
     * The data used to update titulo_tipos.
     * 
    **/
    data: XOR<titulo_tipoUpdateManyMutationInput, titulo_tipoUncheckedUpdateManyInput>
    /**
     * Filter which titulo_tipos to update
     * 
    **/
    where?: titulo_tipoWhereInput
  }


  /**
   * titulo_tipo upsert
   */
  export type titulo_tipoUpsertArgs = {
    /**
     * Select specific fields to fetch from the titulo_tipo
     * 
    **/
    select?: titulo_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_tipoInclude | null
    /**
     * The filter to search for the titulo_tipo to update in case it exists.
     * 
    **/
    where: titulo_tipoWhereUniqueInput
    /**
     * In case the titulo_tipo found by the `where` argument doesn't exist, create a new titulo_tipo with this data.
     * 
    **/
    create: XOR<titulo_tipoCreateInput, titulo_tipoUncheckedCreateInput>
    /**
     * In case the titulo_tipo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<titulo_tipoUpdateInput, titulo_tipoUncheckedUpdateInput>
  }


  /**
   * titulo_tipo delete
   */
  export type titulo_tipoDeleteArgs = {
    /**
     * Select specific fields to fetch from the titulo_tipo
     * 
    **/
    select?: titulo_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_tipoInclude | null
    /**
     * Filter which titulo_tipo to delete.
     * 
    **/
    where: titulo_tipoWhereUniqueInput
  }


  /**
   * titulo_tipo deleteMany
   */
  export type titulo_tipoDeleteManyArgs = {
    /**
     * Filter which titulo_tipos to delete
     * 
    **/
    where?: titulo_tipoWhereInput
  }


  /**
   * titulo_tipo: findUniqueOrThrow
   */
  export type titulo_tipoFindUniqueOrThrowArgs = titulo_tipoFindUniqueArgsBase
      

  /**
   * titulo_tipo: findFirstOrThrow
   */
  export type titulo_tipoFindFirstOrThrowArgs = titulo_tipoFindFirstArgsBase
      

  /**
   * titulo_tipo without action
   */
  export type titulo_tipoArgs = {
    /**
     * Select specific fields to fetch from the titulo_tipo
     * 
    **/
    select?: titulo_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_tipoInclude | null
  }



  /**
   * Model usuario
   */


  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
    pessoa_id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    email: string | null
    senha: string | null
    pessoa_id: number | null
    status: string | null
    primeiro_acesso: boolean | null
    confirmou_cadastro: boolean | null
    codigo_confirma_cadastro: string | null
    codigo_reset_senha: string | null
    codigo_data_expiracao: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    email: string | null
    senha: string | null
    pessoa_id: number | null
    status: string | null
    primeiro_acesso: boolean | null
    confirmou_cadastro: boolean | null
    codigo_confirma_cadastro: string | null
    codigo_reset_senha: string | null
    codigo_data_expiracao: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    email: number
    senha: number
    pessoa_id: number
    status: number
    primeiro_acesso: number
    confirmou_cadastro: number
    codigo_confirma_cadastro: number
    codigo_reset_senha: number
    codigo_data_expiracao: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
    pessoa_id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
    pessoa_id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    email?: true
    senha?: true
    pessoa_id?: true
    status?: true
    primeiro_acesso?: true
    confirmou_cadastro?: true
    codigo_confirma_cadastro?: true
    codigo_reset_senha?: true
    codigo_data_expiracao?: true
    created_at?: true
    updated_at?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    email?: true
    senha?: true
    pessoa_id?: true
    status?: true
    primeiro_acesso?: true
    confirmou_cadastro?: true
    codigo_confirma_cadastro?: true
    codigo_reset_senha?: true
    codigo_data_expiracao?: true
    created_at?: true
    updated_at?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    email?: true
    senha?: true
    pessoa_id?: true
    status?: true
    primeiro_acesso?: true
    confirmou_cadastro?: true
    codigo_confirma_cadastro?: true
    codigo_reset_senha?: true
    codigo_data_expiracao?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsuarioAggregateArgs = {
    /**
     * Filter which usuario to aggregate.
     * 
    **/
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs = {
    where?: usuarioWhereInput
    orderBy?: Enumerable<usuarioOrderByWithAggregationInput>
    by: Array<UsuarioScalarFieldEnum>
    having?: usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }


  export type UsuarioGroupByOutputType = {
    id: number
    email: string
    senha: string
    pessoa_id: number
    status: string | null
    primeiro_acesso: boolean | null
    confirmou_cadastro: boolean | null
    codigo_confirma_cadastro: string | null
    codigo_reset_senha: string | null
    codigo_data_expiracao: Date | null
    created_at: Date
    updated_at: Date | null
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type usuarioSelect = {
    id?: boolean
    email?: boolean
    senha?: boolean
    pessoa_id?: boolean
    status?: boolean
    primeiro_acesso?: boolean
    confirmou_cadastro?: boolean
    codigo_confirma_cadastro?: boolean
    codigo_reset_senha?: boolean
    codigo_data_expiracao?: boolean
    created_at?: boolean
    updated_at?: boolean
    pessoa?: boolean | pessoaArgs
  }


  export type usuarioInclude = {
    pessoa?: boolean | pessoaArgs
  } 

  export type usuarioGetPayload<S extends boolean | null | undefined | usuarioArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? usuario :
    S extends undefined ? never :
    S extends { include: any } & (usuarioArgs | usuarioFindManyArgs)
    ? usuario  & {
    [P in TrueKeys<S['include']>]:
        P extends 'pessoa' ? pessoaGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (usuarioArgs | usuarioFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'pessoa' ? pessoaGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof usuario ? usuario[P] : never
  } 
      : usuario


  type usuarioCountArgs = Merge<
    Omit<usuarioFindManyArgs, 'select' | 'include'> & {
      select?: UsuarioCountAggregateInputType | true
    }
  >

  export interface usuarioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {usuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usuarioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usuarioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'usuario'> extends True ? Prisma__usuarioClient<usuarioGetPayload<T>> : Prisma__usuarioClient<usuarioGetPayload<T> | null, null>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usuarioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usuarioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'usuario'> extends True ? Prisma__usuarioClient<usuarioGetPayload<T>> : Prisma__usuarioClient<usuarioGetPayload<T> | null, null>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usuarioFindManyArgs>(
      args?: SelectSubset<T, usuarioFindManyArgs>
    ): PrismaPromise<Array<usuarioGetPayload<T>>>

    /**
     * Create a Usuario.
     * @param {usuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
    **/
    create<T extends usuarioCreateArgs>(
      args: SelectSubset<T, usuarioCreateArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Create many Usuarios.
     *     @param {usuarioCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuario = await prisma.usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usuarioCreateManyArgs>(
      args?: SelectSubset<T, usuarioCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {usuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
    **/
    delete<T extends usuarioDeleteArgs>(
      args: SelectSubset<T, usuarioDeleteArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Update one Usuario.
     * @param {usuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usuarioUpdateArgs>(
      args: SelectSubset<T, usuarioUpdateArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Delete zero or more Usuarios.
     * @param {usuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usuarioDeleteManyArgs>(
      args?: SelectSubset<T, usuarioDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usuarioUpdateManyArgs>(
      args: SelectSubset<T, usuarioUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {usuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
    **/
    upsert<T extends usuarioUpsertArgs>(
      args: SelectSubset<T, usuarioUpsertArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Find one Usuario that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {usuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usuarioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usuarioFindUniqueOrThrowArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Find the first Usuario that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usuarioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usuarioFindFirstOrThrowArgs>
    ): Prisma__usuarioClient<usuarioGetPayload<T>>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuarioCountArgs>(
      args?: Subset<T, usuarioCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usuarioClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    pessoa<T extends pessoaArgs= {}>(args?: Subset<T, pessoaArgs>): Prisma__pessoaClient<pessoaGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * usuario base type for findUnique actions
   */
  export type usuarioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * Filter, which usuario to fetch.
     * 
    **/
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario: findUnique
   */
  export interface usuarioFindUniqueArgs extends usuarioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario base type for findFirst actions
   */
  export type usuarioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * Filter, which usuario to fetch.
     * 
    **/
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     * 
    **/
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     * 
    **/
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }

  /**
   * usuario: findFirst
   */
  export interface usuarioFindFirstArgs extends usuarioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario findMany
   */
  export type usuarioFindManyArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * Filter, which usuarios to fetch.
     * 
    **/
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     * 
    **/
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsuarioScalarFieldEnum>
  }


  /**
   * usuario create
   */
  export type usuarioCreateArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * The data needed to create a usuario.
     * 
    **/
    data: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
  }


  /**
   * usuario createMany
   */
  export type usuarioCreateManyArgs = {
    /**
     * The data used to create many usuarios.
     * 
    **/
    data: Enumerable<usuarioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * usuario update
   */
  export type usuarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * The data needed to update a usuario.
     * 
    **/
    data: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
    /**
     * Choose, which usuario to update.
     * 
    **/
    where: usuarioWhereUniqueInput
  }


  /**
   * usuario updateMany
   */
  export type usuarioUpdateManyArgs = {
    /**
     * The data used to update usuarios.
     * 
    **/
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     * 
    **/
    where?: usuarioWhereInput
  }


  /**
   * usuario upsert
   */
  export type usuarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * The filter to search for the usuario to update in case it exists.
     * 
    **/
    where: usuarioWhereUniqueInput
    /**
     * In case the usuario found by the `where` argument doesn't exist, create a new usuario with this data.
     * 
    **/
    create: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
    /**
     * In case the usuario was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
  }


  /**
   * usuario delete
   */
  export type usuarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
    /**
     * Filter which usuario to delete.
     * 
    **/
    where: usuarioWhereUniqueInput
  }


  /**
   * usuario deleteMany
   */
  export type usuarioDeleteManyArgs = {
    /**
     * Filter which usuarios to delete
     * 
    **/
    where?: usuarioWhereInput
  }


  /**
   * usuario: findUniqueOrThrow
   */
  export type usuarioFindUniqueOrThrowArgs = usuarioFindUniqueArgsBase
      

  /**
   * usuario: findFirstOrThrow
   */
  export type usuarioFindFirstOrThrowArgs = usuarioFindFirstArgsBase
      

  /**
   * usuario without action
   */
  export type usuarioArgs = {
    /**
     * Select specific fields to fetch from the usuario
     * 
    **/
    select?: usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuarioInclude | null
  }



  /**
   * Model usuario_perfil_tipo
   */


  export type AggregateUsuario_perfil_tipo = {
    _count: Usuario_perfil_tipoCountAggregateOutputType | null
    _avg: Usuario_perfil_tipoAvgAggregateOutputType | null
    _sum: Usuario_perfil_tipoSumAggregateOutputType | null
    _min: Usuario_perfil_tipoMinAggregateOutputType | null
    _max: Usuario_perfil_tipoMaxAggregateOutputType | null
  }

  export type Usuario_perfil_tipoAvgAggregateOutputType = {
    id: number | null
  }

  export type Usuario_perfil_tipoSumAggregateOutputType = {
    id: number | null
  }

  export type Usuario_perfil_tipoMinAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Usuario_perfil_tipoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
  }

  export type Usuario_perfil_tipoCountAggregateOutputType = {
    id: number
    nome: number
    _all: number
  }


  export type Usuario_perfil_tipoAvgAggregateInputType = {
    id?: true
  }

  export type Usuario_perfil_tipoSumAggregateInputType = {
    id?: true
  }

  export type Usuario_perfil_tipoMinAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Usuario_perfil_tipoMaxAggregateInputType = {
    id?: true
    nome?: true
  }

  export type Usuario_perfil_tipoCountAggregateInputType = {
    id?: true
    nome?: true
    _all?: true
  }

  export type Usuario_perfil_tipoAggregateArgs = {
    /**
     * Filter which usuario_perfil_tipo to aggregate.
     * 
    **/
    where?: usuario_perfil_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_perfil_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario_perfil_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: usuario_perfil_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_perfil_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_perfil_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuario_perfil_tipos
    **/
    _count?: true | Usuario_perfil_tipoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Usuario_perfil_tipoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Usuario_perfil_tipoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Usuario_perfil_tipoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Usuario_perfil_tipoMaxAggregateInputType
  }

  export type GetUsuario_perfil_tipoAggregateType<T extends Usuario_perfil_tipoAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario_perfil_tipo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario_perfil_tipo[P]>
      : GetScalarType<T[P], AggregateUsuario_perfil_tipo[P]>
  }




  export type Usuario_perfil_tipoGroupByArgs = {
    where?: usuario_perfil_tipoWhereInput
    orderBy?: Enumerable<usuario_perfil_tipoOrderByWithAggregationInput>
    by: Array<Usuario_perfil_tipoScalarFieldEnum>
    having?: usuario_perfil_tipoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Usuario_perfil_tipoCountAggregateInputType | true
    _avg?: Usuario_perfil_tipoAvgAggregateInputType
    _sum?: Usuario_perfil_tipoSumAggregateInputType
    _min?: Usuario_perfil_tipoMinAggregateInputType
    _max?: Usuario_perfil_tipoMaxAggregateInputType
  }


  export type Usuario_perfil_tipoGroupByOutputType = {
    id: number
    nome: string
    _count: Usuario_perfil_tipoCountAggregateOutputType | null
    _avg: Usuario_perfil_tipoAvgAggregateOutputType | null
    _sum: Usuario_perfil_tipoSumAggregateOutputType | null
    _min: Usuario_perfil_tipoMinAggregateOutputType | null
    _max: Usuario_perfil_tipoMaxAggregateOutputType | null
  }

  type GetUsuario_perfil_tipoGroupByPayload<T extends Usuario_perfil_tipoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Usuario_perfil_tipoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Usuario_perfil_tipoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Usuario_perfil_tipoGroupByOutputType[P]>
            : GetScalarType<T[P], Usuario_perfil_tipoGroupByOutputType[P]>
        }
      >
    >


  export type usuario_perfil_tipoSelect = {
    id?: boolean
    nome?: boolean
    usuario_perfil?: boolean | usuario_perfilFindManyArgs
    _count?: boolean | Usuario_perfil_tipoCountOutputTypeArgs
  }


  export type usuario_perfil_tipoInclude = {
    usuario_perfil?: boolean | usuario_perfilFindManyArgs
    _count?: boolean | Usuario_perfil_tipoCountOutputTypeArgs
  } 

  export type usuario_perfil_tipoGetPayload<S extends boolean | null | undefined | usuario_perfil_tipoArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? usuario_perfil_tipo :
    S extends undefined ? never :
    S extends { include: any } & (usuario_perfil_tipoArgs | usuario_perfil_tipoFindManyArgs)
    ? usuario_perfil_tipo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'usuario_perfil' ? Array < usuario_perfilGetPayload<Exclude<S['include'], undefined | null>[P]>>  :
        P extends '_count' ? Usuario_perfil_tipoCountOutputTypeGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (usuario_perfil_tipoArgs | usuario_perfil_tipoFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'usuario_perfil' ? Array < usuario_perfilGetPayload<Exclude<S['select'], undefined | null>[P]>>  :
        P extends '_count' ? Usuario_perfil_tipoCountOutputTypeGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof usuario_perfil_tipo ? usuario_perfil_tipo[P] : never
  } 
      : usuario_perfil_tipo


  type usuario_perfil_tipoCountArgs = Merge<
    Omit<usuario_perfil_tipoFindManyArgs, 'select' | 'include'> & {
      select?: Usuario_perfil_tipoCountAggregateInputType | true
    }
  >

  export interface usuario_perfil_tipoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Usuario_perfil_tipo that matches the filter.
     * @param {usuario_perfil_tipoFindUniqueArgs} args - Arguments to find a Usuario_perfil_tipo
     * @example
     * // Get one Usuario_perfil_tipo
     * const usuario_perfil_tipo = await prisma.usuario_perfil_tipo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usuario_perfil_tipoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usuario_perfil_tipoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'usuario_perfil_tipo'> extends True ? Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T>> : Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T> | null, null>

    /**
     * Find the first Usuario_perfil_tipo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_perfil_tipoFindFirstArgs} args - Arguments to find a Usuario_perfil_tipo
     * @example
     * // Get one Usuario_perfil_tipo
     * const usuario_perfil_tipo = await prisma.usuario_perfil_tipo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usuario_perfil_tipoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usuario_perfil_tipoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'usuario_perfil_tipo'> extends True ? Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T>> : Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T> | null, null>

    /**
     * Find zero or more Usuario_perfil_tipos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_perfil_tipoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuario_perfil_tipos
     * const usuario_perfil_tipos = await prisma.usuario_perfil_tipo.findMany()
     * 
     * // Get first 10 Usuario_perfil_tipos
     * const usuario_perfil_tipos = await prisma.usuario_perfil_tipo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuario_perfil_tipoWithIdOnly = await prisma.usuario_perfil_tipo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usuario_perfil_tipoFindManyArgs>(
      args?: SelectSubset<T, usuario_perfil_tipoFindManyArgs>
    ): PrismaPromise<Array<usuario_perfil_tipoGetPayload<T>>>

    /**
     * Create a Usuario_perfil_tipo.
     * @param {usuario_perfil_tipoCreateArgs} args - Arguments to create a Usuario_perfil_tipo.
     * @example
     * // Create one Usuario_perfil_tipo
     * const Usuario_perfil_tipo = await prisma.usuario_perfil_tipo.create({
     *   data: {
     *     // ... data to create a Usuario_perfil_tipo
     *   }
     * })
     * 
    **/
    create<T extends usuario_perfil_tipoCreateArgs>(
      args: SelectSubset<T, usuario_perfil_tipoCreateArgs>
    ): Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T>>

    /**
     * Create many Usuario_perfil_tipos.
     *     @param {usuario_perfil_tipoCreateManyArgs} args - Arguments to create many Usuario_perfil_tipos.
     *     @example
     *     // Create many Usuario_perfil_tipos
     *     const usuario_perfil_tipo = await prisma.usuario_perfil_tipo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usuario_perfil_tipoCreateManyArgs>(
      args?: SelectSubset<T, usuario_perfil_tipoCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario_perfil_tipo.
     * @param {usuario_perfil_tipoDeleteArgs} args - Arguments to delete one Usuario_perfil_tipo.
     * @example
     * // Delete one Usuario_perfil_tipo
     * const Usuario_perfil_tipo = await prisma.usuario_perfil_tipo.delete({
     *   where: {
     *     // ... filter to delete one Usuario_perfil_tipo
     *   }
     * })
     * 
    **/
    delete<T extends usuario_perfil_tipoDeleteArgs>(
      args: SelectSubset<T, usuario_perfil_tipoDeleteArgs>
    ): Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T>>

    /**
     * Update one Usuario_perfil_tipo.
     * @param {usuario_perfil_tipoUpdateArgs} args - Arguments to update one Usuario_perfil_tipo.
     * @example
     * // Update one Usuario_perfil_tipo
     * const usuario_perfil_tipo = await prisma.usuario_perfil_tipo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usuario_perfil_tipoUpdateArgs>(
      args: SelectSubset<T, usuario_perfil_tipoUpdateArgs>
    ): Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T>>

    /**
     * Delete zero or more Usuario_perfil_tipos.
     * @param {usuario_perfil_tipoDeleteManyArgs} args - Arguments to filter Usuario_perfil_tipos to delete.
     * @example
     * // Delete a few Usuario_perfil_tipos
     * const { count } = await prisma.usuario_perfil_tipo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usuario_perfil_tipoDeleteManyArgs>(
      args?: SelectSubset<T, usuario_perfil_tipoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuario_perfil_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_perfil_tipoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuario_perfil_tipos
     * const usuario_perfil_tipo = await prisma.usuario_perfil_tipo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usuario_perfil_tipoUpdateManyArgs>(
      args: SelectSubset<T, usuario_perfil_tipoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario_perfil_tipo.
     * @param {usuario_perfil_tipoUpsertArgs} args - Arguments to update or create a Usuario_perfil_tipo.
     * @example
     * // Update or create a Usuario_perfil_tipo
     * const usuario_perfil_tipo = await prisma.usuario_perfil_tipo.upsert({
     *   create: {
     *     // ... data to create a Usuario_perfil_tipo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario_perfil_tipo we want to update
     *   }
     * })
    **/
    upsert<T extends usuario_perfil_tipoUpsertArgs>(
      args: SelectSubset<T, usuario_perfil_tipoUpsertArgs>
    ): Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T>>

    /**
     * Find one Usuario_perfil_tipo that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {usuario_perfil_tipoFindUniqueOrThrowArgs} args - Arguments to find a Usuario_perfil_tipo
     * @example
     * // Get one Usuario_perfil_tipo
     * const usuario_perfil_tipo = await prisma.usuario_perfil_tipo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usuario_perfil_tipoFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usuario_perfil_tipoFindUniqueOrThrowArgs>
    ): Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T>>

    /**
     * Find the first Usuario_perfil_tipo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_perfil_tipoFindFirstOrThrowArgs} args - Arguments to find a Usuario_perfil_tipo
     * @example
     * // Get one Usuario_perfil_tipo
     * const usuario_perfil_tipo = await prisma.usuario_perfil_tipo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usuario_perfil_tipoFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usuario_perfil_tipoFindFirstOrThrowArgs>
    ): Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T>>

    /**
     * Count the number of Usuario_perfil_tipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_perfil_tipoCountArgs} args - Arguments to filter Usuario_perfil_tipos to count.
     * @example
     * // Count the number of Usuario_perfil_tipos
     * const count = await prisma.usuario_perfil_tipo.count({
     *   where: {
     *     // ... the filter for the Usuario_perfil_tipos we want to count
     *   }
     * })
    **/
    count<T extends usuario_perfil_tipoCountArgs>(
      args?: Subset<T, usuario_perfil_tipoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Usuario_perfil_tipoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario_perfil_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Usuario_perfil_tipoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Usuario_perfil_tipoAggregateArgs>(args: Subset<T, Usuario_perfil_tipoAggregateArgs>): PrismaPromise<GetUsuario_perfil_tipoAggregateType<T>>

    /**
     * Group by Usuario_perfil_tipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Usuario_perfil_tipoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Usuario_perfil_tipoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Usuario_perfil_tipoGroupByArgs['orderBy'] }
        : { orderBy?: Usuario_perfil_tipoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Usuario_perfil_tipoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuario_perfil_tipoGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario_perfil_tipo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usuario_perfil_tipoClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    usuario_perfil<T extends usuario_perfilFindManyArgs= {}>(args?: Subset<T, usuario_perfilFindManyArgs>): PrismaPromise<Array<usuario_perfilGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * usuario_perfil_tipo base type for findUnique actions
   */
  export type usuario_perfil_tipoFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the usuario_perfil_tipo
     * 
    **/
    select?: usuario_perfil_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfil_tipoInclude | null
    /**
     * Filter, which usuario_perfil_tipo to fetch.
     * 
    **/
    where: usuario_perfil_tipoWhereUniqueInput
  }

  /**
   * usuario_perfil_tipo: findUnique
   */
  export interface usuario_perfil_tipoFindUniqueArgs extends usuario_perfil_tipoFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario_perfil_tipo base type for findFirst actions
   */
  export type usuario_perfil_tipoFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the usuario_perfil_tipo
     * 
    **/
    select?: usuario_perfil_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfil_tipoInclude | null
    /**
     * Filter, which usuario_perfil_tipo to fetch.
     * 
    **/
    where?: usuario_perfil_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_perfil_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario_perfil_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuario_perfil_tipos.
     * 
    **/
    cursor?: usuario_perfil_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_perfil_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_perfil_tipos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuario_perfil_tipos.
     * 
    **/
    distinct?: Enumerable<Usuario_perfil_tipoScalarFieldEnum>
  }

  /**
   * usuario_perfil_tipo: findFirst
   */
  export interface usuario_perfil_tipoFindFirstArgs extends usuario_perfil_tipoFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario_perfil_tipo findMany
   */
  export type usuario_perfil_tipoFindManyArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil_tipo
     * 
    **/
    select?: usuario_perfil_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfil_tipoInclude | null
    /**
     * Filter, which usuario_perfil_tipos to fetch.
     * 
    **/
    where?: usuario_perfil_tipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_perfil_tipos to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario_perfil_tipoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuario_perfil_tipos.
     * 
    **/
    cursor?: usuario_perfil_tipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_perfil_tipos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_perfil_tipos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Usuario_perfil_tipoScalarFieldEnum>
  }


  /**
   * usuario_perfil_tipo create
   */
  export type usuario_perfil_tipoCreateArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil_tipo
     * 
    **/
    select?: usuario_perfil_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfil_tipoInclude | null
    /**
     * The data needed to create a usuario_perfil_tipo.
     * 
    **/
    data: XOR<usuario_perfil_tipoCreateInput, usuario_perfil_tipoUncheckedCreateInput>
  }


  /**
   * usuario_perfil_tipo createMany
   */
  export type usuario_perfil_tipoCreateManyArgs = {
    /**
     * The data used to create many usuario_perfil_tipos.
     * 
    **/
    data: Enumerable<usuario_perfil_tipoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * usuario_perfil_tipo update
   */
  export type usuario_perfil_tipoUpdateArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil_tipo
     * 
    **/
    select?: usuario_perfil_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfil_tipoInclude | null
    /**
     * The data needed to update a usuario_perfil_tipo.
     * 
    **/
    data: XOR<usuario_perfil_tipoUpdateInput, usuario_perfil_tipoUncheckedUpdateInput>
    /**
     * Choose, which usuario_perfil_tipo to update.
     * 
    **/
    where: usuario_perfil_tipoWhereUniqueInput
  }


  /**
   * usuario_perfil_tipo updateMany
   */
  export type usuario_perfil_tipoUpdateManyArgs = {
    /**
     * The data used to update usuario_perfil_tipos.
     * 
    **/
    data: XOR<usuario_perfil_tipoUpdateManyMutationInput, usuario_perfil_tipoUncheckedUpdateManyInput>
    /**
     * Filter which usuario_perfil_tipos to update
     * 
    **/
    where?: usuario_perfil_tipoWhereInput
  }


  /**
   * usuario_perfil_tipo upsert
   */
  export type usuario_perfil_tipoUpsertArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil_tipo
     * 
    **/
    select?: usuario_perfil_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfil_tipoInclude | null
    /**
     * The filter to search for the usuario_perfil_tipo to update in case it exists.
     * 
    **/
    where: usuario_perfil_tipoWhereUniqueInput
    /**
     * In case the usuario_perfil_tipo found by the `where` argument doesn't exist, create a new usuario_perfil_tipo with this data.
     * 
    **/
    create: XOR<usuario_perfil_tipoCreateInput, usuario_perfil_tipoUncheckedCreateInput>
    /**
     * In case the usuario_perfil_tipo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<usuario_perfil_tipoUpdateInput, usuario_perfil_tipoUncheckedUpdateInput>
  }


  /**
   * usuario_perfil_tipo delete
   */
  export type usuario_perfil_tipoDeleteArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil_tipo
     * 
    **/
    select?: usuario_perfil_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfil_tipoInclude | null
    /**
     * Filter which usuario_perfil_tipo to delete.
     * 
    **/
    where: usuario_perfil_tipoWhereUniqueInput
  }


  /**
   * usuario_perfil_tipo deleteMany
   */
  export type usuario_perfil_tipoDeleteManyArgs = {
    /**
     * Filter which usuario_perfil_tipos to delete
     * 
    **/
    where?: usuario_perfil_tipoWhereInput
  }


  /**
   * usuario_perfil_tipo: findUniqueOrThrow
   */
  export type usuario_perfil_tipoFindUniqueOrThrowArgs = usuario_perfil_tipoFindUniqueArgsBase
      

  /**
   * usuario_perfil_tipo: findFirstOrThrow
   */
  export type usuario_perfil_tipoFindFirstOrThrowArgs = usuario_perfil_tipoFindFirstArgsBase
      

  /**
   * usuario_perfil_tipo without action
   */
  export type usuario_perfil_tipoArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil_tipo
     * 
    **/
    select?: usuario_perfil_tipoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfil_tipoInclude | null
  }



  /**
   * Model carteira_n_cedentes
   */


  export type AggregateCarteira_n_cedentes = {
    _count: Carteira_n_cedentesCountAggregateOutputType | null
    _avg: Carteira_n_cedentesAvgAggregateOutputType | null
    _sum: Carteira_n_cedentesSumAggregateOutputType | null
    _min: Carteira_n_cedentesMinAggregateOutputType | null
    _max: Carteira_n_cedentesMaxAggregateOutputType | null
  }

  export type Carteira_n_cedentesAvgAggregateOutputType = {
    id: number | null
    carteira_id: number | null
    cedente_id: number | null
  }

  export type Carteira_n_cedentesSumAggregateOutputType = {
    id: number | null
    carteira_id: number | null
    cedente_id: number | null
  }

  export type Carteira_n_cedentesMinAggregateOutputType = {
    id: number | null
    carteira_id: number | null
    cedente_id: number | null
  }

  export type Carteira_n_cedentesMaxAggregateOutputType = {
    id: number | null
    carteira_id: number | null
    cedente_id: number | null
  }

  export type Carteira_n_cedentesCountAggregateOutputType = {
    id: number
    carteira_id: number
    cedente_id: number
    _all: number
  }


  export type Carteira_n_cedentesAvgAggregateInputType = {
    id?: true
    carteira_id?: true
    cedente_id?: true
  }

  export type Carteira_n_cedentesSumAggregateInputType = {
    id?: true
    carteira_id?: true
    cedente_id?: true
  }

  export type Carteira_n_cedentesMinAggregateInputType = {
    id?: true
    carteira_id?: true
    cedente_id?: true
  }

  export type Carteira_n_cedentesMaxAggregateInputType = {
    id?: true
    carteira_id?: true
    cedente_id?: true
  }

  export type Carteira_n_cedentesCountAggregateInputType = {
    id?: true
    carteira_id?: true
    cedente_id?: true
    _all?: true
  }

  export type Carteira_n_cedentesAggregateArgs = {
    /**
     * Filter which carteira_n_cedentes to aggregate.
     * 
    **/
    where?: carteira_n_cedentesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteira_n_cedentes to fetch.
     * 
    **/
    orderBy?: Enumerable<carteira_n_cedentesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: carteira_n_cedentesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteira_n_cedentes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteira_n_cedentes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned carteira_n_cedentes
    **/
    _count?: true | Carteira_n_cedentesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Carteira_n_cedentesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Carteira_n_cedentesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Carteira_n_cedentesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Carteira_n_cedentesMaxAggregateInputType
  }

  export type GetCarteira_n_cedentesAggregateType<T extends Carteira_n_cedentesAggregateArgs> = {
        [P in keyof T & keyof AggregateCarteira_n_cedentes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarteira_n_cedentes[P]>
      : GetScalarType<T[P], AggregateCarteira_n_cedentes[P]>
  }




  export type Carteira_n_cedentesGroupByArgs = {
    where?: carteira_n_cedentesWhereInput
    orderBy?: Enumerable<carteira_n_cedentesOrderByWithAggregationInput>
    by: Array<Carteira_n_cedentesScalarFieldEnum>
    having?: carteira_n_cedentesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Carteira_n_cedentesCountAggregateInputType | true
    _avg?: Carteira_n_cedentesAvgAggregateInputType
    _sum?: Carteira_n_cedentesSumAggregateInputType
    _min?: Carteira_n_cedentesMinAggregateInputType
    _max?: Carteira_n_cedentesMaxAggregateInputType
  }


  export type Carteira_n_cedentesGroupByOutputType = {
    id: number
    carteira_id: number
    cedente_id: number
    _count: Carteira_n_cedentesCountAggregateOutputType | null
    _avg: Carteira_n_cedentesAvgAggregateOutputType | null
    _sum: Carteira_n_cedentesSumAggregateOutputType | null
    _min: Carteira_n_cedentesMinAggregateOutputType | null
    _max: Carteira_n_cedentesMaxAggregateOutputType | null
  }

  type GetCarteira_n_cedentesGroupByPayload<T extends Carteira_n_cedentesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Carteira_n_cedentesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Carteira_n_cedentesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Carteira_n_cedentesGroupByOutputType[P]>
            : GetScalarType<T[P], Carteira_n_cedentesGroupByOutputType[P]>
        }
      >
    >


  export type carteira_n_cedentesSelect = {
    id?: boolean
    carteira_id?: boolean
    cedente_id?: boolean
    carteira?: boolean | carteiraArgs
    cedente?: boolean | cedenteArgs
  }


  export type carteira_n_cedentesInclude = {
    carteira?: boolean | carteiraArgs
    cedente?: boolean | cedenteArgs
  } 

  export type carteira_n_cedentesGetPayload<S extends boolean | null | undefined | carteira_n_cedentesArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? carteira_n_cedentes :
    S extends undefined ? never :
    S extends { include: any } & (carteira_n_cedentesArgs | carteira_n_cedentesFindManyArgs)
    ? carteira_n_cedentes  & {
    [P in TrueKeys<S['include']>]:
        P extends 'carteira' ? carteiraGetPayload<Exclude<S['include'], undefined | null>[P]> :
        P extends 'cedente' ? cedenteGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (carteira_n_cedentesArgs | carteira_n_cedentesFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'carteira' ? carteiraGetPayload<Exclude<S['select'], undefined | null>[P]> :
        P extends 'cedente' ? cedenteGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof carteira_n_cedentes ? carteira_n_cedentes[P] : never
  } 
      : carteira_n_cedentes


  type carteira_n_cedentesCountArgs = Merge<
    Omit<carteira_n_cedentesFindManyArgs, 'select' | 'include'> & {
      select?: Carteira_n_cedentesCountAggregateInputType | true
    }
  >

  export interface carteira_n_cedentesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Carteira_n_cedentes that matches the filter.
     * @param {carteira_n_cedentesFindUniqueArgs} args - Arguments to find a Carteira_n_cedentes
     * @example
     * // Get one Carteira_n_cedentes
     * const carteira_n_cedentes = await prisma.carteira_n_cedentes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends carteira_n_cedentesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, carteira_n_cedentesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'carteira_n_cedentes'> extends True ? Prisma__carteira_n_cedentesClient<carteira_n_cedentesGetPayload<T>> : Prisma__carteira_n_cedentesClient<carteira_n_cedentesGetPayload<T> | null, null>

    /**
     * Find the first Carteira_n_cedentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteira_n_cedentesFindFirstArgs} args - Arguments to find a Carteira_n_cedentes
     * @example
     * // Get one Carteira_n_cedentes
     * const carteira_n_cedentes = await prisma.carteira_n_cedentes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends carteira_n_cedentesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, carteira_n_cedentesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'carteira_n_cedentes'> extends True ? Prisma__carteira_n_cedentesClient<carteira_n_cedentesGetPayload<T>> : Prisma__carteira_n_cedentesClient<carteira_n_cedentesGetPayload<T> | null, null>

    /**
     * Find zero or more Carteira_n_cedentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteira_n_cedentesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carteira_n_cedentes
     * const carteira_n_cedentes = await prisma.carteira_n_cedentes.findMany()
     * 
     * // Get first 10 Carteira_n_cedentes
     * const carteira_n_cedentes = await prisma.carteira_n_cedentes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carteira_n_cedentesWithIdOnly = await prisma.carteira_n_cedentes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends carteira_n_cedentesFindManyArgs>(
      args?: SelectSubset<T, carteira_n_cedentesFindManyArgs>
    ): PrismaPromise<Array<carteira_n_cedentesGetPayload<T>>>

    /**
     * Create a Carteira_n_cedentes.
     * @param {carteira_n_cedentesCreateArgs} args - Arguments to create a Carteira_n_cedentes.
     * @example
     * // Create one Carteira_n_cedentes
     * const Carteira_n_cedentes = await prisma.carteira_n_cedentes.create({
     *   data: {
     *     // ... data to create a Carteira_n_cedentes
     *   }
     * })
     * 
    **/
    create<T extends carteira_n_cedentesCreateArgs>(
      args: SelectSubset<T, carteira_n_cedentesCreateArgs>
    ): Prisma__carteira_n_cedentesClient<carteira_n_cedentesGetPayload<T>>

    /**
     * Create many Carteira_n_cedentes.
     *     @param {carteira_n_cedentesCreateManyArgs} args - Arguments to create many Carteira_n_cedentes.
     *     @example
     *     // Create many Carteira_n_cedentes
     *     const carteira_n_cedentes = await prisma.carteira_n_cedentes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends carteira_n_cedentesCreateManyArgs>(
      args?: SelectSubset<T, carteira_n_cedentesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Carteira_n_cedentes.
     * @param {carteira_n_cedentesDeleteArgs} args - Arguments to delete one Carteira_n_cedentes.
     * @example
     * // Delete one Carteira_n_cedentes
     * const Carteira_n_cedentes = await prisma.carteira_n_cedentes.delete({
     *   where: {
     *     // ... filter to delete one Carteira_n_cedentes
     *   }
     * })
     * 
    **/
    delete<T extends carteira_n_cedentesDeleteArgs>(
      args: SelectSubset<T, carteira_n_cedentesDeleteArgs>
    ): Prisma__carteira_n_cedentesClient<carteira_n_cedentesGetPayload<T>>

    /**
     * Update one Carteira_n_cedentes.
     * @param {carteira_n_cedentesUpdateArgs} args - Arguments to update one Carteira_n_cedentes.
     * @example
     * // Update one Carteira_n_cedentes
     * const carteira_n_cedentes = await prisma.carteira_n_cedentes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends carteira_n_cedentesUpdateArgs>(
      args: SelectSubset<T, carteira_n_cedentesUpdateArgs>
    ): Prisma__carteira_n_cedentesClient<carteira_n_cedentesGetPayload<T>>

    /**
     * Delete zero or more Carteira_n_cedentes.
     * @param {carteira_n_cedentesDeleteManyArgs} args - Arguments to filter Carteira_n_cedentes to delete.
     * @example
     * // Delete a few Carteira_n_cedentes
     * const { count } = await prisma.carteira_n_cedentes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends carteira_n_cedentesDeleteManyArgs>(
      args?: SelectSubset<T, carteira_n_cedentesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carteira_n_cedentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteira_n_cedentesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carteira_n_cedentes
     * const carteira_n_cedentes = await prisma.carteira_n_cedentes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends carteira_n_cedentesUpdateManyArgs>(
      args: SelectSubset<T, carteira_n_cedentesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Carteira_n_cedentes.
     * @param {carteira_n_cedentesUpsertArgs} args - Arguments to update or create a Carteira_n_cedentes.
     * @example
     * // Update or create a Carteira_n_cedentes
     * const carteira_n_cedentes = await prisma.carteira_n_cedentes.upsert({
     *   create: {
     *     // ... data to create a Carteira_n_cedentes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carteira_n_cedentes we want to update
     *   }
     * })
    **/
    upsert<T extends carteira_n_cedentesUpsertArgs>(
      args: SelectSubset<T, carteira_n_cedentesUpsertArgs>
    ): Prisma__carteira_n_cedentesClient<carteira_n_cedentesGetPayload<T>>

    /**
     * Find one Carteira_n_cedentes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {carteira_n_cedentesFindUniqueOrThrowArgs} args - Arguments to find a Carteira_n_cedentes
     * @example
     * // Get one Carteira_n_cedentes
     * const carteira_n_cedentes = await prisma.carteira_n_cedentes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends carteira_n_cedentesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, carteira_n_cedentesFindUniqueOrThrowArgs>
    ): Prisma__carteira_n_cedentesClient<carteira_n_cedentesGetPayload<T>>

    /**
     * Find the first Carteira_n_cedentes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteira_n_cedentesFindFirstOrThrowArgs} args - Arguments to find a Carteira_n_cedentes
     * @example
     * // Get one Carteira_n_cedentes
     * const carteira_n_cedentes = await prisma.carteira_n_cedentes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends carteira_n_cedentesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, carteira_n_cedentesFindFirstOrThrowArgs>
    ): Prisma__carteira_n_cedentesClient<carteira_n_cedentesGetPayload<T>>

    /**
     * Count the number of Carteira_n_cedentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {carteira_n_cedentesCountArgs} args - Arguments to filter Carteira_n_cedentes to count.
     * @example
     * // Count the number of Carteira_n_cedentes
     * const count = await prisma.carteira_n_cedentes.count({
     *   where: {
     *     // ... the filter for the Carteira_n_cedentes we want to count
     *   }
     * })
    **/
    count<T extends carteira_n_cedentesCountArgs>(
      args?: Subset<T, carteira_n_cedentesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Carteira_n_cedentesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Carteira_n_cedentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Carteira_n_cedentesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Carteira_n_cedentesAggregateArgs>(args: Subset<T, Carteira_n_cedentesAggregateArgs>): PrismaPromise<GetCarteira_n_cedentesAggregateType<T>>

    /**
     * Group by Carteira_n_cedentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Carteira_n_cedentesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Carteira_n_cedentesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Carteira_n_cedentesGroupByArgs['orderBy'] }
        : { orderBy?: Carteira_n_cedentesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Carteira_n_cedentesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarteira_n_cedentesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for carteira_n_cedentes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__carteira_n_cedentesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    carteira<T extends carteiraArgs= {}>(args?: Subset<T, carteiraArgs>): Prisma__carteiraClient<carteiraGetPayload<T> | Null>;

    cedente<T extends cedenteArgs= {}>(args?: Subset<T, cedenteArgs>): Prisma__cedenteClient<cedenteGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * carteira_n_cedentes base type for findUnique actions
   */
  export type carteira_n_cedentesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the carteira_n_cedentes
     * 
    **/
    select?: carteira_n_cedentesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteira_n_cedentesInclude | null
    /**
     * Filter, which carteira_n_cedentes to fetch.
     * 
    **/
    where: carteira_n_cedentesWhereUniqueInput
  }

  /**
   * carteira_n_cedentes: findUnique
   */
  export interface carteira_n_cedentesFindUniqueArgs extends carteira_n_cedentesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * carteira_n_cedentes base type for findFirst actions
   */
  export type carteira_n_cedentesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the carteira_n_cedentes
     * 
    **/
    select?: carteira_n_cedentesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteira_n_cedentesInclude | null
    /**
     * Filter, which carteira_n_cedentes to fetch.
     * 
    **/
    where?: carteira_n_cedentesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteira_n_cedentes to fetch.
     * 
    **/
    orderBy?: Enumerable<carteira_n_cedentesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for carteira_n_cedentes.
     * 
    **/
    cursor?: carteira_n_cedentesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteira_n_cedentes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteira_n_cedentes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of carteira_n_cedentes.
     * 
    **/
    distinct?: Enumerable<Carteira_n_cedentesScalarFieldEnum>
  }

  /**
   * carteira_n_cedentes: findFirst
   */
  export interface carteira_n_cedentesFindFirstArgs extends carteira_n_cedentesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * carteira_n_cedentes findMany
   */
  export type carteira_n_cedentesFindManyArgs = {
    /**
     * Select specific fields to fetch from the carteira_n_cedentes
     * 
    **/
    select?: carteira_n_cedentesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteira_n_cedentesInclude | null
    /**
     * Filter, which carteira_n_cedentes to fetch.
     * 
    **/
    where?: carteira_n_cedentesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carteira_n_cedentes to fetch.
     * 
    **/
    orderBy?: Enumerable<carteira_n_cedentesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing carteira_n_cedentes.
     * 
    **/
    cursor?: carteira_n_cedentesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carteira_n_cedentes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carteira_n_cedentes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Carteira_n_cedentesScalarFieldEnum>
  }


  /**
   * carteira_n_cedentes create
   */
  export type carteira_n_cedentesCreateArgs = {
    /**
     * Select specific fields to fetch from the carteira_n_cedentes
     * 
    **/
    select?: carteira_n_cedentesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteira_n_cedentesInclude | null
    /**
     * The data needed to create a carteira_n_cedentes.
     * 
    **/
    data: XOR<carteira_n_cedentesCreateInput, carteira_n_cedentesUncheckedCreateInput>
  }


  /**
   * carteira_n_cedentes createMany
   */
  export type carteira_n_cedentesCreateManyArgs = {
    /**
     * The data used to create many carteira_n_cedentes.
     * 
    **/
    data: Enumerable<carteira_n_cedentesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * carteira_n_cedentes update
   */
  export type carteira_n_cedentesUpdateArgs = {
    /**
     * Select specific fields to fetch from the carteira_n_cedentes
     * 
    **/
    select?: carteira_n_cedentesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteira_n_cedentesInclude | null
    /**
     * The data needed to update a carteira_n_cedentes.
     * 
    **/
    data: XOR<carteira_n_cedentesUpdateInput, carteira_n_cedentesUncheckedUpdateInput>
    /**
     * Choose, which carteira_n_cedentes to update.
     * 
    **/
    where: carteira_n_cedentesWhereUniqueInput
  }


  /**
   * carteira_n_cedentes updateMany
   */
  export type carteira_n_cedentesUpdateManyArgs = {
    /**
     * The data used to update carteira_n_cedentes.
     * 
    **/
    data: XOR<carteira_n_cedentesUpdateManyMutationInput, carteira_n_cedentesUncheckedUpdateManyInput>
    /**
     * Filter which carteira_n_cedentes to update
     * 
    **/
    where?: carteira_n_cedentesWhereInput
  }


  /**
   * carteira_n_cedentes upsert
   */
  export type carteira_n_cedentesUpsertArgs = {
    /**
     * Select specific fields to fetch from the carteira_n_cedentes
     * 
    **/
    select?: carteira_n_cedentesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteira_n_cedentesInclude | null
    /**
     * The filter to search for the carteira_n_cedentes to update in case it exists.
     * 
    **/
    where: carteira_n_cedentesWhereUniqueInput
    /**
     * In case the carteira_n_cedentes found by the `where` argument doesn't exist, create a new carteira_n_cedentes with this data.
     * 
    **/
    create: XOR<carteira_n_cedentesCreateInput, carteira_n_cedentesUncheckedCreateInput>
    /**
     * In case the carteira_n_cedentes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<carteira_n_cedentesUpdateInput, carteira_n_cedentesUncheckedUpdateInput>
  }


  /**
   * carteira_n_cedentes delete
   */
  export type carteira_n_cedentesDeleteArgs = {
    /**
     * Select specific fields to fetch from the carteira_n_cedentes
     * 
    **/
    select?: carteira_n_cedentesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteira_n_cedentesInclude | null
    /**
     * Filter which carteira_n_cedentes to delete.
     * 
    **/
    where: carteira_n_cedentesWhereUniqueInput
  }


  /**
   * carteira_n_cedentes deleteMany
   */
  export type carteira_n_cedentesDeleteManyArgs = {
    /**
     * Filter which carteira_n_cedentes to delete
     * 
    **/
    where?: carteira_n_cedentesWhereInput
  }


  /**
   * carteira_n_cedentes: findUniqueOrThrow
   */
  export type carteira_n_cedentesFindUniqueOrThrowArgs = carteira_n_cedentesFindUniqueArgsBase
      

  /**
   * carteira_n_cedentes: findFirstOrThrow
   */
  export type carteira_n_cedentesFindFirstOrThrowArgs = carteira_n_cedentesFindFirstArgsBase
      

  /**
   * carteira_n_cedentes without action
   */
  export type carteira_n_cedentesArgs = {
    /**
     * Select specific fields to fetch from the carteira_n_cedentes
     * 
    **/
    select?: carteira_n_cedentesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: carteira_n_cedentesInclude | null
  }



  /**
   * Model organograma_x_usuario
   */


  export type AggregateOrganograma_x_usuario = {
    _count: Organograma_x_usuarioCountAggregateOutputType | null
    _avg: Organograma_x_usuarioAvgAggregateOutputType | null
    _sum: Organograma_x_usuarioSumAggregateOutputType | null
    _min: Organograma_x_usuarioMinAggregateOutputType | null
    _max: Organograma_x_usuarioMaxAggregateOutputType | null
  }

  export type Organograma_x_usuarioAvgAggregateOutputType = {
    id: number | null
    organograma_id: number | null
    usuario_id: number | null
  }

  export type Organograma_x_usuarioSumAggregateOutputType = {
    id: number | null
    organograma_id: number | null
    usuario_id: number | null
  }

  export type Organograma_x_usuarioMinAggregateOutputType = {
    id: number | null
    organograma_id: number | null
    usuario_id: number | null
  }

  export type Organograma_x_usuarioMaxAggregateOutputType = {
    id: number | null
    organograma_id: number | null
    usuario_id: number | null
  }

  export type Organograma_x_usuarioCountAggregateOutputType = {
    id: number
    organograma_id: number
    usuario_id: number
    _all: number
  }


  export type Organograma_x_usuarioAvgAggregateInputType = {
    id?: true
    organograma_id?: true
    usuario_id?: true
  }

  export type Organograma_x_usuarioSumAggregateInputType = {
    id?: true
    organograma_id?: true
    usuario_id?: true
  }

  export type Organograma_x_usuarioMinAggregateInputType = {
    id?: true
    organograma_id?: true
    usuario_id?: true
  }

  export type Organograma_x_usuarioMaxAggregateInputType = {
    id?: true
    organograma_id?: true
    usuario_id?: true
  }

  export type Organograma_x_usuarioCountAggregateInputType = {
    id?: true
    organograma_id?: true
    usuario_id?: true
    _all?: true
  }

  export type Organograma_x_usuarioAggregateArgs = {
    /**
     * Filter which organograma_x_usuario to aggregate.
     * 
    **/
    where?: organograma_x_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_x_usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_x_usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: organograma_x_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_x_usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_x_usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organograma_x_usuarios
    **/
    _count?: true | Organograma_x_usuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Organograma_x_usuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Organograma_x_usuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Organograma_x_usuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Organograma_x_usuarioMaxAggregateInputType
  }

  export type GetOrganograma_x_usuarioAggregateType<T extends Organograma_x_usuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganograma_x_usuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganograma_x_usuario[P]>
      : GetScalarType<T[P], AggregateOrganograma_x_usuario[P]>
  }




  export type Organograma_x_usuarioGroupByArgs = {
    where?: organograma_x_usuarioWhereInput
    orderBy?: Enumerable<organograma_x_usuarioOrderByWithAggregationInput>
    by: Array<Organograma_x_usuarioScalarFieldEnum>
    having?: organograma_x_usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Organograma_x_usuarioCountAggregateInputType | true
    _avg?: Organograma_x_usuarioAvgAggregateInputType
    _sum?: Organograma_x_usuarioSumAggregateInputType
    _min?: Organograma_x_usuarioMinAggregateInputType
    _max?: Organograma_x_usuarioMaxAggregateInputType
  }


  export type Organograma_x_usuarioGroupByOutputType = {
    id: number
    organograma_id: number
    usuario_id: number
    _count: Organograma_x_usuarioCountAggregateOutputType | null
    _avg: Organograma_x_usuarioAvgAggregateOutputType | null
    _sum: Organograma_x_usuarioSumAggregateOutputType | null
    _min: Organograma_x_usuarioMinAggregateOutputType | null
    _max: Organograma_x_usuarioMaxAggregateOutputType | null
  }

  type GetOrganograma_x_usuarioGroupByPayload<T extends Organograma_x_usuarioGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Organograma_x_usuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Organograma_x_usuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Organograma_x_usuarioGroupByOutputType[P]>
            : GetScalarType<T[P], Organograma_x_usuarioGroupByOutputType[P]>
        }
      >
    >


  export type organograma_x_usuarioSelect = {
    id?: boolean
    organograma_id?: boolean
    usuario_id?: boolean
    organograma?: boolean | organogramaArgs
  }


  export type organograma_x_usuarioInclude = {
    organograma?: boolean | organogramaArgs
  } 

  export type organograma_x_usuarioGetPayload<S extends boolean | null | undefined | organograma_x_usuarioArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? organograma_x_usuario :
    S extends undefined ? never :
    S extends { include: any } & (organograma_x_usuarioArgs | organograma_x_usuarioFindManyArgs)
    ? organograma_x_usuario  & {
    [P in TrueKeys<S['include']>]:
        P extends 'organograma' ? organogramaGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (organograma_x_usuarioArgs | organograma_x_usuarioFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'organograma' ? organogramaGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof organograma_x_usuario ? organograma_x_usuario[P] : never
  } 
      : organograma_x_usuario


  type organograma_x_usuarioCountArgs = Merge<
    Omit<organograma_x_usuarioFindManyArgs, 'select' | 'include'> & {
      select?: Organograma_x_usuarioCountAggregateInputType | true
    }
  >

  export interface organograma_x_usuarioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Organograma_x_usuario that matches the filter.
     * @param {organograma_x_usuarioFindUniqueArgs} args - Arguments to find a Organograma_x_usuario
     * @example
     * // Get one Organograma_x_usuario
     * const organograma_x_usuario = await prisma.organograma_x_usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends organograma_x_usuarioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, organograma_x_usuarioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'organograma_x_usuario'> extends True ? Prisma__organograma_x_usuarioClient<organograma_x_usuarioGetPayload<T>> : Prisma__organograma_x_usuarioClient<organograma_x_usuarioGetPayload<T> | null, null>

    /**
     * Find the first Organograma_x_usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_usuarioFindFirstArgs} args - Arguments to find a Organograma_x_usuario
     * @example
     * // Get one Organograma_x_usuario
     * const organograma_x_usuario = await prisma.organograma_x_usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends organograma_x_usuarioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, organograma_x_usuarioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'organograma_x_usuario'> extends True ? Prisma__organograma_x_usuarioClient<organograma_x_usuarioGetPayload<T>> : Prisma__organograma_x_usuarioClient<organograma_x_usuarioGetPayload<T> | null, null>

    /**
     * Find zero or more Organograma_x_usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_usuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organograma_x_usuarios
     * const organograma_x_usuarios = await prisma.organograma_x_usuario.findMany()
     * 
     * // Get first 10 Organograma_x_usuarios
     * const organograma_x_usuarios = await prisma.organograma_x_usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organograma_x_usuarioWithIdOnly = await prisma.organograma_x_usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends organograma_x_usuarioFindManyArgs>(
      args?: SelectSubset<T, organograma_x_usuarioFindManyArgs>
    ): PrismaPromise<Array<organograma_x_usuarioGetPayload<T>>>

    /**
     * Create a Organograma_x_usuario.
     * @param {organograma_x_usuarioCreateArgs} args - Arguments to create a Organograma_x_usuario.
     * @example
     * // Create one Organograma_x_usuario
     * const Organograma_x_usuario = await prisma.organograma_x_usuario.create({
     *   data: {
     *     // ... data to create a Organograma_x_usuario
     *   }
     * })
     * 
    **/
    create<T extends organograma_x_usuarioCreateArgs>(
      args: SelectSubset<T, organograma_x_usuarioCreateArgs>
    ): Prisma__organograma_x_usuarioClient<organograma_x_usuarioGetPayload<T>>

    /**
     * Create many Organograma_x_usuarios.
     *     @param {organograma_x_usuarioCreateManyArgs} args - Arguments to create many Organograma_x_usuarios.
     *     @example
     *     // Create many Organograma_x_usuarios
     *     const organograma_x_usuario = await prisma.organograma_x_usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends organograma_x_usuarioCreateManyArgs>(
      args?: SelectSubset<T, organograma_x_usuarioCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Organograma_x_usuario.
     * @param {organograma_x_usuarioDeleteArgs} args - Arguments to delete one Organograma_x_usuario.
     * @example
     * // Delete one Organograma_x_usuario
     * const Organograma_x_usuario = await prisma.organograma_x_usuario.delete({
     *   where: {
     *     // ... filter to delete one Organograma_x_usuario
     *   }
     * })
     * 
    **/
    delete<T extends organograma_x_usuarioDeleteArgs>(
      args: SelectSubset<T, organograma_x_usuarioDeleteArgs>
    ): Prisma__organograma_x_usuarioClient<organograma_x_usuarioGetPayload<T>>

    /**
     * Update one Organograma_x_usuario.
     * @param {organograma_x_usuarioUpdateArgs} args - Arguments to update one Organograma_x_usuario.
     * @example
     * // Update one Organograma_x_usuario
     * const organograma_x_usuario = await prisma.organograma_x_usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends organograma_x_usuarioUpdateArgs>(
      args: SelectSubset<T, organograma_x_usuarioUpdateArgs>
    ): Prisma__organograma_x_usuarioClient<organograma_x_usuarioGetPayload<T>>

    /**
     * Delete zero or more Organograma_x_usuarios.
     * @param {organograma_x_usuarioDeleteManyArgs} args - Arguments to filter Organograma_x_usuarios to delete.
     * @example
     * // Delete a few Organograma_x_usuarios
     * const { count } = await prisma.organograma_x_usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends organograma_x_usuarioDeleteManyArgs>(
      args?: SelectSubset<T, organograma_x_usuarioDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organograma_x_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organograma_x_usuarios
     * const organograma_x_usuario = await prisma.organograma_x_usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends organograma_x_usuarioUpdateManyArgs>(
      args: SelectSubset<T, organograma_x_usuarioUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Organograma_x_usuario.
     * @param {organograma_x_usuarioUpsertArgs} args - Arguments to update or create a Organograma_x_usuario.
     * @example
     * // Update or create a Organograma_x_usuario
     * const organograma_x_usuario = await prisma.organograma_x_usuario.upsert({
     *   create: {
     *     // ... data to create a Organograma_x_usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organograma_x_usuario we want to update
     *   }
     * })
    **/
    upsert<T extends organograma_x_usuarioUpsertArgs>(
      args: SelectSubset<T, organograma_x_usuarioUpsertArgs>
    ): Prisma__organograma_x_usuarioClient<organograma_x_usuarioGetPayload<T>>

    /**
     * Find one Organograma_x_usuario that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {organograma_x_usuarioFindUniqueOrThrowArgs} args - Arguments to find a Organograma_x_usuario
     * @example
     * // Get one Organograma_x_usuario
     * const organograma_x_usuario = await prisma.organograma_x_usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends organograma_x_usuarioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, organograma_x_usuarioFindUniqueOrThrowArgs>
    ): Prisma__organograma_x_usuarioClient<organograma_x_usuarioGetPayload<T>>

    /**
     * Find the first Organograma_x_usuario that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_usuarioFindFirstOrThrowArgs} args - Arguments to find a Organograma_x_usuario
     * @example
     * // Get one Organograma_x_usuario
     * const organograma_x_usuario = await prisma.organograma_x_usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends organograma_x_usuarioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, organograma_x_usuarioFindFirstOrThrowArgs>
    ): Prisma__organograma_x_usuarioClient<organograma_x_usuarioGetPayload<T>>

    /**
     * Count the number of Organograma_x_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organograma_x_usuarioCountArgs} args - Arguments to filter Organograma_x_usuarios to count.
     * @example
     * // Count the number of Organograma_x_usuarios
     * const count = await prisma.organograma_x_usuario.count({
     *   where: {
     *     // ... the filter for the Organograma_x_usuarios we want to count
     *   }
     * })
    **/
    count<T extends organograma_x_usuarioCountArgs>(
      args?: Subset<T, organograma_x_usuarioCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Organograma_x_usuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organograma_x_usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Organograma_x_usuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Organograma_x_usuarioAggregateArgs>(args: Subset<T, Organograma_x_usuarioAggregateArgs>): PrismaPromise<GetOrganograma_x_usuarioAggregateType<T>>

    /**
     * Group by Organograma_x_usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Organograma_x_usuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Organograma_x_usuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Organograma_x_usuarioGroupByArgs['orderBy'] }
        : { orderBy?: Organograma_x_usuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Organograma_x_usuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganograma_x_usuarioGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for organograma_x_usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__organograma_x_usuarioClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organograma<T extends organogramaArgs= {}>(args?: Subset<T, organogramaArgs>): Prisma__organogramaClient<organogramaGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * organograma_x_usuario base type for findUnique actions
   */
  export type organograma_x_usuarioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the organograma_x_usuario
     * 
    **/
    select?: organograma_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_x_usuarioInclude | null
    /**
     * Filter, which organograma_x_usuario to fetch.
     * 
    **/
    where: organograma_x_usuarioWhereUniqueInput
  }

  /**
   * organograma_x_usuario: findUnique
   */
  export interface organograma_x_usuarioFindUniqueArgs extends organograma_x_usuarioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organograma_x_usuario base type for findFirst actions
   */
  export type organograma_x_usuarioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the organograma_x_usuario
     * 
    **/
    select?: organograma_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_x_usuarioInclude | null
    /**
     * Filter, which organograma_x_usuario to fetch.
     * 
    **/
    where?: organograma_x_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_x_usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_x_usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organograma_x_usuarios.
     * 
    **/
    cursor?: organograma_x_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_x_usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_x_usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organograma_x_usuarios.
     * 
    **/
    distinct?: Enumerable<Organograma_x_usuarioScalarFieldEnum>
  }

  /**
   * organograma_x_usuario: findFirst
   */
  export interface organograma_x_usuarioFindFirstArgs extends organograma_x_usuarioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organograma_x_usuario findMany
   */
  export type organograma_x_usuarioFindManyArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_usuario
     * 
    **/
    select?: organograma_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_x_usuarioInclude | null
    /**
     * Filter, which organograma_x_usuarios to fetch.
     * 
    **/
    where?: organograma_x_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organograma_x_usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<organograma_x_usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organograma_x_usuarios.
     * 
    **/
    cursor?: organograma_x_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organograma_x_usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organograma_x_usuarios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Organograma_x_usuarioScalarFieldEnum>
  }


  /**
   * organograma_x_usuario create
   */
  export type organograma_x_usuarioCreateArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_usuario
     * 
    **/
    select?: organograma_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_x_usuarioInclude | null
    /**
     * The data needed to create a organograma_x_usuario.
     * 
    **/
    data: XOR<organograma_x_usuarioCreateInput, organograma_x_usuarioUncheckedCreateInput>
  }


  /**
   * organograma_x_usuario createMany
   */
  export type organograma_x_usuarioCreateManyArgs = {
    /**
     * The data used to create many organograma_x_usuarios.
     * 
    **/
    data: Enumerable<organograma_x_usuarioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * organograma_x_usuario update
   */
  export type organograma_x_usuarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_usuario
     * 
    **/
    select?: organograma_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_x_usuarioInclude | null
    /**
     * The data needed to update a organograma_x_usuario.
     * 
    **/
    data: XOR<organograma_x_usuarioUpdateInput, organograma_x_usuarioUncheckedUpdateInput>
    /**
     * Choose, which organograma_x_usuario to update.
     * 
    **/
    where: organograma_x_usuarioWhereUniqueInput
  }


  /**
   * organograma_x_usuario updateMany
   */
  export type organograma_x_usuarioUpdateManyArgs = {
    /**
     * The data used to update organograma_x_usuarios.
     * 
    **/
    data: XOR<organograma_x_usuarioUpdateManyMutationInput, organograma_x_usuarioUncheckedUpdateManyInput>
    /**
     * Filter which organograma_x_usuarios to update
     * 
    **/
    where?: organograma_x_usuarioWhereInput
  }


  /**
   * organograma_x_usuario upsert
   */
  export type organograma_x_usuarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_usuario
     * 
    **/
    select?: organograma_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_x_usuarioInclude | null
    /**
     * The filter to search for the organograma_x_usuario to update in case it exists.
     * 
    **/
    where: organograma_x_usuarioWhereUniqueInput
    /**
     * In case the organograma_x_usuario found by the `where` argument doesn't exist, create a new organograma_x_usuario with this data.
     * 
    **/
    create: XOR<organograma_x_usuarioCreateInput, organograma_x_usuarioUncheckedCreateInput>
    /**
     * In case the organograma_x_usuario was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<organograma_x_usuarioUpdateInput, organograma_x_usuarioUncheckedUpdateInput>
  }


  /**
   * organograma_x_usuario delete
   */
  export type organograma_x_usuarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_usuario
     * 
    **/
    select?: organograma_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_x_usuarioInclude | null
    /**
     * Filter which organograma_x_usuario to delete.
     * 
    **/
    where: organograma_x_usuarioWhereUniqueInput
  }


  /**
   * organograma_x_usuario deleteMany
   */
  export type organograma_x_usuarioDeleteManyArgs = {
    /**
     * Filter which organograma_x_usuarios to delete
     * 
    **/
    where?: organograma_x_usuarioWhereInput
  }


  /**
   * organograma_x_usuario: findUniqueOrThrow
   */
  export type organograma_x_usuarioFindUniqueOrThrowArgs = organograma_x_usuarioFindUniqueArgsBase
      

  /**
   * organograma_x_usuario: findFirstOrThrow
   */
  export type organograma_x_usuarioFindFirstOrThrowArgs = organograma_x_usuarioFindFirstArgsBase
      

  /**
   * organograma_x_usuario without action
   */
  export type organograma_x_usuarioArgs = {
    /**
     * Select specific fields to fetch from the organograma_x_usuario
     * 
    **/
    select?: organograma_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organograma_x_usuarioInclude | null
  }



  /**
   * Model plataforma_x_usuario
   */


  export type AggregatePlataforma_x_usuario = {
    _count: Plataforma_x_usuarioCountAggregateOutputType | null
    _avg: Plataforma_x_usuarioAvgAggregateOutputType | null
    _sum: Plataforma_x_usuarioSumAggregateOutputType | null
    _min: Plataforma_x_usuarioMinAggregateOutputType | null
    _max: Plataforma_x_usuarioMaxAggregateOutputType | null
  }

  export type Plataforma_x_usuarioAvgAggregateOutputType = {
    id: number | null
    plataforma_id: number | null
    usuario_id: number | null
  }

  export type Plataforma_x_usuarioSumAggregateOutputType = {
    id: number | null
    plataforma_id: number | null
    usuario_id: number | null
  }

  export type Plataforma_x_usuarioMinAggregateOutputType = {
    id: number | null
    plataforma_id: number | null
    usuario_id: number | null
  }

  export type Plataforma_x_usuarioMaxAggregateOutputType = {
    id: number | null
    plataforma_id: number | null
    usuario_id: number | null
  }

  export type Plataforma_x_usuarioCountAggregateOutputType = {
    id: number
    plataforma_id: number
    usuario_id: number
    _all: number
  }


  export type Plataforma_x_usuarioAvgAggregateInputType = {
    id?: true
    plataforma_id?: true
    usuario_id?: true
  }

  export type Plataforma_x_usuarioSumAggregateInputType = {
    id?: true
    plataforma_id?: true
    usuario_id?: true
  }

  export type Plataforma_x_usuarioMinAggregateInputType = {
    id?: true
    plataforma_id?: true
    usuario_id?: true
  }

  export type Plataforma_x_usuarioMaxAggregateInputType = {
    id?: true
    plataforma_id?: true
    usuario_id?: true
  }

  export type Plataforma_x_usuarioCountAggregateInputType = {
    id?: true
    plataforma_id?: true
    usuario_id?: true
    _all?: true
  }

  export type Plataforma_x_usuarioAggregateArgs = {
    /**
     * Filter which plataforma_x_usuario to aggregate.
     * 
    **/
    where?: plataforma_x_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_x_usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_x_usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: plataforma_x_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_x_usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_x_usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plataforma_x_usuarios
    **/
    _count?: true | Plataforma_x_usuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Plataforma_x_usuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Plataforma_x_usuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Plataforma_x_usuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Plataforma_x_usuarioMaxAggregateInputType
  }

  export type GetPlataforma_x_usuarioAggregateType<T extends Plataforma_x_usuarioAggregateArgs> = {
        [P in keyof T & keyof AggregatePlataforma_x_usuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlataforma_x_usuario[P]>
      : GetScalarType<T[P], AggregatePlataforma_x_usuario[P]>
  }




  export type Plataforma_x_usuarioGroupByArgs = {
    where?: plataforma_x_usuarioWhereInput
    orderBy?: Enumerable<plataforma_x_usuarioOrderByWithAggregationInput>
    by: Array<Plataforma_x_usuarioScalarFieldEnum>
    having?: plataforma_x_usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Plataforma_x_usuarioCountAggregateInputType | true
    _avg?: Plataforma_x_usuarioAvgAggregateInputType
    _sum?: Plataforma_x_usuarioSumAggregateInputType
    _min?: Plataforma_x_usuarioMinAggregateInputType
    _max?: Plataforma_x_usuarioMaxAggregateInputType
  }


  export type Plataforma_x_usuarioGroupByOutputType = {
    id: number
    plataforma_id: number
    usuario_id: number
    _count: Plataforma_x_usuarioCountAggregateOutputType | null
    _avg: Plataforma_x_usuarioAvgAggregateOutputType | null
    _sum: Plataforma_x_usuarioSumAggregateOutputType | null
    _min: Plataforma_x_usuarioMinAggregateOutputType | null
    _max: Plataforma_x_usuarioMaxAggregateOutputType | null
  }

  type GetPlataforma_x_usuarioGroupByPayload<T extends Plataforma_x_usuarioGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Plataforma_x_usuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Plataforma_x_usuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Plataforma_x_usuarioGroupByOutputType[P]>
            : GetScalarType<T[P], Plataforma_x_usuarioGroupByOutputType[P]>
        }
      >
    >


  export type plataforma_x_usuarioSelect = {
    id?: boolean
    plataforma_id?: boolean
    usuario_id?: boolean
    plataforma?: boolean | plataformaArgs
  }


  export type plataforma_x_usuarioInclude = {
    plataforma?: boolean | plataformaArgs
  } 

  export type plataforma_x_usuarioGetPayload<S extends boolean | null | undefined | plataforma_x_usuarioArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? plataforma_x_usuario :
    S extends undefined ? never :
    S extends { include: any } & (plataforma_x_usuarioArgs | plataforma_x_usuarioFindManyArgs)
    ? plataforma_x_usuario  & {
    [P in TrueKeys<S['include']>]:
        P extends 'plataforma' ? plataformaGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (plataforma_x_usuarioArgs | plataforma_x_usuarioFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'plataforma' ? plataformaGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof plataforma_x_usuario ? plataforma_x_usuario[P] : never
  } 
      : plataforma_x_usuario


  type plataforma_x_usuarioCountArgs = Merge<
    Omit<plataforma_x_usuarioFindManyArgs, 'select' | 'include'> & {
      select?: Plataforma_x_usuarioCountAggregateInputType | true
    }
  >

  export interface plataforma_x_usuarioDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Plataforma_x_usuario that matches the filter.
     * @param {plataforma_x_usuarioFindUniqueArgs} args - Arguments to find a Plataforma_x_usuario
     * @example
     * // Get one Plataforma_x_usuario
     * const plataforma_x_usuario = await prisma.plataforma_x_usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends plataforma_x_usuarioFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, plataforma_x_usuarioFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'plataforma_x_usuario'> extends True ? Prisma__plataforma_x_usuarioClient<plataforma_x_usuarioGetPayload<T>> : Prisma__plataforma_x_usuarioClient<plataforma_x_usuarioGetPayload<T> | null, null>

    /**
     * Find the first Plataforma_x_usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_x_usuarioFindFirstArgs} args - Arguments to find a Plataforma_x_usuario
     * @example
     * // Get one Plataforma_x_usuario
     * const plataforma_x_usuario = await prisma.plataforma_x_usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends plataforma_x_usuarioFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, plataforma_x_usuarioFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'plataforma_x_usuario'> extends True ? Prisma__plataforma_x_usuarioClient<plataforma_x_usuarioGetPayload<T>> : Prisma__plataforma_x_usuarioClient<plataforma_x_usuarioGetPayload<T> | null, null>

    /**
     * Find zero or more Plataforma_x_usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_x_usuarioFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plataforma_x_usuarios
     * const plataforma_x_usuarios = await prisma.plataforma_x_usuario.findMany()
     * 
     * // Get first 10 Plataforma_x_usuarios
     * const plataforma_x_usuarios = await prisma.plataforma_x_usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plataforma_x_usuarioWithIdOnly = await prisma.plataforma_x_usuario.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends plataforma_x_usuarioFindManyArgs>(
      args?: SelectSubset<T, plataforma_x_usuarioFindManyArgs>
    ): PrismaPromise<Array<plataforma_x_usuarioGetPayload<T>>>

    /**
     * Create a Plataforma_x_usuario.
     * @param {plataforma_x_usuarioCreateArgs} args - Arguments to create a Plataforma_x_usuario.
     * @example
     * // Create one Plataforma_x_usuario
     * const Plataforma_x_usuario = await prisma.plataforma_x_usuario.create({
     *   data: {
     *     // ... data to create a Plataforma_x_usuario
     *   }
     * })
     * 
    **/
    create<T extends plataforma_x_usuarioCreateArgs>(
      args: SelectSubset<T, plataforma_x_usuarioCreateArgs>
    ): Prisma__plataforma_x_usuarioClient<plataforma_x_usuarioGetPayload<T>>

    /**
     * Create many Plataforma_x_usuarios.
     *     @param {plataforma_x_usuarioCreateManyArgs} args - Arguments to create many Plataforma_x_usuarios.
     *     @example
     *     // Create many Plataforma_x_usuarios
     *     const plataforma_x_usuario = await prisma.plataforma_x_usuario.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends plataforma_x_usuarioCreateManyArgs>(
      args?: SelectSubset<T, plataforma_x_usuarioCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Plataforma_x_usuario.
     * @param {plataforma_x_usuarioDeleteArgs} args - Arguments to delete one Plataforma_x_usuario.
     * @example
     * // Delete one Plataforma_x_usuario
     * const Plataforma_x_usuario = await prisma.plataforma_x_usuario.delete({
     *   where: {
     *     // ... filter to delete one Plataforma_x_usuario
     *   }
     * })
     * 
    **/
    delete<T extends plataforma_x_usuarioDeleteArgs>(
      args: SelectSubset<T, plataforma_x_usuarioDeleteArgs>
    ): Prisma__plataforma_x_usuarioClient<plataforma_x_usuarioGetPayload<T>>

    /**
     * Update one Plataforma_x_usuario.
     * @param {plataforma_x_usuarioUpdateArgs} args - Arguments to update one Plataforma_x_usuario.
     * @example
     * // Update one Plataforma_x_usuario
     * const plataforma_x_usuario = await prisma.plataforma_x_usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends plataforma_x_usuarioUpdateArgs>(
      args: SelectSubset<T, plataforma_x_usuarioUpdateArgs>
    ): Prisma__plataforma_x_usuarioClient<plataforma_x_usuarioGetPayload<T>>

    /**
     * Delete zero or more Plataforma_x_usuarios.
     * @param {plataforma_x_usuarioDeleteManyArgs} args - Arguments to filter Plataforma_x_usuarios to delete.
     * @example
     * // Delete a few Plataforma_x_usuarios
     * const { count } = await prisma.plataforma_x_usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends plataforma_x_usuarioDeleteManyArgs>(
      args?: SelectSubset<T, plataforma_x_usuarioDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plataforma_x_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_x_usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plataforma_x_usuarios
     * const plataforma_x_usuario = await prisma.plataforma_x_usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends plataforma_x_usuarioUpdateManyArgs>(
      args: SelectSubset<T, plataforma_x_usuarioUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Plataforma_x_usuario.
     * @param {plataforma_x_usuarioUpsertArgs} args - Arguments to update or create a Plataforma_x_usuario.
     * @example
     * // Update or create a Plataforma_x_usuario
     * const plataforma_x_usuario = await prisma.plataforma_x_usuario.upsert({
     *   create: {
     *     // ... data to create a Plataforma_x_usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plataforma_x_usuario we want to update
     *   }
     * })
    **/
    upsert<T extends plataforma_x_usuarioUpsertArgs>(
      args: SelectSubset<T, plataforma_x_usuarioUpsertArgs>
    ): Prisma__plataforma_x_usuarioClient<plataforma_x_usuarioGetPayload<T>>

    /**
     * Find one Plataforma_x_usuario that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {plataforma_x_usuarioFindUniqueOrThrowArgs} args - Arguments to find a Plataforma_x_usuario
     * @example
     * // Get one Plataforma_x_usuario
     * const plataforma_x_usuario = await prisma.plataforma_x_usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends plataforma_x_usuarioFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, plataforma_x_usuarioFindUniqueOrThrowArgs>
    ): Prisma__plataforma_x_usuarioClient<plataforma_x_usuarioGetPayload<T>>

    /**
     * Find the first Plataforma_x_usuario that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_x_usuarioFindFirstOrThrowArgs} args - Arguments to find a Plataforma_x_usuario
     * @example
     * // Get one Plataforma_x_usuario
     * const plataforma_x_usuario = await prisma.plataforma_x_usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends plataforma_x_usuarioFindFirstOrThrowArgs>(
      args?: SelectSubset<T, plataforma_x_usuarioFindFirstOrThrowArgs>
    ): Prisma__plataforma_x_usuarioClient<plataforma_x_usuarioGetPayload<T>>

    /**
     * Count the number of Plataforma_x_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plataforma_x_usuarioCountArgs} args - Arguments to filter Plataforma_x_usuarios to count.
     * @example
     * // Count the number of Plataforma_x_usuarios
     * const count = await prisma.plataforma_x_usuario.count({
     *   where: {
     *     // ... the filter for the Plataforma_x_usuarios we want to count
     *   }
     * })
    **/
    count<T extends plataforma_x_usuarioCountArgs>(
      args?: Subset<T, plataforma_x_usuarioCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Plataforma_x_usuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plataforma_x_usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plataforma_x_usuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Plataforma_x_usuarioAggregateArgs>(args: Subset<T, Plataforma_x_usuarioAggregateArgs>): PrismaPromise<GetPlataforma_x_usuarioAggregateType<T>>

    /**
     * Group by Plataforma_x_usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Plataforma_x_usuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Plataforma_x_usuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Plataforma_x_usuarioGroupByArgs['orderBy'] }
        : { orderBy?: Plataforma_x_usuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Plataforma_x_usuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlataforma_x_usuarioGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for plataforma_x_usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__plataforma_x_usuarioClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    plataforma<T extends plataformaArgs= {}>(args?: Subset<T, plataformaArgs>): Prisma__plataformaClient<plataformaGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * plataforma_x_usuario base type for findUnique actions
   */
  export type plataforma_x_usuarioFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma_x_usuario
     * 
    **/
    select?: plataforma_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_x_usuarioInclude | null
    /**
     * Filter, which plataforma_x_usuario to fetch.
     * 
    **/
    where: plataforma_x_usuarioWhereUniqueInput
  }

  /**
   * plataforma_x_usuario: findUnique
   */
  export interface plataforma_x_usuarioFindUniqueArgs extends plataforma_x_usuarioFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma_x_usuario base type for findFirst actions
   */
  export type plataforma_x_usuarioFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the plataforma_x_usuario
     * 
    **/
    select?: plataforma_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_x_usuarioInclude | null
    /**
     * Filter, which plataforma_x_usuario to fetch.
     * 
    **/
    where?: plataforma_x_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_x_usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_x_usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plataforma_x_usuarios.
     * 
    **/
    cursor?: plataforma_x_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_x_usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_x_usuarios.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plataforma_x_usuarios.
     * 
    **/
    distinct?: Enumerable<Plataforma_x_usuarioScalarFieldEnum>
  }

  /**
   * plataforma_x_usuario: findFirst
   */
  export interface plataforma_x_usuarioFindFirstArgs extends plataforma_x_usuarioFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * plataforma_x_usuario findMany
   */
  export type plataforma_x_usuarioFindManyArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_usuario
     * 
    **/
    select?: plataforma_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_x_usuarioInclude | null
    /**
     * Filter, which plataforma_x_usuarios to fetch.
     * 
    **/
    where?: plataforma_x_usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plataforma_x_usuarios to fetch.
     * 
    **/
    orderBy?: Enumerable<plataforma_x_usuarioOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plataforma_x_usuarios.
     * 
    **/
    cursor?: plataforma_x_usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plataforma_x_usuarios from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plataforma_x_usuarios.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Plataforma_x_usuarioScalarFieldEnum>
  }


  /**
   * plataforma_x_usuario create
   */
  export type plataforma_x_usuarioCreateArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_usuario
     * 
    **/
    select?: plataforma_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_x_usuarioInclude | null
    /**
     * The data needed to create a plataforma_x_usuario.
     * 
    **/
    data: XOR<plataforma_x_usuarioCreateInput, plataforma_x_usuarioUncheckedCreateInput>
  }


  /**
   * plataforma_x_usuario createMany
   */
  export type plataforma_x_usuarioCreateManyArgs = {
    /**
     * The data used to create many plataforma_x_usuarios.
     * 
    **/
    data: Enumerable<plataforma_x_usuarioCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * plataforma_x_usuario update
   */
  export type plataforma_x_usuarioUpdateArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_usuario
     * 
    **/
    select?: plataforma_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_x_usuarioInclude | null
    /**
     * The data needed to update a plataforma_x_usuario.
     * 
    **/
    data: XOR<plataforma_x_usuarioUpdateInput, plataforma_x_usuarioUncheckedUpdateInput>
    /**
     * Choose, which plataforma_x_usuario to update.
     * 
    **/
    where: plataforma_x_usuarioWhereUniqueInput
  }


  /**
   * plataforma_x_usuario updateMany
   */
  export type plataforma_x_usuarioUpdateManyArgs = {
    /**
     * The data used to update plataforma_x_usuarios.
     * 
    **/
    data: XOR<plataforma_x_usuarioUpdateManyMutationInput, plataforma_x_usuarioUncheckedUpdateManyInput>
    /**
     * Filter which plataforma_x_usuarios to update
     * 
    **/
    where?: plataforma_x_usuarioWhereInput
  }


  /**
   * plataforma_x_usuario upsert
   */
  export type plataforma_x_usuarioUpsertArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_usuario
     * 
    **/
    select?: plataforma_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_x_usuarioInclude | null
    /**
     * The filter to search for the plataforma_x_usuario to update in case it exists.
     * 
    **/
    where: plataforma_x_usuarioWhereUniqueInput
    /**
     * In case the plataforma_x_usuario found by the `where` argument doesn't exist, create a new plataforma_x_usuario with this data.
     * 
    **/
    create: XOR<plataforma_x_usuarioCreateInput, plataforma_x_usuarioUncheckedCreateInput>
    /**
     * In case the plataforma_x_usuario was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<plataforma_x_usuarioUpdateInput, plataforma_x_usuarioUncheckedUpdateInput>
  }


  /**
   * plataforma_x_usuario delete
   */
  export type plataforma_x_usuarioDeleteArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_usuario
     * 
    **/
    select?: plataforma_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_x_usuarioInclude | null
    /**
     * Filter which plataforma_x_usuario to delete.
     * 
    **/
    where: plataforma_x_usuarioWhereUniqueInput
  }


  /**
   * plataforma_x_usuario deleteMany
   */
  export type plataforma_x_usuarioDeleteManyArgs = {
    /**
     * Filter which plataforma_x_usuarios to delete
     * 
    **/
    where?: plataforma_x_usuarioWhereInput
  }


  /**
   * plataforma_x_usuario: findUniqueOrThrow
   */
  export type plataforma_x_usuarioFindUniqueOrThrowArgs = plataforma_x_usuarioFindUniqueArgsBase
      

  /**
   * plataforma_x_usuario: findFirstOrThrow
   */
  export type plataforma_x_usuarioFindFirstOrThrowArgs = plataforma_x_usuarioFindFirstArgsBase
      

  /**
   * plataforma_x_usuario without action
   */
  export type plataforma_x_usuarioArgs = {
    /**
     * Select specific fields to fetch from the plataforma_x_usuario
     * 
    **/
    select?: plataforma_x_usuarioSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: plataforma_x_usuarioInclude | null
  }



  /**
   * Model titulo_itens
   */


  export type AggregateTitulo_itens = {
    _count: Titulo_itensCountAggregateOutputType | null
    _avg: Titulo_itensAvgAggregateOutputType | null
    _sum: Titulo_itensSumAggregateOutputType | null
    _min: Titulo_itensMinAggregateOutputType | null
    _max: Titulo_itensMaxAggregateOutputType | null
  }

  export type Titulo_itensAvgAggregateOutputType = {
    id: number | null
    titulo_id: number | null
  }

  export type Titulo_itensSumAggregateOutputType = {
    id: number | null
    titulo_id: number | null
  }

  export type Titulo_itensMinAggregateOutputType = {
    id: number | null
    titulo_id: number | null
  }

  export type Titulo_itensMaxAggregateOutputType = {
    id: number | null
    titulo_id: number | null
  }

  export type Titulo_itensCountAggregateOutputType = {
    id: number
    titulo_id: number
    _all: number
  }


  export type Titulo_itensAvgAggregateInputType = {
    id?: true
    titulo_id?: true
  }

  export type Titulo_itensSumAggregateInputType = {
    id?: true
    titulo_id?: true
  }

  export type Titulo_itensMinAggregateInputType = {
    id?: true
    titulo_id?: true
  }

  export type Titulo_itensMaxAggregateInputType = {
    id?: true
    titulo_id?: true
  }

  export type Titulo_itensCountAggregateInputType = {
    id?: true
    titulo_id?: true
    _all?: true
  }

  export type Titulo_itensAggregateArgs = {
    /**
     * Filter which titulo_itens to aggregate.
     * 
    **/
    where?: titulo_itensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_itens to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_itensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: titulo_itensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_itens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_itens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned titulo_itens
    **/
    _count?: true | Titulo_itensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Titulo_itensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Titulo_itensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Titulo_itensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Titulo_itensMaxAggregateInputType
  }

  export type GetTitulo_itensAggregateType<T extends Titulo_itensAggregateArgs> = {
        [P in keyof T & keyof AggregateTitulo_itens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTitulo_itens[P]>
      : GetScalarType<T[P], AggregateTitulo_itens[P]>
  }




  export type Titulo_itensGroupByArgs = {
    where?: titulo_itensWhereInput
    orderBy?: Enumerable<titulo_itensOrderByWithAggregationInput>
    by: Array<Titulo_itensScalarFieldEnum>
    having?: titulo_itensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Titulo_itensCountAggregateInputType | true
    _avg?: Titulo_itensAvgAggregateInputType
    _sum?: Titulo_itensSumAggregateInputType
    _min?: Titulo_itensMinAggregateInputType
    _max?: Titulo_itensMaxAggregateInputType
  }


  export type Titulo_itensGroupByOutputType = {
    id: number
    titulo_id: number
    _count: Titulo_itensCountAggregateOutputType | null
    _avg: Titulo_itensAvgAggregateOutputType | null
    _sum: Titulo_itensSumAggregateOutputType | null
    _min: Titulo_itensMinAggregateOutputType | null
    _max: Titulo_itensMaxAggregateOutputType | null
  }

  type GetTitulo_itensGroupByPayload<T extends Titulo_itensGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Titulo_itensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Titulo_itensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Titulo_itensGroupByOutputType[P]>
            : GetScalarType<T[P], Titulo_itensGroupByOutputType[P]>
        }
      >
    >


  export type titulo_itensSelect = {
    id?: boolean
    titulo_id?: boolean
    titulo?: boolean | tituloArgs
  }


  export type titulo_itensInclude = {
    titulo?: boolean | tituloArgs
  } 

  export type titulo_itensGetPayload<S extends boolean | null | undefined | titulo_itensArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? titulo_itens :
    S extends undefined ? never :
    S extends { include: any } & (titulo_itensArgs | titulo_itensFindManyArgs)
    ? titulo_itens  & {
    [P in TrueKeys<S['include']>]:
        P extends 'titulo' ? tituloGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (titulo_itensArgs | titulo_itensFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'titulo' ? tituloGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof titulo_itens ? titulo_itens[P] : never
  } 
      : titulo_itens


  type titulo_itensCountArgs = Merge<
    Omit<titulo_itensFindManyArgs, 'select' | 'include'> & {
      select?: Titulo_itensCountAggregateInputType | true
    }
  >

  export interface titulo_itensDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Titulo_itens that matches the filter.
     * @param {titulo_itensFindUniqueArgs} args - Arguments to find a Titulo_itens
     * @example
     * // Get one Titulo_itens
     * const titulo_itens = await prisma.titulo_itens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends titulo_itensFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, titulo_itensFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'titulo_itens'> extends True ? Prisma__titulo_itensClient<titulo_itensGetPayload<T>> : Prisma__titulo_itensClient<titulo_itensGetPayload<T> | null, null>

    /**
     * Find the first Titulo_itens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_itensFindFirstArgs} args - Arguments to find a Titulo_itens
     * @example
     * // Get one Titulo_itens
     * const titulo_itens = await prisma.titulo_itens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends titulo_itensFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, titulo_itensFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'titulo_itens'> extends True ? Prisma__titulo_itensClient<titulo_itensGetPayload<T>> : Prisma__titulo_itensClient<titulo_itensGetPayload<T> | null, null>

    /**
     * Find zero or more Titulo_itens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_itensFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Titulo_itens
     * const titulo_itens = await prisma.titulo_itens.findMany()
     * 
     * // Get first 10 Titulo_itens
     * const titulo_itens = await prisma.titulo_itens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const titulo_itensWithIdOnly = await prisma.titulo_itens.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends titulo_itensFindManyArgs>(
      args?: SelectSubset<T, titulo_itensFindManyArgs>
    ): PrismaPromise<Array<titulo_itensGetPayload<T>>>

    /**
     * Create a Titulo_itens.
     * @param {titulo_itensCreateArgs} args - Arguments to create a Titulo_itens.
     * @example
     * // Create one Titulo_itens
     * const Titulo_itens = await prisma.titulo_itens.create({
     *   data: {
     *     // ... data to create a Titulo_itens
     *   }
     * })
     * 
    **/
    create<T extends titulo_itensCreateArgs>(
      args: SelectSubset<T, titulo_itensCreateArgs>
    ): Prisma__titulo_itensClient<titulo_itensGetPayload<T>>

    /**
     * Create many Titulo_itens.
     *     @param {titulo_itensCreateManyArgs} args - Arguments to create many Titulo_itens.
     *     @example
     *     // Create many Titulo_itens
     *     const titulo_itens = await prisma.titulo_itens.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends titulo_itensCreateManyArgs>(
      args?: SelectSubset<T, titulo_itensCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Titulo_itens.
     * @param {titulo_itensDeleteArgs} args - Arguments to delete one Titulo_itens.
     * @example
     * // Delete one Titulo_itens
     * const Titulo_itens = await prisma.titulo_itens.delete({
     *   where: {
     *     // ... filter to delete one Titulo_itens
     *   }
     * })
     * 
    **/
    delete<T extends titulo_itensDeleteArgs>(
      args: SelectSubset<T, titulo_itensDeleteArgs>
    ): Prisma__titulo_itensClient<titulo_itensGetPayload<T>>

    /**
     * Update one Titulo_itens.
     * @param {titulo_itensUpdateArgs} args - Arguments to update one Titulo_itens.
     * @example
     * // Update one Titulo_itens
     * const titulo_itens = await prisma.titulo_itens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends titulo_itensUpdateArgs>(
      args: SelectSubset<T, titulo_itensUpdateArgs>
    ): Prisma__titulo_itensClient<titulo_itensGetPayload<T>>

    /**
     * Delete zero or more Titulo_itens.
     * @param {titulo_itensDeleteManyArgs} args - Arguments to filter Titulo_itens to delete.
     * @example
     * // Delete a few Titulo_itens
     * const { count } = await prisma.titulo_itens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends titulo_itensDeleteManyArgs>(
      args?: SelectSubset<T, titulo_itensDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Titulo_itens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_itensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Titulo_itens
     * const titulo_itens = await prisma.titulo_itens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends titulo_itensUpdateManyArgs>(
      args: SelectSubset<T, titulo_itensUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Titulo_itens.
     * @param {titulo_itensUpsertArgs} args - Arguments to update or create a Titulo_itens.
     * @example
     * // Update or create a Titulo_itens
     * const titulo_itens = await prisma.titulo_itens.upsert({
     *   create: {
     *     // ... data to create a Titulo_itens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Titulo_itens we want to update
     *   }
     * })
    **/
    upsert<T extends titulo_itensUpsertArgs>(
      args: SelectSubset<T, titulo_itensUpsertArgs>
    ): Prisma__titulo_itensClient<titulo_itensGetPayload<T>>

    /**
     * Find one Titulo_itens that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {titulo_itensFindUniqueOrThrowArgs} args - Arguments to find a Titulo_itens
     * @example
     * // Get one Titulo_itens
     * const titulo_itens = await prisma.titulo_itens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends titulo_itensFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, titulo_itensFindUniqueOrThrowArgs>
    ): Prisma__titulo_itensClient<titulo_itensGetPayload<T>>

    /**
     * Find the first Titulo_itens that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_itensFindFirstOrThrowArgs} args - Arguments to find a Titulo_itens
     * @example
     * // Get one Titulo_itens
     * const titulo_itens = await prisma.titulo_itens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends titulo_itensFindFirstOrThrowArgs>(
      args?: SelectSubset<T, titulo_itensFindFirstOrThrowArgs>
    ): Prisma__titulo_itensClient<titulo_itensGetPayload<T>>

    /**
     * Count the number of Titulo_itens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {titulo_itensCountArgs} args - Arguments to filter Titulo_itens to count.
     * @example
     * // Count the number of Titulo_itens
     * const count = await prisma.titulo_itens.count({
     *   where: {
     *     // ... the filter for the Titulo_itens we want to count
     *   }
     * })
    **/
    count<T extends titulo_itensCountArgs>(
      args?: Subset<T, titulo_itensCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Titulo_itensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Titulo_itens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Titulo_itensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Titulo_itensAggregateArgs>(args: Subset<T, Titulo_itensAggregateArgs>): PrismaPromise<GetTitulo_itensAggregateType<T>>

    /**
     * Group by Titulo_itens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Titulo_itensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Titulo_itensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Titulo_itensGroupByArgs['orderBy'] }
        : { orderBy?: Titulo_itensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Titulo_itensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTitulo_itensGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for titulo_itens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__titulo_itensClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    titulo<T extends tituloArgs= {}>(args?: Subset<T, tituloArgs>): Prisma__tituloClient<tituloGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * titulo_itens base type for findUnique actions
   */
  export type titulo_itensFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the titulo_itens
     * 
    **/
    select?: titulo_itensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_itensInclude | null
    /**
     * Filter, which titulo_itens to fetch.
     * 
    **/
    where: titulo_itensWhereUniqueInput
  }

  /**
   * titulo_itens: findUnique
   */
  export interface titulo_itensFindUniqueArgs extends titulo_itensFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulo_itens base type for findFirst actions
   */
  export type titulo_itensFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the titulo_itens
     * 
    **/
    select?: titulo_itensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_itensInclude | null
    /**
     * Filter, which titulo_itens to fetch.
     * 
    **/
    where?: titulo_itensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_itens to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_itensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for titulo_itens.
     * 
    **/
    cursor?: titulo_itensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_itens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_itens.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of titulo_itens.
     * 
    **/
    distinct?: Enumerable<Titulo_itensScalarFieldEnum>
  }

  /**
   * titulo_itens: findFirst
   */
  export interface titulo_itensFindFirstArgs extends titulo_itensFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * titulo_itens findMany
   */
  export type titulo_itensFindManyArgs = {
    /**
     * Select specific fields to fetch from the titulo_itens
     * 
    **/
    select?: titulo_itensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_itensInclude | null
    /**
     * Filter, which titulo_itens to fetch.
     * 
    **/
    where?: titulo_itensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of titulo_itens to fetch.
     * 
    **/
    orderBy?: Enumerable<titulo_itensOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing titulo_itens.
     * 
    **/
    cursor?: titulo_itensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` titulo_itens from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` titulo_itens.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Titulo_itensScalarFieldEnum>
  }


  /**
   * titulo_itens create
   */
  export type titulo_itensCreateArgs = {
    /**
     * Select specific fields to fetch from the titulo_itens
     * 
    **/
    select?: titulo_itensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_itensInclude | null
    /**
     * The data needed to create a titulo_itens.
     * 
    **/
    data: XOR<titulo_itensCreateInput, titulo_itensUncheckedCreateInput>
  }


  /**
   * titulo_itens createMany
   */
  export type titulo_itensCreateManyArgs = {
    /**
     * The data used to create many titulo_itens.
     * 
    **/
    data: Enumerable<titulo_itensCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * titulo_itens update
   */
  export type titulo_itensUpdateArgs = {
    /**
     * Select specific fields to fetch from the titulo_itens
     * 
    **/
    select?: titulo_itensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_itensInclude | null
    /**
     * The data needed to update a titulo_itens.
     * 
    **/
    data: XOR<titulo_itensUpdateInput, titulo_itensUncheckedUpdateInput>
    /**
     * Choose, which titulo_itens to update.
     * 
    **/
    where: titulo_itensWhereUniqueInput
  }


  /**
   * titulo_itens updateMany
   */
  export type titulo_itensUpdateManyArgs = {
    /**
     * The data used to update titulo_itens.
     * 
    **/
    data: XOR<titulo_itensUpdateManyMutationInput, titulo_itensUncheckedUpdateManyInput>
    /**
     * Filter which titulo_itens to update
     * 
    **/
    where?: titulo_itensWhereInput
  }


  /**
   * titulo_itens upsert
   */
  export type titulo_itensUpsertArgs = {
    /**
     * Select specific fields to fetch from the titulo_itens
     * 
    **/
    select?: titulo_itensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_itensInclude | null
    /**
     * The filter to search for the titulo_itens to update in case it exists.
     * 
    **/
    where: titulo_itensWhereUniqueInput
    /**
     * In case the titulo_itens found by the `where` argument doesn't exist, create a new titulo_itens with this data.
     * 
    **/
    create: XOR<titulo_itensCreateInput, titulo_itensUncheckedCreateInput>
    /**
     * In case the titulo_itens was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<titulo_itensUpdateInput, titulo_itensUncheckedUpdateInput>
  }


  /**
   * titulo_itens delete
   */
  export type titulo_itensDeleteArgs = {
    /**
     * Select specific fields to fetch from the titulo_itens
     * 
    **/
    select?: titulo_itensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_itensInclude | null
    /**
     * Filter which titulo_itens to delete.
     * 
    **/
    where: titulo_itensWhereUniqueInput
  }


  /**
   * titulo_itens deleteMany
   */
  export type titulo_itensDeleteManyArgs = {
    /**
     * Filter which titulo_itens to delete
     * 
    **/
    where?: titulo_itensWhereInput
  }


  /**
   * titulo_itens: findUniqueOrThrow
   */
  export type titulo_itensFindUniqueOrThrowArgs = titulo_itensFindUniqueArgsBase
      

  /**
   * titulo_itens: findFirstOrThrow
   */
  export type titulo_itensFindFirstOrThrowArgs = titulo_itensFindFirstArgsBase
      

  /**
   * titulo_itens without action
   */
  export type titulo_itensArgs = {
    /**
     * Select specific fields to fetch from the titulo_itens
     * 
    **/
    select?: titulo_itensSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: titulo_itensInclude | null
  }



  /**
   * Model usuario_perfil
   */


  export type AggregateUsuario_perfil = {
    _count: Usuario_perfilCountAggregateOutputType | null
    _avg: Usuario_perfilAvgAggregateOutputType | null
    _sum: Usuario_perfilSumAggregateOutputType | null
    _min: Usuario_perfilMinAggregateOutputType | null
    _max: Usuario_perfilMaxAggregateOutputType | null
  }

  export type Usuario_perfilAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    usuario_perfil_tipo_id: number | null
  }

  export type Usuario_perfilSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    usuario_perfil_tipo_id: number | null
  }

  export type Usuario_perfilMinAggregateOutputType = {
    id: number | null
    senha: string | null
    usuario_id: number | null
    usuario_perfil_tipo_id: number | null
  }

  export type Usuario_perfilMaxAggregateOutputType = {
    id: number | null
    senha: string | null
    usuario_id: number | null
    usuario_perfil_tipo_id: number | null
  }

  export type Usuario_perfilCountAggregateOutputType = {
    id: number
    senha: number
    usuario_id: number
    usuario_perfil_tipo_id: number
    _all: number
  }


  export type Usuario_perfilAvgAggregateInputType = {
    id?: true
    usuario_id?: true
    usuario_perfil_tipo_id?: true
  }

  export type Usuario_perfilSumAggregateInputType = {
    id?: true
    usuario_id?: true
    usuario_perfil_tipo_id?: true
  }

  export type Usuario_perfilMinAggregateInputType = {
    id?: true
    senha?: true
    usuario_id?: true
    usuario_perfil_tipo_id?: true
  }

  export type Usuario_perfilMaxAggregateInputType = {
    id?: true
    senha?: true
    usuario_id?: true
    usuario_perfil_tipo_id?: true
  }

  export type Usuario_perfilCountAggregateInputType = {
    id?: true
    senha?: true
    usuario_id?: true
    usuario_perfil_tipo_id?: true
    _all?: true
  }

  export type Usuario_perfilAggregateArgs = {
    /**
     * Filter which usuario_perfil to aggregate.
     * 
    **/
    where?: usuario_perfilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_perfils to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario_perfilOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: usuario_perfilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_perfils from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_perfils.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuario_perfils
    **/
    _count?: true | Usuario_perfilCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Usuario_perfilAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Usuario_perfilSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Usuario_perfilMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Usuario_perfilMaxAggregateInputType
  }

  export type GetUsuario_perfilAggregateType<T extends Usuario_perfilAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario_perfil]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario_perfil[P]>
      : GetScalarType<T[P], AggregateUsuario_perfil[P]>
  }




  export type Usuario_perfilGroupByArgs = {
    where?: usuario_perfilWhereInput
    orderBy?: Enumerable<usuario_perfilOrderByWithAggregationInput>
    by: Array<Usuario_perfilScalarFieldEnum>
    having?: usuario_perfilScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Usuario_perfilCountAggregateInputType | true
    _avg?: Usuario_perfilAvgAggregateInputType
    _sum?: Usuario_perfilSumAggregateInputType
    _min?: Usuario_perfilMinAggregateInputType
    _max?: Usuario_perfilMaxAggregateInputType
  }


  export type Usuario_perfilGroupByOutputType = {
    id: number
    senha: string
    usuario_id: number
    usuario_perfil_tipo_id: number
    _count: Usuario_perfilCountAggregateOutputType | null
    _avg: Usuario_perfilAvgAggregateOutputType | null
    _sum: Usuario_perfilSumAggregateOutputType | null
    _min: Usuario_perfilMinAggregateOutputType | null
    _max: Usuario_perfilMaxAggregateOutputType | null
  }

  type GetUsuario_perfilGroupByPayload<T extends Usuario_perfilGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Usuario_perfilGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Usuario_perfilGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Usuario_perfilGroupByOutputType[P]>
            : GetScalarType<T[P], Usuario_perfilGroupByOutputType[P]>
        }
      >
    >


  export type usuario_perfilSelect = {
    id?: boolean
    senha?: boolean
    usuario_id?: boolean
    usuario_perfil_tipo_id?: boolean
    usuario_perfil_tipo?: boolean | usuario_perfil_tipoArgs
  }


  export type usuario_perfilInclude = {
    usuario_perfil_tipo?: boolean | usuario_perfil_tipoArgs
  } 

  export type usuario_perfilGetPayload<S extends boolean | null | undefined | usuario_perfilArgs, U = keyof S> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? usuario_perfil :
    S extends undefined ? never :
    S extends { include: any } & (usuario_perfilArgs | usuario_perfilFindManyArgs)
    ? usuario_perfil  & {
    [P in TrueKeys<S['include']>]:
        P extends 'usuario_perfil_tipo' ? usuario_perfil_tipoGetPayload<Exclude<S['include'], undefined | null>[P]> :  never
  } 
    : S extends { select: any } & (usuario_perfilArgs | usuario_perfilFindManyArgs)
      ? {
    [P in TrueKeys<S['select']>]:
        P extends 'usuario_perfil_tipo' ? usuario_perfil_tipoGetPayload<Exclude<S['select'], undefined | null>[P]> :  P extends keyof usuario_perfil ? usuario_perfil[P] : never
  } 
      : usuario_perfil


  type usuario_perfilCountArgs = Merge<
    Omit<usuario_perfilFindManyArgs, 'select' | 'include'> & {
      select?: Usuario_perfilCountAggregateInputType | true
    }
  >

  export interface usuario_perfilDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Usuario_perfil that matches the filter.
     * @param {usuario_perfilFindUniqueArgs} args - Arguments to find a Usuario_perfil
     * @example
     * // Get one Usuario_perfil
     * const usuario_perfil = await prisma.usuario_perfil.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usuario_perfilFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usuario_perfilFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'usuario_perfil'> extends True ? Prisma__usuario_perfilClient<usuario_perfilGetPayload<T>> : Prisma__usuario_perfilClient<usuario_perfilGetPayload<T> | null, null>

    /**
     * Find the first Usuario_perfil that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_perfilFindFirstArgs} args - Arguments to find a Usuario_perfil
     * @example
     * // Get one Usuario_perfil
     * const usuario_perfil = await prisma.usuario_perfil.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usuario_perfilFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usuario_perfilFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'usuario_perfil'> extends True ? Prisma__usuario_perfilClient<usuario_perfilGetPayload<T>> : Prisma__usuario_perfilClient<usuario_perfilGetPayload<T> | null, null>

    /**
     * Find zero or more Usuario_perfils that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_perfilFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuario_perfils
     * const usuario_perfils = await prisma.usuario_perfil.findMany()
     * 
     * // Get first 10 Usuario_perfils
     * const usuario_perfils = await prisma.usuario_perfil.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuario_perfilWithIdOnly = await prisma.usuario_perfil.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usuario_perfilFindManyArgs>(
      args?: SelectSubset<T, usuario_perfilFindManyArgs>
    ): PrismaPromise<Array<usuario_perfilGetPayload<T>>>

    /**
     * Create a Usuario_perfil.
     * @param {usuario_perfilCreateArgs} args - Arguments to create a Usuario_perfil.
     * @example
     * // Create one Usuario_perfil
     * const Usuario_perfil = await prisma.usuario_perfil.create({
     *   data: {
     *     // ... data to create a Usuario_perfil
     *   }
     * })
     * 
    **/
    create<T extends usuario_perfilCreateArgs>(
      args: SelectSubset<T, usuario_perfilCreateArgs>
    ): Prisma__usuario_perfilClient<usuario_perfilGetPayload<T>>

    /**
     * Create many Usuario_perfils.
     *     @param {usuario_perfilCreateManyArgs} args - Arguments to create many Usuario_perfils.
     *     @example
     *     // Create many Usuario_perfils
     *     const usuario_perfil = await prisma.usuario_perfil.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usuario_perfilCreateManyArgs>(
      args?: SelectSubset<T, usuario_perfilCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario_perfil.
     * @param {usuario_perfilDeleteArgs} args - Arguments to delete one Usuario_perfil.
     * @example
     * // Delete one Usuario_perfil
     * const Usuario_perfil = await prisma.usuario_perfil.delete({
     *   where: {
     *     // ... filter to delete one Usuario_perfil
     *   }
     * })
     * 
    **/
    delete<T extends usuario_perfilDeleteArgs>(
      args: SelectSubset<T, usuario_perfilDeleteArgs>
    ): Prisma__usuario_perfilClient<usuario_perfilGetPayload<T>>

    /**
     * Update one Usuario_perfil.
     * @param {usuario_perfilUpdateArgs} args - Arguments to update one Usuario_perfil.
     * @example
     * // Update one Usuario_perfil
     * const usuario_perfil = await prisma.usuario_perfil.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usuario_perfilUpdateArgs>(
      args: SelectSubset<T, usuario_perfilUpdateArgs>
    ): Prisma__usuario_perfilClient<usuario_perfilGetPayload<T>>

    /**
     * Delete zero or more Usuario_perfils.
     * @param {usuario_perfilDeleteManyArgs} args - Arguments to filter Usuario_perfils to delete.
     * @example
     * // Delete a few Usuario_perfils
     * const { count } = await prisma.usuario_perfil.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usuario_perfilDeleteManyArgs>(
      args?: SelectSubset<T, usuario_perfilDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuario_perfils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_perfilUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuario_perfils
     * const usuario_perfil = await prisma.usuario_perfil.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usuario_perfilUpdateManyArgs>(
      args: SelectSubset<T, usuario_perfilUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario_perfil.
     * @param {usuario_perfilUpsertArgs} args - Arguments to update or create a Usuario_perfil.
     * @example
     * // Update or create a Usuario_perfil
     * const usuario_perfil = await prisma.usuario_perfil.upsert({
     *   create: {
     *     // ... data to create a Usuario_perfil
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario_perfil we want to update
     *   }
     * })
    **/
    upsert<T extends usuario_perfilUpsertArgs>(
      args: SelectSubset<T, usuario_perfilUpsertArgs>
    ): Prisma__usuario_perfilClient<usuario_perfilGetPayload<T>>

    /**
     * Find one Usuario_perfil that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {usuario_perfilFindUniqueOrThrowArgs} args - Arguments to find a Usuario_perfil
     * @example
     * // Get one Usuario_perfil
     * const usuario_perfil = await prisma.usuario_perfil.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usuario_perfilFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usuario_perfilFindUniqueOrThrowArgs>
    ): Prisma__usuario_perfilClient<usuario_perfilGetPayload<T>>

    /**
     * Find the first Usuario_perfil that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_perfilFindFirstOrThrowArgs} args - Arguments to find a Usuario_perfil
     * @example
     * // Get one Usuario_perfil
     * const usuario_perfil = await prisma.usuario_perfil.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usuario_perfilFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usuario_perfilFindFirstOrThrowArgs>
    ): Prisma__usuario_perfilClient<usuario_perfilGetPayload<T>>

    /**
     * Count the number of Usuario_perfils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_perfilCountArgs} args - Arguments to filter Usuario_perfils to count.
     * @example
     * // Count the number of Usuario_perfils
     * const count = await prisma.usuario_perfil.count({
     *   where: {
     *     // ... the filter for the Usuario_perfils we want to count
     *   }
     * })
    **/
    count<T extends usuario_perfilCountArgs>(
      args?: Subset<T, usuario_perfilCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Usuario_perfilCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario_perfil.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Usuario_perfilAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Usuario_perfilAggregateArgs>(args: Subset<T, Usuario_perfilAggregateArgs>): PrismaPromise<GetUsuario_perfilAggregateType<T>>

    /**
     * Group by Usuario_perfil.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Usuario_perfilGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Usuario_perfilGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Usuario_perfilGroupByArgs['orderBy'] }
        : { orderBy?: Usuario_perfilGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Usuario_perfilGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuario_perfilGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario_perfil.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usuario_perfilClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    usuario_perfil_tipo<T extends usuario_perfil_tipoArgs= {}>(args?: Subset<T, usuario_perfil_tipoArgs>): Prisma__usuario_perfil_tipoClient<usuario_perfil_tipoGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * usuario_perfil base type for findUnique actions
   */
  export type usuario_perfilFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the usuario_perfil
     * 
    **/
    select?: usuario_perfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfilInclude | null
    /**
     * Filter, which usuario_perfil to fetch.
     * 
    **/
    where: usuario_perfilWhereUniqueInput
  }

  /**
   * usuario_perfil: findUnique
   */
  export interface usuario_perfilFindUniqueArgs extends usuario_perfilFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario_perfil base type for findFirst actions
   */
  export type usuario_perfilFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the usuario_perfil
     * 
    **/
    select?: usuario_perfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfilInclude | null
    /**
     * Filter, which usuario_perfil to fetch.
     * 
    **/
    where?: usuario_perfilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_perfils to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario_perfilOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuario_perfils.
     * 
    **/
    cursor?: usuario_perfilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_perfils from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_perfils.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuario_perfils.
     * 
    **/
    distinct?: Enumerable<Usuario_perfilScalarFieldEnum>
  }

  /**
   * usuario_perfil: findFirst
   */
  export interface usuario_perfilFindFirstArgs extends usuario_perfilFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * usuario_perfil findMany
   */
  export type usuario_perfilFindManyArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil
     * 
    **/
    select?: usuario_perfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfilInclude | null
    /**
     * Filter, which usuario_perfils to fetch.
     * 
    **/
    where?: usuario_perfilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_perfils to fetch.
     * 
    **/
    orderBy?: Enumerable<usuario_perfilOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuario_perfils.
     * 
    **/
    cursor?: usuario_perfilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_perfils from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_perfils.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Usuario_perfilScalarFieldEnum>
  }


  /**
   * usuario_perfil create
   */
  export type usuario_perfilCreateArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil
     * 
    **/
    select?: usuario_perfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfilInclude | null
    /**
     * The data needed to create a usuario_perfil.
     * 
    **/
    data: XOR<usuario_perfilCreateInput, usuario_perfilUncheckedCreateInput>
  }


  /**
   * usuario_perfil createMany
   */
  export type usuario_perfilCreateManyArgs = {
    /**
     * The data used to create many usuario_perfils.
     * 
    **/
    data: Enumerable<usuario_perfilCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * usuario_perfil update
   */
  export type usuario_perfilUpdateArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil
     * 
    **/
    select?: usuario_perfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfilInclude | null
    /**
     * The data needed to update a usuario_perfil.
     * 
    **/
    data: XOR<usuario_perfilUpdateInput, usuario_perfilUncheckedUpdateInput>
    /**
     * Choose, which usuario_perfil to update.
     * 
    **/
    where: usuario_perfilWhereUniqueInput
  }


  /**
   * usuario_perfil updateMany
   */
  export type usuario_perfilUpdateManyArgs = {
    /**
     * The data used to update usuario_perfils.
     * 
    **/
    data: XOR<usuario_perfilUpdateManyMutationInput, usuario_perfilUncheckedUpdateManyInput>
    /**
     * Filter which usuario_perfils to update
     * 
    **/
    where?: usuario_perfilWhereInput
  }


  /**
   * usuario_perfil upsert
   */
  export type usuario_perfilUpsertArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil
     * 
    **/
    select?: usuario_perfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfilInclude | null
    /**
     * The filter to search for the usuario_perfil to update in case it exists.
     * 
    **/
    where: usuario_perfilWhereUniqueInput
    /**
     * In case the usuario_perfil found by the `where` argument doesn't exist, create a new usuario_perfil with this data.
     * 
    **/
    create: XOR<usuario_perfilCreateInput, usuario_perfilUncheckedCreateInput>
    /**
     * In case the usuario_perfil was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<usuario_perfilUpdateInput, usuario_perfilUncheckedUpdateInput>
  }


  /**
   * usuario_perfil delete
   */
  export type usuario_perfilDeleteArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil
     * 
    **/
    select?: usuario_perfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfilInclude | null
    /**
     * Filter which usuario_perfil to delete.
     * 
    **/
    where: usuario_perfilWhereUniqueInput
  }


  /**
   * usuario_perfil deleteMany
   */
  export type usuario_perfilDeleteManyArgs = {
    /**
     * Filter which usuario_perfils to delete
     * 
    **/
    where?: usuario_perfilWhereInput
  }


  /**
   * usuario_perfil: findUniqueOrThrow
   */
  export type usuario_perfilFindUniqueOrThrowArgs = usuario_perfilFindUniqueArgsBase
      

  /**
   * usuario_perfil: findFirstOrThrow
   */
  export type usuario_perfilFindFirstOrThrowArgs = usuario_perfilFindFirstArgsBase
      

  /**
   * usuario_perfil without action
   */
  export type usuario_perfilArgs = {
    /**
     * Select specific fields to fetch from the usuario_perfil
     * 
    **/
    select?: usuario_perfilSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usuario_perfilInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AuditoriaScalarFieldEnum: {
    action: 'action',
    usuario: 'usuario',
    data: 'data',
    modulo: 'modulo',
    id: 'id'
  };

  export type AuditoriaScalarFieldEnum = (typeof AuditoriaScalarFieldEnum)[keyof typeof AuditoriaScalarFieldEnum]


  export const BorderoScalarFieldEnum: {
    id: 'id',
    carteira_id: 'carteira_id'
  };

  export type BorderoScalarFieldEnum = (typeof BorderoScalarFieldEnum)[keyof typeof BorderoScalarFieldEnum]


  export const CarteiraScalarFieldEnum: {
    id: 'id',
    fiduc_fundo_id: 'fiduc_fundo_id'
  };

  export type CarteiraScalarFieldEnum = (typeof CarteiraScalarFieldEnum)[keyof typeof CarteiraScalarFieldEnum]


  export const Carteira_n_cedentesScalarFieldEnum: {
    id: 'id',
    carteira_id: 'carteira_id',
    cedente_id: 'cedente_id'
  };

  export type Carteira_n_cedentesScalarFieldEnum = (typeof Carteira_n_cedentesScalarFieldEnum)[keyof typeof Carteira_n_cedentesScalarFieldEnum]


  export const CedenteScalarFieldEnum: {
    id: 'id',
    pessoa_id: 'pessoa_id',
    razao_social: 'razao_social',
    nome_fantasia: 'nome_fantasia',
    abertura: 'abertura',
    cnpj: 'cnpj',
    endereco: 'endereco',
    numero: 'numero',
    cep: 'cep',
    bairro: 'bairro',
    cidade: 'cidade',
    uf: 'uf',
    telefone: 'telefone'
  };

  export type CedenteScalarFieldEnum = (typeof CedenteScalarFieldEnum)[keyof typeof CedenteScalarFieldEnum]


  export const Cedente_analiseScalarFieldEnum: {
    id: 'id',
    status: 'status',
    cedente: 'cedente'
  };

  export type Cedente_analiseScalarFieldEnum = (typeof Cedente_analiseScalarFieldEnum)[keyof typeof Cedente_analiseScalarFieldEnum]


  export const Cedente_n_sacadosScalarFieldEnum: {
    id: 'id',
    cedente: 'cedente',
    sacado: 'sacado'
  };

  export type Cedente_n_sacadosScalarFieldEnum = (typeof Cedente_n_sacadosScalarFieldEnum)[keyof typeof Cedente_n_sacadosScalarFieldEnum]


  export const ChecagemScalarFieldEnum: {
    id: 'id',
    nf: 'nf',
    status: 'status',
    usuario: 'usuario',
    titulos: 'titulos'
  };

  export type ChecagemScalarFieldEnum = (typeof ChecagemScalarFieldEnum)[keyof typeof ChecagemScalarFieldEnum]


  export const Fidic_fundoScalarFieldEnum: {
    id: 'id',
    pessoa_id: 'pessoa_id',
    razao_social: 'razao_social',
    nome_fantasia: 'nome_fantasia',
    abertura: 'abertura',
    cnpj: 'cnpj'
  };

  export type Fidic_fundoScalarFieldEnum = (typeof Fidic_fundoScalarFieldEnum)[keyof typeof Fidic_fundoScalarFieldEnum]


  export const Fidic_fundo_x_usuarioScalarFieldEnum: {
    id: 'id',
    usuario: 'usuario',
    fidic: 'fidic'
  };

  export type Fidic_fundo_x_usuarioScalarFieldEnum = (typeof Fidic_fundo_x_usuarioScalarFieldEnum)[keyof typeof Fidic_fundo_x_usuarioScalarFieldEnum]


  export const OrganogramaScalarFieldEnum: {
    id: 'id',
    organograma_id: 'organograma_id'
  };

  export type OrganogramaScalarFieldEnum = (typeof OrganogramaScalarFieldEnum)[keyof typeof OrganogramaScalarFieldEnum]


  export const Organograma_tipoScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type Organograma_tipoScalarFieldEnum = (typeof Organograma_tipoScalarFieldEnum)[keyof typeof Organograma_tipoScalarFieldEnum]


  export const Organograma_x_regiao_atuacaoScalarFieldEnum: {
    id: 'id',
    organograma_id: 'organograma_id',
    regiao_atuacao_id: 'regiao_atuacao_id'
  };

  export type Organograma_x_regiao_atuacaoScalarFieldEnum = (typeof Organograma_x_regiao_atuacaoScalarFieldEnum)[keyof typeof Organograma_x_regiao_atuacaoScalarFieldEnum]


  export const Organograma_x_usuarioScalarFieldEnum: {
    id: 'id',
    organograma_id: 'organograma_id',
    usuario_id: 'usuario_id'
  };

  export type Organograma_x_usuarioScalarFieldEnum = (typeof Organograma_x_usuarioScalarFieldEnum)[keyof typeof Organograma_x_usuarioScalarFieldEnum]


  export const PessoaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    sobrenome: 'sobrenome',
    sexo: 'sexo',
    nascimento: 'nascimento',
    cpf: 'cpf',
    rg: 'rg'
  };

  export type PessoaScalarFieldEnum = (typeof PessoaScalarFieldEnum)[keyof typeof PessoaScalarFieldEnum]


  export const PlataformaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    plataforma_papel_tipo_id: 'plataforma_papel_tipo_id'
  };

  export type PlataformaScalarFieldEnum = (typeof PlataformaScalarFieldEnum)[keyof typeof PlataformaScalarFieldEnum]


  export const Plataforma_papel_tipoScalarFieldEnum: {
    id: 'id'
  };

  export type Plataforma_papel_tipoScalarFieldEnum = (typeof Plataforma_papel_tipoScalarFieldEnum)[keyof typeof Plataforma_papel_tipoScalarFieldEnum]


  export const Plataforma_x_regiao_atuacaoScalarFieldEnum: {
    id: 'id',
    plataforma_id: 'plataforma_id',
    regiao_atuacao_id: 'regiao_atuacao_id'
  };

  export type Plataforma_x_regiao_atuacaoScalarFieldEnum = (typeof Plataforma_x_regiao_atuacaoScalarFieldEnum)[keyof typeof Plataforma_x_regiao_atuacaoScalarFieldEnum]


  export const Plataforma_x_usuarioScalarFieldEnum: {
    id: 'id',
    plataforma_id: 'plataforma_id',
    usuario_id: 'usuario_id'
  };

  export type Plataforma_x_usuarioScalarFieldEnum = (typeof Plataforma_x_usuarioScalarFieldEnum)[keyof typeof Plataforma_x_usuarioScalarFieldEnum]


  export const Regiao_atuacaoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    regiao_atuacao_tipo_id: 'regiao_atuacao_tipo_id'
  };

  export type Regiao_atuacaoScalarFieldEnum = (typeof Regiao_atuacaoScalarFieldEnum)[keyof typeof Regiao_atuacaoScalarFieldEnum]


  export const Regiao_atuacao_tipoScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type Regiao_atuacao_tipoScalarFieldEnum = (typeof Regiao_atuacao_tipoScalarFieldEnum)[keyof typeof Regiao_atuacao_tipoScalarFieldEnum]


  export const SacadoScalarFieldEnum: {
    id: 'id',
    pessoa_id: 'pessoa_id',
    razao_social: 'razao_social',
    nome_fantasia: 'nome_fantasia',
    abertura: 'abertura',
    cnpj: 'cnpj'
  };

  export type SacadoScalarFieldEnum = (typeof SacadoScalarFieldEnum)[keyof typeof SacadoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TituloScalarFieldEnum: {
    id: 'id',
    titulo_tipo_id: 'titulo_tipo_id',
    bordero_id: 'bordero_id',
    nf: 'nf',
    valor: 'valor',
    vencimento: 'vencimento',
    numero: 'numero',
    emissao: 'emissao',
    parcela: 'parcela'
  };

  export type TituloScalarFieldEnum = (typeof TituloScalarFieldEnum)[keyof typeof TituloScalarFieldEnum]


  export const Titulo_itensScalarFieldEnum: {
    id: 'id',
    titulo_id: 'titulo_id'
  };

  export type Titulo_itensScalarFieldEnum = (typeof Titulo_itensScalarFieldEnum)[keyof typeof Titulo_itensScalarFieldEnum]


  export const Titulo_tipoScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type Titulo_tipoScalarFieldEnum = (typeof Titulo_tipoScalarFieldEnum)[keyof typeof Titulo_tipoScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    email: 'email',
    senha: 'senha',
    pessoa_id: 'pessoa_id',
    status: 'status',
    primeiro_acesso: 'primeiro_acesso',
    confirmou_cadastro: 'confirmou_cadastro',
    codigo_confirma_cadastro: 'codigo_confirma_cadastro',
    codigo_reset_senha: 'codigo_reset_senha',
    codigo_data_expiracao: 'codigo_data_expiracao',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const Usuario_perfilScalarFieldEnum: {
    id: 'id',
    senha: 'senha',
    usuario_id: 'usuario_id',
    usuario_perfil_tipo_id: 'usuario_perfil_tipo_id'
  };

  export type Usuario_perfilScalarFieldEnum = (typeof Usuario_perfilScalarFieldEnum)[keyof typeof Usuario_perfilScalarFieldEnum]


  export const Usuario_perfil_tipoScalarFieldEnum: {
    id: 'id',
    nome: 'nome'
  };

  export type Usuario_perfil_tipoScalarFieldEnum = (typeof Usuario_perfil_tipoScalarFieldEnum)[keyof typeof Usuario_perfil_tipoScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type auditoriaWhereInput = {
    AND?: Enumerable<auditoriaWhereInput>
    OR?: Enumerable<auditoriaWhereInput>
    NOT?: Enumerable<auditoriaWhereInput>
    action?: StringNullableFilter | string | null
    usuario?: IntNullableFilter | number | null
    data?: DateTimeNullableFilter | Date | string | null
    modulo?: StringNullableFilter | string | null
    id?: IntFilter | number
  }

  export type auditoriaOrderByWithRelationInput = {
    action?: SortOrder
    usuario?: SortOrder
    data?: SortOrder
    modulo?: SortOrder
    id?: SortOrder
  }

  export type auditoriaWhereUniqueInput = {
    id?: number
  }

  export type auditoriaOrderByWithAggregationInput = {
    action?: SortOrder
    usuario?: SortOrder
    data?: SortOrder
    modulo?: SortOrder
    id?: SortOrder
    _count?: auditoriaCountOrderByAggregateInput
    _avg?: auditoriaAvgOrderByAggregateInput
    _max?: auditoriaMaxOrderByAggregateInput
    _min?: auditoriaMinOrderByAggregateInput
    _sum?: auditoriaSumOrderByAggregateInput
  }

  export type auditoriaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<auditoriaScalarWhereWithAggregatesInput>
    OR?: Enumerable<auditoriaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<auditoriaScalarWhereWithAggregatesInput>
    action?: StringNullableWithAggregatesFilter | string | null
    usuario?: IntNullableWithAggregatesFilter | number | null
    data?: DateTimeNullableWithAggregatesFilter | Date | string | null
    modulo?: StringNullableWithAggregatesFilter | string | null
    id?: IntWithAggregatesFilter | number
  }

  export type borderoWhereInput = {
    AND?: Enumerable<borderoWhereInput>
    OR?: Enumerable<borderoWhereInput>
    NOT?: Enumerable<borderoWhereInput>
    id?: IntFilter | number
    carteira_id?: IntFilter | number
    carteira?: XOR<CarteiraRelationFilter, carteiraWhereInput>
    titulo?: TituloListRelationFilter
  }

  export type borderoOrderByWithRelationInput = {
    id?: SortOrder
    carteira_id?: SortOrder
    carteira?: carteiraOrderByWithRelationInput
    titulo?: tituloOrderByRelationAggregateInput
  }

  export type borderoWhereUniqueInput = {
    id?: number
  }

  export type borderoOrderByWithAggregationInput = {
    id?: SortOrder
    carteira_id?: SortOrder
    _count?: borderoCountOrderByAggregateInput
    _avg?: borderoAvgOrderByAggregateInput
    _max?: borderoMaxOrderByAggregateInput
    _min?: borderoMinOrderByAggregateInput
    _sum?: borderoSumOrderByAggregateInput
  }

  export type borderoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<borderoScalarWhereWithAggregatesInput>
    OR?: Enumerable<borderoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<borderoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    carteira_id?: IntWithAggregatesFilter | number
  }

  export type carteiraWhereInput = {
    AND?: Enumerable<carteiraWhereInput>
    OR?: Enumerable<carteiraWhereInput>
    NOT?: Enumerable<carteiraWhereInput>
    id?: IntFilter | number
    fiduc_fundo_id?: IntFilter | number
    fidic_fundo?: XOR<Fidic_fundoRelationFilter, fidic_fundoWhereInput>
    bordero?: BorderoListRelationFilter
    carteira_n_cedentes?: Carteira_n_cedentesListRelationFilter
  }

  export type carteiraOrderByWithRelationInput = {
    id?: SortOrder
    fiduc_fundo_id?: SortOrder
    fidic_fundo?: fidic_fundoOrderByWithRelationInput
    bordero?: borderoOrderByRelationAggregateInput
    carteira_n_cedentes?: carteira_n_cedentesOrderByRelationAggregateInput
  }

  export type carteiraWhereUniqueInput = {
    id?: number
  }

  export type carteiraOrderByWithAggregationInput = {
    id?: SortOrder
    fiduc_fundo_id?: SortOrder
    _count?: carteiraCountOrderByAggregateInput
    _avg?: carteiraAvgOrderByAggregateInput
    _max?: carteiraMaxOrderByAggregateInput
    _min?: carteiraMinOrderByAggregateInput
    _sum?: carteiraSumOrderByAggregateInput
  }

  export type carteiraScalarWhereWithAggregatesInput = {
    AND?: Enumerable<carteiraScalarWhereWithAggregatesInput>
    OR?: Enumerable<carteiraScalarWhereWithAggregatesInput>
    NOT?: Enumerable<carteiraScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    fiduc_fundo_id?: IntWithAggregatesFilter | number
  }

  export type cedenteWhereInput = {
    AND?: Enumerable<cedenteWhereInput>
    OR?: Enumerable<cedenteWhereInput>
    NOT?: Enumerable<cedenteWhereInput>
    id?: IntFilter | number
    pessoa_id?: IntFilter | number
    razao_social?: StringFilter | string
    nome_fantasia?: StringNullableFilter | string | null
    abertura?: DateTimeNullableFilter | Date | string | null
    cnpj?: StringNullableFilter | string | null
    endereco?: StringNullableFilter | string | null
    numero?: StringNullableFilter | string | null
    cep?: StringNullableFilter | string | null
    bairro?: StringNullableFilter | string | null
    cidade?: StringNullableFilter | string | null
    uf?: StringNullableFilter | string | null
    telefone?: StringNullableFilter | string | null
    carteira_n_cedentes?: Carteira_n_cedentesListRelationFilter
    cedente_analise?: Cedente_analiseListRelationFilter
    cedente_n_sacados?: Cedente_n_sacadosListRelationFilter
  }

  export type cedenteOrderByWithRelationInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrder
    numero?: SortOrder
    cep?: SortOrder
    bairro?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    telefone?: SortOrder
    carteira_n_cedentes?: carteira_n_cedentesOrderByRelationAggregateInput
    cedente_analise?: cedente_analiseOrderByRelationAggregateInput
    cedente_n_sacados?: cedente_n_sacadosOrderByRelationAggregateInput
  }

  export type cedenteWhereUniqueInput = {
    id?: number
  }

  export type cedenteOrderByWithAggregationInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrder
    numero?: SortOrder
    cep?: SortOrder
    bairro?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    telefone?: SortOrder
    _count?: cedenteCountOrderByAggregateInput
    _avg?: cedenteAvgOrderByAggregateInput
    _max?: cedenteMaxOrderByAggregateInput
    _min?: cedenteMinOrderByAggregateInput
    _sum?: cedenteSumOrderByAggregateInput
  }

  export type cedenteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<cedenteScalarWhereWithAggregatesInput>
    OR?: Enumerable<cedenteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<cedenteScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    pessoa_id?: IntWithAggregatesFilter | number
    razao_social?: StringWithAggregatesFilter | string
    nome_fantasia?: StringNullableWithAggregatesFilter | string | null
    abertura?: DateTimeNullableWithAggregatesFilter | Date | string | null
    cnpj?: StringNullableWithAggregatesFilter | string | null
    endereco?: StringNullableWithAggregatesFilter | string | null
    numero?: StringNullableWithAggregatesFilter | string | null
    cep?: StringNullableWithAggregatesFilter | string | null
    bairro?: StringNullableWithAggregatesFilter | string | null
    cidade?: StringNullableWithAggregatesFilter | string | null
    uf?: StringNullableWithAggregatesFilter | string | null
    telefone?: StringNullableWithAggregatesFilter | string | null
  }

  export type cedente_analiseWhereInput = {
    AND?: Enumerable<cedente_analiseWhereInput>
    OR?: Enumerable<cedente_analiseWhereInput>
    NOT?: Enumerable<cedente_analiseWhereInput>
    id?: IntFilter | number
    status?: StringNullableFilter | string | null
    cedente?: IntNullableFilter | number | null
    cedente_cedenteTocedente_analise?: XOR<CedenteRelationFilter, cedenteWhereInput> | null
  }

  export type cedente_analiseOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    cedente?: SortOrder
    cedente_cedenteTocedente_analise?: cedenteOrderByWithRelationInput
  }

  export type cedente_analiseWhereUniqueInput = {
    id?: number
  }

  export type cedente_analiseOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    cedente?: SortOrder
    _count?: cedente_analiseCountOrderByAggregateInput
    _avg?: cedente_analiseAvgOrderByAggregateInput
    _max?: cedente_analiseMaxOrderByAggregateInput
    _min?: cedente_analiseMinOrderByAggregateInput
    _sum?: cedente_analiseSumOrderByAggregateInput
  }

  export type cedente_analiseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<cedente_analiseScalarWhereWithAggregatesInput>
    OR?: Enumerable<cedente_analiseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<cedente_analiseScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    status?: StringNullableWithAggregatesFilter | string | null
    cedente?: IntNullableWithAggregatesFilter | number | null
  }

  export type cedente_n_sacadosWhereInput = {
    AND?: Enumerable<cedente_n_sacadosWhereInput>
    OR?: Enumerable<cedente_n_sacadosWhereInput>
    NOT?: Enumerable<cedente_n_sacadosWhereInput>
    id?: IntFilter | number
    cedente?: IntNullableFilter | number | null
    sacado?: IntNullableFilter | number | null
    cedente_cedenteTocedente_n_sacados?: XOR<CedenteRelationFilter, cedenteWhereInput> | null
    sacado_cedente_n_sacadosTosacado?: XOR<SacadoRelationFilter, sacadoWhereInput> | null
  }

  export type cedente_n_sacadosOrderByWithRelationInput = {
    id?: SortOrder
    cedente?: SortOrder
    sacado?: SortOrder
    cedente_cedenteTocedente_n_sacados?: cedenteOrderByWithRelationInput
    sacado_cedente_n_sacadosTosacado?: sacadoOrderByWithRelationInput
  }

  export type cedente_n_sacadosWhereUniqueInput = {
    id?: number
  }

  export type cedente_n_sacadosOrderByWithAggregationInput = {
    id?: SortOrder
    cedente?: SortOrder
    sacado?: SortOrder
    _count?: cedente_n_sacadosCountOrderByAggregateInput
    _avg?: cedente_n_sacadosAvgOrderByAggregateInput
    _max?: cedente_n_sacadosMaxOrderByAggregateInput
    _min?: cedente_n_sacadosMinOrderByAggregateInput
    _sum?: cedente_n_sacadosSumOrderByAggregateInput
  }

  export type cedente_n_sacadosScalarWhereWithAggregatesInput = {
    AND?: Enumerable<cedente_n_sacadosScalarWhereWithAggregatesInput>
    OR?: Enumerable<cedente_n_sacadosScalarWhereWithAggregatesInput>
    NOT?: Enumerable<cedente_n_sacadosScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    cedente?: IntNullableWithAggregatesFilter | number | null
    sacado?: IntNullableWithAggregatesFilter | number | null
  }

  export type checagemWhereInput = {
    AND?: Enumerable<checagemWhereInput>
    OR?: Enumerable<checagemWhereInput>
    NOT?: Enumerable<checagemWhereInput>
    id?: IntFilter | number
    nf?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    usuario?: IntNullableFilter | number | null
    titulos?: StringNullableFilter | string | null
  }

  export type checagemOrderByWithRelationInput = {
    id?: SortOrder
    nf?: SortOrder
    status?: SortOrder
    usuario?: SortOrder
    titulos?: SortOrder
  }

  export type checagemWhereUniqueInput = {
    id?: number
  }

  export type checagemOrderByWithAggregationInput = {
    id?: SortOrder
    nf?: SortOrder
    status?: SortOrder
    usuario?: SortOrder
    titulos?: SortOrder
    _count?: checagemCountOrderByAggregateInput
    _avg?: checagemAvgOrderByAggregateInput
    _max?: checagemMaxOrderByAggregateInput
    _min?: checagemMinOrderByAggregateInput
    _sum?: checagemSumOrderByAggregateInput
  }

  export type checagemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<checagemScalarWhereWithAggregatesInput>
    OR?: Enumerable<checagemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<checagemScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nf?: StringNullableWithAggregatesFilter | string | null
    status?: StringNullableWithAggregatesFilter | string | null
    usuario?: IntNullableWithAggregatesFilter | number | null
    titulos?: StringNullableWithAggregatesFilter | string | null
  }

  export type fidic_fundoWhereInput = {
    AND?: Enumerable<fidic_fundoWhereInput>
    OR?: Enumerable<fidic_fundoWhereInput>
    NOT?: Enumerable<fidic_fundoWhereInput>
    id?: IntFilter | number
    pessoa_id?: IntFilter | number
    razao_social?: StringFilter | string
    nome_fantasia?: StringNullableFilter | string | null
    abertura?: DateTimeNullableFilter | Date | string | null
    cnpj?: StringNullableFilter | string | null
    carteira?: CarteiraListRelationFilter
    fidic_fundo_x_usuario?: Fidic_fundo_x_usuarioListRelationFilter
  }

  export type fidic_fundoOrderByWithRelationInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    carteira?: carteiraOrderByRelationAggregateInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioOrderByRelationAggregateInput
  }

  export type fidic_fundoWhereUniqueInput = {
    id?: number
  }

  export type fidic_fundoOrderByWithAggregationInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    _count?: fidic_fundoCountOrderByAggregateInput
    _avg?: fidic_fundoAvgOrderByAggregateInput
    _max?: fidic_fundoMaxOrderByAggregateInput
    _min?: fidic_fundoMinOrderByAggregateInput
    _sum?: fidic_fundoSumOrderByAggregateInput
  }

  export type fidic_fundoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<fidic_fundoScalarWhereWithAggregatesInput>
    OR?: Enumerable<fidic_fundoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<fidic_fundoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    pessoa_id?: IntWithAggregatesFilter | number
    razao_social?: StringWithAggregatesFilter | string
    nome_fantasia?: StringNullableWithAggregatesFilter | string | null
    abertura?: DateTimeNullableWithAggregatesFilter | Date | string | null
    cnpj?: StringNullableWithAggregatesFilter | string | null
  }

  export type fidic_fundo_x_usuarioWhereInput = {
    AND?: Enumerable<fidic_fundo_x_usuarioWhereInput>
    OR?: Enumerable<fidic_fundo_x_usuarioWhereInput>
    NOT?: Enumerable<fidic_fundo_x_usuarioWhereInput>
    id?: IntFilter | number
    usuario?: IntNullableFilter | number | null
    fidic?: IntFilter | number
    fidic_fundo?: XOR<Fidic_fundoRelationFilter, fidic_fundoWhereInput>
  }

  export type fidic_fundo_x_usuarioOrderByWithRelationInput = {
    id?: SortOrder
    usuario?: SortOrder
    fidic?: SortOrder
    fidic_fundo?: fidic_fundoOrderByWithRelationInput
  }

  export type fidic_fundo_x_usuarioWhereUniqueInput = {
    id?: number
  }

  export type fidic_fundo_x_usuarioOrderByWithAggregationInput = {
    id?: SortOrder
    usuario?: SortOrder
    fidic?: SortOrder
    _count?: fidic_fundo_x_usuarioCountOrderByAggregateInput
    _avg?: fidic_fundo_x_usuarioAvgOrderByAggregateInput
    _max?: fidic_fundo_x_usuarioMaxOrderByAggregateInput
    _min?: fidic_fundo_x_usuarioMinOrderByAggregateInput
    _sum?: fidic_fundo_x_usuarioSumOrderByAggregateInput
  }

  export type fidic_fundo_x_usuarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<fidic_fundo_x_usuarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<fidic_fundo_x_usuarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<fidic_fundo_x_usuarioScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    usuario?: IntNullableWithAggregatesFilter | number | null
    fidic?: IntWithAggregatesFilter | number
  }

  export type organogramaWhereInput = {
    AND?: Enumerable<organogramaWhereInput>
    OR?: Enumerable<organogramaWhereInput>
    NOT?: Enumerable<organogramaWhereInput>
    id?: IntFilter | number
    organograma_id?: IntFilter | number
    organograma_tipo?: XOR<Organograma_tipoRelationFilter, organograma_tipoWhereInput>
    organograma_x_regiao_atuacao?: Organograma_x_regiao_atuacaoListRelationFilter
    organograma_x_usuario?: Organograma_x_usuarioListRelationFilter
  }

  export type organogramaOrderByWithRelationInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    organograma_tipo?: organograma_tipoOrderByWithRelationInput
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoOrderByRelationAggregateInput
    organograma_x_usuario?: organograma_x_usuarioOrderByRelationAggregateInput
  }

  export type organogramaWhereUniqueInput = {
    id?: number
  }

  export type organogramaOrderByWithAggregationInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    _count?: organogramaCountOrderByAggregateInput
    _avg?: organogramaAvgOrderByAggregateInput
    _max?: organogramaMaxOrderByAggregateInput
    _min?: organogramaMinOrderByAggregateInput
    _sum?: organogramaSumOrderByAggregateInput
  }

  export type organogramaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<organogramaScalarWhereWithAggregatesInput>
    OR?: Enumerable<organogramaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<organogramaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    organograma_id?: IntWithAggregatesFilter | number
  }

  export type organograma_tipoWhereInput = {
    AND?: Enumerable<organograma_tipoWhereInput>
    OR?: Enumerable<organograma_tipoWhereInput>
    NOT?: Enumerable<organograma_tipoWhereInput>
    id?: IntFilter | number
    nome?: StringFilter | string
    organograma?: OrganogramaListRelationFilter
  }

  export type organograma_tipoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    organograma?: organogramaOrderByRelationAggregateInput
  }

  export type organograma_tipoWhereUniqueInput = {
    id?: number
  }

  export type organograma_tipoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    _count?: organograma_tipoCountOrderByAggregateInput
    _avg?: organograma_tipoAvgOrderByAggregateInput
    _max?: organograma_tipoMaxOrderByAggregateInput
    _min?: organograma_tipoMinOrderByAggregateInput
    _sum?: organograma_tipoSumOrderByAggregateInput
  }

  export type organograma_tipoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<organograma_tipoScalarWhereWithAggregatesInput>
    OR?: Enumerable<organograma_tipoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<organograma_tipoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
  }

  export type organograma_x_regiao_atuacaoWhereInput = {
    AND?: Enumerable<organograma_x_regiao_atuacaoWhereInput>
    OR?: Enumerable<organograma_x_regiao_atuacaoWhereInput>
    NOT?: Enumerable<organograma_x_regiao_atuacaoWhereInput>
    id?: IntFilter | number
    organograma_id?: IntFilter | number
    regiao_atuacao_id?: IntFilter | number
    organograma?: XOR<OrganogramaRelationFilter, organogramaWhereInput>
    regiao_atuacao?: XOR<Regiao_atuacaoRelationFilter, regiao_atuacaoWhereInput>
  }

  export type organograma_x_regiao_atuacaoOrderByWithRelationInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_atuacao_id?: SortOrder
    organograma?: organogramaOrderByWithRelationInput
    regiao_atuacao?: regiao_atuacaoOrderByWithRelationInput
  }

  export type organograma_x_regiao_atuacaoWhereUniqueInput = {
    id?: number
  }

  export type organograma_x_regiao_atuacaoOrderByWithAggregationInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_atuacao_id?: SortOrder
    _count?: organograma_x_regiao_atuacaoCountOrderByAggregateInput
    _avg?: organograma_x_regiao_atuacaoAvgOrderByAggregateInput
    _max?: organograma_x_regiao_atuacaoMaxOrderByAggregateInput
    _min?: organograma_x_regiao_atuacaoMinOrderByAggregateInput
    _sum?: organograma_x_regiao_atuacaoSumOrderByAggregateInput
  }

  export type organograma_x_regiao_atuacaoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<organograma_x_regiao_atuacaoScalarWhereWithAggregatesInput>
    OR?: Enumerable<organograma_x_regiao_atuacaoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<organograma_x_regiao_atuacaoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    organograma_id?: IntWithAggregatesFilter | number
    regiao_atuacao_id?: IntWithAggregatesFilter | number
  }

  export type pessoaWhereInput = {
    AND?: Enumerable<pessoaWhereInput>
    OR?: Enumerable<pessoaWhereInput>
    NOT?: Enumerable<pessoaWhereInput>
    id?: IntFilter | number
    nome?: StringFilter | string
    sobrenome?: StringFilter | string
    sexo?: StringNullableFilter | string | null
    nascimento?: DateTimeNullableFilter | Date | string | null
    cpf?: StringNullableFilter | string | null
    rg?: StringNullableFilter | string | null
    usuario?: UsuarioListRelationFilter
  }

  export type pessoaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    sexo?: SortOrder
    nascimento?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
    usuario?: usuarioOrderByRelationAggregateInput
  }

  export type pessoaWhereUniqueInput = {
    id?: number
  }

  export type pessoaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    sexo?: SortOrder
    nascimento?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
    _count?: pessoaCountOrderByAggregateInput
    _avg?: pessoaAvgOrderByAggregateInput
    _max?: pessoaMaxOrderByAggregateInput
    _min?: pessoaMinOrderByAggregateInput
    _sum?: pessoaSumOrderByAggregateInput
  }

  export type pessoaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<pessoaScalarWhereWithAggregatesInput>
    OR?: Enumerable<pessoaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<pessoaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
    sobrenome?: StringWithAggregatesFilter | string
    sexo?: StringNullableWithAggregatesFilter | string | null
    nascimento?: DateTimeNullableWithAggregatesFilter | Date | string | null
    cpf?: StringNullableWithAggregatesFilter | string | null
    rg?: StringNullableWithAggregatesFilter | string | null
  }

  export type plataformaWhereInput = {
    AND?: Enumerable<plataformaWhereInput>
    OR?: Enumerable<plataformaWhereInput>
    NOT?: Enumerable<plataformaWhereInput>
    id?: IntFilter | number
    nome?: StringNullableFilter | string | null
    plataforma_papel_tipo_id?: IntFilter | number
    plataforma_papel_tipo?: XOR<Plataforma_papel_tipoRelationFilter, plataforma_papel_tipoWhereInput>
    plataforma_x_regiao_atuacao?: Plataforma_x_regiao_atuacaoListRelationFilter
    plataforma_x_usuario?: Plataforma_x_usuarioListRelationFilter
  }

  export type plataformaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    plataforma_papel_tipo_id?: SortOrder
    plataforma_papel_tipo?: plataforma_papel_tipoOrderByWithRelationInput
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoOrderByRelationAggregateInput
    plataforma_x_usuario?: plataforma_x_usuarioOrderByRelationAggregateInput
  }

  export type plataformaWhereUniqueInput = {
    id?: number
  }

  export type plataformaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    plataforma_papel_tipo_id?: SortOrder
    _count?: plataformaCountOrderByAggregateInput
    _avg?: plataformaAvgOrderByAggregateInput
    _max?: plataformaMaxOrderByAggregateInput
    _min?: plataformaMinOrderByAggregateInput
    _sum?: plataformaSumOrderByAggregateInput
  }

  export type plataformaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<plataformaScalarWhereWithAggregatesInput>
    OR?: Enumerable<plataformaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<plataformaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringNullableWithAggregatesFilter | string | null
    plataforma_papel_tipo_id?: IntWithAggregatesFilter | number
  }

  export type plataforma_papel_tipoWhereInput = {
    AND?: Enumerable<plataforma_papel_tipoWhereInput>
    OR?: Enumerable<plataforma_papel_tipoWhereInput>
    NOT?: Enumerable<plataforma_papel_tipoWhereInput>
    id?: IntFilter | number
    plataforma?: PlataformaListRelationFilter
  }

  export type plataforma_papel_tipoOrderByWithRelationInput = {
    id?: SortOrder
    plataforma?: plataformaOrderByRelationAggregateInput
  }

  export type plataforma_papel_tipoWhereUniqueInput = {
    id?: number
  }

  export type plataforma_papel_tipoOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: plataforma_papel_tipoCountOrderByAggregateInput
    _avg?: plataforma_papel_tipoAvgOrderByAggregateInput
    _max?: plataforma_papel_tipoMaxOrderByAggregateInput
    _min?: plataforma_papel_tipoMinOrderByAggregateInput
    _sum?: plataforma_papel_tipoSumOrderByAggregateInput
  }

  export type plataforma_papel_tipoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<plataforma_papel_tipoScalarWhereWithAggregatesInput>
    OR?: Enumerable<plataforma_papel_tipoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<plataforma_papel_tipoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type plataforma_x_regiao_atuacaoWhereInput = {
    AND?: Enumerable<plataforma_x_regiao_atuacaoWhereInput>
    OR?: Enumerable<plataforma_x_regiao_atuacaoWhereInput>
    NOT?: Enumerable<plataforma_x_regiao_atuacaoWhereInput>
    id?: IntFilter | number
    plataforma_id?: IntFilter | number
    regiao_atuacao_id?: IntFilter | number
    plataforma?: XOR<PlataformaRelationFilter, plataformaWhereInput>
    regiao_atuacao?: XOR<Regiao_atuacaoRelationFilter, regiao_atuacaoWhereInput>
  }

  export type plataforma_x_regiao_atuacaoOrderByWithRelationInput = {
    id?: SortOrder
    plataforma_id?: SortOrder
    regiao_atuacao_id?: SortOrder
    plataforma?: plataformaOrderByWithRelationInput
    regiao_atuacao?: regiao_atuacaoOrderByWithRelationInput
  }

  export type plataforma_x_regiao_atuacaoWhereUniqueInput = {
    id?: number
  }

  export type plataforma_x_regiao_atuacaoOrderByWithAggregationInput = {
    id?: SortOrder
    plataforma_id?: SortOrder
    regiao_atuacao_id?: SortOrder
    _count?: plataforma_x_regiao_atuacaoCountOrderByAggregateInput
    _avg?: plataforma_x_regiao_atuacaoAvgOrderByAggregateInput
    _max?: plataforma_x_regiao_atuacaoMaxOrderByAggregateInput
    _min?: plataforma_x_regiao_atuacaoMinOrderByAggregateInput
    _sum?: plataforma_x_regiao_atuacaoSumOrderByAggregateInput
  }

  export type plataforma_x_regiao_atuacaoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<plataforma_x_regiao_atuacaoScalarWhereWithAggregatesInput>
    OR?: Enumerable<plataforma_x_regiao_atuacaoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<plataforma_x_regiao_atuacaoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    plataforma_id?: IntWithAggregatesFilter | number
    regiao_atuacao_id?: IntWithAggregatesFilter | number
  }

  export type regiao_atuacaoWhereInput = {
    AND?: Enumerable<regiao_atuacaoWhereInput>
    OR?: Enumerable<regiao_atuacaoWhereInput>
    NOT?: Enumerable<regiao_atuacaoWhereInput>
    id?: IntFilter | number
    nome?: StringFilter | string
    regiao_atuacao_tipo_id?: IntFilter | number
    regiao_atuacao_tipo?: XOR<Regiao_atuacao_tipoRelationFilter, regiao_atuacao_tipoWhereInput>
    organograma_x_regiao_atuacao?: Organograma_x_regiao_atuacaoListRelationFilter
    plataforma_x_regiao_atuacao?: Plataforma_x_regiao_atuacaoListRelationFilter
  }

  export type regiao_atuacaoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    regiao_atuacao_tipo_id?: SortOrder
    regiao_atuacao_tipo?: regiao_atuacao_tipoOrderByWithRelationInput
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoOrderByRelationAggregateInput
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoOrderByRelationAggregateInput
  }

  export type regiao_atuacaoWhereUniqueInput = {
    id?: number
  }

  export type regiao_atuacaoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    regiao_atuacao_tipo_id?: SortOrder
    _count?: regiao_atuacaoCountOrderByAggregateInput
    _avg?: regiao_atuacaoAvgOrderByAggregateInput
    _max?: regiao_atuacaoMaxOrderByAggregateInput
    _min?: regiao_atuacaoMinOrderByAggregateInput
    _sum?: regiao_atuacaoSumOrderByAggregateInput
  }

  export type regiao_atuacaoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<regiao_atuacaoScalarWhereWithAggregatesInput>
    OR?: Enumerable<regiao_atuacaoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<regiao_atuacaoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
    regiao_atuacao_tipo_id?: IntWithAggregatesFilter | number
  }

  export type regiao_atuacao_tipoWhereInput = {
    AND?: Enumerable<regiao_atuacao_tipoWhereInput>
    OR?: Enumerable<regiao_atuacao_tipoWhereInput>
    NOT?: Enumerable<regiao_atuacao_tipoWhereInput>
    id?: IntFilter | number
    nome?: StringFilter | string
    regiao_atuacao?: Regiao_atuacaoListRelationFilter
  }

  export type regiao_atuacao_tipoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    regiao_atuacao?: regiao_atuacaoOrderByRelationAggregateInput
  }

  export type regiao_atuacao_tipoWhereUniqueInput = {
    id?: number
  }

  export type regiao_atuacao_tipoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    _count?: regiao_atuacao_tipoCountOrderByAggregateInput
    _avg?: regiao_atuacao_tipoAvgOrderByAggregateInput
    _max?: regiao_atuacao_tipoMaxOrderByAggregateInput
    _min?: regiao_atuacao_tipoMinOrderByAggregateInput
    _sum?: regiao_atuacao_tipoSumOrderByAggregateInput
  }

  export type regiao_atuacao_tipoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<regiao_atuacao_tipoScalarWhereWithAggregatesInput>
    OR?: Enumerable<regiao_atuacao_tipoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<regiao_atuacao_tipoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
  }

  export type sacadoWhereInput = {
    AND?: Enumerable<sacadoWhereInput>
    OR?: Enumerable<sacadoWhereInput>
    NOT?: Enumerable<sacadoWhereInput>
    id?: IntFilter | number
    pessoa_id?: IntFilter | number
    razao_social?: StringFilter | string
    nome_fantasia?: StringNullableFilter | string | null
    abertura?: DateTimeNullableFilter | Date | string | null
    cnpj?: StringNullableFilter | string | null
    cedente_n_sacados?: Cedente_n_sacadosListRelationFilter
  }

  export type sacadoOrderByWithRelationInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    cedente_n_sacados?: cedente_n_sacadosOrderByRelationAggregateInput
  }

  export type sacadoWhereUniqueInput = {
    id?: number
  }

  export type sacadoOrderByWithAggregationInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    _count?: sacadoCountOrderByAggregateInput
    _avg?: sacadoAvgOrderByAggregateInput
    _max?: sacadoMaxOrderByAggregateInput
    _min?: sacadoMinOrderByAggregateInput
    _sum?: sacadoSumOrderByAggregateInput
  }

  export type sacadoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<sacadoScalarWhereWithAggregatesInput>
    OR?: Enumerable<sacadoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<sacadoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    pessoa_id?: IntWithAggregatesFilter | number
    razao_social?: StringWithAggregatesFilter | string
    nome_fantasia?: StringNullableWithAggregatesFilter | string | null
    abertura?: DateTimeNullableWithAggregatesFilter | Date | string | null
    cnpj?: StringNullableWithAggregatesFilter | string | null
  }

  export type tituloWhereInput = {
    AND?: Enumerable<tituloWhereInput>
    OR?: Enumerable<tituloWhereInput>
    NOT?: Enumerable<tituloWhereInput>
    id?: IntFilter | number
    titulo_tipo_id?: IntFilter | number
    bordero_id?: IntFilter | number
    nf?: StringNullableFilter | string | null
    valor?: FloatNullableFilter | number | null
    vencimento?: DateTimeNullableFilter | Date | string | null
    numero?: StringNullableFilter | string | null
    emissao?: DateTimeNullableFilter | Date | string | null
    parcela?: StringNullableFilter | string | null
    titulo_tipo?: XOR<Titulo_tipoRelationFilter, titulo_tipoWhereInput>
    bordero?: XOR<BorderoRelationFilter, borderoWhereInput>
    titulo_itens?: Titulo_itensListRelationFilter
  }

  export type tituloOrderByWithRelationInput = {
    id?: SortOrder
    titulo_tipo_id?: SortOrder
    bordero_id?: SortOrder
    nf?: SortOrder
    valor?: SortOrder
    vencimento?: SortOrder
    numero?: SortOrder
    emissao?: SortOrder
    parcela?: SortOrder
    titulo_tipo?: titulo_tipoOrderByWithRelationInput
    bordero?: borderoOrderByWithRelationInput
    titulo_itens?: titulo_itensOrderByRelationAggregateInput
  }

  export type tituloWhereUniqueInput = {
    id?: number
  }

  export type tituloOrderByWithAggregationInput = {
    id?: SortOrder
    titulo_tipo_id?: SortOrder
    bordero_id?: SortOrder
    nf?: SortOrder
    valor?: SortOrder
    vencimento?: SortOrder
    numero?: SortOrder
    emissao?: SortOrder
    parcela?: SortOrder
    _count?: tituloCountOrderByAggregateInput
    _avg?: tituloAvgOrderByAggregateInput
    _max?: tituloMaxOrderByAggregateInput
    _min?: tituloMinOrderByAggregateInput
    _sum?: tituloSumOrderByAggregateInput
  }

  export type tituloScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tituloScalarWhereWithAggregatesInput>
    OR?: Enumerable<tituloScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tituloScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    titulo_tipo_id?: IntWithAggregatesFilter | number
    bordero_id?: IntWithAggregatesFilter | number
    nf?: StringNullableWithAggregatesFilter | string | null
    valor?: FloatNullableWithAggregatesFilter | number | null
    vencimento?: DateTimeNullableWithAggregatesFilter | Date | string | null
    numero?: StringNullableWithAggregatesFilter | string | null
    emissao?: DateTimeNullableWithAggregatesFilter | Date | string | null
    parcela?: StringNullableWithAggregatesFilter | string | null
  }

  export type titulo_tipoWhereInput = {
    AND?: Enumerable<titulo_tipoWhereInput>
    OR?: Enumerable<titulo_tipoWhereInput>
    NOT?: Enumerable<titulo_tipoWhereInput>
    id?: IntFilter | number
    nome?: StringNullableFilter | string | null
    titulo?: TituloListRelationFilter
  }

  export type titulo_tipoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    titulo?: tituloOrderByRelationAggregateInput
  }

  export type titulo_tipoWhereUniqueInput = {
    id?: number
  }

  export type titulo_tipoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    _count?: titulo_tipoCountOrderByAggregateInput
    _avg?: titulo_tipoAvgOrderByAggregateInput
    _max?: titulo_tipoMaxOrderByAggregateInput
    _min?: titulo_tipoMinOrderByAggregateInput
    _sum?: titulo_tipoSumOrderByAggregateInput
  }

  export type titulo_tipoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<titulo_tipoScalarWhereWithAggregatesInput>
    OR?: Enumerable<titulo_tipoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<titulo_tipoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringNullableWithAggregatesFilter | string | null
  }

  export type usuarioWhereInput = {
    AND?: Enumerable<usuarioWhereInput>
    OR?: Enumerable<usuarioWhereInput>
    NOT?: Enumerable<usuarioWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    senha?: StringFilter | string
    pessoa_id?: IntFilter | number
    status?: StringNullableFilter | string | null
    primeiro_acesso?: BoolNullableFilter | boolean | null
    confirmou_cadastro?: BoolNullableFilter | boolean | null
    codigo_confirma_cadastro?: StringNullableFilter | string | null
    codigo_reset_senha?: StringNullableFilter | string | null
    codigo_data_expiracao?: DateTimeNullableFilter | Date | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeNullableFilter | Date | string | null
    pessoa?: XOR<PessoaRelationFilter, pessoaWhereInput>
  }

  export type usuarioOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    pessoa_id?: SortOrder
    status?: SortOrder
    primeiro_acesso?: SortOrder
    confirmou_cadastro?: SortOrder
    codigo_confirma_cadastro?: SortOrder
    codigo_reset_senha?: SortOrder
    codigo_data_expiracao?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    pessoa?: pessoaOrderByWithRelationInput
  }

  export type usuarioWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type usuarioOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    pessoa_id?: SortOrder
    status?: SortOrder
    primeiro_acesso?: SortOrder
    confirmou_cadastro?: SortOrder
    codigo_confirma_cadastro?: SortOrder
    codigo_reset_senha?: SortOrder
    codigo_data_expiracao?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: usuarioCountOrderByAggregateInput
    _avg?: usuarioAvgOrderByAggregateInput
    _max?: usuarioMaxOrderByAggregateInput
    _min?: usuarioMinOrderByAggregateInput
    _sum?: usuarioSumOrderByAggregateInput
  }

  export type usuarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usuarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<usuarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usuarioScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    email?: StringWithAggregatesFilter | string
    senha?: StringWithAggregatesFilter | string
    pessoa_id?: IntWithAggregatesFilter | number
    status?: StringNullableWithAggregatesFilter | string | null
    primeiro_acesso?: BoolNullableWithAggregatesFilter | boolean | null
    confirmou_cadastro?: BoolNullableWithAggregatesFilter | boolean | null
    codigo_confirma_cadastro?: StringNullableWithAggregatesFilter | string | null
    codigo_reset_senha?: StringNullableWithAggregatesFilter | string | null
    codigo_data_expiracao?: DateTimeNullableWithAggregatesFilter | Date | string | null
    created_at?: DateTimeWithAggregatesFilter | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type usuario_perfil_tipoWhereInput = {
    AND?: Enumerable<usuario_perfil_tipoWhereInput>
    OR?: Enumerable<usuario_perfil_tipoWhereInput>
    NOT?: Enumerable<usuario_perfil_tipoWhereInput>
    id?: IntFilter | number
    nome?: StringFilter | string
    usuario_perfil?: Usuario_perfilListRelationFilter
  }

  export type usuario_perfil_tipoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    usuario_perfil?: usuario_perfilOrderByRelationAggregateInput
  }

  export type usuario_perfil_tipoWhereUniqueInput = {
    id?: number
  }

  export type usuario_perfil_tipoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    _count?: usuario_perfil_tipoCountOrderByAggregateInput
    _avg?: usuario_perfil_tipoAvgOrderByAggregateInput
    _max?: usuario_perfil_tipoMaxOrderByAggregateInput
    _min?: usuario_perfil_tipoMinOrderByAggregateInput
    _sum?: usuario_perfil_tipoSumOrderByAggregateInput
  }

  export type usuario_perfil_tipoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usuario_perfil_tipoScalarWhereWithAggregatesInput>
    OR?: Enumerable<usuario_perfil_tipoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usuario_perfil_tipoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nome?: StringWithAggregatesFilter | string
  }

  export type carteira_n_cedentesWhereInput = {
    AND?: Enumerable<carteira_n_cedentesWhereInput>
    OR?: Enumerable<carteira_n_cedentesWhereInput>
    NOT?: Enumerable<carteira_n_cedentesWhereInput>
    id?: IntFilter | number
    carteira_id?: IntFilter | number
    cedente_id?: IntFilter | number
    carteira?: XOR<CarteiraRelationFilter, carteiraWhereInput>
    cedente?: XOR<CedenteRelationFilter, cedenteWhereInput>
  }

  export type carteira_n_cedentesOrderByWithRelationInput = {
    id?: SortOrder
    carteira_id?: SortOrder
    cedente_id?: SortOrder
    carteira?: carteiraOrderByWithRelationInput
    cedente?: cedenteOrderByWithRelationInput
  }

  export type carteira_n_cedentesWhereUniqueInput = {
    id?: number
  }

  export type carteira_n_cedentesOrderByWithAggregationInput = {
    id?: SortOrder
    carteira_id?: SortOrder
    cedente_id?: SortOrder
    _count?: carteira_n_cedentesCountOrderByAggregateInput
    _avg?: carteira_n_cedentesAvgOrderByAggregateInput
    _max?: carteira_n_cedentesMaxOrderByAggregateInput
    _min?: carteira_n_cedentesMinOrderByAggregateInput
    _sum?: carteira_n_cedentesSumOrderByAggregateInput
  }

  export type carteira_n_cedentesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<carteira_n_cedentesScalarWhereWithAggregatesInput>
    OR?: Enumerable<carteira_n_cedentesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<carteira_n_cedentesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    carteira_id?: IntWithAggregatesFilter | number
    cedente_id?: IntWithAggregatesFilter | number
  }

  export type organograma_x_usuarioWhereInput = {
    AND?: Enumerable<organograma_x_usuarioWhereInput>
    OR?: Enumerable<organograma_x_usuarioWhereInput>
    NOT?: Enumerable<organograma_x_usuarioWhereInput>
    id?: IntFilter | number
    organograma_id?: IntFilter | number
    usuario_id?: IntFilter | number
    organograma?: XOR<OrganogramaRelationFilter, organogramaWhereInput>
  }

  export type organograma_x_usuarioOrderByWithRelationInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    usuario_id?: SortOrder
    organograma?: organogramaOrderByWithRelationInput
  }

  export type organograma_x_usuarioWhereUniqueInput = {
    id?: number
  }

  export type organograma_x_usuarioOrderByWithAggregationInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    usuario_id?: SortOrder
    _count?: organograma_x_usuarioCountOrderByAggregateInput
    _avg?: organograma_x_usuarioAvgOrderByAggregateInput
    _max?: organograma_x_usuarioMaxOrderByAggregateInput
    _min?: organograma_x_usuarioMinOrderByAggregateInput
    _sum?: organograma_x_usuarioSumOrderByAggregateInput
  }

  export type organograma_x_usuarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<organograma_x_usuarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<organograma_x_usuarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<organograma_x_usuarioScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    organograma_id?: IntWithAggregatesFilter | number
    usuario_id?: IntWithAggregatesFilter | number
  }

  export type plataforma_x_usuarioWhereInput = {
    AND?: Enumerable<plataforma_x_usuarioWhereInput>
    OR?: Enumerable<plataforma_x_usuarioWhereInput>
    NOT?: Enumerable<plataforma_x_usuarioWhereInput>
    id?: IntFilter | number
    plataforma_id?: IntFilter | number
    usuario_id?: IntFilter | number
    plataforma?: XOR<PlataformaRelationFilter, plataformaWhereInput>
  }

  export type plataforma_x_usuarioOrderByWithRelationInput = {
    id?: SortOrder
    plataforma_id?: SortOrder
    usuario_id?: SortOrder
    plataforma?: plataformaOrderByWithRelationInput
  }

  export type plataforma_x_usuarioWhereUniqueInput = {
    id?: number
  }

  export type plataforma_x_usuarioOrderByWithAggregationInput = {
    id?: SortOrder
    plataforma_id?: SortOrder
    usuario_id?: SortOrder
    _count?: plataforma_x_usuarioCountOrderByAggregateInput
    _avg?: plataforma_x_usuarioAvgOrderByAggregateInput
    _max?: plataforma_x_usuarioMaxOrderByAggregateInput
    _min?: plataforma_x_usuarioMinOrderByAggregateInput
    _sum?: plataforma_x_usuarioSumOrderByAggregateInput
  }

  export type plataforma_x_usuarioScalarWhereWithAggregatesInput = {
    AND?: Enumerable<plataforma_x_usuarioScalarWhereWithAggregatesInput>
    OR?: Enumerable<plataforma_x_usuarioScalarWhereWithAggregatesInput>
    NOT?: Enumerable<plataforma_x_usuarioScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    plataforma_id?: IntWithAggregatesFilter | number
    usuario_id?: IntWithAggregatesFilter | number
  }

  export type titulo_itensWhereInput = {
    AND?: Enumerable<titulo_itensWhereInput>
    OR?: Enumerable<titulo_itensWhereInput>
    NOT?: Enumerable<titulo_itensWhereInput>
    id?: IntFilter | number
    titulo_id?: IntFilter | number
    titulo?: XOR<TituloRelationFilter, tituloWhereInput>
  }

  export type titulo_itensOrderByWithRelationInput = {
    id?: SortOrder
    titulo_id?: SortOrder
    titulo?: tituloOrderByWithRelationInput
  }

  export type titulo_itensWhereUniqueInput = {
    id?: number
  }

  export type titulo_itensOrderByWithAggregationInput = {
    id?: SortOrder
    titulo_id?: SortOrder
    _count?: titulo_itensCountOrderByAggregateInput
    _avg?: titulo_itensAvgOrderByAggregateInput
    _max?: titulo_itensMaxOrderByAggregateInput
    _min?: titulo_itensMinOrderByAggregateInput
    _sum?: titulo_itensSumOrderByAggregateInput
  }

  export type titulo_itensScalarWhereWithAggregatesInput = {
    AND?: Enumerable<titulo_itensScalarWhereWithAggregatesInput>
    OR?: Enumerable<titulo_itensScalarWhereWithAggregatesInput>
    NOT?: Enumerable<titulo_itensScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    titulo_id?: IntWithAggregatesFilter | number
  }

  export type usuario_perfilWhereInput = {
    AND?: Enumerable<usuario_perfilWhereInput>
    OR?: Enumerable<usuario_perfilWhereInput>
    NOT?: Enumerable<usuario_perfilWhereInput>
    id?: IntFilter | number
    senha?: StringFilter | string
    usuario_id?: IntFilter | number
    usuario_perfil_tipo_id?: IntFilter | number
    usuario_perfil_tipo?: XOR<Usuario_perfil_tipoRelationFilter, usuario_perfil_tipoWhereInput>
  }

  export type usuario_perfilOrderByWithRelationInput = {
    id?: SortOrder
    senha?: SortOrder
    usuario_id?: SortOrder
    usuario_perfil_tipo_id?: SortOrder
    usuario_perfil_tipo?: usuario_perfil_tipoOrderByWithRelationInput
  }

  export type usuario_perfilWhereUniqueInput = {
    id?: number
  }

  export type usuario_perfilOrderByWithAggregationInput = {
    id?: SortOrder
    senha?: SortOrder
    usuario_id?: SortOrder
    usuario_perfil_tipo_id?: SortOrder
    _count?: usuario_perfilCountOrderByAggregateInput
    _avg?: usuario_perfilAvgOrderByAggregateInput
    _max?: usuario_perfilMaxOrderByAggregateInput
    _min?: usuario_perfilMinOrderByAggregateInput
    _sum?: usuario_perfilSumOrderByAggregateInput
  }

  export type usuario_perfilScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usuario_perfilScalarWhereWithAggregatesInput>
    OR?: Enumerable<usuario_perfilScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usuario_perfilScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    senha?: StringWithAggregatesFilter | string
    usuario_id?: IntWithAggregatesFilter | number
    usuario_perfil_tipo_id?: IntWithAggregatesFilter | number
  }

  export type auditoriaCreateInput = {
    action?: string | null
    usuario?: number | null
    data?: Date | string | null
    modulo?: string | null
  }

  export type auditoriaUncheckedCreateInput = {
    action?: string | null
    usuario?: number | null
    data?: Date | string | null
    modulo?: string | null
    id?: number
  }

  export type auditoriaUpdateInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modulo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditoriaUncheckedUpdateInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modulo?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type auditoriaCreateManyInput = {
    action?: string | null
    usuario?: number | null
    data?: Date | string | null
    modulo?: string | null
    id?: number
  }

  export type auditoriaUpdateManyMutationInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modulo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type auditoriaUncheckedUpdateManyInput = {
    action?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    data?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    modulo?: NullableStringFieldUpdateOperationsInput | string | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type borderoCreateInput = {
    carteira: carteiraCreateNestedOneWithoutBorderoInput
    titulo?: tituloCreateNestedManyWithoutBorderoInput
  }

  export type borderoUncheckedCreateInput = {
    id?: number
    carteira_id: number
    titulo?: tituloUncheckedCreateNestedManyWithoutBorderoInput
  }

  export type borderoUpdateInput = {
    carteira?: carteiraUpdateOneRequiredWithoutBorderoNestedInput
    titulo?: tituloUpdateManyWithoutBorderoNestedInput
  }

  export type borderoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    carteira_id?: IntFieldUpdateOperationsInput | number
    titulo?: tituloUncheckedUpdateManyWithoutBorderoNestedInput
  }

  export type borderoCreateManyInput = {
    id?: number
    carteira_id: number
  }

  export type borderoUpdateManyMutationInput = {

  }

  export type borderoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    carteira_id?: IntFieldUpdateOperationsInput | number
  }

  export type carteiraCreateInput = {
    fidic_fundo: fidic_fundoCreateNestedOneWithoutCarteiraInput
    bordero?: borderoCreateNestedManyWithoutCarteiraInput
    carteira_n_cedentes?: carteira_n_cedentesCreateNestedManyWithoutCarteiraInput
  }

  export type carteiraUncheckedCreateInput = {
    id?: number
    fiduc_fundo_id: number
    bordero?: borderoUncheckedCreateNestedManyWithoutCarteiraInput
    carteira_n_cedentes?: carteira_n_cedentesUncheckedCreateNestedManyWithoutCarteiraInput
  }

  export type carteiraUpdateInput = {
    fidic_fundo?: fidic_fundoUpdateOneRequiredWithoutCarteiraNestedInput
    bordero?: borderoUpdateManyWithoutCarteiraNestedInput
    carteira_n_cedentes?: carteira_n_cedentesUpdateManyWithoutCarteiraNestedInput
  }

  export type carteiraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fiduc_fundo_id?: IntFieldUpdateOperationsInput | number
    bordero?: borderoUncheckedUpdateManyWithoutCarteiraNestedInput
    carteira_n_cedentes?: carteira_n_cedentesUncheckedUpdateManyWithoutCarteiraNestedInput
  }

  export type carteiraCreateManyInput = {
    id?: number
    fiduc_fundo_id: number
  }

  export type carteiraUpdateManyMutationInput = {

  }

  export type carteiraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fiduc_fundo_id?: IntFieldUpdateOperationsInput | number
  }

  export type cedenteCreateInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    carteira_n_cedentes?: carteira_n_cedentesCreateNestedManyWithoutCedenteInput
    cedente_analise?: cedente_analiseCreateNestedManyWithoutCedente_cedenteTocedente_analiseInput
    cedente_n_sacados?: cedente_n_sacadosCreateNestedManyWithoutCedente_cedenteTocedente_n_sacadosInput
  }

  export type cedenteUncheckedCreateInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    carteira_n_cedentes?: carteira_n_cedentesUncheckedCreateNestedManyWithoutCedenteInput
    cedente_analise?: cedente_analiseUncheckedCreateNestedManyWithoutCedente_cedenteTocedente_analiseInput
    cedente_n_sacados?: cedente_n_sacadosUncheckedCreateNestedManyWithoutCedente_cedenteTocedente_n_sacadosInput
  }

  export type cedenteUpdateInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    carteira_n_cedentes?: carteira_n_cedentesUpdateManyWithoutCedenteNestedInput
    cedente_analise?: cedente_analiseUpdateManyWithoutCedente_cedenteTocedente_analiseNestedInput
    cedente_n_sacados?: cedente_n_sacadosUpdateManyWithoutCedente_cedenteTocedente_n_sacadosNestedInput
  }

  export type cedenteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    carteira_n_cedentes?: carteira_n_cedentesUncheckedUpdateManyWithoutCedenteNestedInput
    cedente_analise?: cedente_analiseUncheckedUpdateManyWithoutCedente_cedenteTocedente_analiseNestedInput
    cedente_n_sacados?: cedente_n_sacadosUncheckedUpdateManyWithoutCedente_cedenteTocedente_n_sacadosNestedInput
  }

  export type cedenteCreateManyInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
  }

  export type cedenteUpdateManyMutationInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cedenteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cedente_analiseCreateInput = {
    status?: string | null
    cedente_cedenteTocedente_analise?: cedenteCreateNestedOneWithoutCedente_analiseInput
  }

  export type cedente_analiseUncheckedCreateInput = {
    id?: number
    status?: string | null
    cedente?: number | null
  }

  export type cedente_analiseUpdateInput = {
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cedente_cedenteTocedente_analise?: cedenteUpdateOneWithoutCedente_analiseNestedInput
  }

  export type cedente_analiseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cedente?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cedente_analiseCreateManyInput = {
    id?: number
    status?: string | null
    cedente?: number | null
  }

  export type cedente_analiseUpdateManyMutationInput = {
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cedente_analiseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    cedente?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cedente_n_sacadosCreateInput = {
    cedente_cedenteTocedente_n_sacados?: cedenteCreateNestedOneWithoutCedente_n_sacadosInput
    sacado_cedente_n_sacadosTosacado?: sacadoCreateNestedOneWithoutCedente_n_sacadosInput
  }

  export type cedente_n_sacadosUncheckedCreateInput = {
    id?: number
    cedente?: number | null
    sacado?: number | null
  }

  export type cedente_n_sacadosUpdateInput = {
    cedente_cedenteTocedente_n_sacados?: cedenteUpdateOneWithoutCedente_n_sacadosNestedInput
    sacado_cedente_n_sacadosTosacado?: sacadoUpdateOneWithoutCedente_n_sacadosNestedInput
  }

  export type cedente_n_sacadosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedente?: NullableIntFieldUpdateOperationsInput | number | null
    sacado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cedente_n_sacadosCreateManyInput = {
    id?: number
    cedente?: number | null
    sacado?: number | null
  }

  export type cedente_n_sacadosUpdateManyMutationInput = {

  }

  export type cedente_n_sacadosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedente?: NullableIntFieldUpdateOperationsInput | number | null
    sacado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type checagemCreateInput = {
    nf?: string | null
    status?: string | null
    usuario?: number | null
    titulos?: string | null
  }

  export type checagemUncheckedCreateInput = {
    id?: number
    nf?: string | null
    status?: string | null
    usuario?: number | null
    titulos?: string | null
  }

  export type checagemUpdateInput = {
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    titulos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type checagemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    titulos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type checagemCreateManyInput = {
    id?: number
    nf?: string | null
    status?: string | null
    usuario?: number | null
    titulos?: string | null
  }

  export type checagemUpdateManyMutationInput = {
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    titulos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type checagemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    titulos?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fidic_fundoCreateInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    carteira?: carteiraCreateNestedManyWithoutFidic_fundoInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioCreateNestedManyWithoutFidic_fundoInput
  }

  export type fidic_fundoUncheckedCreateInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    carteira?: carteiraUncheckedCreateNestedManyWithoutFidic_fundoInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedCreateNestedManyWithoutFidic_fundoInput
  }

  export type fidic_fundoUpdateInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    carteira?: carteiraUpdateManyWithoutFidic_fundoNestedInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUpdateManyWithoutFidic_fundoNestedInput
  }

  export type fidic_fundoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    carteira?: carteiraUncheckedUpdateManyWithoutFidic_fundoNestedInput
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedUpdateManyWithoutFidic_fundoNestedInput
  }

  export type fidic_fundoCreateManyInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
  }

  export type fidic_fundoUpdateManyMutationInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fidic_fundoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fidic_fundo_x_usuarioCreateInput = {
    usuario?: number | null
    fidic_fundo: fidic_fundoCreateNestedOneWithoutFidic_fundo_x_usuarioInput
  }

  export type fidic_fundo_x_usuarioUncheckedCreateInput = {
    id?: number
    usuario?: number | null
    fidic: number
  }

  export type fidic_fundo_x_usuarioUpdateInput = {
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    fidic_fundo?: fidic_fundoUpdateOneRequiredWithoutFidic_fundo_x_usuarioNestedInput
  }

  export type fidic_fundo_x_usuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    fidic?: IntFieldUpdateOperationsInput | number
  }

  export type fidic_fundo_x_usuarioCreateManyInput = {
    id?: number
    usuario?: number | null
    fidic: number
  }

  export type fidic_fundo_x_usuarioUpdateManyMutationInput = {
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type fidic_fundo_x_usuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
    fidic?: IntFieldUpdateOperationsInput | number
  }

  export type organogramaCreateInput = {
    organograma_tipo: organograma_tipoCreateNestedOneWithoutOrganogramaInput
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoCreateNestedManyWithoutOrganogramaInput
    organograma_x_usuario?: organograma_x_usuarioCreateNestedManyWithoutOrganogramaInput
  }

  export type organogramaUncheckedCreateInput = {
    id?: number
    organograma_id: number
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUncheckedCreateNestedManyWithoutOrganogramaInput
    organograma_x_usuario?: organograma_x_usuarioUncheckedCreateNestedManyWithoutOrganogramaInput
  }

  export type organogramaUpdateInput = {
    organograma_tipo?: organograma_tipoUpdateOneRequiredWithoutOrganogramaNestedInput
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUpdateManyWithoutOrganogramaNestedInput
    organograma_x_usuario?: organograma_x_usuarioUpdateManyWithoutOrganogramaNestedInput
  }

  export type organogramaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organograma_id?: IntFieldUpdateOperationsInput | number
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUncheckedUpdateManyWithoutOrganogramaNestedInput
    organograma_x_usuario?: organograma_x_usuarioUncheckedUpdateManyWithoutOrganogramaNestedInput
  }

  export type organogramaCreateManyInput = {
    id?: number
    organograma_id: number
  }

  export type organogramaUpdateManyMutationInput = {

  }

  export type organogramaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organograma_id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_tipoCreateInput = {
    nome: string
    organograma?: organogramaCreateNestedManyWithoutOrganograma_tipoInput
  }

  export type organograma_tipoUncheckedCreateInput = {
    id?: number
    nome: string
    organograma?: organogramaUncheckedCreateNestedManyWithoutOrganograma_tipoInput
  }

  export type organograma_tipoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    organograma?: organogramaUpdateManyWithoutOrganograma_tipoNestedInput
  }

  export type organograma_tipoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    organograma?: organogramaUncheckedUpdateManyWithoutOrganograma_tipoNestedInput
  }

  export type organograma_tipoCreateManyInput = {
    id?: number
    nome: string
  }

  export type organograma_tipoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type organograma_tipoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type organograma_x_regiao_atuacaoCreateInput = {
    organograma: organogramaCreateNestedOneWithoutOrganograma_x_regiao_atuacaoInput
    regiao_atuacao: regiao_atuacaoCreateNestedOneWithoutOrganograma_x_regiao_atuacaoInput
  }

  export type organograma_x_regiao_atuacaoUncheckedCreateInput = {
    id?: number
    organograma_id: number
    regiao_atuacao_id: number
  }

  export type organograma_x_regiao_atuacaoUpdateInput = {
    organograma?: organogramaUpdateOneRequiredWithoutOrganograma_x_regiao_atuacaoNestedInput
    regiao_atuacao?: regiao_atuacaoUpdateOneRequiredWithoutOrganograma_x_regiao_atuacaoNestedInput
  }

  export type organograma_x_regiao_atuacaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organograma_id?: IntFieldUpdateOperationsInput | number
    regiao_atuacao_id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_x_regiao_atuacaoCreateManyInput = {
    id?: number
    organograma_id: number
    regiao_atuacao_id: number
  }

  export type organograma_x_regiao_atuacaoUpdateManyMutationInput = {

  }

  export type organograma_x_regiao_atuacaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organograma_id?: IntFieldUpdateOperationsInput | number
    regiao_atuacao_id?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCreateInput = {
    nome: string
    sobrenome: string
    sexo?: string | null
    nascimento?: Date | string | null
    cpf?: string | null
    rg?: string | null
    usuario?: usuarioCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateInput = {
    id?: number
    nome: string
    sobrenome: string
    sexo?: string | null
    nascimento?: Date | string | null
    cpf?: string | null
    rg?: string | null
    usuario?: usuarioUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: usuarioUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: usuarioUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaCreateManyInput = {
    id?: number
    nome: string
    sobrenome: string
    sexo?: string | null
    nascimento?: Date | string | null
    cpf?: string | null
    rg?: string | null
  }

  export type pessoaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pessoaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plataformaCreateInput = {
    nome?: string | null
    plataforma_papel_tipo: plataforma_papel_tipoCreateNestedOneWithoutPlataformaInput
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoCreateNestedManyWithoutPlataformaInput
    plataforma_x_usuario?: plataforma_x_usuarioCreateNestedManyWithoutPlataformaInput
  }

  export type plataformaUncheckedCreateInput = {
    id?: number
    nome?: string | null
    plataforma_papel_tipo_id: number
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUncheckedCreateNestedManyWithoutPlataformaInput
    plataforma_x_usuario?: plataforma_x_usuarioUncheckedCreateNestedManyWithoutPlataformaInput
  }

  export type plataformaUpdateInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    plataforma_papel_tipo?: plataforma_papel_tipoUpdateOneRequiredWithoutPlataformaNestedInput
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUpdateManyWithoutPlataformaNestedInput
    plataforma_x_usuario?: plataforma_x_usuarioUpdateManyWithoutPlataformaNestedInput
  }

  export type plataformaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    plataforma_papel_tipo_id?: IntFieldUpdateOperationsInput | number
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUncheckedUpdateManyWithoutPlataformaNestedInput
    plataforma_x_usuario?: plataforma_x_usuarioUncheckedUpdateManyWithoutPlataformaNestedInput
  }

  export type plataformaCreateManyInput = {
    id?: number
    nome?: string | null
    plataforma_papel_tipo_id: number
  }

  export type plataformaUpdateManyMutationInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plataformaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    plataforma_papel_tipo_id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_papel_tipoCreateInput = {
    plataforma?: plataformaCreateNestedManyWithoutPlataforma_papel_tipoInput
  }

  export type plataforma_papel_tipoUncheckedCreateInput = {
    id?: number
    plataforma?: plataformaUncheckedCreateNestedManyWithoutPlataforma_papel_tipoInput
  }

  export type plataforma_papel_tipoUpdateInput = {
    plataforma?: plataformaUpdateManyWithoutPlataforma_papel_tipoNestedInput
  }

  export type plataforma_papel_tipoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    plataforma?: plataformaUncheckedUpdateManyWithoutPlataforma_papel_tipoNestedInput
  }

  export type plataforma_papel_tipoCreateManyInput = {
    id?: number
  }

  export type plataforma_papel_tipoUpdateManyMutationInput = {

  }

  export type plataforma_papel_tipoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_x_regiao_atuacaoCreateInput = {
    plataforma: plataformaCreateNestedOneWithoutPlataforma_x_regiao_atuacaoInput
    regiao_atuacao: regiao_atuacaoCreateNestedOneWithoutPlataforma_x_regiao_atuacaoInput
  }

  export type plataforma_x_regiao_atuacaoUncheckedCreateInput = {
    id?: number
    plataforma_id: number
    regiao_atuacao_id: number
  }

  export type plataforma_x_regiao_atuacaoUpdateInput = {
    plataforma?: plataformaUpdateOneRequiredWithoutPlataforma_x_regiao_atuacaoNestedInput
    regiao_atuacao?: regiao_atuacaoUpdateOneRequiredWithoutPlataforma_x_regiao_atuacaoNestedInput
  }

  export type plataforma_x_regiao_atuacaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    plataforma_id?: IntFieldUpdateOperationsInput | number
    regiao_atuacao_id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_x_regiao_atuacaoCreateManyInput = {
    id?: number
    plataforma_id: number
    regiao_atuacao_id: number
  }

  export type plataforma_x_regiao_atuacaoUpdateManyMutationInput = {

  }

  export type plataforma_x_regiao_atuacaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    plataforma_id?: IntFieldUpdateOperationsInput | number
    regiao_atuacao_id?: IntFieldUpdateOperationsInput | number
  }

  export type regiao_atuacaoCreateInput = {
    nome: string
    regiao_atuacao_tipo: regiao_atuacao_tipoCreateNestedOneWithoutRegiao_atuacaoInput
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoCreateNestedManyWithoutRegiao_atuacaoInput
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoCreateNestedManyWithoutRegiao_atuacaoInput
  }

  export type regiao_atuacaoUncheckedCreateInput = {
    id?: number
    nome: string
    regiao_atuacao_tipo_id: number
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUncheckedCreateNestedManyWithoutRegiao_atuacaoInput
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUncheckedCreateNestedManyWithoutRegiao_atuacaoInput
  }

  export type regiao_atuacaoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    regiao_atuacao_tipo?: regiao_atuacao_tipoUpdateOneRequiredWithoutRegiao_atuacaoNestedInput
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUpdateManyWithoutRegiao_atuacaoNestedInput
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUpdateManyWithoutRegiao_atuacaoNestedInput
  }

  export type regiao_atuacaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    regiao_atuacao_tipo_id?: IntFieldUpdateOperationsInput | number
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUncheckedUpdateManyWithoutRegiao_atuacaoNestedInput
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUncheckedUpdateManyWithoutRegiao_atuacaoNestedInput
  }

  export type regiao_atuacaoCreateManyInput = {
    id?: number
    nome: string
    regiao_atuacao_tipo_id: number
  }

  export type regiao_atuacaoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type regiao_atuacaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    regiao_atuacao_tipo_id?: IntFieldUpdateOperationsInput | number
  }

  export type regiao_atuacao_tipoCreateInput = {
    nome: string
    regiao_atuacao?: regiao_atuacaoCreateNestedManyWithoutRegiao_atuacao_tipoInput
  }

  export type regiao_atuacao_tipoUncheckedCreateInput = {
    id?: number
    nome: string
    regiao_atuacao?: regiao_atuacaoUncheckedCreateNestedManyWithoutRegiao_atuacao_tipoInput
  }

  export type regiao_atuacao_tipoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    regiao_atuacao?: regiao_atuacaoUpdateManyWithoutRegiao_atuacao_tipoNestedInput
  }

  export type regiao_atuacao_tipoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    regiao_atuacao?: regiao_atuacaoUncheckedUpdateManyWithoutRegiao_atuacao_tipoNestedInput
  }

  export type regiao_atuacao_tipoCreateManyInput = {
    id?: number
    nome: string
  }

  export type regiao_atuacao_tipoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type regiao_atuacao_tipoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type sacadoCreateInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    cedente_n_sacados?: cedente_n_sacadosCreateNestedManyWithoutSacado_cedente_n_sacadosTosacadoInput
  }

  export type sacadoUncheckedCreateInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    cedente_n_sacados?: cedente_n_sacadosUncheckedCreateNestedManyWithoutSacado_cedente_n_sacadosTosacadoInput
  }

  export type sacadoUpdateInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cedente_n_sacados?: cedente_n_sacadosUpdateManyWithoutSacado_cedente_n_sacadosTosacadoNestedInput
  }

  export type sacadoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    cedente_n_sacados?: cedente_n_sacadosUncheckedUpdateManyWithoutSacado_cedente_n_sacadosTosacadoNestedInput
  }

  export type sacadoCreateManyInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
  }

  export type sacadoUpdateManyMutationInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sacadoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tituloCreateInput = {
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
    titulo_tipo: titulo_tipoCreateNestedOneWithoutTituloInput
    bordero: borderoCreateNestedOneWithoutTituloInput
    titulo_itens?: titulo_itensCreateNestedManyWithoutTituloInput
  }

  export type tituloUncheckedCreateInput = {
    id?: number
    titulo_tipo_id: number
    bordero_id: number
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
    titulo_itens?: titulo_itensUncheckedCreateNestedManyWithoutTituloInput
  }

  export type tituloUpdateInput = {
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    titulo_tipo?: titulo_tipoUpdateOneRequiredWithoutTituloNestedInput
    bordero?: borderoUpdateOneRequiredWithoutTituloNestedInput
    titulo_itens?: titulo_itensUpdateManyWithoutTituloNestedInput
  }

  export type tituloUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo_tipo_id?: IntFieldUpdateOperationsInput | number
    bordero_id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    titulo_itens?: titulo_itensUncheckedUpdateManyWithoutTituloNestedInput
  }

  export type tituloCreateManyInput = {
    id?: number
    titulo_tipo_id: number
    bordero_id: number
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
  }

  export type tituloUpdateManyMutationInput = {
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tituloUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo_tipo_id?: IntFieldUpdateOperationsInput | number
    bordero_id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type titulo_tipoCreateInput = {
    nome?: string | null
    titulo?: tituloCreateNestedManyWithoutTitulo_tipoInput
  }

  export type titulo_tipoUncheckedCreateInput = {
    id?: number
    nome?: string | null
    titulo?: tituloUncheckedCreateNestedManyWithoutTitulo_tipoInput
  }

  export type titulo_tipoUpdateInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: tituloUpdateManyWithoutTitulo_tipoNestedInput
  }

  export type titulo_tipoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    titulo?: tituloUncheckedUpdateManyWithoutTitulo_tipoNestedInput
  }

  export type titulo_tipoCreateManyInput = {
    id?: number
    nome?: string | null
  }

  export type titulo_tipoUpdateManyMutationInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type titulo_tipoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuarioCreateInput = {
    email: string
    senha: string
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    pessoa: pessoaCreateNestedOneWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateInput = {
    id?: number
    email: string
    senha: string
    pessoa_id: number
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type usuarioUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pessoa?: pessoaUpdateOneRequiredWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    pessoa_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuarioCreateManyInput = {
    id?: number
    email: string
    senha: string
    pessoa_id: number
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type usuarioUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    pessoa_id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuario_perfil_tipoCreateInput = {
    nome: string
    usuario_perfil?: usuario_perfilCreateNestedManyWithoutUsuario_perfil_tipoInput
  }

  export type usuario_perfil_tipoUncheckedCreateInput = {
    id?: number
    nome: string
    usuario_perfil?: usuario_perfilUncheckedCreateNestedManyWithoutUsuario_perfil_tipoInput
  }

  export type usuario_perfil_tipoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    usuario_perfil?: usuario_perfilUpdateManyWithoutUsuario_perfil_tipoNestedInput
  }

  export type usuario_perfil_tipoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    usuario_perfil?: usuario_perfilUncheckedUpdateManyWithoutUsuario_perfil_tipoNestedInput
  }

  export type usuario_perfil_tipoCreateManyInput = {
    id?: number
    nome: string
  }

  export type usuario_perfil_tipoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type usuario_perfil_tipoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type carteira_n_cedentesCreateInput = {
    carteira: carteiraCreateNestedOneWithoutCarteira_n_cedentesInput
    cedente: cedenteCreateNestedOneWithoutCarteira_n_cedentesInput
  }

  export type carteira_n_cedentesUncheckedCreateInput = {
    id?: number
    carteira_id: number
    cedente_id: number
  }

  export type carteira_n_cedentesUpdateInput = {
    carteira?: carteiraUpdateOneRequiredWithoutCarteira_n_cedentesNestedInput
    cedente?: cedenteUpdateOneRequiredWithoutCarteira_n_cedentesNestedInput
  }

  export type carteira_n_cedentesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    carteira_id?: IntFieldUpdateOperationsInput | number
    cedente_id?: IntFieldUpdateOperationsInput | number
  }

  export type carteira_n_cedentesCreateManyInput = {
    id?: number
    carteira_id: number
    cedente_id: number
  }

  export type carteira_n_cedentesUpdateManyMutationInput = {

  }

  export type carteira_n_cedentesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    carteira_id?: IntFieldUpdateOperationsInput | number
    cedente_id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_x_usuarioCreateInput = {
    usuario_id: number
    organograma: organogramaCreateNestedOneWithoutOrganograma_x_usuarioInput
  }

  export type organograma_x_usuarioUncheckedCreateInput = {
    id?: number
    organograma_id: number
    usuario_id: number
  }

  export type organograma_x_usuarioUpdateInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    organograma?: organogramaUpdateOneRequiredWithoutOrganograma_x_usuarioNestedInput
  }

  export type organograma_x_usuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organograma_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_x_usuarioCreateManyInput = {
    id?: number
    organograma_id: number
    usuario_id: number
  }

  export type organograma_x_usuarioUpdateManyMutationInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_x_usuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organograma_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_x_usuarioCreateInput = {
    usuario_id: number
    plataforma: plataformaCreateNestedOneWithoutPlataforma_x_usuarioInput
  }

  export type plataforma_x_usuarioUncheckedCreateInput = {
    id?: number
    plataforma_id: number
    usuario_id: number
  }

  export type plataforma_x_usuarioUpdateInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
    plataforma?: plataformaUpdateOneRequiredWithoutPlataforma_x_usuarioNestedInput
  }

  export type plataforma_x_usuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    plataforma_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_x_usuarioCreateManyInput = {
    id?: number
    plataforma_id: number
    usuario_id: number
  }

  export type plataforma_x_usuarioUpdateManyMutationInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_x_usuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    plataforma_id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type titulo_itensCreateInput = {
    titulo: tituloCreateNestedOneWithoutTitulo_itensInput
  }

  export type titulo_itensUncheckedCreateInput = {
    id?: number
    titulo_id: number
  }

  export type titulo_itensUpdateInput = {
    titulo?: tituloUpdateOneRequiredWithoutTitulo_itensNestedInput
  }

  export type titulo_itensUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo_id?: IntFieldUpdateOperationsInput | number
  }

  export type titulo_itensCreateManyInput = {
    id?: number
    titulo_id: number
  }

  export type titulo_itensUpdateManyMutationInput = {

  }

  export type titulo_itensUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo_id?: IntFieldUpdateOperationsInput | number
  }

  export type usuario_perfilCreateInput = {
    senha: string
    usuario_id: number
    usuario_perfil_tipo: usuario_perfil_tipoCreateNestedOneWithoutUsuario_perfilInput
  }

  export type usuario_perfilUncheckedCreateInput = {
    id?: number
    senha: string
    usuario_id: number
    usuario_perfil_tipo_id: number
  }

  export type usuario_perfilUpdateInput = {
    senha?: StringFieldUpdateOperationsInput | string
    usuario_id?: IntFieldUpdateOperationsInput | number
    usuario_perfil_tipo?: usuario_perfil_tipoUpdateOneRequiredWithoutUsuario_perfilNestedInput
  }

  export type usuario_perfilUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    usuario_id?: IntFieldUpdateOperationsInput | number
    usuario_perfil_tipo_id?: IntFieldUpdateOperationsInput | number
  }

  export type usuario_perfilCreateManyInput = {
    id?: number
    senha: string
    usuario_id: number
    usuario_perfil_tipo_id: number
  }

  export type usuario_perfilUpdateManyMutationInput = {
    senha?: StringFieldUpdateOperationsInput | string
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type usuario_perfilUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    usuario_id?: IntFieldUpdateOperationsInput | number
    usuario_perfil_tipo_id?: IntFieldUpdateOperationsInput | number
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type auditoriaCountOrderByAggregateInput = {
    action?: SortOrder
    usuario?: SortOrder
    data?: SortOrder
    modulo?: SortOrder
    id?: SortOrder
  }

  export type auditoriaAvgOrderByAggregateInput = {
    usuario?: SortOrder
    id?: SortOrder
  }

  export type auditoriaMaxOrderByAggregateInput = {
    action?: SortOrder
    usuario?: SortOrder
    data?: SortOrder
    modulo?: SortOrder
    id?: SortOrder
  }

  export type auditoriaMinOrderByAggregateInput = {
    action?: SortOrder
    usuario?: SortOrder
    data?: SortOrder
    modulo?: SortOrder
    id?: SortOrder
  }

  export type auditoriaSumOrderByAggregateInput = {
    usuario?: SortOrder
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type CarteiraRelationFilter = {
    is?: carteiraWhereInput
    isNot?: carteiraWhereInput
  }

  export type TituloListRelationFilter = {
    every?: tituloWhereInput
    some?: tituloWhereInput
    none?: tituloWhereInput
  }

  export type tituloOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type borderoCountOrderByAggregateInput = {
    id?: SortOrder
    carteira_id?: SortOrder
  }

  export type borderoAvgOrderByAggregateInput = {
    id?: SortOrder
    carteira_id?: SortOrder
  }

  export type borderoMaxOrderByAggregateInput = {
    id?: SortOrder
    carteira_id?: SortOrder
  }

  export type borderoMinOrderByAggregateInput = {
    id?: SortOrder
    carteira_id?: SortOrder
  }

  export type borderoSumOrderByAggregateInput = {
    id?: SortOrder
    carteira_id?: SortOrder
  }

  export type Fidic_fundoRelationFilter = {
    is?: fidic_fundoWhereInput
    isNot?: fidic_fundoWhereInput
  }

  export type BorderoListRelationFilter = {
    every?: borderoWhereInput
    some?: borderoWhereInput
    none?: borderoWhereInput
  }

  export type Carteira_n_cedentesListRelationFilter = {
    every?: carteira_n_cedentesWhereInput
    some?: carteira_n_cedentesWhereInput
    none?: carteira_n_cedentesWhereInput
  }

  export type borderoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type carteira_n_cedentesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type carteiraCountOrderByAggregateInput = {
    id?: SortOrder
    fiduc_fundo_id?: SortOrder
  }

  export type carteiraAvgOrderByAggregateInput = {
    id?: SortOrder
    fiduc_fundo_id?: SortOrder
  }

  export type carteiraMaxOrderByAggregateInput = {
    id?: SortOrder
    fiduc_fundo_id?: SortOrder
  }

  export type carteiraMinOrderByAggregateInput = {
    id?: SortOrder
    fiduc_fundo_id?: SortOrder
  }

  export type carteiraSumOrderByAggregateInput = {
    id?: SortOrder
    fiduc_fundo_id?: SortOrder
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type Cedente_analiseListRelationFilter = {
    every?: cedente_analiseWhereInput
    some?: cedente_analiseWhereInput
    none?: cedente_analiseWhereInput
  }

  export type Cedente_n_sacadosListRelationFilter = {
    every?: cedente_n_sacadosWhereInput
    some?: cedente_n_sacadosWhereInput
    none?: cedente_n_sacadosWhereInput
  }

  export type cedente_analiseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cedente_n_sacadosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cedenteCountOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrder
    numero?: SortOrder
    cep?: SortOrder
    bairro?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    telefone?: SortOrder
  }

  export type cedenteAvgOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
  }

  export type cedenteMaxOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrder
    numero?: SortOrder
    cep?: SortOrder
    bairro?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    telefone?: SortOrder
  }

  export type cedenteMinOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
    endereco?: SortOrder
    numero?: SortOrder
    cep?: SortOrder
    bairro?: SortOrder
    cidade?: SortOrder
    uf?: SortOrder
    telefone?: SortOrder
  }

  export type cedenteSumOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type CedenteRelationFilter = {
    is?: cedenteWhereInput | null
    isNot?: cedenteWhereInput | null
  }

  export type cedente_analiseCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    cedente?: SortOrder
  }

  export type cedente_analiseAvgOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
  }

  export type cedente_analiseMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    cedente?: SortOrder
  }

  export type cedente_analiseMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    cedente?: SortOrder
  }

  export type cedente_analiseSumOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
  }

  export type SacadoRelationFilter = {
    is?: sacadoWhereInput | null
    isNot?: sacadoWhereInput | null
  }

  export type cedente_n_sacadosCountOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
    sacado?: SortOrder
  }

  export type cedente_n_sacadosAvgOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
    sacado?: SortOrder
  }

  export type cedente_n_sacadosMaxOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
    sacado?: SortOrder
  }

  export type cedente_n_sacadosMinOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
    sacado?: SortOrder
  }

  export type cedente_n_sacadosSumOrderByAggregateInput = {
    id?: SortOrder
    cedente?: SortOrder
    sacado?: SortOrder
  }

  export type checagemCountOrderByAggregateInput = {
    id?: SortOrder
    nf?: SortOrder
    status?: SortOrder
    usuario?: SortOrder
    titulos?: SortOrder
  }

  export type checagemAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
  }

  export type checagemMaxOrderByAggregateInput = {
    id?: SortOrder
    nf?: SortOrder
    status?: SortOrder
    usuario?: SortOrder
    titulos?: SortOrder
  }

  export type checagemMinOrderByAggregateInput = {
    id?: SortOrder
    nf?: SortOrder
    status?: SortOrder
    usuario?: SortOrder
    titulos?: SortOrder
  }

  export type checagemSumOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
  }

  export type CarteiraListRelationFilter = {
    every?: carteiraWhereInput
    some?: carteiraWhereInput
    none?: carteiraWhereInput
  }

  export type Fidic_fundo_x_usuarioListRelationFilter = {
    every?: fidic_fundo_x_usuarioWhereInput
    some?: fidic_fundo_x_usuarioWhereInput
    none?: fidic_fundo_x_usuarioWhereInput
  }

  export type carteiraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type fidic_fundo_x_usuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type fidic_fundoCountOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
  }

  export type fidic_fundoAvgOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
  }

  export type fidic_fundoMaxOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
  }

  export type fidic_fundoMinOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
  }

  export type fidic_fundoSumOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
  }

  export type fidic_fundo_x_usuarioCountOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
    fidic?: SortOrder
  }

  export type fidic_fundo_x_usuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
    fidic?: SortOrder
  }

  export type fidic_fundo_x_usuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
    fidic?: SortOrder
  }

  export type fidic_fundo_x_usuarioMinOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
    fidic?: SortOrder
  }

  export type fidic_fundo_x_usuarioSumOrderByAggregateInput = {
    id?: SortOrder
    usuario?: SortOrder
    fidic?: SortOrder
  }

  export type Organograma_tipoRelationFilter = {
    is?: organograma_tipoWhereInput
    isNot?: organograma_tipoWhereInput
  }

  export type Organograma_x_regiao_atuacaoListRelationFilter = {
    every?: organograma_x_regiao_atuacaoWhereInput
    some?: organograma_x_regiao_atuacaoWhereInput
    none?: organograma_x_regiao_atuacaoWhereInput
  }

  export type Organograma_x_usuarioListRelationFilter = {
    every?: organograma_x_usuarioWhereInput
    some?: organograma_x_usuarioWhereInput
    none?: organograma_x_usuarioWhereInput
  }

  export type organograma_x_regiao_atuacaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type organograma_x_usuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type organogramaCountOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
  }

  export type organogramaAvgOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
  }

  export type organogramaMaxOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
  }

  export type organogramaMinOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
  }

  export type organogramaSumOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
  }

  export type OrganogramaListRelationFilter = {
    every?: organogramaWhereInput
    some?: organogramaWhereInput
    none?: organogramaWhereInput
  }

  export type organogramaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type organograma_tipoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type organograma_tipoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type organograma_tipoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type organograma_tipoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type organograma_tipoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrganogramaRelationFilter = {
    is?: organogramaWhereInput
    isNot?: organogramaWhereInput
  }

  export type Regiao_atuacaoRelationFilter = {
    is?: regiao_atuacaoWhereInput
    isNot?: regiao_atuacaoWhereInput
  }

  export type organograma_x_regiao_atuacaoCountOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_atuacao_id?: SortOrder
  }

  export type organograma_x_regiao_atuacaoAvgOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_atuacao_id?: SortOrder
  }

  export type organograma_x_regiao_atuacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_atuacao_id?: SortOrder
  }

  export type organograma_x_regiao_atuacaoMinOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_atuacao_id?: SortOrder
  }

  export type organograma_x_regiao_atuacaoSumOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    regiao_atuacao_id?: SortOrder
  }

  export type UsuarioListRelationFilter = {
    every?: usuarioWhereInput
    some?: usuarioWhereInput
    none?: usuarioWhereInput
  }

  export type usuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pessoaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    sexo?: SortOrder
    nascimento?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
  }

  export type pessoaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pessoaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    sexo?: SortOrder
    nascimento?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
  }

  export type pessoaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    sexo?: SortOrder
    nascimento?: SortOrder
    cpf?: SortOrder
    rg?: SortOrder
  }

  export type pessoaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Plataforma_papel_tipoRelationFilter = {
    is?: plataforma_papel_tipoWhereInput
    isNot?: plataforma_papel_tipoWhereInput
  }

  export type Plataforma_x_regiao_atuacaoListRelationFilter = {
    every?: plataforma_x_regiao_atuacaoWhereInput
    some?: plataforma_x_regiao_atuacaoWhereInput
    none?: plataforma_x_regiao_atuacaoWhereInput
  }

  export type Plataforma_x_usuarioListRelationFilter = {
    every?: plataforma_x_usuarioWhereInput
    some?: plataforma_x_usuarioWhereInput
    none?: plataforma_x_usuarioWhereInput
  }

  export type plataforma_x_regiao_atuacaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type plataforma_x_usuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type plataformaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    plataforma_papel_tipo_id?: SortOrder
  }

  export type plataformaAvgOrderByAggregateInput = {
    id?: SortOrder
    plataforma_papel_tipo_id?: SortOrder
  }

  export type plataformaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    plataforma_papel_tipo_id?: SortOrder
  }

  export type plataformaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    plataforma_papel_tipo_id?: SortOrder
  }

  export type plataformaSumOrderByAggregateInput = {
    id?: SortOrder
    plataforma_papel_tipo_id?: SortOrder
  }

  export type PlataformaListRelationFilter = {
    every?: plataformaWhereInput
    some?: plataformaWhereInput
    none?: plataformaWhereInput
  }

  export type plataformaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type plataforma_papel_tipoCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_papel_tipoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_papel_tipoMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_papel_tipoMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plataforma_papel_tipoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PlataformaRelationFilter = {
    is?: plataformaWhereInput
    isNot?: plataformaWhereInput
  }

  export type plataforma_x_regiao_atuacaoCountOrderByAggregateInput = {
    id?: SortOrder
    plataforma_id?: SortOrder
    regiao_atuacao_id?: SortOrder
  }

  export type plataforma_x_regiao_atuacaoAvgOrderByAggregateInput = {
    id?: SortOrder
    plataforma_id?: SortOrder
    regiao_atuacao_id?: SortOrder
  }

  export type plataforma_x_regiao_atuacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    plataforma_id?: SortOrder
    regiao_atuacao_id?: SortOrder
  }

  export type plataforma_x_regiao_atuacaoMinOrderByAggregateInput = {
    id?: SortOrder
    plataforma_id?: SortOrder
    regiao_atuacao_id?: SortOrder
  }

  export type plataforma_x_regiao_atuacaoSumOrderByAggregateInput = {
    id?: SortOrder
    plataforma_id?: SortOrder
    regiao_atuacao_id?: SortOrder
  }

  export type Regiao_atuacao_tipoRelationFilter = {
    is?: regiao_atuacao_tipoWhereInput
    isNot?: regiao_atuacao_tipoWhereInput
  }

  export type regiao_atuacaoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    regiao_atuacao_tipo_id?: SortOrder
  }

  export type regiao_atuacaoAvgOrderByAggregateInput = {
    id?: SortOrder
    regiao_atuacao_tipo_id?: SortOrder
  }

  export type regiao_atuacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    regiao_atuacao_tipo_id?: SortOrder
  }

  export type regiao_atuacaoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    regiao_atuacao_tipo_id?: SortOrder
  }

  export type regiao_atuacaoSumOrderByAggregateInput = {
    id?: SortOrder
    regiao_atuacao_tipo_id?: SortOrder
  }

  export type Regiao_atuacaoListRelationFilter = {
    every?: regiao_atuacaoWhereInput
    some?: regiao_atuacaoWhereInput
    none?: regiao_atuacaoWhereInput
  }

  export type regiao_atuacaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type regiao_atuacao_tipoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type regiao_atuacao_tipoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type regiao_atuacao_tipoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type regiao_atuacao_tipoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type regiao_atuacao_tipoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type sacadoCountOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
  }

  export type sacadoAvgOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
  }

  export type sacadoMaxOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
  }

  export type sacadoMinOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
    razao_social?: SortOrder
    nome_fantasia?: SortOrder
    abertura?: SortOrder
    cnpj?: SortOrder
  }

  export type sacadoSumOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type Titulo_tipoRelationFilter = {
    is?: titulo_tipoWhereInput
    isNot?: titulo_tipoWhereInput
  }

  export type BorderoRelationFilter = {
    is?: borderoWhereInput
    isNot?: borderoWhereInput
  }

  export type Titulo_itensListRelationFilter = {
    every?: titulo_itensWhereInput
    some?: titulo_itensWhereInput
    none?: titulo_itensWhereInput
  }

  export type titulo_itensOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tituloCountOrderByAggregateInput = {
    id?: SortOrder
    titulo_tipo_id?: SortOrder
    bordero_id?: SortOrder
    nf?: SortOrder
    valor?: SortOrder
    vencimento?: SortOrder
    numero?: SortOrder
    emissao?: SortOrder
    parcela?: SortOrder
  }

  export type tituloAvgOrderByAggregateInput = {
    id?: SortOrder
    titulo_tipo_id?: SortOrder
    bordero_id?: SortOrder
    valor?: SortOrder
  }

  export type tituloMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo_tipo_id?: SortOrder
    bordero_id?: SortOrder
    nf?: SortOrder
    valor?: SortOrder
    vencimento?: SortOrder
    numero?: SortOrder
    emissao?: SortOrder
    parcela?: SortOrder
  }

  export type tituloMinOrderByAggregateInput = {
    id?: SortOrder
    titulo_tipo_id?: SortOrder
    bordero_id?: SortOrder
    nf?: SortOrder
    valor?: SortOrder
    vencimento?: SortOrder
    numero?: SortOrder
    emissao?: SortOrder
    parcela?: SortOrder
  }

  export type tituloSumOrderByAggregateInput = {
    id?: SortOrder
    titulo_tipo_id?: SortOrder
    bordero_id?: SortOrder
    valor?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type titulo_tipoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type titulo_tipoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type titulo_tipoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type titulo_tipoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type titulo_tipoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type PessoaRelationFilter = {
    is?: pessoaWhereInput
    isNot?: pessoaWhereInput
  }

  export type usuarioCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    pessoa_id?: SortOrder
    status?: SortOrder
    primeiro_acesso?: SortOrder
    confirmou_cadastro?: SortOrder
    codigo_confirma_cadastro?: SortOrder
    codigo_reset_senha?: SortOrder
    codigo_data_expiracao?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
  }

  export type usuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    pessoa_id?: SortOrder
    status?: SortOrder
    primeiro_acesso?: SortOrder
    confirmou_cadastro?: SortOrder
    codigo_confirma_cadastro?: SortOrder
    codigo_reset_senha?: SortOrder
    codigo_data_expiracao?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usuarioMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    pessoa_id?: SortOrder
    status?: SortOrder
    primeiro_acesso?: SortOrder
    confirmou_cadastro?: SortOrder
    codigo_confirma_cadastro?: SortOrder
    codigo_reset_senha?: SortOrder
    codigo_data_expiracao?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usuarioSumOrderByAggregateInput = {
    id?: SortOrder
    pessoa_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type Usuario_perfilListRelationFilter = {
    every?: usuario_perfilWhereInput
    some?: usuario_perfilWhereInput
    none?: usuario_perfilWhereInput
  }

  export type usuario_perfilOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuario_perfil_tipoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type usuario_perfil_tipoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usuario_perfil_tipoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type usuario_perfil_tipoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
  }

  export type usuario_perfil_tipoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type carteira_n_cedentesCountOrderByAggregateInput = {
    id?: SortOrder
    carteira_id?: SortOrder
    cedente_id?: SortOrder
  }

  export type carteira_n_cedentesAvgOrderByAggregateInput = {
    id?: SortOrder
    carteira_id?: SortOrder
    cedente_id?: SortOrder
  }

  export type carteira_n_cedentesMaxOrderByAggregateInput = {
    id?: SortOrder
    carteira_id?: SortOrder
    cedente_id?: SortOrder
  }

  export type carteira_n_cedentesMinOrderByAggregateInput = {
    id?: SortOrder
    carteira_id?: SortOrder
    cedente_id?: SortOrder
  }

  export type carteira_n_cedentesSumOrderByAggregateInput = {
    id?: SortOrder
    carteira_id?: SortOrder
    cedente_id?: SortOrder
  }

  export type organograma_x_usuarioCountOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type organograma_x_usuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type organograma_x_usuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type organograma_x_usuarioMinOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type organograma_x_usuarioSumOrderByAggregateInput = {
    id?: SortOrder
    organograma_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type plataforma_x_usuarioCountOrderByAggregateInput = {
    id?: SortOrder
    plataforma_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type plataforma_x_usuarioAvgOrderByAggregateInput = {
    id?: SortOrder
    plataforma_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type plataforma_x_usuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    plataforma_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type plataforma_x_usuarioMinOrderByAggregateInput = {
    id?: SortOrder
    plataforma_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type plataforma_x_usuarioSumOrderByAggregateInput = {
    id?: SortOrder
    plataforma_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type TituloRelationFilter = {
    is?: tituloWhereInput
    isNot?: tituloWhereInput
  }

  export type titulo_itensCountOrderByAggregateInput = {
    id?: SortOrder
    titulo_id?: SortOrder
  }

  export type titulo_itensAvgOrderByAggregateInput = {
    id?: SortOrder
    titulo_id?: SortOrder
  }

  export type titulo_itensMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo_id?: SortOrder
  }

  export type titulo_itensMinOrderByAggregateInput = {
    id?: SortOrder
    titulo_id?: SortOrder
  }

  export type titulo_itensSumOrderByAggregateInput = {
    id?: SortOrder
    titulo_id?: SortOrder
  }

  export type Usuario_perfil_tipoRelationFilter = {
    is?: usuario_perfil_tipoWhereInput
    isNot?: usuario_perfil_tipoWhereInput
  }

  export type usuario_perfilCountOrderByAggregateInput = {
    id?: SortOrder
    senha?: SortOrder
    usuario_id?: SortOrder
    usuario_perfil_tipo_id?: SortOrder
  }

  export type usuario_perfilAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    usuario_perfil_tipo_id?: SortOrder
  }

  export type usuario_perfilMaxOrderByAggregateInput = {
    id?: SortOrder
    senha?: SortOrder
    usuario_id?: SortOrder
    usuario_perfil_tipo_id?: SortOrder
  }

  export type usuario_perfilMinOrderByAggregateInput = {
    id?: SortOrder
    senha?: SortOrder
    usuario_id?: SortOrder
    usuario_perfil_tipo_id?: SortOrder
  }

  export type usuario_perfilSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    usuario_perfil_tipo_id?: SortOrder
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type carteiraCreateNestedOneWithoutBorderoInput = {
    create?: XOR<carteiraCreateWithoutBorderoInput, carteiraUncheckedCreateWithoutBorderoInput>
    connectOrCreate?: carteiraCreateOrConnectWithoutBorderoInput
    connect?: carteiraWhereUniqueInput
  }

  export type tituloCreateNestedManyWithoutBorderoInput = {
    create?: XOR<Enumerable<tituloCreateWithoutBorderoInput>, Enumerable<tituloUncheckedCreateWithoutBorderoInput>>
    connectOrCreate?: Enumerable<tituloCreateOrConnectWithoutBorderoInput>
    createMany?: tituloCreateManyBorderoInputEnvelope
    connect?: Enumerable<tituloWhereUniqueInput>
  }

  export type tituloUncheckedCreateNestedManyWithoutBorderoInput = {
    create?: XOR<Enumerable<tituloCreateWithoutBorderoInput>, Enumerable<tituloUncheckedCreateWithoutBorderoInput>>
    connectOrCreate?: Enumerable<tituloCreateOrConnectWithoutBorderoInput>
    createMany?: tituloCreateManyBorderoInputEnvelope
    connect?: Enumerable<tituloWhereUniqueInput>
  }

  export type carteiraUpdateOneRequiredWithoutBorderoNestedInput = {
    create?: XOR<carteiraCreateWithoutBorderoInput, carteiraUncheckedCreateWithoutBorderoInput>
    connectOrCreate?: carteiraCreateOrConnectWithoutBorderoInput
    upsert?: carteiraUpsertWithoutBorderoInput
    connect?: carteiraWhereUniqueInput
    update?: XOR<carteiraUpdateWithoutBorderoInput, carteiraUncheckedUpdateWithoutBorderoInput>
  }

  export type tituloUpdateManyWithoutBorderoNestedInput = {
    create?: XOR<Enumerable<tituloCreateWithoutBorderoInput>, Enumerable<tituloUncheckedCreateWithoutBorderoInput>>
    connectOrCreate?: Enumerable<tituloCreateOrConnectWithoutBorderoInput>
    upsert?: Enumerable<tituloUpsertWithWhereUniqueWithoutBorderoInput>
    createMany?: tituloCreateManyBorderoInputEnvelope
    set?: Enumerable<tituloWhereUniqueInput>
    disconnect?: Enumerable<tituloWhereUniqueInput>
    delete?: Enumerable<tituloWhereUniqueInput>
    connect?: Enumerable<tituloWhereUniqueInput>
    update?: Enumerable<tituloUpdateWithWhereUniqueWithoutBorderoInput>
    updateMany?: Enumerable<tituloUpdateManyWithWhereWithoutBorderoInput>
    deleteMany?: Enumerable<tituloScalarWhereInput>
  }

  export type tituloUncheckedUpdateManyWithoutBorderoNestedInput = {
    create?: XOR<Enumerable<tituloCreateWithoutBorderoInput>, Enumerable<tituloUncheckedCreateWithoutBorderoInput>>
    connectOrCreate?: Enumerable<tituloCreateOrConnectWithoutBorderoInput>
    upsert?: Enumerable<tituloUpsertWithWhereUniqueWithoutBorderoInput>
    createMany?: tituloCreateManyBorderoInputEnvelope
    set?: Enumerable<tituloWhereUniqueInput>
    disconnect?: Enumerable<tituloWhereUniqueInput>
    delete?: Enumerable<tituloWhereUniqueInput>
    connect?: Enumerable<tituloWhereUniqueInput>
    update?: Enumerable<tituloUpdateWithWhereUniqueWithoutBorderoInput>
    updateMany?: Enumerable<tituloUpdateManyWithWhereWithoutBorderoInput>
    deleteMany?: Enumerable<tituloScalarWhereInput>
  }

  export type fidic_fundoCreateNestedOneWithoutCarteiraInput = {
    create?: XOR<fidic_fundoCreateWithoutCarteiraInput, fidic_fundoUncheckedCreateWithoutCarteiraInput>
    connectOrCreate?: fidic_fundoCreateOrConnectWithoutCarteiraInput
    connect?: fidic_fundoWhereUniqueInput
  }

  export type borderoCreateNestedManyWithoutCarteiraInput = {
    create?: XOR<Enumerable<borderoCreateWithoutCarteiraInput>, Enumerable<borderoUncheckedCreateWithoutCarteiraInput>>
    connectOrCreate?: Enumerable<borderoCreateOrConnectWithoutCarteiraInput>
    createMany?: borderoCreateManyCarteiraInputEnvelope
    connect?: Enumerable<borderoWhereUniqueInput>
  }

  export type carteira_n_cedentesCreateNestedManyWithoutCarteiraInput = {
    create?: XOR<Enumerable<carteira_n_cedentesCreateWithoutCarteiraInput>, Enumerable<carteira_n_cedentesUncheckedCreateWithoutCarteiraInput>>
    connectOrCreate?: Enumerable<carteira_n_cedentesCreateOrConnectWithoutCarteiraInput>
    createMany?: carteira_n_cedentesCreateManyCarteiraInputEnvelope
    connect?: Enumerable<carteira_n_cedentesWhereUniqueInput>
  }

  export type borderoUncheckedCreateNestedManyWithoutCarteiraInput = {
    create?: XOR<Enumerable<borderoCreateWithoutCarteiraInput>, Enumerable<borderoUncheckedCreateWithoutCarteiraInput>>
    connectOrCreate?: Enumerable<borderoCreateOrConnectWithoutCarteiraInput>
    createMany?: borderoCreateManyCarteiraInputEnvelope
    connect?: Enumerable<borderoWhereUniqueInput>
  }

  export type carteira_n_cedentesUncheckedCreateNestedManyWithoutCarteiraInput = {
    create?: XOR<Enumerable<carteira_n_cedentesCreateWithoutCarteiraInput>, Enumerable<carteira_n_cedentesUncheckedCreateWithoutCarteiraInput>>
    connectOrCreate?: Enumerable<carteira_n_cedentesCreateOrConnectWithoutCarteiraInput>
    createMany?: carteira_n_cedentesCreateManyCarteiraInputEnvelope
    connect?: Enumerable<carteira_n_cedentesWhereUniqueInput>
  }

  export type fidic_fundoUpdateOneRequiredWithoutCarteiraNestedInput = {
    create?: XOR<fidic_fundoCreateWithoutCarteiraInput, fidic_fundoUncheckedCreateWithoutCarteiraInput>
    connectOrCreate?: fidic_fundoCreateOrConnectWithoutCarteiraInput
    upsert?: fidic_fundoUpsertWithoutCarteiraInput
    connect?: fidic_fundoWhereUniqueInput
    update?: XOR<fidic_fundoUpdateWithoutCarteiraInput, fidic_fundoUncheckedUpdateWithoutCarteiraInput>
  }

  export type borderoUpdateManyWithoutCarteiraNestedInput = {
    create?: XOR<Enumerable<borderoCreateWithoutCarteiraInput>, Enumerable<borderoUncheckedCreateWithoutCarteiraInput>>
    connectOrCreate?: Enumerable<borderoCreateOrConnectWithoutCarteiraInput>
    upsert?: Enumerable<borderoUpsertWithWhereUniqueWithoutCarteiraInput>
    createMany?: borderoCreateManyCarteiraInputEnvelope
    set?: Enumerable<borderoWhereUniqueInput>
    disconnect?: Enumerable<borderoWhereUniqueInput>
    delete?: Enumerable<borderoWhereUniqueInput>
    connect?: Enumerable<borderoWhereUniqueInput>
    update?: Enumerable<borderoUpdateWithWhereUniqueWithoutCarteiraInput>
    updateMany?: Enumerable<borderoUpdateManyWithWhereWithoutCarteiraInput>
    deleteMany?: Enumerable<borderoScalarWhereInput>
  }

  export type carteira_n_cedentesUpdateManyWithoutCarteiraNestedInput = {
    create?: XOR<Enumerable<carteira_n_cedentesCreateWithoutCarteiraInput>, Enumerable<carteira_n_cedentesUncheckedCreateWithoutCarteiraInput>>
    connectOrCreate?: Enumerable<carteira_n_cedentesCreateOrConnectWithoutCarteiraInput>
    upsert?: Enumerable<carteira_n_cedentesUpsertWithWhereUniqueWithoutCarteiraInput>
    createMany?: carteira_n_cedentesCreateManyCarteiraInputEnvelope
    set?: Enumerable<carteira_n_cedentesWhereUniqueInput>
    disconnect?: Enumerable<carteira_n_cedentesWhereUniqueInput>
    delete?: Enumerable<carteira_n_cedentesWhereUniqueInput>
    connect?: Enumerable<carteira_n_cedentesWhereUniqueInput>
    update?: Enumerable<carteira_n_cedentesUpdateWithWhereUniqueWithoutCarteiraInput>
    updateMany?: Enumerable<carteira_n_cedentesUpdateManyWithWhereWithoutCarteiraInput>
    deleteMany?: Enumerable<carteira_n_cedentesScalarWhereInput>
  }

  export type borderoUncheckedUpdateManyWithoutCarteiraNestedInput = {
    create?: XOR<Enumerable<borderoCreateWithoutCarteiraInput>, Enumerable<borderoUncheckedCreateWithoutCarteiraInput>>
    connectOrCreate?: Enumerable<borderoCreateOrConnectWithoutCarteiraInput>
    upsert?: Enumerable<borderoUpsertWithWhereUniqueWithoutCarteiraInput>
    createMany?: borderoCreateManyCarteiraInputEnvelope
    set?: Enumerable<borderoWhereUniqueInput>
    disconnect?: Enumerable<borderoWhereUniqueInput>
    delete?: Enumerable<borderoWhereUniqueInput>
    connect?: Enumerable<borderoWhereUniqueInput>
    update?: Enumerable<borderoUpdateWithWhereUniqueWithoutCarteiraInput>
    updateMany?: Enumerable<borderoUpdateManyWithWhereWithoutCarteiraInput>
    deleteMany?: Enumerable<borderoScalarWhereInput>
  }

  export type carteira_n_cedentesUncheckedUpdateManyWithoutCarteiraNestedInput = {
    create?: XOR<Enumerable<carteira_n_cedentesCreateWithoutCarteiraInput>, Enumerable<carteira_n_cedentesUncheckedCreateWithoutCarteiraInput>>
    connectOrCreate?: Enumerable<carteira_n_cedentesCreateOrConnectWithoutCarteiraInput>
    upsert?: Enumerable<carteira_n_cedentesUpsertWithWhereUniqueWithoutCarteiraInput>
    createMany?: carteira_n_cedentesCreateManyCarteiraInputEnvelope
    set?: Enumerable<carteira_n_cedentesWhereUniqueInput>
    disconnect?: Enumerable<carteira_n_cedentesWhereUniqueInput>
    delete?: Enumerable<carteira_n_cedentesWhereUniqueInput>
    connect?: Enumerable<carteira_n_cedentesWhereUniqueInput>
    update?: Enumerable<carteira_n_cedentesUpdateWithWhereUniqueWithoutCarteiraInput>
    updateMany?: Enumerable<carteira_n_cedentesUpdateManyWithWhereWithoutCarteiraInput>
    deleteMany?: Enumerable<carteira_n_cedentesScalarWhereInput>
  }

  export type carteira_n_cedentesCreateNestedManyWithoutCedenteInput = {
    create?: XOR<Enumerable<carteira_n_cedentesCreateWithoutCedenteInput>, Enumerable<carteira_n_cedentesUncheckedCreateWithoutCedenteInput>>
    connectOrCreate?: Enumerable<carteira_n_cedentesCreateOrConnectWithoutCedenteInput>
    createMany?: carteira_n_cedentesCreateManyCedenteInputEnvelope
    connect?: Enumerable<carteira_n_cedentesWhereUniqueInput>
  }

  export type cedente_analiseCreateNestedManyWithoutCedente_cedenteTocedente_analiseInput = {
    create?: XOR<Enumerable<cedente_analiseCreateWithoutCedente_cedenteTocedente_analiseInput>, Enumerable<cedente_analiseUncheckedCreateWithoutCedente_cedenteTocedente_analiseInput>>
    connectOrCreate?: Enumerable<cedente_analiseCreateOrConnectWithoutCedente_cedenteTocedente_analiseInput>
    createMany?: cedente_analiseCreateManyCedente_cedenteTocedente_analiseInputEnvelope
    connect?: Enumerable<cedente_analiseWhereUniqueInput>
  }

  export type cedente_n_sacadosCreateNestedManyWithoutCedente_cedenteTocedente_n_sacadosInput = {
    create?: XOR<Enumerable<cedente_n_sacadosCreateWithoutCedente_cedenteTocedente_n_sacadosInput>, Enumerable<cedente_n_sacadosUncheckedCreateWithoutCedente_cedenteTocedente_n_sacadosInput>>
    connectOrCreate?: Enumerable<cedente_n_sacadosCreateOrConnectWithoutCedente_cedenteTocedente_n_sacadosInput>
    createMany?: cedente_n_sacadosCreateManyCedente_cedenteTocedente_n_sacadosInputEnvelope
    connect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
  }

  export type carteira_n_cedentesUncheckedCreateNestedManyWithoutCedenteInput = {
    create?: XOR<Enumerable<carteira_n_cedentesCreateWithoutCedenteInput>, Enumerable<carteira_n_cedentesUncheckedCreateWithoutCedenteInput>>
    connectOrCreate?: Enumerable<carteira_n_cedentesCreateOrConnectWithoutCedenteInput>
    createMany?: carteira_n_cedentesCreateManyCedenteInputEnvelope
    connect?: Enumerable<carteira_n_cedentesWhereUniqueInput>
  }

  export type cedente_analiseUncheckedCreateNestedManyWithoutCedente_cedenteTocedente_analiseInput = {
    create?: XOR<Enumerable<cedente_analiseCreateWithoutCedente_cedenteTocedente_analiseInput>, Enumerable<cedente_analiseUncheckedCreateWithoutCedente_cedenteTocedente_analiseInput>>
    connectOrCreate?: Enumerable<cedente_analiseCreateOrConnectWithoutCedente_cedenteTocedente_analiseInput>
    createMany?: cedente_analiseCreateManyCedente_cedenteTocedente_analiseInputEnvelope
    connect?: Enumerable<cedente_analiseWhereUniqueInput>
  }

  export type cedente_n_sacadosUncheckedCreateNestedManyWithoutCedente_cedenteTocedente_n_sacadosInput = {
    create?: XOR<Enumerable<cedente_n_sacadosCreateWithoutCedente_cedenteTocedente_n_sacadosInput>, Enumerable<cedente_n_sacadosUncheckedCreateWithoutCedente_cedenteTocedente_n_sacadosInput>>
    connectOrCreate?: Enumerable<cedente_n_sacadosCreateOrConnectWithoutCedente_cedenteTocedente_n_sacadosInput>
    createMany?: cedente_n_sacadosCreateManyCedente_cedenteTocedente_n_sacadosInputEnvelope
    connect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type carteira_n_cedentesUpdateManyWithoutCedenteNestedInput = {
    create?: XOR<Enumerable<carteira_n_cedentesCreateWithoutCedenteInput>, Enumerable<carteira_n_cedentesUncheckedCreateWithoutCedenteInput>>
    connectOrCreate?: Enumerable<carteira_n_cedentesCreateOrConnectWithoutCedenteInput>
    upsert?: Enumerable<carteira_n_cedentesUpsertWithWhereUniqueWithoutCedenteInput>
    createMany?: carteira_n_cedentesCreateManyCedenteInputEnvelope
    set?: Enumerable<carteira_n_cedentesWhereUniqueInput>
    disconnect?: Enumerable<carteira_n_cedentesWhereUniqueInput>
    delete?: Enumerable<carteira_n_cedentesWhereUniqueInput>
    connect?: Enumerable<carteira_n_cedentesWhereUniqueInput>
    update?: Enumerable<carteira_n_cedentesUpdateWithWhereUniqueWithoutCedenteInput>
    updateMany?: Enumerable<carteira_n_cedentesUpdateManyWithWhereWithoutCedenteInput>
    deleteMany?: Enumerable<carteira_n_cedentesScalarWhereInput>
  }

  export type cedente_analiseUpdateManyWithoutCedente_cedenteTocedente_analiseNestedInput = {
    create?: XOR<Enumerable<cedente_analiseCreateWithoutCedente_cedenteTocedente_analiseInput>, Enumerable<cedente_analiseUncheckedCreateWithoutCedente_cedenteTocedente_analiseInput>>
    connectOrCreate?: Enumerable<cedente_analiseCreateOrConnectWithoutCedente_cedenteTocedente_analiseInput>
    upsert?: Enumerable<cedente_analiseUpsertWithWhereUniqueWithoutCedente_cedenteTocedente_analiseInput>
    createMany?: cedente_analiseCreateManyCedente_cedenteTocedente_analiseInputEnvelope
    set?: Enumerable<cedente_analiseWhereUniqueInput>
    disconnect?: Enumerable<cedente_analiseWhereUniqueInput>
    delete?: Enumerable<cedente_analiseWhereUniqueInput>
    connect?: Enumerable<cedente_analiseWhereUniqueInput>
    update?: Enumerable<cedente_analiseUpdateWithWhereUniqueWithoutCedente_cedenteTocedente_analiseInput>
    updateMany?: Enumerable<cedente_analiseUpdateManyWithWhereWithoutCedente_cedenteTocedente_analiseInput>
    deleteMany?: Enumerable<cedente_analiseScalarWhereInput>
  }

  export type cedente_n_sacadosUpdateManyWithoutCedente_cedenteTocedente_n_sacadosNestedInput = {
    create?: XOR<Enumerable<cedente_n_sacadosCreateWithoutCedente_cedenteTocedente_n_sacadosInput>, Enumerable<cedente_n_sacadosUncheckedCreateWithoutCedente_cedenteTocedente_n_sacadosInput>>
    connectOrCreate?: Enumerable<cedente_n_sacadosCreateOrConnectWithoutCedente_cedenteTocedente_n_sacadosInput>
    upsert?: Enumerable<cedente_n_sacadosUpsertWithWhereUniqueWithoutCedente_cedenteTocedente_n_sacadosInput>
    createMany?: cedente_n_sacadosCreateManyCedente_cedenteTocedente_n_sacadosInputEnvelope
    set?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    disconnect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    delete?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    connect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    update?: Enumerable<cedente_n_sacadosUpdateWithWhereUniqueWithoutCedente_cedenteTocedente_n_sacadosInput>
    updateMany?: Enumerable<cedente_n_sacadosUpdateManyWithWhereWithoutCedente_cedenteTocedente_n_sacadosInput>
    deleteMany?: Enumerable<cedente_n_sacadosScalarWhereInput>
  }

  export type carteira_n_cedentesUncheckedUpdateManyWithoutCedenteNestedInput = {
    create?: XOR<Enumerable<carteira_n_cedentesCreateWithoutCedenteInput>, Enumerable<carteira_n_cedentesUncheckedCreateWithoutCedenteInput>>
    connectOrCreate?: Enumerable<carteira_n_cedentesCreateOrConnectWithoutCedenteInput>
    upsert?: Enumerable<carteira_n_cedentesUpsertWithWhereUniqueWithoutCedenteInput>
    createMany?: carteira_n_cedentesCreateManyCedenteInputEnvelope
    set?: Enumerable<carteira_n_cedentesWhereUniqueInput>
    disconnect?: Enumerable<carteira_n_cedentesWhereUniqueInput>
    delete?: Enumerable<carteira_n_cedentesWhereUniqueInput>
    connect?: Enumerable<carteira_n_cedentesWhereUniqueInput>
    update?: Enumerable<carteira_n_cedentesUpdateWithWhereUniqueWithoutCedenteInput>
    updateMany?: Enumerable<carteira_n_cedentesUpdateManyWithWhereWithoutCedenteInput>
    deleteMany?: Enumerable<carteira_n_cedentesScalarWhereInput>
  }

  export type cedente_analiseUncheckedUpdateManyWithoutCedente_cedenteTocedente_analiseNestedInput = {
    create?: XOR<Enumerable<cedente_analiseCreateWithoutCedente_cedenteTocedente_analiseInput>, Enumerable<cedente_analiseUncheckedCreateWithoutCedente_cedenteTocedente_analiseInput>>
    connectOrCreate?: Enumerable<cedente_analiseCreateOrConnectWithoutCedente_cedenteTocedente_analiseInput>
    upsert?: Enumerable<cedente_analiseUpsertWithWhereUniqueWithoutCedente_cedenteTocedente_analiseInput>
    createMany?: cedente_analiseCreateManyCedente_cedenteTocedente_analiseInputEnvelope
    set?: Enumerable<cedente_analiseWhereUniqueInput>
    disconnect?: Enumerable<cedente_analiseWhereUniqueInput>
    delete?: Enumerable<cedente_analiseWhereUniqueInput>
    connect?: Enumerable<cedente_analiseWhereUniqueInput>
    update?: Enumerable<cedente_analiseUpdateWithWhereUniqueWithoutCedente_cedenteTocedente_analiseInput>
    updateMany?: Enumerable<cedente_analiseUpdateManyWithWhereWithoutCedente_cedenteTocedente_analiseInput>
    deleteMany?: Enumerable<cedente_analiseScalarWhereInput>
  }

  export type cedente_n_sacadosUncheckedUpdateManyWithoutCedente_cedenteTocedente_n_sacadosNestedInput = {
    create?: XOR<Enumerable<cedente_n_sacadosCreateWithoutCedente_cedenteTocedente_n_sacadosInput>, Enumerable<cedente_n_sacadosUncheckedCreateWithoutCedente_cedenteTocedente_n_sacadosInput>>
    connectOrCreate?: Enumerable<cedente_n_sacadosCreateOrConnectWithoutCedente_cedenteTocedente_n_sacadosInput>
    upsert?: Enumerable<cedente_n_sacadosUpsertWithWhereUniqueWithoutCedente_cedenteTocedente_n_sacadosInput>
    createMany?: cedente_n_sacadosCreateManyCedente_cedenteTocedente_n_sacadosInputEnvelope
    set?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    disconnect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    delete?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    connect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    update?: Enumerable<cedente_n_sacadosUpdateWithWhereUniqueWithoutCedente_cedenteTocedente_n_sacadosInput>
    updateMany?: Enumerable<cedente_n_sacadosUpdateManyWithWhereWithoutCedente_cedenteTocedente_n_sacadosInput>
    deleteMany?: Enumerable<cedente_n_sacadosScalarWhereInput>
  }

  export type cedenteCreateNestedOneWithoutCedente_analiseInput = {
    create?: XOR<cedenteCreateWithoutCedente_analiseInput, cedenteUncheckedCreateWithoutCedente_analiseInput>
    connectOrCreate?: cedenteCreateOrConnectWithoutCedente_analiseInput
    connect?: cedenteWhereUniqueInput
  }

  export type cedenteUpdateOneWithoutCedente_analiseNestedInput = {
    create?: XOR<cedenteCreateWithoutCedente_analiseInput, cedenteUncheckedCreateWithoutCedente_analiseInput>
    connectOrCreate?: cedenteCreateOrConnectWithoutCedente_analiseInput
    upsert?: cedenteUpsertWithoutCedente_analiseInput
    disconnect?: boolean
    delete?: boolean
    connect?: cedenteWhereUniqueInput
    update?: XOR<cedenteUpdateWithoutCedente_analiseInput, cedenteUncheckedUpdateWithoutCedente_analiseInput>
  }

  export type cedenteCreateNestedOneWithoutCedente_n_sacadosInput = {
    create?: XOR<cedenteCreateWithoutCedente_n_sacadosInput, cedenteUncheckedCreateWithoutCedente_n_sacadosInput>
    connectOrCreate?: cedenteCreateOrConnectWithoutCedente_n_sacadosInput
    connect?: cedenteWhereUniqueInput
  }

  export type sacadoCreateNestedOneWithoutCedente_n_sacadosInput = {
    create?: XOR<sacadoCreateWithoutCedente_n_sacadosInput, sacadoUncheckedCreateWithoutCedente_n_sacadosInput>
    connectOrCreate?: sacadoCreateOrConnectWithoutCedente_n_sacadosInput
    connect?: sacadoWhereUniqueInput
  }

  export type cedenteUpdateOneWithoutCedente_n_sacadosNestedInput = {
    create?: XOR<cedenteCreateWithoutCedente_n_sacadosInput, cedenteUncheckedCreateWithoutCedente_n_sacadosInput>
    connectOrCreate?: cedenteCreateOrConnectWithoutCedente_n_sacadosInput
    upsert?: cedenteUpsertWithoutCedente_n_sacadosInput
    disconnect?: boolean
    delete?: boolean
    connect?: cedenteWhereUniqueInput
    update?: XOR<cedenteUpdateWithoutCedente_n_sacadosInput, cedenteUncheckedUpdateWithoutCedente_n_sacadosInput>
  }

  export type sacadoUpdateOneWithoutCedente_n_sacadosNestedInput = {
    create?: XOR<sacadoCreateWithoutCedente_n_sacadosInput, sacadoUncheckedCreateWithoutCedente_n_sacadosInput>
    connectOrCreate?: sacadoCreateOrConnectWithoutCedente_n_sacadosInput
    upsert?: sacadoUpsertWithoutCedente_n_sacadosInput
    disconnect?: boolean
    delete?: boolean
    connect?: sacadoWhereUniqueInput
    update?: XOR<sacadoUpdateWithoutCedente_n_sacadosInput, sacadoUncheckedUpdateWithoutCedente_n_sacadosInput>
  }

  export type carteiraCreateNestedManyWithoutFidic_fundoInput = {
    create?: XOR<Enumerable<carteiraCreateWithoutFidic_fundoInput>, Enumerable<carteiraUncheckedCreateWithoutFidic_fundoInput>>
    connectOrCreate?: Enumerable<carteiraCreateOrConnectWithoutFidic_fundoInput>
    createMany?: carteiraCreateManyFidic_fundoInputEnvelope
    connect?: Enumerable<carteiraWhereUniqueInput>
  }

  export type fidic_fundo_x_usuarioCreateNestedManyWithoutFidic_fundoInput = {
    create?: XOR<Enumerable<fidic_fundo_x_usuarioCreateWithoutFidic_fundoInput>, Enumerable<fidic_fundo_x_usuarioUncheckedCreateWithoutFidic_fundoInput>>
    connectOrCreate?: Enumerable<fidic_fundo_x_usuarioCreateOrConnectWithoutFidic_fundoInput>
    createMany?: fidic_fundo_x_usuarioCreateManyFidic_fundoInputEnvelope
    connect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
  }

  export type carteiraUncheckedCreateNestedManyWithoutFidic_fundoInput = {
    create?: XOR<Enumerable<carteiraCreateWithoutFidic_fundoInput>, Enumerable<carteiraUncheckedCreateWithoutFidic_fundoInput>>
    connectOrCreate?: Enumerable<carteiraCreateOrConnectWithoutFidic_fundoInput>
    createMany?: carteiraCreateManyFidic_fundoInputEnvelope
    connect?: Enumerable<carteiraWhereUniqueInput>
  }

  export type fidic_fundo_x_usuarioUncheckedCreateNestedManyWithoutFidic_fundoInput = {
    create?: XOR<Enumerable<fidic_fundo_x_usuarioCreateWithoutFidic_fundoInput>, Enumerable<fidic_fundo_x_usuarioUncheckedCreateWithoutFidic_fundoInput>>
    connectOrCreate?: Enumerable<fidic_fundo_x_usuarioCreateOrConnectWithoutFidic_fundoInput>
    createMany?: fidic_fundo_x_usuarioCreateManyFidic_fundoInputEnvelope
    connect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
  }

  export type carteiraUpdateManyWithoutFidic_fundoNestedInput = {
    create?: XOR<Enumerable<carteiraCreateWithoutFidic_fundoInput>, Enumerable<carteiraUncheckedCreateWithoutFidic_fundoInput>>
    connectOrCreate?: Enumerable<carteiraCreateOrConnectWithoutFidic_fundoInput>
    upsert?: Enumerable<carteiraUpsertWithWhereUniqueWithoutFidic_fundoInput>
    createMany?: carteiraCreateManyFidic_fundoInputEnvelope
    set?: Enumerable<carteiraWhereUniqueInput>
    disconnect?: Enumerable<carteiraWhereUniqueInput>
    delete?: Enumerable<carteiraWhereUniqueInput>
    connect?: Enumerable<carteiraWhereUniqueInput>
    update?: Enumerable<carteiraUpdateWithWhereUniqueWithoutFidic_fundoInput>
    updateMany?: Enumerable<carteiraUpdateManyWithWhereWithoutFidic_fundoInput>
    deleteMany?: Enumerable<carteiraScalarWhereInput>
  }

  export type fidic_fundo_x_usuarioUpdateManyWithoutFidic_fundoNestedInput = {
    create?: XOR<Enumerable<fidic_fundo_x_usuarioCreateWithoutFidic_fundoInput>, Enumerable<fidic_fundo_x_usuarioUncheckedCreateWithoutFidic_fundoInput>>
    connectOrCreate?: Enumerable<fidic_fundo_x_usuarioCreateOrConnectWithoutFidic_fundoInput>
    upsert?: Enumerable<fidic_fundo_x_usuarioUpsertWithWhereUniqueWithoutFidic_fundoInput>
    createMany?: fidic_fundo_x_usuarioCreateManyFidic_fundoInputEnvelope
    set?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    disconnect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    delete?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    connect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    update?: Enumerable<fidic_fundo_x_usuarioUpdateWithWhereUniqueWithoutFidic_fundoInput>
    updateMany?: Enumerable<fidic_fundo_x_usuarioUpdateManyWithWhereWithoutFidic_fundoInput>
    deleteMany?: Enumerable<fidic_fundo_x_usuarioScalarWhereInput>
  }

  export type carteiraUncheckedUpdateManyWithoutFidic_fundoNestedInput = {
    create?: XOR<Enumerable<carteiraCreateWithoutFidic_fundoInput>, Enumerable<carteiraUncheckedCreateWithoutFidic_fundoInput>>
    connectOrCreate?: Enumerable<carteiraCreateOrConnectWithoutFidic_fundoInput>
    upsert?: Enumerable<carteiraUpsertWithWhereUniqueWithoutFidic_fundoInput>
    createMany?: carteiraCreateManyFidic_fundoInputEnvelope
    set?: Enumerable<carteiraWhereUniqueInput>
    disconnect?: Enumerable<carteiraWhereUniqueInput>
    delete?: Enumerable<carteiraWhereUniqueInput>
    connect?: Enumerable<carteiraWhereUniqueInput>
    update?: Enumerable<carteiraUpdateWithWhereUniqueWithoutFidic_fundoInput>
    updateMany?: Enumerable<carteiraUpdateManyWithWhereWithoutFidic_fundoInput>
    deleteMany?: Enumerable<carteiraScalarWhereInput>
  }

  export type fidic_fundo_x_usuarioUncheckedUpdateManyWithoutFidic_fundoNestedInput = {
    create?: XOR<Enumerable<fidic_fundo_x_usuarioCreateWithoutFidic_fundoInput>, Enumerable<fidic_fundo_x_usuarioUncheckedCreateWithoutFidic_fundoInput>>
    connectOrCreate?: Enumerable<fidic_fundo_x_usuarioCreateOrConnectWithoutFidic_fundoInput>
    upsert?: Enumerable<fidic_fundo_x_usuarioUpsertWithWhereUniqueWithoutFidic_fundoInput>
    createMany?: fidic_fundo_x_usuarioCreateManyFidic_fundoInputEnvelope
    set?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    disconnect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    delete?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    connect?: Enumerable<fidic_fundo_x_usuarioWhereUniqueInput>
    update?: Enumerable<fidic_fundo_x_usuarioUpdateWithWhereUniqueWithoutFidic_fundoInput>
    updateMany?: Enumerable<fidic_fundo_x_usuarioUpdateManyWithWhereWithoutFidic_fundoInput>
    deleteMany?: Enumerable<fidic_fundo_x_usuarioScalarWhereInput>
  }

  export type fidic_fundoCreateNestedOneWithoutFidic_fundo_x_usuarioInput = {
    create?: XOR<fidic_fundoCreateWithoutFidic_fundo_x_usuarioInput, fidic_fundoUncheckedCreateWithoutFidic_fundo_x_usuarioInput>
    connectOrCreate?: fidic_fundoCreateOrConnectWithoutFidic_fundo_x_usuarioInput
    connect?: fidic_fundoWhereUniqueInput
  }

  export type fidic_fundoUpdateOneRequiredWithoutFidic_fundo_x_usuarioNestedInput = {
    create?: XOR<fidic_fundoCreateWithoutFidic_fundo_x_usuarioInput, fidic_fundoUncheckedCreateWithoutFidic_fundo_x_usuarioInput>
    connectOrCreate?: fidic_fundoCreateOrConnectWithoutFidic_fundo_x_usuarioInput
    upsert?: fidic_fundoUpsertWithoutFidic_fundo_x_usuarioInput
    connect?: fidic_fundoWhereUniqueInput
    update?: XOR<fidic_fundoUpdateWithoutFidic_fundo_x_usuarioInput, fidic_fundoUncheckedUpdateWithoutFidic_fundo_x_usuarioInput>
  }

  export type organograma_tipoCreateNestedOneWithoutOrganogramaInput = {
    create?: XOR<organograma_tipoCreateWithoutOrganogramaInput, organograma_tipoUncheckedCreateWithoutOrganogramaInput>
    connectOrCreate?: organograma_tipoCreateOrConnectWithoutOrganogramaInput
    connect?: organograma_tipoWhereUniqueInput
  }

  export type organograma_x_regiao_atuacaoCreateNestedManyWithoutOrganogramaInput = {
    create?: XOR<Enumerable<organograma_x_regiao_atuacaoCreateWithoutOrganogramaInput>, Enumerable<organograma_x_regiao_atuacaoUncheckedCreateWithoutOrganogramaInput>>
    connectOrCreate?: Enumerable<organograma_x_regiao_atuacaoCreateOrConnectWithoutOrganogramaInput>
    createMany?: organograma_x_regiao_atuacaoCreateManyOrganogramaInputEnvelope
    connect?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
  }

  export type organograma_x_usuarioCreateNestedManyWithoutOrganogramaInput = {
    create?: XOR<Enumerable<organograma_x_usuarioCreateWithoutOrganogramaInput>, Enumerable<organograma_x_usuarioUncheckedCreateWithoutOrganogramaInput>>
    connectOrCreate?: Enumerable<organograma_x_usuarioCreateOrConnectWithoutOrganogramaInput>
    createMany?: organograma_x_usuarioCreateManyOrganogramaInputEnvelope
    connect?: Enumerable<organograma_x_usuarioWhereUniqueInput>
  }

  export type organograma_x_regiao_atuacaoUncheckedCreateNestedManyWithoutOrganogramaInput = {
    create?: XOR<Enumerable<organograma_x_regiao_atuacaoCreateWithoutOrganogramaInput>, Enumerable<organograma_x_regiao_atuacaoUncheckedCreateWithoutOrganogramaInput>>
    connectOrCreate?: Enumerable<organograma_x_regiao_atuacaoCreateOrConnectWithoutOrganogramaInput>
    createMany?: organograma_x_regiao_atuacaoCreateManyOrganogramaInputEnvelope
    connect?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
  }

  export type organograma_x_usuarioUncheckedCreateNestedManyWithoutOrganogramaInput = {
    create?: XOR<Enumerable<organograma_x_usuarioCreateWithoutOrganogramaInput>, Enumerable<organograma_x_usuarioUncheckedCreateWithoutOrganogramaInput>>
    connectOrCreate?: Enumerable<organograma_x_usuarioCreateOrConnectWithoutOrganogramaInput>
    createMany?: organograma_x_usuarioCreateManyOrganogramaInputEnvelope
    connect?: Enumerable<organograma_x_usuarioWhereUniqueInput>
  }

  export type organograma_tipoUpdateOneRequiredWithoutOrganogramaNestedInput = {
    create?: XOR<organograma_tipoCreateWithoutOrganogramaInput, organograma_tipoUncheckedCreateWithoutOrganogramaInput>
    connectOrCreate?: organograma_tipoCreateOrConnectWithoutOrganogramaInput
    upsert?: organograma_tipoUpsertWithoutOrganogramaInput
    connect?: organograma_tipoWhereUniqueInput
    update?: XOR<organograma_tipoUpdateWithoutOrganogramaInput, organograma_tipoUncheckedUpdateWithoutOrganogramaInput>
  }

  export type organograma_x_regiao_atuacaoUpdateManyWithoutOrganogramaNestedInput = {
    create?: XOR<Enumerable<organograma_x_regiao_atuacaoCreateWithoutOrganogramaInput>, Enumerable<organograma_x_regiao_atuacaoUncheckedCreateWithoutOrganogramaInput>>
    connectOrCreate?: Enumerable<organograma_x_regiao_atuacaoCreateOrConnectWithoutOrganogramaInput>
    upsert?: Enumerable<organograma_x_regiao_atuacaoUpsertWithWhereUniqueWithoutOrganogramaInput>
    createMany?: organograma_x_regiao_atuacaoCreateManyOrganogramaInputEnvelope
    set?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
    disconnect?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
    delete?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
    connect?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
    update?: Enumerable<organograma_x_regiao_atuacaoUpdateWithWhereUniqueWithoutOrganogramaInput>
    updateMany?: Enumerable<organograma_x_regiao_atuacaoUpdateManyWithWhereWithoutOrganogramaInput>
    deleteMany?: Enumerable<organograma_x_regiao_atuacaoScalarWhereInput>
  }

  export type organograma_x_usuarioUpdateManyWithoutOrganogramaNestedInput = {
    create?: XOR<Enumerable<organograma_x_usuarioCreateWithoutOrganogramaInput>, Enumerable<organograma_x_usuarioUncheckedCreateWithoutOrganogramaInput>>
    connectOrCreate?: Enumerable<organograma_x_usuarioCreateOrConnectWithoutOrganogramaInput>
    upsert?: Enumerable<organograma_x_usuarioUpsertWithWhereUniqueWithoutOrganogramaInput>
    createMany?: organograma_x_usuarioCreateManyOrganogramaInputEnvelope
    set?: Enumerable<organograma_x_usuarioWhereUniqueInput>
    disconnect?: Enumerable<organograma_x_usuarioWhereUniqueInput>
    delete?: Enumerable<organograma_x_usuarioWhereUniqueInput>
    connect?: Enumerable<organograma_x_usuarioWhereUniqueInput>
    update?: Enumerable<organograma_x_usuarioUpdateWithWhereUniqueWithoutOrganogramaInput>
    updateMany?: Enumerable<organograma_x_usuarioUpdateManyWithWhereWithoutOrganogramaInput>
    deleteMany?: Enumerable<organograma_x_usuarioScalarWhereInput>
  }

  export type organograma_x_regiao_atuacaoUncheckedUpdateManyWithoutOrganogramaNestedInput = {
    create?: XOR<Enumerable<organograma_x_regiao_atuacaoCreateWithoutOrganogramaInput>, Enumerable<organograma_x_regiao_atuacaoUncheckedCreateWithoutOrganogramaInput>>
    connectOrCreate?: Enumerable<organograma_x_regiao_atuacaoCreateOrConnectWithoutOrganogramaInput>
    upsert?: Enumerable<organograma_x_regiao_atuacaoUpsertWithWhereUniqueWithoutOrganogramaInput>
    createMany?: organograma_x_regiao_atuacaoCreateManyOrganogramaInputEnvelope
    set?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
    disconnect?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
    delete?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
    connect?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
    update?: Enumerable<organograma_x_regiao_atuacaoUpdateWithWhereUniqueWithoutOrganogramaInput>
    updateMany?: Enumerable<organograma_x_regiao_atuacaoUpdateManyWithWhereWithoutOrganogramaInput>
    deleteMany?: Enumerable<organograma_x_regiao_atuacaoScalarWhereInput>
  }

  export type organograma_x_usuarioUncheckedUpdateManyWithoutOrganogramaNestedInput = {
    create?: XOR<Enumerable<organograma_x_usuarioCreateWithoutOrganogramaInput>, Enumerable<organograma_x_usuarioUncheckedCreateWithoutOrganogramaInput>>
    connectOrCreate?: Enumerable<organograma_x_usuarioCreateOrConnectWithoutOrganogramaInput>
    upsert?: Enumerable<organograma_x_usuarioUpsertWithWhereUniqueWithoutOrganogramaInput>
    createMany?: organograma_x_usuarioCreateManyOrganogramaInputEnvelope
    set?: Enumerable<organograma_x_usuarioWhereUniqueInput>
    disconnect?: Enumerable<organograma_x_usuarioWhereUniqueInput>
    delete?: Enumerable<organograma_x_usuarioWhereUniqueInput>
    connect?: Enumerable<organograma_x_usuarioWhereUniqueInput>
    update?: Enumerable<organograma_x_usuarioUpdateWithWhereUniqueWithoutOrganogramaInput>
    updateMany?: Enumerable<organograma_x_usuarioUpdateManyWithWhereWithoutOrganogramaInput>
    deleteMany?: Enumerable<organograma_x_usuarioScalarWhereInput>
  }

  export type organogramaCreateNestedManyWithoutOrganograma_tipoInput = {
    create?: XOR<Enumerable<organogramaCreateWithoutOrganograma_tipoInput>, Enumerable<organogramaUncheckedCreateWithoutOrganograma_tipoInput>>
    connectOrCreate?: Enumerable<organogramaCreateOrConnectWithoutOrganograma_tipoInput>
    createMany?: organogramaCreateManyOrganograma_tipoInputEnvelope
    connect?: Enumerable<organogramaWhereUniqueInput>
  }

  export type organogramaUncheckedCreateNestedManyWithoutOrganograma_tipoInput = {
    create?: XOR<Enumerable<organogramaCreateWithoutOrganograma_tipoInput>, Enumerable<organogramaUncheckedCreateWithoutOrganograma_tipoInput>>
    connectOrCreate?: Enumerable<organogramaCreateOrConnectWithoutOrganograma_tipoInput>
    createMany?: organogramaCreateManyOrganograma_tipoInputEnvelope
    connect?: Enumerable<organogramaWhereUniqueInput>
  }

  export type organogramaUpdateManyWithoutOrganograma_tipoNestedInput = {
    create?: XOR<Enumerable<organogramaCreateWithoutOrganograma_tipoInput>, Enumerable<organogramaUncheckedCreateWithoutOrganograma_tipoInput>>
    connectOrCreate?: Enumerable<organogramaCreateOrConnectWithoutOrganograma_tipoInput>
    upsert?: Enumerable<organogramaUpsertWithWhereUniqueWithoutOrganograma_tipoInput>
    createMany?: organogramaCreateManyOrganograma_tipoInputEnvelope
    set?: Enumerable<organogramaWhereUniqueInput>
    disconnect?: Enumerable<organogramaWhereUniqueInput>
    delete?: Enumerable<organogramaWhereUniqueInput>
    connect?: Enumerable<organogramaWhereUniqueInput>
    update?: Enumerable<organogramaUpdateWithWhereUniqueWithoutOrganograma_tipoInput>
    updateMany?: Enumerable<organogramaUpdateManyWithWhereWithoutOrganograma_tipoInput>
    deleteMany?: Enumerable<organogramaScalarWhereInput>
  }

  export type organogramaUncheckedUpdateManyWithoutOrganograma_tipoNestedInput = {
    create?: XOR<Enumerable<organogramaCreateWithoutOrganograma_tipoInput>, Enumerable<organogramaUncheckedCreateWithoutOrganograma_tipoInput>>
    connectOrCreate?: Enumerable<organogramaCreateOrConnectWithoutOrganograma_tipoInput>
    upsert?: Enumerable<organogramaUpsertWithWhereUniqueWithoutOrganograma_tipoInput>
    createMany?: organogramaCreateManyOrganograma_tipoInputEnvelope
    set?: Enumerable<organogramaWhereUniqueInput>
    disconnect?: Enumerable<organogramaWhereUniqueInput>
    delete?: Enumerable<organogramaWhereUniqueInput>
    connect?: Enumerable<organogramaWhereUniqueInput>
    update?: Enumerable<organogramaUpdateWithWhereUniqueWithoutOrganograma_tipoInput>
    updateMany?: Enumerable<organogramaUpdateManyWithWhereWithoutOrganograma_tipoInput>
    deleteMany?: Enumerable<organogramaScalarWhereInput>
  }

  export type organogramaCreateNestedOneWithoutOrganograma_x_regiao_atuacaoInput = {
    create?: XOR<organogramaCreateWithoutOrganograma_x_regiao_atuacaoInput, organogramaUncheckedCreateWithoutOrganograma_x_regiao_atuacaoInput>
    connectOrCreate?: organogramaCreateOrConnectWithoutOrganograma_x_regiao_atuacaoInput
    connect?: organogramaWhereUniqueInput
  }

  export type regiao_atuacaoCreateNestedOneWithoutOrganograma_x_regiao_atuacaoInput = {
    create?: XOR<regiao_atuacaoCreateWithoutOrganograma_x_regiao_atuacaoInput, regiao_atuacaoUncheckedCreateWithoutOrganograma_x_regiao_atuacaoInput>
    connectOrCreate?: regiao_atuacaoCreateOrConnectWithoutOrganograma_x_regiao_atuacaoInput
    connect?: regiao_atuacaoWhereUniqueInput
  }

  export type organogramaUpdateOneRequiredWithoutOrganograma_x_regiao_atuacaoNestedInput = {
    create?: XOR<organogramaCreateWithoutOrganograma_x_regiao_atuacaoInput, organogramaUncheckedCreateWithoutOrganograma_x_regiao_atuacaoInput>
    connectOrCreate?: organogramaCreateOrConnectWithoutOrganograma_x_regiao_atuacaoInput
    upsert?: organogramaUpsertWithoutOrganograma_x_regiao_atuacaoInput
    connect?: organogramaWhereUniqueInput
    update?: XOR<organogramaUpdateWithoutOrganograma_x_regiao_atuacaoInput, organogramaUncheckedUpdateWithoutOrganograma_x_regiao_atuacaoInput>
  }

  export type regiao_atuacaoUpdateOneRequiredWithoutOrganograma_x_regiao_atuacaoNestedInput = {
    create?: XOR<regiao_atuacaoCreateWithoutOrganograma_x_regiao_atuacaoInput, regiao_atuacaoUncheckedCreateWithoutOrganograma_x_regiao_atuacaoInput>
    connectOrCreate?: regiao_atuacaoCreateOrConnectWithoutOrganograma_x_regiao_atuacaoInput
    upsert?: regiao_atuacaoUpsertWithoutOrganograma_x_regiao_atuacaoInput
    connect?: regiao_atuacaoWhereUniqueInput
    update?: XOR<regiao_atuacaoUpdateWithoutOrganograma_x_regiao_atuacaoInput, regiao_atuacaoUncheckedUpdateWithoutOrganograma_x_regiao_atuacaoInput>
  }

  export type usuarioCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<usuarioCreateWithoutPessoaInput>, Enumerable<usuarioUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<usuarioCreateOrConnectWithoutPessoaInput>
    createMany?: usuarioCreateManyPessoaInputEnvelope
    connect?: Enumerable<usuarioWhereUniqueInput>
  }

  export type usuarioUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<Enumerable<usuarioCreateWithoutPessoaInput>, Enumerable<usuarioUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<usuarioCreateOrConnectWithoutPessoaInput>
    createMany?: usuarioCreateManyPessoaInputEnvelope
    connect?: Enumerable<usuarioWhereUniqueInput>
  }

  export type usuarioUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<usuarioCreateWithoutPessoaInput>, Enumerable<usuarioUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<usuarioCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<usuarioUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: usuarioCreateManyPessoaInputEnvelope
    set?: Enumerable<usuarioWhereUniqueInput>
    disconnect?: Enumerable<usuarioWhereUniqueInput>
    delete?: Enumerable<usuarioWhereUniqueInput>
    connect?: Enumerable<usuarioWhereUniqueInput>
    update?: Enumerable<usuarioUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<usuarioUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<usuarioScalarWhereInput>
  }

  export type usuarioUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<Enumerable<usuarioCreateWithoutPessoaInput>, Enumerable<usuarioUncheckedCreateWithoutPessoaInput>>
    connectOrCreate?: Enumerable<usuarioCreateOrConnectWithoutPessoaInput>
    upsert?: Enumerable<usuarioUpsertWithWhereUniqueWithoutPessoaInput>
    createMany?: usuarioCreateManyPessoaInputEnvelope
    set?: Enumerable<usuarioWhereUniqueInput>
    disconnect?: Enumerable<usuarioWhereUniqueInput>
    delete?: Enumerable<usuarioWhereUniqueInput>
    connect?: Enumerable<usuarioWhereUniqueInput>
    update?: Enumerable<usuarioUpdateWithWhereUniqueWithoutPessoaInput>
    updateMany?: Enumerable<usuarioUpdateManyWithWhereWithoutPessoaInput>
    deleteMany?: Enumerable<usuarioScalarWhereInput>
  }

  export type plataforma_papel_tipoCreateNestedOneWithoutPlataformaInput = {
    create?: XOR<plataforma_papel_tipoCreateWithoutPlataformaInput, plataforma_papel_tipoUncheckedCreateWithoutPlataformaInput>
    connectOrCreate?: plataforma_papel_tipoCreateOrConnectWithoutPlataformaInput
    connect?: plataforma_papel_tipoWhereUniqueInput
  }

  export type plataforma_x_regiao_atuacaoCreateNestedManyWithoutPlataformaInput = {
    create?: XOR<Enumerable<plataforma_x_regiao_atuacaoCreateWithoutPlataformaInput>, Enumerable<plataforma_x_regiao_atuacaoUncheckedCreateWithoutPlataformaInput>>
    connectOrCreate?: Enumerable<plataforma_x_regiao_atuacaoCreateOrConnectWithoutPlataformaInput>
    createMany?: plataforma_x_regiao_atuacaoCreateManyPlataformaInputEnvelope
    connect?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
  }

  export type plataforma_x_usuarioCreateNestedManyWithoutPlataformaInput = {
    create?: XOR<Enumerable<plataforma_x_usuarioCreateWithoutPlataformaInput>, Enumerable<plataforma_x_usuarioUncheckedCreateWithoutPlataformaInput>>
    connectOrCreate?: Enumerable<plataforma_x_usuarioCreateOrConnectWithoutPlataformaInput>
    createMany?: plataforma_x_usuarioCreateManyPlataformaInputEnvelope
    connect?: Enumerable<plataforma_x_usuarioWhereUniqueInput>
  }

  export type plataforma_x_regiao_atuacaoUncheckedCreateNestedManyWithoutPlataformaInput = {
    create?: XOR<Enumerable<plataforma_x_regiao_atuacaoCreateWithoutPlataformaInput>, Enumerable<plataforma_x_regiao_atuacaoUncheckedCreateWithoutPlataformaInput>>
    connectOrCreate?: Enumerable<plataforma_x_regiao_atuacaoCreateOrConnectWithoutPlataformaInput>
    createMany?: plataforma_x_regiao_atuacaoCreateManyPlataformaInputEnvelope
    connect?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
  }

  export type plataforma_x_usuarioUncheckedCreateNestedManyWithoutPlataformaInput = {
    create?: XOR<Enumerable<plataforma_x_usuarioCreateWithoutPlataformaInput>, Enumerable<plataforma_x_usuarioUncheckedCreateWithoutPlataformaInput>>
    connectOrCreate?: Enumerable<plataforma_x_usuarioCreateOrConnectWithoutPlataformaInput>
    createMany?: plataforma_x_usuarioCreateManyPlataformaInputEnvelope
    connect?: Enumerable<plataforma_x_usuarioWhereUniqueInput>
  }

  export type plataforma_papel_tipoUpdateOneRequiredWithoutPlataformaNestedInput = {
    create?: XOR<plataforma_papel_tipoCreateWithoutPlataformaInput, plataforma_papel_tipoUncheckedCreateWithoutPlataformaInput>
    connectOrCreate?: plataforma_papel_tipoCreateOrConnectWithoutPlataformaInput
    upsert?: plataforma_papel_tipoUpsertWithoutPlataformaInput
    connect?: plataforma_papel_tipoWhereUniqueInput
    update?: XOR<plataforma_papel_tipoUpdateWithoutPlataformaInput, plataforma_papel_tipoUncheckedUpdateWithoutPlataformaInput>
  }

  export type plataforma_x_regiao_atuacaoUpdateManyWithoutPlataformaNestedInput = {
    create?: XOR<Enumerable<plataforma_x_regiao_atuacaoCreateWithoutPlataformaInput>, Enumerable<plataforma_x_regiao_atuacaoUncheckedCreateWithoutPlataformaInput>>
    connectOrCreate?: Enumerable<plataforma_x_regiao_atuacaoCreateOrConnectWithoutPlataformaInput>
    upsert?: Enumerable<plataforma_x_regiao_atuacaoUpsertWithWhereUniqueWithoutPlataformaInput>
    createMany?: plataforma_x_regiao_atuacaoCreateManyPlataformaInputEnvelope
    set?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
    disconnect?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
    delete?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
    connect?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
    update?: Enumerable<plataforma_x_regiao_atuacaoUpdateWithWhereUniqueWithoutPlataformaInput>
    updateMany?: Enumerable<plataforma_x_regiao_atuacaoUpdateManyWithWhereWithoutPlataformaInput>
    deleteMany?: Enumerable<plataforma_x_regiao_atuacaoScalarWhereInput>
  }

  export type plataforma_x_usuarioUpdateManyWithoutPlataformaNestedInput = {
    create?: XOR<Enumerable<plataforma_x_usuarioCreateWithoutPlataformaInput>, Enumerable<plataforma_x_usuarioUncheckedCreateWithoutPlataformaInput>>
    connectOrCreate?: Enumerable<plataforma_x_usuarioCreateOrConnectWithoutPlataformaInput>
    upsert?: Enumerable<plataforma_x_usuarioUpsertWithWhereUniqueWithoutPlataformaInput>
    createMany?: plataforma_x_usuarioCreateManyPlataformaInputEnvelope
    set?: Enumerable<plataforma_x_usuarioWhereUniqueInput>
    disconnect?: Enumerable<plataforma_x_usuarioWhereUniqueInput>
    delete?: Enumerable<plataforma_x_usuarioWhereUniqueInput>
    connect?: Enumerable<plataforma_x_usuarioWhereUniqueInput>
    update?: Enumerable<plataforma_x_usuarioUpdateWithWhereUniqueWithoutPlataformaInput>
    updateMany?: Enumerable<plataforma_x_usuarioUpdateManyWithWhereWithoutPlataformaInput>
    deleteMany?: Enumerable<plataforma_x_usuarioScalarWhereInput>
  }

  export type plataforma_x_regiao_atuacaoUncheckedUpdateManyWithoutPlataformaNestedInput = {
    create?: XOR<Enumerable<plataforma_x_regiao_atuacaoCreateWithoutPlataformaInput>, Enumerable<plataforma_x_regiao_atuacaoUncheckedCreateWithoutPlataformaInput>>
    connectOrCreate?: Enumerable<plataforma_x_regiao_atuacaoCreateOrConnectWithoutPlataformaInput>
    upsert?: Enumerable<plataforma_x_regiao_atuacaoUpsertWithWhereUniqueWithoutPlataformaInput>
    createMany?: plataforma_x_regiao_atuacaoCreateManyPlataformaInputEnvelope
    set?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
    disconnect?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
    delete?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
    connect?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
    update?: Enumerable<plataforma_x_regiao_atuacaoUpdateWithWhereUniqueWithoutPlataformaInput>
    updateMany?: Enumerable<plataforma_x_regiao_atuacaoUpdateManyWithWhereWithoutPlataformaInput>
    deleteMany?: Enumerable<plataforma_x_regiao_atuacaoScalarWhereInput>
  }

  export type plataforma_x_usuarioUncheckedUpdateManyWithoutPlataformaNestedInput = {
    create?: XOR<Enumerable<plataforma_x_usuarioCreateWithoutPlataformaInput>, Enumerable<plataforma_x_usuarioUncheckedCreateWithoutPlataformaInput>>
    connectOrCreate?: Enumerable<plataforma_x_usuarioCreateOrConnectWithoutPlataformaInput>
    upsert?: Enumerable<plataforma_x_usuarioUpsertWithWhereUniqueWithoutPlataformaInput>
    createMany?: plataforma_x_usuarioCreateManyPlataformaInputEnvelope
    set?: Enumerable<plataforma_x_usuarioWhereUniqueInput>
    disconnect?: Enumerable<plataforma_x_usuarioWhereUniqueInput>
    delete?: Enumerable<plataforma_x_usuarioWhereUniqueInput>
    connect?: Enumerable<plataforma_x_usuarioWhereUniqueInput>
    update?: Enumerable<plataforma_x_usuarioUpdateWithWhereUniqueWithoutPlataformaInput>
    updateMany?: Enumerable<plataforma_x_usuarioUpdateManyWithWhereWithoutPlataformaInput>
    deleteMany?: Enumerable<plataforma_x_usuarioScalarWhereInput>
  }

  export type plataformaCreateNestedManyWithoutPlataforma_papel_tipoInput = {
    create?: XOR<Enumerable<plataformaCreateWithoutPlataforma_papel_tipoInput>, Enumerable<plataformaUncheckedCreateWithoutPlataforma_papel_tipoInput>>
    connectOrCreate?: Enumerable<plataformaCreateOrConnectWithoutPlataforma_papel_tipoInput>
    createMany?: plataformaCreateManyPlataforma_papel_tipoInputEnvelope
    connect?: Enumerable<plataformaWhereUniqueInput>
  }

  export type plataformaUncheckedCreateNestedManyWithoutPlataforma_papel_tipoInput = {
    create?: XOR<Enumerable<plataformaCreateWithoutPlataforma_papel_tipoInput>, Enumerable<plataformaUncheckedCreateWithoutPlataforma_papel_tipoInput>>
    connectOrCreate?: Enumerable<plataformaCreateOrConnectWithoutPlataforma_papel_tipoInput>
    createMany?: plataformaCreateManyPlataforma_papel_tipoInputEnvelope
    connect?: Enumerable<plataformaWhereUniqueInput>
  }

  export type plataformaUpdateManyWithoutPlataforma_papel_tipoNestedInput = {
    create?: XOR<Enumerable<plataformaCreateWithoutPlataforma_papel_tipoInput>, Enumerable<plataformaUncheckedCreateWithoutPlataforma_papel_tipoInput>>
    connectOrCreate?: Enumerable<plataformaCreateOrConnectWithoutPlataforma_papel_tipoInput>
    upsert?: Enumerable<plataformaUpsertWithWhereUniqueWithoutPlataforma_papel_tipoInput>
    createMany?: plataformaCreateManyPlataforma_papel_tipoInputEnvelope
    set?: Enumerable<plataformaWhereUniqueInput>
    disconnect?: Enumerable<plataformaWhereUniqueInput>
    delete?: Enumerable<plataformaWhereUniqueInput>
    connect?: Enumerable<plataformaWhereUniqueInput>
    update?: Enumerable<plataformaUpdateWithWhereUniqueWithoutPlataforma_papel_tipoInput>
    updateMany?: Enumerable<plataformaUpdateManyWithWhereWithoutPlataforma_papel_tipoInput>
    deleteMany?: Enumerable<plataformaScalarWhereInput>
  }

  export type plataformaUncheckedUpdateManyWithoutPlataforma_papel_tipoNestedInput = {
    create?: XOR<Enumerable<plataformaCreateWithoutPlataforma_papel_tipoInput>, Enumerable<plataformaUncheckedCreateWithoutPlataforma_papel_tipoInput>>
    connectOrCreate?: Enumerable<plataformaCreateOrConnectWithoutPlataforma_papel_tipoInput>
    upsert?: Enumerable<plataformaUpsertWithWhereUniqueWithoutPlataforma_papel_tipoInput>
    createMany?: plataformaCreateManyPlataforma_papel_tipoInputEnvelope
    set?: Enumerable<plataformaWhereUniqueInput>
    disconnect?: Enumerable<plataformaWhereUniqueInput>
    delete?: Enumerable<plataformaWhereUniqueInput>
    connect?: Enumerable<plataformaWhereUniqueInput>
    update?: Enumerable<plataformaUpdateWithWhereUniqueWithoutPlataforma_papel_tipoInput>
    updateMany?: Enumerable<plataformaUpdateManyWithWhereWithoutPlataforma_papel_tipoInput>
    deleteMany?: Enumerable<plataformaScalarWhereInput>
  }

  export type plataformaCreateNestedOneWithoutPlataforma_x_regiao_atuacaoInput = {
    create?: XOR<plataformaCreateWithoutPlataforma_x_regiao_atuacaoInput, plataformaUncheckedCreateWithoutPlataforma_x_regiao_atuacaoInput>
    connectOrCreate?: plataformaCreateOrConnectWithoutPlataforma_x_regiao_atuacaoInput
    connect?: plataformaWhereUniqueInput
  }

  export type regiao_atuacaoCreateNestedOneWithoutPlataforma_x_regiao_atuacaoInput = {
    create?: XOR<regiao_atuacaoCreateWithoutPlataforma_x_regiao_atuacaoInput, regiao_atuacaoUncheckedCreateWithoutPlataforma_x_regiao_atuacaoInput>
    connectOrCreate?: regiao_atuacaoCreateOrConnectWithoutPlataforma_x_regiao_atuacaoInput
    connect?: regiao_atuacaoWhereUniqueInput
  }

  export type plataformaUpdateOneRequiredWithoutPlataforma_x_regiao_atuacaoNestedInput = {
    create?: XOR<plataformaCreateWithoutPlataforma_x_regiao_atuacaoInput, plataformaUncheckedCreateWithoutPlataforma_x_regiao_atuacaoInput>
    connectOrCreate?: plataformaCreateOrConnectWithoutPlataforma_x_regiao_atuacaoInput
    upsert?: plataformaUpsertWithoutPlataforma_x_regiao_atuacaoInput
    connect?: plataformaWhereUniqueInput
    update?: XOR<plataformaUpdateWithoutPlataforma_x_regiao_atuacaoInput, plataformaUncheckedUpdateWithoutPlataforma_x_regiao_atuacaoInput>
  }

  export type regiao_atuacaoUpdateOneRequiredWithoutPlataforma_x_regiao_atuacaoNestedInput = {
    create?: XOR<regiao_atuacaoCreateWithoutPlataforma_x_regiao_atuacaoInput, regiao_atuacaoUncheckedCreateWithoutPlataforma_x_regiao_atuacaoInput>
    connectOrCreate?: regiao_atuacaoCreateOrConnectWithoutPlataforma_x_regiao_atuacaoInput
    upsert?: regiao_atuacaoUpsertWithoutPlataforma_x_regiao_atuacaoInput
    connect?: regiao_atuacaoWhereUniqueInput
    update?: XOR<regiao_atuacaoUpdateWithoutPlataforma_x_regiao_atuacaoInput, regiao_atuacaoUncheckedUpdateWithoutPlataforma_x_regiao_atuacaoInput>
  }

  export type regiao_atuacao_tipoCreateNestedOneWithoutRegiao_atuacaoInput = {
    create?: XOR<regiao_atuacao_tipoCreateWithoutRegiao_atuacaoInput, regiao_atuacao_tipoUncheckedCreateWithoutRegiao_atuacaoInput>
    connectOrCreate?: regiao_atuacao_tipoCreateOrConnectWithoutRegiao_atuacaoInput
    connect?: regiao_atuacao_tipoWhereUniqueInput
  }

  export type organograma_x_regiao_atuacaoCreateNestedManyWithoutRegiao_atuacaoInput = {
    create?: XOR<Enumerable<organograma_x_regiao_atuacaoCreateWithoutRegiao_atuacaoInput>, Enumerable<organograma_x_regiao_atuacaoUncheckedCreateWithoutRegiao_atuacaoInput>>
    connectOrCreate?: Enumerable<organograma_x_regiao_atuacaoCreateOrConnectWithoutRegiao_atuacaoInput>
    createMany?: organograma_x_regiao_atuacaoCreateManyRegiao_atuacaoInputEnvelope
    connect?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
  }

  export type plataforma_x_regiao_atuacaoCreateNestedManyWithoutRegiao_atuacaoInput = {
    create?: XOR<Enumerable<plataforma_x_regiao_atuacaoCreateWithoutRegiao_atuacaoInput>, Enumerable<plataforma_x_regiao_atuacaoUncheckedCreateWithoutRegiao_atuacaoInput>>
    connectOrCreate?: Enumerable<plataforma_x_regiao_atuacaoCreateOrConnectWithoutRegiao_atuacaoInput>
    createMany?: plataforma_x_regiao_atuacaoCreateManyRegiao_atuacaoInputEnvelope
    connect?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
  }

  export type organograma_x_regiao_atuacaoUncheckedCreateNestedManyWithoutRegiao_atuacaoInput = {
    create?: XOR<Enumerable<organograma_x_regiao_atuacaoCreateWithoutRegiao_atuacaoInput>, Enumerable<organograma_x_regiao_atuacaoUncheckedCreateWithoutRegiao_atuacaoInput>>
    connectOrCreate?: Enumerable<organograma_x_regiao_atuacaoCreateOrConnectWithoutRegiao_atuacaoInput>
    createMany?: organograma_x_regiao_atuacaoCreateManyRegiao_atuacaoInputEnvelope
    connect?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
  }

  export type plataforma_x_regiao_atuacaoUncheckedCreateNestedManyWithoutRegiao_atuacaoInput = {
    create?: XOR<Enumerable<plataforma_x_regiao_atuacaoCreateWithoutRegiao_atuacaoInput>, Enumerable<plataforma_x_regiao_atuacaoUncheckedCreateWithoutRegiao_atuacaoInput>>
    connectOrCreate?: Enumerable<plataforma_x_regiao_atuacaoCreateOrConnectWithoutRegiao_atuacaoInput>
    createMany?: plataforma_x_regiao_atuacaoCreateManyRegiao_atuacaoInputEnvelope
    connect?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
  }

  export type regiao_atuacao_tipoUpdateOneRequiredWithoutRegiao_atuacaoNestedInput = {
    create?: XOR<regiao_atuacao_tipoCreateWithoutRegiao_atuacaoInput, regiao_atuacao_tipoUncheckedCreateWithoutRegiao_atuacaoInput>
    connectOrCreate?: regiao_atuacao_tipoCreateOrConnectWithoutRegiao_atuacaoInput
    upsert?: regiao_atuacao_tipoUpsertWithoutRegiao_atuacaoInput
    connect?: regiao_atuacao_tipoWhereUniqueInput
    update?: XOR<regiao_atuacao_tipoUpdateWithoutRegiao_atuacaoInput, regiao_atuacao_tipoUncheckedUpdateWithoutRegiao_atuacaoInput>
  }

  export type organograma_x_regiao_atuacaoUpdateManyWithoutRegiao_atuacaoNestedInput = {
    create?: XOR<Enumerable<organograma_x_regiao_atuacaoCreateWithoutRegiao_atuacaoInput>, Enumerable<organograma_x_regiao_atuacaoUncheckedCreateWithoutRegiao_atuacaoInput>>
    connectOrCreate?: Enumerable<organograma_x_regiao_atuacaoCreateOrConnectWithoutRegiao_atuacaoInput>
    upsert?: Enumerable<organograma_x_regiao_atuacaoUpsertWithWhereUniqueWithoutRegiao_atuacaoInput>
    createMany?: organograma_x_regiao_atuacaoCreateManyRegiao_atuacaoInputEnvelope
    set?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
    disconnect?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
    delete?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
    connect?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
    update?: Enumerable<organograma_x_regiao_atuacaoUpdateWithWhereUniqueWithoutRegiao_atuacaoInput>
    updateMany?: Enumerable<organograma_x_regiao_atuacaoUpdateManyWithWhereWithoutRegiao_atuacaoInput>
    deleteMany?: Enumerable<organograma_x_regiao_atuacaoScalarWhereInput>
  }

  export type plataforma_x_regiao_atuacaoUpdateManyWithoutRegiao_atuacaoNestedInput = {
    create?: XOR<Enumerable<plataforma_x_regiao_atuacaoCreateWithoutRegiao_atuacaoInput>, Enumerable<plataforma_x_regiao_atuacaoUncheckedCreateWithoutRegiao_atuacaoInput>>
    connectOrCreate?: Enumerable<plataforma_x_regiao_atuacaoCreateOrConnectWithoutRegiao_atuacaoInput>
    upsert?: Enumerable<plataforma_x_regiao_atuacaoUpsertWithWhereUniqueWithoutRegiao_atuacaoInput>
    createMany?: plataforma_x_regiao_atuacaoCreateManyRegiao_atuacaoInputEnvelope
    set?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
    disconnect?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
    delete?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
    connect?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
    update?: Enumerable<plataforma_x_regiao_atuacaoUpdateWithWhereUniqueWithoutRegiao_atuacaoInput>
    updateMany?: Enumerable<plataforma_x_regiao_atuacaoUpdateManyWithWhereWithoutRegiao_atuacaoInput>
    deleteMany?: Enumerable<plataforma_x_regiao_atuacaoScalarWhereInput>
  }

  export type organograma_x_regiao_atuacaoUncheckedUpdateManyWithoutRegiao_atuacaoNestedInput = {
    create?: XOR<Enumerable<organograma_x_regiao_atuacaoCreateWithoutRegiao_atuacaoInput>, Enumerable<organograma_x_regiao_atuacaoUncheckedCreateWithoutRegiao_atuacaoInput>>
    connectOrCreate?: Enumerable<organograma_x_regiao_atuacaoCreateOrConnectWithoutRegiao_atuacaoInput>
    upsert?: Enumerable<organograma_x_regiao_atuacaoUpsertWithWhereUniqueWithoutRegiao_atuacaoInput>
    createMany?: organograma_x_regiao_atuacaoCreateManyRegiao_atuacaoInputEnvelope
    set?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
    disconnect?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
    delete?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
    connect?: Enumerable<organograma_x_regiao_atuacaoWhereUniqueInput>
    update?: Enumerable<organograma_x_regiao_atuacaoUpdateWithWhereUniqueWithoutRegiao_atuacaoInput>
    updateMany?: Enumerable<organograma_x_regiao_atuacaoUpdateManyWithWhereWithoutRegiao_atuacaoInput>
    deleteMany?: Enumerable<organograma_x_regiao_atuacaoScalarWhereInput>
  }

  export type plataforma_x_regiao_atuacaoUncheckedUpdateManyWithoutRegiao_atuacaoNestedInput = {
    create?: XOR<Enumerable<plataforma_x_regiao_atuacaoCreateWithoutRegiao_atuacaoInput>, Enumerable<plataforma_x_regiao_atuacaoUncheckedCreateWithoutRegiao_atuacaoInput>>
    connectOrCreate?: Enumerable<plataforma_x_regiao_atuacaoCreateOrConnectWithoutRegiao_atuacaoInput>
    upsert?: Enumerable<plataforma_x_regiao_atuacaoUpsertWithWhereUniqueWithoutRegiao_atuacaoInput>
    createMany?: plataforma_x_regiao_atuacaoCreateManyRegiao_atuacaoInputEnvelope
    set?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
    disconnect?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
    delete?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
    connect?: Enumerable<plataforma_x_regiao_atuacaoWhereUniqueInput>
    update?: Enumerable<plataforma_x_regiao_atuacaoUpdateWithWhereUniqueWithoutRegiao_atuacaoInput>
    updateMany?: Enumerable<plataforma_x_regiao_atuacaoUpdateManyWithWhereWithoutRegiao_atuacaoInput>
    deleteMany?: Enumerable<plataforma_x_regiao_atuacaoScalarWhereInput>
  }

  export type regiao_atuacaoCreateNestedManyWithoutRegiao_atuacao_tipoInput = {
    create?: XOR<Enumerable<regiao_atuacaoCreateWithoutRegiao_atuacao_tipoInput>, Enumerable<regiao_atuacaoUncheckedCreateWithoutRegiao_atuacao_tipoInput>>
    connectOrCreate?: Enumerable<regiao_atuacaoCreateOrConnectWithoutRegiao_atuacao_tipoInput>
    createMany?: regiao_atuacaoCreateManyRegiao_atuacao_tipoInputEnvelope
    connect?: Enumerable<regiao_atuacaoWhereUniqueInput>
  }

  export type regiao_atuacaoUncheckedCreateNestedManyWithoutRegiao_atuacao_tipoInput = {
    create?: XOR<Enumerable<regiao_atuacaoCreateWithoutRegiao_atuacao_tipoInput>, Enumerable<regiao_atuacaoUncheckedCreateWithoutRegiao_atuacao_tipoInput>>
    connectOrCreate?: Enumerable<regiao_atuacaoCreateOrConnectWithoutRegiao_atuacao_tipoInput>
    createMany?: regiao_atuacaoCreateManyRegiao_atuacao_tipoInputEnvelope
    connect?: Enumerable<regiao_atuacaoWhereUniqueInput>
  }

  export type regiao_atuacaoUpdateManyWithoutRegiao_atuacao_tipoNestedInput = {
    create?: XOR<Enumerable<regiao_atuacaoCreateWithoutRegiao_atuacao_tipoInput>, Enumerable<regiao_atuacaoUncheckedCreateWithoutRegiao_atuacao_tipoInput>>
    connectOrCreate?: Enumerable<regiao_atuacaoCreateOrConnectWithoutRegiao_atuacao_tipoInput>
    upsert?: Enumerable<regiao_atuacaoUpsertWithWhereUniqueWithoutRegiao_atuacao_tipoInput>
    createMany?: regiao_atuacaoCreateManyRegiao_atuacao_tipoInputEnvelope
    set?: Enumerable<regiao_atuacaoWhereUniqueInput>
    disconnect?: Enumerable<regiao_atuacaoWhereUniqueInput>
    delete?: Enumerable<regiao_atuacaoWhereUniqueInput>
    connect?: Enumerable<regiao_atuacaoWhereUniqueInput>
    update?: Enumerable<regiao_atuacaoUpdateWithWhereUniqueWithoutRegiao_atuacao_tipoInput>
    updateMany?: Enumerable<regiao_atuacaoUpdateManyWithWhereWithoutRegiao_atuacao_tipoInput>
    deleteMany?: Enumerable<regiao_atuacaoScalarWhereInput>
  }

  export type regiao_atuacaoUncheckedUpdateManyWithoutRegiao_atuacao_tipoNestedInput = {
    create?: XOR<Enumerable<regiao_atuacaoCreateWithoutRegiao_atuacao_tipoInput>, Enumerable<regiao_atuacaoUncheckedCreateWithoutRegiao_atuacao_tipoInput>>
    connectOrCreate?: Enumerable<regiao_atuacaoCreateOrConnectWithoutRegiao_atuacao_tipoInput>
    upsert?: Enumerable<regiao_atuacaoUpsertWithWhereUniqueWithoutRegiao_atuacao_tipoInput>
    createMany?: regiao_atuacaoCreateManyRegiao_atuacao_tipoInputEnvelope
    set?: Enumerable<regiao_atuacaoWhereUniqueInput>
    disconnect?: Enumerable<regiao_atuacaoWhereUniqueInput>
    delete?: Enumerable<regiao_atuacaoWhereUniqueInput>
    connect?: Enumerable<regiao_atuacaoWhereUniqueInput>
    update?: Enumerable<regiao_atuacaoUpdateWithWhereUniqueWithoutRegiao_atuacao_tipoInput>
    updateMany?: Enumerable<regiao_atuacaoUpdateManyWithWhereWithoutRegiao_atuacao_tipoInput>
    deleteMany?: Enumerable<regiao_atuacaoScalarWhereInput>
  }

  export type cedente_n_sacadosCreateNestedManyWithoutSacado_cedente_n_sacadosTosacadoInput = {
    create?: XOR<Enumerable<cedente_n_sacadosCreateWithoutSacado_cedente_n_sacadosTosacadoInput>, Enumerable<cedente_n_sacadosUncheckedCreateWithoutSacado_cedente_n_sacadosTosacadoInput>>
    connectOrCreate?: Enumerable<cedente_n_sacadosCreateOrConnectWithoutSacado_cedente_n_sacadosTosacadoInput>
    createMany?: cedente_n_sacadosCreateManySacado_cedente_n_sacadosTosacadoInputEnvelope
    connect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
  }

  export type cedente_n_sacadosUncheckedCreateNestedManyWithoutSacado_cedente_n_sacadosTosacadoInput = {
    create?: XOR<Enumerable<cedente_n_sacadosCreateWithoutSacado_cedente_n_sacadosTosacadoInput>, Enumerable<cedente_n_sacadosUncheckedCreateWithoutSacado_cedente_n_sacadosTosacadoInput>>
    connectOrCreate?: Enumerable<cedente_n_sacadosCreateOrConnectWithoutSacado_cedente_n_sacadosTosacadoInput>
    createMany?: cedente_n_sacadosCreateManySacado_cedente_n_sacadosTosacadoInputEnvelope
    connect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
  }

  export type cedente_n_sacadosUpdateManyWithoutSacado_cedente_n_sacadosTosacadoNestedInput = {
    create?: XOR<Enumerable<cedente_n_sacadosCreateWithoutSacado_cedente_n_sacadosTosacadoInput>, Enumerable<cedente_n_sacadosUncheckedCreateWithoutSacado_cedente_n_sacadosTosacadoInput>>
    connectOrCreate?: Enumerable<cedente_n_sacadosCreateOrConnectWithoutSacado_cedente_n_sacadosTosacadoInput>
    upsert?: Enumerable<cedente_n_sacadosUpsertWithWhereUniqueWithoutSacado_cedente_n_sacadosTosacadoInput>
    createMany?: cedente_n_sacadosCreateManySacado_cedente_n_sacadosTosacadoInputEnvelope
    set?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    disconnect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    delete?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    connect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    update?: Enumerable<cedente_n_sacadosUpdateWithWhereUniqueWithoutSacado_cedente_n_sacadosTosacadoInput>
    updateMany?: Enumerable<cedente_n_sacadosUpdateManyWithWhereWithoutSacado_cedente_n_sacadosTosacadoInput>
    deleteMany?: Enumerable<cedente_n_sacadosScalarWhereInput>
  }

  export type cedente_n_sacadosUncheckedUpdateManyWithoutSacado_cedente_n_sacadosTosacadoNestedInput = {
    create?: XOR<Enumerable<cedente_n_sacadosCreateWithoutSacado_cedente_n_sacadosTosacadoInput>, Enumerable<cedente_n_sacadosUncheckedCreateWithoutSacado_cedente_n_sacadosTosacadoInput>>
    connectOrCreate?: Enumerable<cedente_n_sacadosCreateOrConnectWithoutSacado_cedente_n_sacadosTosacadoInput>
    upsert?: Enumerable<cedente_n_sacadosUpsertWithWhereUniqueWithoutSacado_cedente_n_sacadosTosacadoInput>
    createMany?: cedente_n_sacadosCreateManySacado_cedente_n_sacadosTosacadoInputEnvelope
    set?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    disconnect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    delete?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    connect?: Enumerable<cedente_n_sacadosWhereUniqueInput>
    update?: Enumerable<cedente_n_sacadosUpdateWithWhereUniqueWithoutSacado_cedente_n_sacadosTosacadoInput>
    updateMany?: Enumerable<cedente_n_sacadosUpdateManyWithWhereWithoutSacado_cedente_n_sacadosTosacadoInput>
    deleteMany?: Enumerable<cedente_n_sacadosScalarWhereInput>
  }

  export type titulo_tipoCreateNestedOneWithoutTituloInput = {
    create?: XOR<titulo_tipoCreateWithoutTituloInput, titulo_tipoUncheckedCreateWithoutTituloInput>
    connectOrCreate?: titulo_tipoCreateOrConnectWithoutTituloInput
    connect?: titulo_tipoWhereUniqueInput
  }

  export type borderoCreateNestedOneWithoutTituloInput = {
    create?: XOR<borderoCreateWithoutTituloInput, borderoUncheckedCreateWithoutTituloInput>
    connectOrCreate?: borderoCreateOrConnectWithoutTituloInput
    connect?: borderoWhereUniqueInput
  }

  export type titulo_itensCreateNestedManyWithoutTituloInput = {
    create?: XOR<Enumerable<titulo_itensCreateWithoutTituloInput>, Enumerable<titulo_itensUncheckedCreateWithoutTituloInput>>
    connectOrCreate?: Enumerable<titulo_itensCreateOrConnectWithoutTituloInput>
    createMany?: titulo_itensCreateManyTituloInputEnvelope
    connect?: Enumerable<titulo_itensWhereUniqueInput>
  }

  export type titulo_itensUncheckedCreateNestedManyWithoutTituloInput = {
    create?: XOR<Enumerable<titulo_itensCreateWithoutTituloInput>, Enumerable<titulo_itensUncheckedCreateWithoutTituloInput>>
    connectOrCreate?: Enumerable<titulo_itensCreateOrConnectWithoutTituloInput>
    createMany?: titulo_itensCreateManyTituloInputEnvelope
    connect?: Enumerable<titulo_itensWhereUniqueInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type titulo_tipoUpdateOneRequiredWithoutTituloNestedInput = {
    create?: XOR<titulo_tipoCreateWithoutTituloInput, titulo_tipoUncheckedCreateWithoutTituloInput>
    connectOrCreate?: titulo_tipoCreateOrConnectWithoutTituloInput
    upsert?: titulo_tipoUpsertWithoutTituloInput
    connect?: titulo_tipoWhereUniqueInput
    update?: XOR<titulo_tipoUpdateWithoutTituloInput, titulo_tipoUncheckedUpdateWithoutTituloInput>
  }

  export type borderoUpdateOneRequiredWithoutTituloNestedInput = {
    create?: XOR<borderoCreateWithoutTituloInput, borderoUncheckedCreateWithoutTituloInput>
    connectOrCreate?: borderoCreateOrConnectWithoutTituloInput
    upsert?: borderoUpsertWithoutTituloInput
    connect?: borderoWhereUniqueInput
    update?: XOR<borderoUpdateWithoutTituloInput, borderoUncheckedUpdateWithoutTituloInput>
  }

  export type titulo_itensUpdateManyWithoutTituloNestedInput = {
    create?: XOR<Enumerable<titulo_itensCreateWithoutTituloInput>, Enumerable<titulo_itensUncheckedCreateWithoutTituloInput>>
    connectOrCreate?: Enumerable<titulo_itensCreateOrConnectWithoutTituloInput>
    upsert?: Enumerable<titulo_itensUpsertWithWhereUniqueWithoutTituloInput>
    createMany?: titulo_itensCreateManyTituloInputEnvelope
    set?: Enumerable<titulo_itensWhereUniqueInput>
    disconnect?: Enumerable<titulo_itensWhereUniqueInput>
    delete?: Enumerable<titulo_itensWhereUniqueInput>
    connect?: Enumerable<titulo_itensWhereUniqueInput>
    update?: Enumerable<titulo_itensUpdateWithWhereUniqueWithoutTituloInput>
    updateMany?: Enumerable<titulo_itensUpdateManyWithWhereWithoutTituloInput>
    deleteMany?: Enumerable<titulo_itensScalarWhereInput>
  }

  export type titulo_itensUncheckedUpdateManyWithoutTituloNestedInput = {
    create?: XOR<Enumerable<titulo_itensCreateWithoutTituloInput>, Enumerable<titulo_itensUncheckedCreateWithoutTituloInput>>
    connectOrCreate?: Enumerable<titulo_itensCreateOrConnectWithoutTituloInput>
    upsert?: Enumerable<titulo_itensUpsertWithWhereUniqueWithoutTituloInput>
    createMany?: titulo_itensCreateManyTituloInputEnvelope
    set?: Enumerable<titulo_itensWhereUniqueInput>
    disconnect?: Enumerable<titulo_itensWhereUniqueInput>
    delete?: Enumerable<titulo_itensWhereUniqueInput>
    connect?: Enumerable<titulo_itensWhereUniqueInput>
    update?: Enumerable<titulo_itensUpdateWithWhereUniqueWithoutTituloInput>
    updateMany?: Enumerable<titulo_itensUpdateManyWithWhereWithoutTituloInput>
    deleteMany?: Enumerable<titulo_itensScalarWhereInput>
  }

  export type tituloCreateNestedManyWithoutTitulo_tipoInput = {
    create?: XOR<Enumerable<tituloCreateWithoutTitulo_tipoInput>, Enumerable<tituloUncheckedCreateWithoutTitulo_tipoInput>>
    connectOrCreate?: Enumerable<tituloCreateOrConnectWithoutTitulo_tipoInput>
    createMany?: tituloCreateManyTitulo_tipoInputEnvelope
    connect?: Enumerable<tituloWhereUniqueInput>
  }

  export type tituloUncheckedCreateNestedManyWithoutTitulo_tipoInput = {
    create?: XOR<Enumerable<tituloCreateWithoutTitulo_tipoInput>, Enumerable<tituloUncheckedCreateWithoutTitulo_tipoInput>>
    connectOrCreate?: Enumerable<tituloCreateOrConnectWithoutTitulo_tipoInput>
    createMany?: tituloCreateManyTitulo_tipoInputEnvelope
    connect?: Enumerable<tituloWhereUniqueInput>
  }

  export type tituloUpdateManyWithoutTitulo_tipoNestedInput = {
    create?: XOR<Enumerable<tituloCreateWithoutTitulo_tipoInput>, Enumerable<tituloUncheckedCreateWithoutTitulo_tipoInput>>
    connectOrCreate?: Enumerable<tituloCreateOrConnectWithoutTitulo_tipoInput>
    upsert?: Enumerable<tituloUpsertWithWhereUniqueWithoutTitulo_tipoInput>
    createMany?: tituloCreateManyTitulo_tipoInputEnvelope
    set?: Enumerable<tituloWhereUniqueInput>
    disconnect?: Enumerable<tituloWhereUniqueInput>
    delete?: Enumerable<tituloWhereUniqueInput>
    connect?: Enumerable<tituloWhereUniqueInput>
    update?: Enumerable<tituloUpdateWithWhereUniqueWithoutTitulo_tipoInput>
    updateMany?: Enumerable<tituloUpdateManyWithWhereWithoutTitulo_tipoInput>
    deleteMany?: Enumerable<tituloScalarWhereInput>
  }

  export type tituloUncheckedUpdateManyWithoutTitulo_tipoNestedInput = {
    create?: XOR<Enumerable<tituloCreateWithoutTitulo_tipoInput>, Enumerable<tituloUncheckedCreateWithoutTitulo_tipoInput>>
    connectOrCreate?: Enumerable<tituloCreateOrConnectWithoutTitulo_tipoInput>
    upsert?: Enumerable<tituloUpsertWithWhereUniqueWithoutTitulo_tipoInput>
    createMany?: tituloCreateManyTitulo_tipoInputEnvelope
    set?: Enumerable<tituloWhereUniqueInput>
    disconnect?: Enumerable<tituloWhereUniqueInput>
    delete?: Enumerable<tituloWhereUniqueInput>
    connect?: Enumerable<tituloWhereUniqueInput>
    update?: Enumerable<tituloUpdateWithWhereUniqueWithoutTitulo_tipoInput>
    updateMany?: Enumerable<tituloUpdateManyWithWhereWithoutTitulo_tipoInput>
    deleteMany?: Enumerable<tituloScalarWhereInput>
  }

  export type pessoaCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<pessoaCreateWithoutUsuarioInput, pessoaUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutUsuarioInput
    connect?: pessoaWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type pessoaUpdateOneRequiredWithoutUsuarioNestedInput = {
    create?: XOR<pessoaCreateWithoutUsuarioInput, pessoaUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutUsuarioInput
    upsert?: pessoaUpsertWithoutUsuarioInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<pessoaUpdateWithoutUsuarioInput, pessoaUncheckedUpdateWithoutUsuarioInput>
  }

  export type usuario_perfilCreateNestedManyWithoutUsuario_perfil_tipoInput = {
    create?: XOR<Enumerable<usuario_perfilCreateWithoutUsuario_perfil_tipoInput>, Enumerable<usuario_perfilUncheckedCreateWithoutUsuario_perfil_tipoInput>>
    connectOrCreate?: Enumerable<usuario_perfilCreateOrConnectWithoutUsuario_perfil_tipoInput>
    createMany?: usuario_perfilCreateManyUsuario_perfil_tipoInputEnvelope
    connect?: Enumerable<usuario_perfilWhereUniqueInput>
  }

  export type usuario_perfilUncheckedCreateNestedManyWithoutUsuario_perfil_tipoInput = {
    create?: XOR<Enumerable<usuario_perfilCreateWithoutUsuario_perfil_tipoInput>, Enumerable<usuario_perfilUncheckedCreateWithoutUsuario_perfil_tipoInput>>
    connectOrCreate?: Enumerable<usuario_perfilCreateOrConnectWithoutUsuario_perfil_tipoInput>
    createMany?: usuario_perfilCreateManyUsuario_perfil_tipoInputEnvelope
    connect?: Enumerable<usuario_perfilWhereUniqueInput>
  }

  export type usuario_perfilUpdateManyWithoutUsuario_perfil_tipoNestedInput = {
    create?: XOR<Enumerable<usuario_perfilCreateWithoutUsuario_perfil_tipoInput>, Enumerable<usuario_perfilUncheckedCreateWithoutUsuario_perfil_tipoInput>>
    connectOrCreate?: Enumerable<usuario_perfilCreateOrConnectWithoutUsuario_perfil_tipoInput>
    upsert?: Enumerable<usuario_perfilUpsertWithWhereUniqueWithoutUsuario_perfil_tipoInput>
    createMany?: usuario_perfilCreateManyUsuario_perfil_tipoInputEnvelope
    set?: Enumerable<usuario_perfilWhereUniqueInput>
    disconnect?: Enumerable<usuario_perfilWhereUniqueInput>
    delete?: Enumerable<usuario_perfilWhereUniqueInput>
    connect?: Enumerable<usuario_perfilWhereUniqueInput>
    update?: Enumerable<usuario_perfilUpdateWithWhereUniqueWithoutUsuario_perfil_tipoInput>
    updateMany?: Enumerable<usuario_perfilUpdateManyWithWhereWithoutUsuario_perfil_tipoInput>
    deleteMany?: Enumerable<usuario_perfilScalarWhereInput>
  }

  export type usuario_perfilUncheckedUpdateManyWithoutUsuario_perfil_tipoNestedInput = {
    create?: XOR<Enumerable<usuario_perfilCreateWithoutUsuario_perfil_tipoInput>, Enumerable<usuario_perfilUncheckedCreateWithoutUsuario_perfil_tipoInput>>
    connectOrCreate?: Enumerable<usuario_perfilCreateOrConnectWithoutUsuario_perfil_tipoInput>
    upsert?: Enumerable<usuario_perfilUpsertWithWhereUniqueWithoutUsuario_perfil_tipoInput>
    createMany?: usuario_perfilCreateManyUsuario_perfil_tipoInputEnvelope
    set?: Enumerable<usuario_perfilWhereUniqueInput>
    disconnect?: Enumerable<usuario_perfilWhereUniqueInput>
    delete?: Enumerable<usuario_perfilWhereUniqueInput>
    connect?: Enumerable<usuario_perfilWhereUniqueInput>
    update?: Enumerable<usuario_perfilUpdateWithWhereUniqueWithoutUsuario_perfil_tipoInput>
    updateMany?: Enumerable<usuario_perfilUpdateManyWithWhereWithoutUsuario_perfil_tipoInput>
    deleteMany?: Enumerable<usuario_perfilScalarWhereInput>
  }

  export type carteiraCreateNestedOneWithoutCarteira_n_cedentesInput = {
    create?: XOR<carteiraCreateWithoutCarteira_n_cedentesInput, carteiraUncheckedCreateWithoutCarteira_n_cedentesInput>
    connectOrCreate?: carteiraCreateOrConnectWithoutCarteira_n_cedentesInput
    connect?: carteiraWhereUniqueInput
  }

  export type cedenteCreateNestedOneWithoutCarteira_n_cedentesInput = {
    create?: XOR<cedenteCreateWithoutCarteira_n_cedentesInput, cedenteUncheckedCreateWithoutCarteira_n_cedentesInput>
    connectOrCreate?: cedenteCreateOrConnectWithoutCarteira_n_cedentesInput
    connect?: cedenteWhereUniqueInput
  }

  export type carteiraUpdateOneRequiredWithoutCarteira_n_cedentesNestedInput = {
    create?: XOR<carteiraCreateWithoutCarteira_n_cedentesInput, carteiraUncheckedCreateWithoutCarteira_n_cedentesInput>
    connectOrCreate?: carteiraCreateOrConnectWithoutCarteira_n_cedentesInput
    upsert?: carteiraUpsertWithoutCarteira_n_cedentesInput
    connect?: carteiraWhereUniqueInput
    update?: XOR<carteiraUpdateWithoutCarteira_n_cedentesInput, carteiraUncheckedUpdateWithoutCarteira_n_cedentesInput>
  }

  export type cedenteUpdateOneRequiredWithoutCarteira_n_cedentesNestedInput = {
    create?: XOR<cedenteCreateWithoutCarteira_n_cedentesInput, cedenteUncheckedCreateWithoutCarteira_n_cedentesInput>
    connectOrCreate?: cedenteCreateOrConnectWithoutCarteira_n_cedentesInput
    upsert?: cedenteUpsertWithoutCarteira_n_cedentesInput
    connect?: cedenteWhereUniqueInput
    update?: XOR<cedenteUpdateWithoutCarteira_n_cedentesInput, cedenteUncheckedUpdateWithoutCarteira_n_cedentesInput>
  }

  export type organogramaCreateNestedOneWithoutOrganograma_x_usuarioInput = {
    create?: XOR<organogramaCreateWithoutOrganograma_x_usuarioInput, organogramaUncheckedCreateWithoutOrganograma_x_usuarioInput>
    connectOrCreate?: organogramaCreateOrConnectWithoutOrganograma_x_usuarioInput
    connect?: organogramaWhereUniqueInput
  }

  export type organogramaUpdateOneRequiredWithoutOrganograma_x_usuarioNestedInput = {
    create?: XOR<organogramaCreateWithoutOrganograma_x_usuarioInput, organogramaUncheckedCreateWithoutOrganograma_x_usuarioInput>
    connectOrCreate?: organogramaCreateOrConnectWithoutOrganograma_x_usuarioInput
    upsert?: organogramaUpsertWithoutOrganograma_x_usuarioInput
    connect?: organogramaWhereUniqueInput
    update?: XOR<organogramaUpdateWithoutOrganograma_x_usuarioInput, organogramaUncheckedUpdateWithoutOrganograma_x_usuarioInput>
  }

  export type plataformaCreateNestedOneWithoutPlataforma_x_usuarioInput = {
    create?: XOR<plataformaCreateWithoutPlataforma_x_usuarioInput, plataformaUncheckedCreateWithoutPlataforma_x_usuarioInput>
    connectOrCreate?: plataformaCreateOrConnectWithoutPlataforma_x_usuarioInput
    connect?: plataformaWhereUniqueInput
  }

  export type plataformaUpdateOneRequiredWithoutPlataforma_x_usuarioNestedInput = {
    create?: XOR<plataformaCreateWithoutPlataforma_x_usuarioInput, plataformaUncheckedCreateWithoutPlataforma_x_usuarioInput>
    connectOrCreate?: plataformaCreateOrConnectWithoutPlataforma_x_usuarioInput
    upsert?: plataformaUpsertWithoutPlataforma_x_usuarioInput
    connect?: plataformaWhereUniqueInput
    update?: XOR<plataformaUpdateWithoutPlataforma_x_usuarioInput, plataformaUncheckedUpdateWithoutPlataforma_x_usuarioInput>
  }

  export type tituloCreateNestedOneWithoutTitulo_itensInput = {
    create?: XOR<tituloCreateWithoutTitulo_itensInput, tituloUncheckedCreateWithoutTitulo_itensInput>
    connectOrCreate?: tituloCreateOrConnectWithoutTitulo_itensInput
    connect?: tituloWhereUniqueInput
  }

  export type tituloUpdateOneRequiredWithoutTitulo_itensNestedInput = {
    create?: XOR<tituloCreateWithoutTitulo_itensInput, tituloUncheckedCreateWithoutTitulo_itensInput>
    connectOrCreate?: tituloCreateOrConnectWithoutTitulo_itensInput
    upsert?: tituloUpsertWithoutTitulo_itensInput
    connect?: tituloWhereUniqueInput
    update?: XOR<tituloUpdateWithoutTitulo_itensInput, tituloUncheckedUpdateWithoutTitulo_itensInput>
  }

  export type usuario_perfil_tipoCreateNestedOneWithoutUsuario_perfilInput = {
    create?: XOR<usuario_perfil_tipoCreateWithoutUsuario_perfilInput, usuario_perfil_tipoUncheckedCreateWithoutUsuario_perfilInput>
    connectOrCreate?: usuario_perfil_tipoCreateOrConnectWithoutUsuario_perfilInput
    connect?: usuario_perfil_tipoWhereUniqueInput
  }

  export type usuario_perfil_tipoUpdateOneRequiredWithoutUsuario_perfilNestedInput = {
    create?: XOR<usuario_perfil_tipoCreateWithoutUsuario_perfilInput, usuario_perfil_tipoUncheckedCreateWithoutUsuario_perfilInput>
    connectOrCreate?: usuario_perfil_tipoCreateOrConnectWithoutUsuario_perfilInput
    upsert?: usuario_perfil_tipoUpsertWithoutUsuario_perfilInput
    connect?: usuario_perfil_tipoWhereUniqueInput
    update?: XOR<usuario_perfil_tipoUpdateWithoutUsuario_perfilInput, usuario_perfil_tipoUncheckedUpdateWithoutUsuario_perfilInput>
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type carteiraCreateWithoutBorderoInput = {
    fidic_fundo: fidic_fundoCreateNestedOneWithoutCarteiraInput
    carteira_n_cedentes?: carteira_n_cedentesCreateNestedManyWithoutCarteiraInput
  }

  export type carteiraUncheckedCreateWithoutBorderoInput = {
    id?: number
    fiduc_fundo_id: number
    carteira_n_cedentes?: carteira_n_cedentesUncheckedCreateNestedManyWithoutCarteiraInput
  }

  export type carteiraCreateOrConnectWithoutBorderoInput = {
    where: carteiraWhereUniqueInput
    create: XOR<carteiraCreateWithoutBorderoInput, carteiraUncheckedCreateWithoutBorderoInput>
  }

  export type tituloCreateWithoutBorderoInput = {
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
    titulo_tipo: titulo_tipoCreateNestedOneWithoutTituloInput
    titulo_itens?: titulo_itensCreateNestedManyWithoutTituloInput
  }

  export type tituloUncheckedCreateWithoutBorderoInput = {
    id?: number
    titulo_tipo_id: number
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
    titulo_itens?: titulo_itensUncheckedCreateNestedManyWithoutTituloInput
  }

  export type tituloCreateOrConnectWithoutBorderoInput = {
    where: tituloWhereUniqueInput
    create: XOR<tituloCreateWithoutBorderoInput, tituloUncheckedCreateWithoutBorderoInput>
  }

  export type tituloCreateManyBorderoInputEnvelope = {
    data: Enumerable<tituloCreateManyBorderoInput>
    skipDuplicates?: boolean
  }

  export type carteiraUpsertWithoutBorderoInput = {
    update: XOR<carteiraUpdateWithoutBorderoInput, carteiraUncheckedUpdateWithoutBorderoInput>
    create: XOR<carteiraCreateWithoutBorderoInput, carteiraUncheckedCreateWithoutBorderoInput>
  }

  export type carteiraUpdateWithoutBorderoInput = {
    fidic_fundo?: fidic_fundoUpdateOneRequiredWithoutCarteiraNestedInput
    carteira_n_cedentes?: carteira_n_cedentesUpdateManyWithoutCarteiraNestedInput
  }

  export type carteiraUncheckedUpdateWithoutBorderoInput = {
    id?: IntFieldUpdateOperationsInput | number
    fiduc_fundo_id?: IntFieldUpdateOperationsInput | number
    carteira_n_cedentes?: carteira_n_cedentesUncheckedUpdateManyWithoutCarteiraNestedInput
  }

  export type tituloUpsertWithWhereUniqueWithoutBorderoInput = {
    where: tituloWhereUniqueInput
    update: XOR<tituloUpdateWithoutBorderoInput, tituloUncheckedUpdateWithoutBorderoInput>
    create: XOR<tituloCreateWithoutBorderoInput, tituloUncheckedCreateWithoutBorderoInput>
  }

  export type tituloUpdateWithWhereUniqueWithoutBorderoInput = {
    where: tituloWhereUniqueInput
    data: XOR<tituloUpdateWithoutBorderoInput, tituloUncheckedUpdateWithoutBorderoInput>
  }

  export type tituloUpdateManyWithWhereWithoutBorderoInput = {
    where: tituloScalarWhereInput
    data: XOR<tituloUpdateManyMutationInput, tituloUncheckedUpdateManyWithoutTituloInput>
  }

  export type tituloScalarWhereInput = {
    AND?: Enumerable<tituloScalarWhereInput>
    OR?: Enumerable<tituloScalarWhereInput>
    NOT?: Enumerable<tituloScalarWhereInput>
    id?: IntFilter | number
    titulo_tipo_id?: IntFilter | number
    bordero_id?: IntFilter | number
    nf?: StringNullableFilter | string | null
    valor?: FloatNullableFilter | number | null
    vencimento?: DateTimeNullableFilter | Date | string | null
    numero?: StringNullableFilter | string | null
    emissao?: DateTimeNullableFilter | Date | string | null
    parcela?: StringNullableFilter | string | null
  }

  export type fidic_fundoCreateWithoutCarteiraInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioCreateNestedManyWithoutFidic_fundoInput
  }

  export type fidic_fundoUncheckedCreateWithoutCarteiraInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedCreateNestedManyWithoutFidic_fundoInput
  }

  export type fidic_fundoCreateOrConnectWithoutCarteiraInput = {
    where: fidic_fundoWhereUniqueInput
    create: XOR<fidic_fundoCreateWithoutCarteiraInput, fidic_fundoUncheckedCreateWithoutCarteiraInput>
  }

  export type borderoCreateWithoutCarteiraInput = {
    titulo?: tituloCreateNestedManyWithoutBorderoInput
  }

  export type borderoUncheckedCreateWithoutCarteiraInput = {
    id?: number
    titulo?: tituloUncheckedCreateNestedManyWithoutBorderoInput
  }

  export type borderoCreateOrConnectWithoutCarteiraInput = {
    where: borderoWhereUniqueInput
    create: XOR<borderoCreateWithoutCarteiraInput, borderoUncheckedCreateWithoutCarteiraInput>
  }

  export type borderoCreateManyCarteiraInputEnvelope = {
    data: Enumerable<borderoCreateManyCarteiraInput>
    skipDuplicates?: boolean
  }

  export type carteira_n_cedentesCreateWithoutCarteiraInput = {
    cedente: cedenteCreateNestedOneWithoutCarteira_n_cedentesInput
  }

  export type carteira_n_cedentesUncheckedCreateWithoutCarteiraInput = {
    id?: number
    cedente_id: number
  }

  export type carteira_n_cedentesCreateOrConnectWithoutCarteiraInput = {
    where: carteira_n_cedentesWhereUniqueInput
    create: XOR<carteira_n_cedentesCreateWithoutCarteiraInput, carteira_n_cedentesUncheckedCreateWithoutCarteiraInput>
  }

  export type carteira_n_cedentesCreateManyCarteiraInputEnvelope = {
    data: Enumerable<carteira_n_cedentesCreateManyCarteiraInput>
    skipDuplicates?: boolean
  }

  export type fidic_fundoUpsertWithoutCarteiraInput = {
    update: XOR<fidic_fundoUpdateWithoutCarteiraInput, fidic_fundoUncheckedUpdateWithoutCarteiraInput>
    create: XOR<fidic_fundoCreateWithoutCarteiraInput, fidic_fundoUncheckedCreateWithoutCarteiraInput>
  }

  export type fidic_fundoUpdateWithoutCarteiraInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUpdateManyWithoutFidic_fundoNestedInput
  }

  export type fidic_fundoUncheckedUpdateWithoutCarteiraInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    fidic_fundo_x_usuario?: fidic_fundo_x_usuarioUncheckedUpdateManyWithoutFidic_fundoNestedInput
  }

  export type borderoUpsertWithWhereUniqueWithoutCarteiraInput = {
    where: borderoWhereUniqueInput
    update: XOR<borderoUpdateWithoutCarteiraInput, borderoUncheckedUpdateWithoutCarteiraInput>
    create: XOR<borderoCreateWithoutCarteiraInput, borderoUncheckedCreateWithoutCarteiraInput>
  }

  export type borderoUpdateWithWhereUniqueWithoutCarteiraInput = {
    where: borderoWhereUniqueInput
    data: XOR<borderoUpdateWithoutCarteiraInput, borderoUncheckedUpdateWithoutCarteiraInput>
  }

  export type borderoUpdateManyWithWhereWithoutCarteiraInput = {
    where: borderoScalarWhereInput
    data: XOR<borderoUpdateManyMutationInput, borderoUncheckedUpdateManyWithoutBorderoInput>
  }

  export type borderoScalarWhereInput = {
    AND?: Enumerable<borderoScalarWhereInput>
    OR?: Enumerable<borderoScalarWhereInput>
    NOT?: Enumerable<borderoScalarWhereInput>
    id?: IntFilter | number
    carteira_id?: IntFilter | number
  }

  export type carteira_n_cedentesUpsertWithWhereUniqueWithoutCarteiraInput = {
    where: carteira_n_cedentesWhereUniqueInput
    update: XOR<carteira_n_cedentesUpdateWithoutCarteiraInput, carteira_n_cedentesUncheckedUpdateWithoutCarteiraInput>
    create: XOR<carteira_n_cedentesCreateWithoutCarteiraInput, carteira_n_cedentesUncheckedCreateWithoutCarteiraInput>
  }

  export type carteira_n_cedentesUpdateWithWhereUniqueWithoutCarteiraInput = {
    where: carteira_n_cedentesWhereUniqueInput
    data: XOR<carteira_n_cedentesUpdateWithoutCarteiraInput, carteira_n_cedentesUncheckedUpdateWithoutCarteiraInput>
  }

  export type carteira_n_cedentesUpdateManyWithWhereWithoutCarteiraInput = {
    where: carteira_n_cedentesScalarWhereInput
    data: XOR<carteira_n_cedentesUpdateManyMutationInput, carteira_n_cedentesUncheckedUpdateManyWithoutCarteira_n_cedentesInput>
  }

  export type carteira_n_cedentesScalarWhereInput = {
    AND?: Enumerable<carteira_n_cedentesScalarWhereInput>
    OR?: Enumerable<carteira_n_cedentesScalarWhereInput>
    NOT?: Enumerable<carteira_n_cedentesScalarWhereInput>
    id?: IntFilter | number
    carteira_id?: IntFilter | number
    cedente_id?: IntFilter | number
  }

  export type carteira_n_cedentesCreateWithoutCedenteInput = {
    carteira: carteiraCreateNestedOneWithoutCarteira_n_cedentesInput
  }

  export type carteira_n_cedentesUncheckedCreateWithoutCedenteInput = {
    id?: number
    carteira_id: number
  }

  export type carteira_n_cedentesCreateOrConnectWithoutCedenteInput = {
    where: carteira_n_cedentesWhereUniqueInput
    create: XOR<carteira_n_cedentesCreateWithoutCedenteInput, carteira_n_cedentesUncheckedCreateWithoutCedenteInput>
  }

  export type carteira_n_cedentesCreateManyCedenteInputEnvelope = {
    data: Enumerable<carteira_n_cedentesCreateManyCedenteInput>
    skipDuplicates?: boolean
  }

  export type cedente_analiseCreateWithoutCedente_cedenteTocedente_analiseInput = {
    status?: string | null
  }

  export type cedente_analiseUncheckedCreateWithoutCedente_cedenteTocedente_analiseInput = {
    id?: number
    status?: string | null
  }

  export type cedente_analiseCreateOrConnectWithoutCedente_cedenteTocedente_analiseInput = {
    where: cedente_analiseWhereUniqueInput
    create: XOR<cedente_analiseCreateWithoutCedente_cedenteTocedente_analiseInput, cedente_analiseUncheckedCreateWithoutCedente_cedenteTocedente_analiseInput>
  }

  export type cedente_analiseCreateManyCedente_cedenteTocedente_analiseInputEnvelope = {
    data: Enumerable<cedente_analiseCreateManyCedente_cedenteTocedente_analiseInput>
    skipDuplicates?: boolean
  }

  export type cedente_n_sacadosCreateWithoutCedente_cedenteTocedente_n_sacadosInput = {
    sacado_cedente_n_sacadosTosacado?: sacadoCreateNestedOneWithoutCedente_n_sacadosInput
  }

  export type cedente_n_sacadosUncheckedCreateWithoutCedente_cedenteTocedente_n_sacadosInput = {
    id?: number
    sacado?: number | null
  }

  export type cedente_n_sacadosCreateOrConnectWithoutCedente_cedenteTocedente_n_sacadosInput = {
    where: cedente_n_sacadosWhereUniqueInput
    create: XOR<cedente_n_sacadosCreateWithoutCedente_cedenteTocedente_n_sacadosInput, cedente_n_sacadosUncheckedCreateWithoutCedente_cedenteTocedente_n_sacadosInput>
  }

  export type cedente_n_sacadosCreateManyCedente_cedenteTocedente_n_sacadosInputEnvelope = {
    data: Enumerable<cedente_n_sacadosCreateManyCedente_cedenteTocedente_n_sacadosInput>
    skipDuplicates?: boolean
  }

  export type carteira_n_cedentesUpsertWithWhereUniqueWithoutCedenteInput = {
    where: carteira_n_cedentesWhereUniqueInput
    update: XOR<carteira_n_cedentesUpdateWithoutCedenteInput, carteira_n_cedentesUncheckedUpdateWithoutCedenteInput>
    create: XOR<carteira_n_cedentesCreateWithoutCedenteInput, carteira_n_cedentesUncheckedCreateWithoutCedenteInput>
  }

  export type carteira_n_cedentesUpdateWithWhereUniqueWithoutCedenteInput = {
    where: carteira_n_cedentesWhereUniqueInput
    data: XOR<carteira_n_cedentesUpdateWithoutCedenteInput, carteira_n_cedentesUncheckedUpdateWithoutCedenteInput>
  }

  export type carteira_n_cedentesUpdateManyWithWhereWithoutCedenteInput = {
    where: carteira_n_cedentesScalarWhereInput
    data: XOR<carteira_n_cedentesUpdateManyMutationInput, carteira_n_cedentesUncheckedUpdateManyWithoutCarteira_n_cedentesInput>
  }

  export type cedente_analiseUpsertWithWhereUniqueWithoutCedente_cedenteTocedente_analiseInput = {
    where: cedente_analiseWhereUniqueInput
    update: XOR<cedente_analiseUpdateWithoutCedente_cedenteTocedente_analiseInput, cedente_analiseUncheckedUpdateWithoutCedente_cedenteTocedente_analiseInput>
    create: XOR<cedente_analiseCreateWithoutCedente_cedenteTocedente_analiseInput, cedente_analiseUncheckedCreateWithoutCedente_cedenteTocedente_analiseInput>
  }

  export type cedente_analiseUpdateWithWhereUniqueWithoutCedente_cedenteTocedente_analiseInput = {
    where: cedente_analiseWhereUniqueInput
    data: XOR<cedente_analiseUpdateWithoutCedente_cedenteTocedente_analiseInput, cedente_analiseUncheckedUpdateWithoutCedente_cedenteTocedente_analiseInput>
  }

  export type cedente_analiseUpdateManyWithWhereWithoutCedente_cedenteTocedente_analiseInput = {
    where: cedente_analiseScalarWhereInput
    data: XOR<cedente_analiseUpdateManyMutationInput, cedente_analiseUncheckedUpdateManyWithoutCedente_analiseInput>
  }

  export type cedente_analiseScalarWhereInput = {
    AND?: Enumerable<cedente_analiseScalarWhereInput>
    OR?: Enumerable<cedente_analiseScalarWhereInput>
    NOT?: Enumerable<cedente_analiseScalarWhereInput>
    id?: IntFilter | number
    status?: StringNullableFilter | string | null
    cedente?: IntNullableFilter | number | null
  }

  export type cedente_n_sacadosUpsertWithWhereUniqueWithoutCedente_cedenteTocedente_n_sacadosInput = {
    where: cedente_n_sacadosWhereUniqueInput
    update: XOR<cedente_n_sacadosUpdateWithoutCedente_cedenteTocedente_n_sacadosInput, cedente_n_sacadosUncheckedUpdateWithoutCedente_cedenteTocedente_n_sacadosInput>
    create: XOR<cedente_n_sacadosCreateWithoutCedente_cedenteTocedente_n_sacadosInput, cedente_n_sacadosUncheckedCreateWithoutCedente_cedenteTocedente_n_sacadosInput>
  }

  export type cedente_n_sacadosUpdateWithWhereUniqueWithoutCedente_cedenteTocedente_n_sacadosInput = {
    where: cedente_n_sacadosWhereUniqueInput
    data: XOR<cedente_n_sacadosUpdateWithoutCedente_cedenteTocedente_n_sacadosInput, cedente_n_sacadosUncheckedUpdateWithoutCedente_cedenteTocedente_n_sacadosInput>
  }

  export type cedente_n_sacadosUpdateManyWithWhereWithoutCedente_cedenteTocedente_n_sacadosInput = {
    where: cedente_n_sacadosScalarWhereInput
    data: XOR<cedente_n_sacadosUpdateManyMutationInput, cedente_n_sacadosUncheckedUpdateManyWithoutCedente_n_sacadosInput>
  }

  export type cedente_n_sacadosScalarWhereInput = {
    AND?: Enumerable<cedente_n_sacadosScalarWhereInput>
    OR?: Enumerable<cedente_n_sacadosScalarWhereInput>
    NOT?: Enumerable<cedente_n_sacadosScalarWhereInput>
    id?: IntFilter | number
    cedente?: IntNullableFilter | number | null
    sacado?: IntNullableFilter | number | null
  }

  export type cedenteCreateWithoutCedente_analiseInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    carteira_n_cedentes?: carteira_n_cedentesCreateNestedManyWithoutCedenteInput
    cedente_n_sacados?: cedente_n_sacadosCreateNestedManyWithoutCedente_cedenteTocedente_n_sacadosInput
  }

  export type cedenteUncheckedCreateWithoutCedente_analiseInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    carteira_n_cedentes?: carteira_n_cedentesUncheckedCreateNestedManyWithoutCedenteInput
    cedente_n_sacados?: cedente_n_sacadosUncheckedCreateNestedManyWithoutCedente_cedenteTocedente_n_sacadosInput
  }

  export type cedenteCreateOrConnectWithoutCedente_analiseInput = {
    where: cedenteWhereUniqueInput
    create: XOR<cedenteCreateWithoutCedente_analiseInput, cedenteUncheckedCreateWithoutCedente_analiseInput>
  }

  export type cedenteUpsertWithoutCedente_analiseInput = {
    update: XOR<cedenteUpdateWithoutCedente_analiseInput, cedenteUncheckedUpdateWithoutCedente_analiseInput>
    create: XOR<cedenteCreateWithoutCedente_analiseInput, cedenteUncheckedCreateWithoutCedente_analiseInput>
  }

  export type cedenteUpdateWithoutCedente_analiseInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    carteira_n_cedentes?: carteira_n_cedentesUpdateManyWithoutCedenteNestedInput
    cedente_n_sacados?: cedente_n_sacadosUpdateManyWithoutCedente_cedenteTocedente_n_sacadosNestedInput
  }

  export type cedenteUncheckedUpdateWithoutCedente_analiseInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    carteira_n_cedentes?: carteira_n_cedentesUncheckedUpdateManyWithoutCedenteNestedInput
    cedente_n_sacados?: cedente_n_sacadosUncheckedUpdateManyWithoutCedente_cedenteTocedente_n_sacadosNestedInput
  }

  export type cedenteCreateWithoutCedente_n_sacadosInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    carteira_n_cedentes?: carteira_n_cedentesCreateNestedManyWithoutCedenteInput
    cedente_analise?: cedente_analiseCreateNestedManyWithoutCedente_cedenteTocedente_analiseInput
  }

  export type cedenteUncheckedCreateWithoutCedente_n_sacadosInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    carteira_n_cedentes?: carteira_n_cedentesUncheckedCreateNestedManyWithoutCedenteInput
    cedente_analise?: cedente_analiseUncheckedCreateNestedManyWithoutCedente_cedenteTocedente_analiseInput
  }

  export type cedenteCreateOrConnectWithoutCedente_n_sacadosInput = {
    where: cedenteWhereUniqueInput
    create: XOR<cedenteCreateWithoutCedente_n_sacadosInput, cedenteUncheckedCreateWithoutCedente_n_sacadosInput>
  }

  export type sacadoCreateWithoutCedente_n_sacadosInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
  }

  export type sacadoUncheckedCreateWithoutCedente_n_sacadosInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
  }

  export type sacadoCreateOrConnectWithoutCedente_n_sacadosInput = {
    where: sacadoWhereUniqueInput
    create: XOR<sacadoCreateWithoutCedente_n_sacadosInput, sacadoUncheckedCreateWithoutCedente_n_sacadosInput>
  }

  export type cedenteUpsertWithoutCedente_n_sacadosInput = {
    update: XOR<cedenteUpdateWithoutCedente_n_sacadosInput, cedenteUncheckedUpdateWithoutCedente_n_sacadosInput>
    create: XOR<cedenteCreateWithoutCedente_n_sacadosInput, cedenteUncheckedCreateWithoutCedente_n_sacadosInput>
  }

  export type cedenteUpdateWithoutCedente_n_sacadosInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    carteira_n_cedentes?: carteira_n_cedentesUpdateManyWithoutCedenteNestedInput
    cedente_analise?: cedente_analiseUpdateManyWithoutCedente_cedenteTocedente_analiseNestedInput
  }

  export type cedenteUncheckedUpdateWithoutCedente_n_sacadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    carteira_n_cedentes?: carteira_n_cedentesUncheckedUpdateManyWithoutCedenteNestedInput
    cedente_analise?: cedente_analiseUncheckedUpdateManyWithoutCedente_cedenteTocedente_analiseNestedInput
  }

  export type sacadoUpsertWithoutCedente_n_sacadosInput = {
    update: XOR<sacadoUpdateWithoutCedente_n_sacadosInput, sacadoUncheckedUpdateWithoutCedente_n_sacadosInput>
    create: XOR<sacadoCreateWithoutCedente_n_sacadosInput, sacadoUncheckedCreateWithoutCedente_n_sacadosInput>
  }

  export type sacadoUpdateWithoutCedente_n_sacadosInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type sacadoUncheckedUpdateWithoutCedente_n_sacadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type carteiraCreateWithoutFidic_fundoInput = {
    bordero?: borderoCreateNestedManyWithoutCarteiraInput
    carteira_n_cedentes?: carteira_n_cedentesCreateNestedManyWithoutCarteiraInput
  }

  export type carteiraUncheckedCreateWithoutFidic_fundoInput = {
    id?: number
    bordero?: borderoUncheckedCreateNestedManyWithoutCarteiraInput
    carteira_n_cedentes?: carteira_n_cedentesUncheckedCreateNestedManyWithoutCarteiraInput
  }

  export type carteiraCreateOrConnectWithoutFidic_fundoInput = {
    where: carteiraWhereUniqueInput
    create: XOR<carteiraCreateWithoutFidic_fundoInput, carteiraUncheckedCreateWithoutFidic_fundoInput>
  }

  export type carteiraCreateManyFidic_fundoInputEnvelope = {
    data: Enumerable<carteiraCreateManyFidic_fundoInput>
    skipDuplicates?: boolean
  }

  export type fidic_fundo_x_usuarioCreateWithoutFidic_fundoInput = {
    usuario?: number | null
  }

  export type fidic_fundo_x_usuarioUncheckedCreateWithoutFidic_fundoInput = {
    id?: number
    usuario?: number | null
  }

  export type fidic_fundo_x_usuarioCreateOrConnectWithoutFidic_fundoInput = {
    where: fidic_fundo_x_usuarioWhereUniqueInput
    create: XOR<fidic_fundo_x_usuarioCreateWithoutFidic_fundoInput, fidic_fundo_x_usuarioUncheckedCreateWithoutFidic_fundoInput>
  }

  export type fidic_fundo_x_usuarioCreateManyFidic_fundoInputEnvelope = {
    data: Enumerable<fidic_fundo_x_usuarioCreateManyFidic_fundoInput>
    skipDuplicates?: boolean
  }

  export type carteiraUpsertWithWhereUniqueWithoutFidic_fundoInput = {
    where: carteiraWhereUniqueInput
    update: XOR<carteiraUpdateWithoutFidic_fundoInput, carteiraUncheckedUpdateWithoutFidic_fundoInput>
    create: XOR<carteiraCreateWithoutFidic_fundoInput, carteiraUncheckedCreateWithoutFidic_fundoInput>
  }

  export type carteiraUpdateWithWhereUniqueWithoutFidic_fundoInput = {
    where: carteiraWhereUniqueInput
    data: XOR<carteiraUpdateWithoutFidic_fundoInput, carteiraUncheckedUpdateWithoutFidic_fundoInput>
  }

  export type carteiraUpdateManyWithWhereWithoutFidic_fundoInput = {
    where: carteiraScalarWhereInput
    data: XOR<carteiraUpdateManyMutationInput, carteiraUncheckedUpdateManyWithoutCarteiraInput>
  }

  export type carteiraScalarWhereInput = {
    AND?: Enumerable<carteiraScalarWhereInput>
    OR?: Enumerable<carteiraScalarWhereInput>
    NOT?: Enumerable<carteiraScalarWhereInput>
    id?: IntFilter | number
    fiduc_fundo_id?: IntFilter | number
  }

  export type fidic_fundo_x_usuarioUpsertWithWhereUniqueWithoutFidic_fundoInput = {
    where: fidic_fundo_x_usuarioWhereUniqueInput
    update: XOR<fidic_fundo_x_usuarioUpdateWithoutFidic_fundoInput, fidic_fundo_x_usuarioUncheckedUpdateWithoutFidic_fundoInput>
    create: XOR<fidic_fundo_x_usuarioCreateWithoutFidic_fundoInput, fidic_fundo_x_usuarioUncheckedCreateWithoutFidic_fundoInput>
  }

  export type fidic_fundo_x_usuarioUpdateWithWhereUniqueWithoutFidic_fundoInput = {
    where: fidic_fundo_x_usuarioWhereUniqueInput
    data: XOR<fidic_fundo_x_usuarioUpdateWithoutFidic_fundoInput, fidic_fundo_x_usuarioUncheckedUpdateWithoutFidic_fundoInput>
  }

  export type fidic_fundo_x_usuarioUpdateManyWithWhereWithoutFidic_fundoInput = {
    where: fidic_fundo_x_usuarioScalarWhereInput
    data: XOR<fidic_fundo_x_usuarioUpdateManyMutationInput, fidic_fundo_x_usuarioUncheckedUpdateManyWithoutFidic_fundo_x_usuarioInput>
  }

  export type fidic_fundo_x_usuarioScalarWhereInput = {
    AND?: Enumerable<fidic_fundo_x_usuarioScalarWhereInput>
    OR?: Enumerable<fidic_fundo_x_usuarioScalarWhereInput>
    NOT?: Enumerable<fidic_fundo_x_usuarioScalarWhereInput>
    id?: IntFilter | number
    usuario?: IntNullableFilter | number | null
    fidic?: IntFilter | number
  }

  export type fidic_fundoCreateWithoutFidic_fundo_x_usuarioInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    carteira?: carteiraCreateNestedManyWithoutFidic_fundoInput
  }

  export type fidic_fundoUncheckedCreateWithoutFidic_fundo_x_usuarioInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    carteira?: carteiraUncheckedCreateNestedManyWithoutFidic_fundoInput
  }

  export type fidic_fundoCreateOrConnectWithoutFidic_fundo_x_usuarioInput = {
    where: fidic_fundoWhereUniqueInput
    create: XOR<fidic_fundoCreateWithoutFidic_fundo_x_usuarioInput, fidic_fundoUncheckedCreateWithoutFidic_fundo_x_usuarioInput>
  }

  export type fidic_fundoUpsertWithoutFidic_fundo_x_usuarioInput = {
    update: XOR<fidic_fundoUpdateWithoutFidic_fundo_x_usuarioInput, fidic_fundoUncheckedUpdateWithoutFidic_fundo_x_usuarioInput>
    create: XOR<fidic_fundoCreateWithoutFidic_fundo_x_usuarioInput, fidic_fundoUncheckedCreateWithoutFidic_fundo_x_usuarioInput>
  }

  export type fidic_fundoUpdateWithoutFidic_fundo_x_usuarioInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    carteira?: carteiraUpdateManyWithoutFidic_fundoNestedInput
  }

  export type fidic_fundoUncheckedUpdateWithoutFidic_fundo_x_usuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    carteira?: carteiraUncheckedUpdateManyWithoutFidic_fundoNestedInput
  }

  export type organograma_tipoCreateWithoutOrganogramaInput = {
    nome: string
  }

  export type organograma_tipoUncheckedCreateWithoutOrganogramaInput = {
    id?: number
    nome: string
  }

  export type organograma_tipoCreateOrConnectWithoutOrganogramaInput = {
    where: organograma_tipoWhereUniqueInput
    create: XOR<organograma_tipoCreateWithoutOrganogramaInput, organograma_tipoUncheckedCreateWithoutOrganogramaInput>
  }

  export type organograma_x_regiao_atuacaoCreateWithoutOrganogramaInput = {
    regiao_atuacao: regiao_atuacaoCreateNestedOneWithoutOrganograma_x_regiao_atuacaoInput
  }

  export type organograma_x_regiao_atuacaoUncheckedCreateWithoutOrganogramaInput = {
    id?: number
    regiao_atuacao_id: number
  }

  export type organograma_x_regiao_atuacaoCreateOrConnectWithoutOrganogramaInput = {
    where: organograma_x_regiao_atuacaoWhereUniqueInput
    create: XOR<organograma_x_regiao_atuacaoCreateWithoutOrganogramaInput, organograma_x_regiao_atuacaoUncheckedCreateWithoutOrganogramaInput>
  }

  export type organograma_x_regiao_atuacaoCreateManyOrganogramaInputEnvelope = {
    data: Enumerable<organograma_x_regiao_atuacaoCreateManyOrganogramaInput>
    skipDuplicates?: boolean
  }

  export type organograma_x_usuarioCreateWithoutOrganogramaInput = {
    usuario_id: number
  }

  export type organograma_x_usuarioUncheckedCreateWithoutOrganogramaInput = {
    id?: number
    usuario_id: number
  }

  export type organograma_x_usuarioCreateOrConnectWithoutOrganogramaInput = {
    where: organograma_x_usuarioWhereUniqueInput
    create: XOR<organograma_x_usuarioCreateWithoutOrganogramaInput, organograma_x_usuarioUncheckedCreateWithoutOrganogramaInput>
  }

  export type organograma_x_usuarioCreateManyOrganogramaInputEnvelope = {
    data: Enumerable<organograma_x_usuarioCreateManyOrganogramaInput>
    skipDuplicates?: boolean
  }

  export type organograma_tipoUpsertWithoutOrganogramaInput = {
    update: XOR<organograma_tipoUpdateWithoutOrganogramaInput, organograma_tipoUncheckedUpdateWithoutOrganogramaInput>
    create: XOR<organograma_tipoCreateWithoutOrganogramaInput, organograma_tipoUncheckedCreateWithoutOrganogramaInput>
  }

  export type organograma_tipoUpdateWithoutOrganogramaInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type organograma_tipoUncheckedUpdateWithoutOrganogramaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type organograma_x_regiao_atuacaoUpsertWithWhereUniqueWithoutOrganogramaInput = {
    where: organograma_x_regiao_atuacaoWhereUniqueInput
    update: XOR<organograma_x_regiao_atuacaoUpdateWithoutOrganogramaInput, organograma_x_regiao_atuacaoUncheckedUpdateWithoutOrganogramaInput>
    create: XOR<organograma_x_regiao_atuacaoCreateWithoutOrganogramaInput, organograma_x_regiao_atuacaoUncheckedCreateWithoutOrganogramaInput>
  }

  export type organograma_x_regiao_atuacaoUpdateWithWhereUniqueWithoutOrganogramaInput = {
    where: organograma_x_regiao_atuacaoWhereUniqueInput
    data: XOR<organograma_x_regiao_atuacaoUpdateWithoutOrganogramaInput, organograma_x_regiao_atuacaoUncheckedUpdateWithoutOrganogramaInput>
  }

  export type organograma_x_regiao_atuacaoUpdateManyWithWhereWithoutOrganogramaInput = {
    where: organograma_x_regiao_atuacaoScalarWhereInput
    data: XOR<organograma_x_regiao_atuacaoUpdateManyMutationInput, organograma_x_regiao_atuacaoUncheckedUpdateManyWithoutOrganograma_x_regiao_atuacaoInput>
  }

  export type organograma_x_regiao_atuacaoScalarWhereInput = {
    AND?: Enumerable<organograma_x_regiao_atuacaoScalarWhereInput>
    OR?: Enumerable<organograma_x_regiao_atuacaoScalarWhereInput>
    NOT?: Enumerable<organograma_x_regiao_atuacaoScalarWhereInput>
    id?: IntFilter | number
    organograma_id?: IntFilter | number
    regiao_atuacao_id?: IntFilter | number
  }

  export type organograma_x_usuarioUpsertWithWhereUniqueWithoutOrganogramaInput = {
    where: organograma_x_usuarioWhereUniqueInput
    update: XOR<organograma_x_usuarioUpdateWithoutOrganogramaInput, organograma_x_usuarioUncheckedUpdateWithoutOrganogramaInput>
    create: XOR<organograma_x_usuarioCreateWithoutOrganogramaInput, organograma_x_usuarioUncheckedCreateWithoutOrganogramaInput>
  }

  export type organograma_x_usuarioUpdateWithWhereUniqueWithoutOrganogramaInput = {
    where: organograma_x_usuarioWhereUniqueInput
    data: XOR<organograma_x_usuarioUpdateWithoutOrganogramaInput, organograma_x_usuarioUncheckedUpdateWithoutOrganogramaInput>
  }

  export type organograma_x_usuarioUpdateManyWithWhereWithoutOrganogramaInput = {
    where: organograma_x_usuarioScalarWhereInput
    data: XOR<organograma_x_usuarioUpdateManyMutationInput, organograma_x_usuarioUncheckedUpdateManyWithoutOrganograma_x_usuarioInput>
  }

  export type organograma_x_usuarioScalarWhereInput = {
    AND?: Enumerable<organograma_x_usuarioScalarWhereInput>
    OR?: Enumerable<organograma_x_usuarioScalarWhereInput>
    NOT?: Enumerable<organograma_x_usuarioScalarWhereInput>
    id?: IntFilter | number
    organograma_id?: IntFilter | number
    usuario_id?: IntFilter | number
  }

  export type organogramaCreateWithoutOrganograma_tipoInput = {
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoCreateNestedManyWithoutOrganogramaInput
    organograma_x_usuario?: organograma_x_usuarioCreateNestedManyWithoutOrganogramaInput
  }

  export type organogramaUncheckedCreateWithoutOrganograma_tipoInput = {
    id?: number
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUncheckedCreateNestedManyWithoutOrganogramaInput
    organograma_x_usuario?: organograma_x_usuarioUncheckedCreateNestedManyWithoutOrganogramaInput
  }

  export type organogramaCreateOrConnectWithoutOrganograma_tipoInput = {
    where: organogramaWhereUniqueInput
    create: XOR<organogramaCreateWithoutOrganograma_tipoInput, organogramaUncheckedCreateWithoutOrganograma_tipoInput>
  }

  export type organogramaCreateManyOrganograma_tipoInputEnvelope = {
    data: Enumerable<organogramaCreateManyOrganograma_tipoInput>
    skipDuplicates?: boolean
  }

  export type organogramaUpsertWithWhereUniqueWithoutOrganograma_tipoInput = {
    where: organogramaWhereUniqueInput
    update: XOR<organogramaUpdateWithoutOrganograma_tipoInput, organogramaUncheckedUpdateWithoutOrganograma_tipoInput>
    create: XOR<organogramaCreateWithoutOrganograma_tipoInput, organogramaUncheckedCreateWithoutOrganograma_tipoInput>
  }

  export type organogramaUpdateWithWhereUniqueWithoutOrganograma_tipoInput = {
    where: organogramaWhereUniqueInput
    data: XOR<organogramaUpdateWithoutOrganograma_tipoInput, organogramaUncheckedUpdateWithoutOrganograma_tipoInput>
  }

  export type organogramaUpdateManyWithWhereWithoutOrganograma_tipoInput = {
    where: organogramaScalarWhereInput
    data: XOR<organogramaUpdateManyMutationInput, organogramaUncheckedUpdateManyWithoutOrganogramaInput>
  }

  export type organogramaScalarWhereInput = {
    AND?: Enumerable<organogramaScalarWhereInput>
    OR?: Enumerable<organogramaScalarWhereInput>
    NOT?: Enumerable<organogramaScalarWhereInput>
    id?: IntFilter | number
    organograma_id?: IntFilter | number
  }

  export type organogramaCreateWithoutOrganograma_x_regiao_atuacaoInput = {
    organograma_tipo: organograma_tipoCreateNestedOneWithoutOrganogramaInput
    organograma_x_usuario?: organograma_x_usuarioCreateNestedManyWithoutOrganogramaInput
  }

  export type organogramaUncheckedCreateWithoutOrganograma_x_regiao_atuacaoInput = {
    id?: number
    organograma_id: number
    organograma_x_usuario?: organograma_x_usuarioUncheckedCreateNestedManyWithoutOrganogramaInput
  }

  export type organogramaCreateOrConnectWithoutOrganograma_x_regiao_atuacaoInput = {
    where: organogramaWhereUniqueInput
    create: XOR<organogramaCreateWithoutOrganograma_x_regiao_atuacaoInput, organogramaUncheckedCreateWithoutOrganograma_x_regiao_atuacaoInput>
  }

  export type regiao_atuacaoCreateWithoutOrganograma_x_regiao_atuacaoInput = {
    nome: string
    regiao_atuacao_tipo: regiao_atuacao_tipoCreateNestedOneWithoutRegiao_atuacaoInput
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoCreateNestedManyWithoutRegiao_atuacaoInput
  }

  export type regiao_atuacaoUncheckedCreateWithoutOrganograma_x_regiao_atuacaoInput = {
    id?: number
    nome: string
    regiao_atuacao_tipo_id: number
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUncheckedCreateNestedManyWithoutRegiao_atuacaoInput
  }

  export type regiao_atuacaoCreateOrConnectWithoutOrganograma_x_regiao_atuacaoInput = {
    where: regiao_atuacaoWhereUniqueInput
    create: XOR<regiao_atuacaoCreateWithoutOrganograma_x_regiao_atuacaoInput, regiao_atuacaoUncheckedCreateWithoutOrganograma_x_regiao_atuacaoInput>
  }

  export type organogramaUpsertWithoutOrganograma_x_regiao_atuacaoInput = {
    update: XOR<organogramaUpdateWithoutOrganograma_x_regiao_atuacaoInput, organogramaUncheckedUpdateWithoutOrganograma_x_regiao_atuacaoInput>
    create: XOR<organogramaCreateWithoutOrganograma_x_regiao_atuacaoInput, organogramaUncheckedCreateWithoutOrganograma_x_regiao_atuacaoInput>
  }

  export type organogramaUpdateWithoutOrganograma_x_regiao_atuacaoInput = {
    organograma_tipo?: organograma_tipoUpdateOneRequiredWithoutOrganogramaNestedInput
    organograma_x_usuario?: organograma_x_usuarioUpdateManyWithoutOrganogramaNestedInput
  }

  export type organogramaUncheckedUpdateWithoutOrganograma_x_regiao_atuacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    organograma_id?: IntFieldUpdateOperationsInput | number
    organograma_x_usuario?: organograma_x_usuarioUncheckedUpdateManyWithoutOrganogramaNestedInput
  }

  export type regiao_atuacaoUpsertWithoutOrganograma_x_regiao_atuacaoInput = {
    update: XOR<regiao_atuacaoUpdateWithoutOrganograma_x_regiao_atuacaoInput, regiao_atuacaoUncheckedUpdateWithoutOrganograma_x_regiao_atuacaoInput>
    create: XOR<regiao_atuacaoCreateWithoutOrganograma_x_regiao_atuacaoInput, regiao_atuacaoUncheckedCreateWithoutOrganograma_x_regiao_atuacaoInput>
  }

  export type regiao_atuacaoUpdateWithoutOrganograma_x_regiao_atuacaoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    regiao_atuacao_tipo?: regiao_atuacao_tipoUpdateOneRequiredWithoutRegiao_atuacaoNestedInput
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUpdateManyWithoutRegiao_atuacaoNestedInput
  }

  export type regiao_atuacaoUncheckedUpdateWithoutOrganograma_x_regiao_atuacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    regiao_atuacao_tipo_id?: IntFieldUpdateOperationsInput | number
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUncheckedUpdateManyWithoutRegiao_atuacaoNestedInput
  }

  export type usuarioCreateWithoutPessoaInput = {
    email: string
    senha: string
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type usuarioUncheckedCreateWithoutPessoaInput = {
    id?: number
    email: string
    senha: string
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type usuarioCreateOrConnectWithoutPessoaInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutPessoaInput, usuarioUncheckedCreateWithoutPessoaInput>
  }

  export type usuarioCreateManyPessoaInputEnvelope = {
    data: Enumerable<usuarioCreateManyPessoaInput>
    skipDuplicates?: boolean
  }

  export type usuarioUpsertWithWhereUniqueWithoutPessoaInput = {
    where: usuarioWhereUniqueInput
    update: XOR<usuarioUpdateWithoutPessoaInput, usuarioUncheckedUpdateWithoutPessoaInput>
    create: XOR<usuarioCreateWithoutPessoaInput, usuarioUncheckedCreateWithoutPessoaInput>
  }

  export type usuarioUpdateWithWhereUniqueWithoutPessoaInput = {
    where: usuarioWhereUniqueInput
    data: XOR<usuarioUpdateWithoutPessoaInput, usuarioUncheckedUpdateWithoutPessoaInput>
  }

  export type usuarioUpdateManyWithWhereWithoutPessoaInput = {
    where: usuarioScalarWhereInput
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type usuarioScalarWhereInput = {
    AND?: Enumerable<usuarioScalarWhereInput>
    OR?: Enumerable<usuarioScalarWhereInput>
    NOT?: Enumerable<usuarioScalarWhereInput>
    id?: IntFilter | number
    email?: StringFilter | string
    senha?: StringFilter | string
    pessoa_id?: IntFilter | number
    status?: StringNullableFilter | string | null
    primeiro_acesso?: BoolNullableFilter | boolean | null
    confirmou_cadastro?: BoolNullableFilter | boolean | null
    codigo_confirma_cadastro?: StringNullableFilter | string | null
    codigo_reset_senha?: StringNullableFilter | string | null
    codigo_data_expiracao?: DateTimeNullableFilter | Date | string | null
    created_at?: DateTimeFilter | Date | string
    updated_at?: DateTimeNullableFilter | Date | string | null
  }

  export type plataforma_papel_tipoCreateWithoutPlataformaInput = {

  }

  export type plataforma_papel_tipoUncheckedCreateWithoutPlataformaInput = {
    id?: number
  }

  export type plataforma_papel_tipoCreateOrConnectWithoutPlataformaInput = {
    where: plataforma_papel_tipoWhereUniqueInput
    create: XOR<plataforma_papel_tipoCreateWithoutPlataformaInput, plataforma_papel_tipoUncheckedCreateWithoutPlataformaInput>
  }

  export type plataforma_x_regiao_atuacaoCreateWithoutPlataformaInput = {
    regiao_atuacao: regiao_atuacaoCreateNestedOneWithoutPlataforma_x_regiao_atuacaoInput
  }

  export type plataforma_x_regiao_atuacaoUncheckedCreateWithoutPlataformaInput = {
    id?: number
    regiao_atuacao_id: number
  }

  export type plataforma_x_regiao_atuacaoCreateOrConnectWithoutPlataformaInput = {
    where: plataforma_x_regiao_atuacaoWhereUniqueInput
    create: XOR<plataforma_x_regiao_atuacaoCreateWithoutPlataformaInput, plataforma_x_regiao_atuacaoUncheckedCreateWithoutPlataformaInput>
  }

  export type plataforma_x_regiao_atuacaoCreateManyPlataformaInputEnvelope = {
    data: Enumerable<plataforma_x_regiao_atuacaoCreateManyPlataformaInput>
    skipDuplicates?: boolean
  }

  export type plataforma_x_usuarioCreateWithoutPlataformaInput = {
    usuario_id: number
  }

  export type plataforma_x_usuarioUncheckedCreateWithoutPlataformaInput = {
    id?: number
    usuario_id: number
  }

  export type plataforma_x_usuarioCreateOrConnectWithoutPlataformaInput = {
    where: plataforma_x_usuarioWhereUniqueInput
    create: XOR<plataforma_x_usuarioCreateWithoutPlataformaInput, plataforma_x_usuarioUncheckedCreateWithoutPlataformaInput>
  }

  export type plataforma_x_usuarioCreateManyPlataformaInputEnvelope = {
    data: Enumerable<plataforma_x_usuarioCreateManyPlataformaInput>
    skipDuplicates?: boolean
  }

  export type plataforma_papel_tipoUpsertWithoutPlataformaInput = {
    update: XOR<plataforma_papel_tipoUpdateWithoutPlataformaInput, plataforma_papel_tipoUncheckedUpdateWithoutPlataformaInput>
    create: XOR<plataforma_papel_tipoCreateWithoutPlataformaInput, plataforma_papel_tipoUncheckedCreateWithoutPlataformaInput>
  }

  export type plataforma_papel_tipoUpdateWithoutPlataformaInput = {

  }

  export type plataforma_papel_tipoUncheckedUpdateWithoutPlataformaInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_x_regiao_atuacaoUpsertWithWhereUniqueWithoutPlataformaInput = {
    where: plataforma_x_regiao_atuacaoWhereUniqueInput
    update: XOR<plataforma_x_regiao_atuacaoUpdateWithoutPlataformaInput, plataforma_x_regiao_atuacaoUncheckedUpdateWithoutPlataformaInput>
    create: XOR<plataforma_x_regiao_atuacaoCreateWithoutPlataformaInput, plataforma_x_regiao_atuacaoUncheckedCreateWithoutPlataformaInput>
  }

  export type plataforma_x_regiao_atuacaoUpdateWithWhereUniqueWithoutPlataformaInput = {
    where: plataforma_x_regiao_atuacaoWhereUniqueInput
    data: XOR<plataforma_x_regiao_atuacaoUpdateWithoutPlataformaInput, plataforma_x_regiao_atuacaoUncheckedUpdateWithoutPlataformaInput>
  }

  export type plataforma_x_regiao_atuacaoUpdateManyWithWhereWithoutPlataformaInput = {
    where: plataforma_x_regiao_atuacaoScalarWhereInput
    data: XOR<plataforma_x_regiao_atuacaoUpdateManyMutationInput, plataforma_x_regiao_atuacaoUncheckedUpdateManyWithoutPlataforma_x_regiao_atuacaoInput>
  }

  export type plataforma_x_regiao_atuacaoScalarWhereInput = {
    AND?: Enumerable<plataforma_x_regiao_atuacaoScalarWhereInput>
    OR?: Enumerable<plataforma_x_regiao_atuacaoScalarWhereInput>
    NOT?: Enumerable<plataforma_x_regiao_atuacaoScalarWhereInput>
    id?: IntFilter | number
    plataforma_id?: IntFilter | number
    regiao_atuacao_id?: IntFilter | number
  }

  export type plataforma_x_usuarioUpsertWithWhereUniqueWithoutPlataformaInput = {
    where: plataforma_x_usuarioWhereUniqueInput
    update: XOR<plataforma_x_usuarioUpdateWithoutPlataformaInput, plataforma_x_usuarioUncheckedUpdateWithoutPlataformaInput>
    create: XOR<plataforma_x_usuarioCreateWithoutPlataformaInput, plataforma_x_usuarioUncheckedCreateWithoutPlataformaInput>
  }

  export type plataforma_x_usuarioUpdateWithWhereUniqueWithoutPlataformaInput = {
    where: plataforma_x_usuarioWhereUniqueInput
    data: XOR<plataforma_x_usuarioUpdateWithoutPlataformaInput, plataforma_x_usuarioUncheckedUpdateWithoutPlataformaInput>
  }

  export type plataforma_x_usuarioUpdateManyWithWhereWithoutPlataformaInput = {
    where: plataforma_x_usuarioScalarWhereInput
    data: XOR<plataforma_x_usuarioUpdateManyMutationInput, plataforma_x_usuarioUncheckedUpdateManyWithoutPlataforma_x_usuarioInput>
  }

  export type plataforma_x_usuarioScalarWhereInput = {
    AND?: Enumerable<plataforma_x_usuarioScalarWhereInput>
    OR?: Enumerable<plataforma_x_usuarioScalarWhereInput>
    NOT?: Enumerable<plataforma_x_usuarioScalarWhereInput>
    id?: IntFilter | number
    plataforma_id?: IntFilter | number
    usuario_id?: IntFilter | number
  }

  export type plataformaCreateWithoutPlataforma_papel_tipoInput = {
    nome?: string | null
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoCreateNestedManyWithoutPlataformaInput
    plataforma_x_usuario?: plataforma_x_usuarioCreateNestedManyWithoutPlataformaInput
  }

  export type plataformaUncheckedCreateWithoutPlataforma_papel_tipoInput = {
    id?: number
    nome?: string | null
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUncheckedCreateNestedManyWithoutPlataformaInput
    plataforma_x_usuario?: plataforma_x_usuarioUncheckedCreateNestedManyWithoutPlataformaInput
  }

  export type plataformaCreateOrConnectWithoutPlataforma_papel_tipoInput = {
    where: plataformaWhereUniqueInput
    create: XOR<plataformaCreateWithoutPlataforma_papel_tipoInput, plataformaUncheckedCreateWithoutPlataforma_papel_tipoInput>
  }

  export type plataformaCreateManyPlataforma_papel_tipoInputEnvelope = {
    data: Enumerable<plataformaCreateManyPlataforma_papel_tipoInput>
    skipDuplicates?: boolean
  }

  export type plataformaUpsertWithWhereUniqueWithoutPlataforma_papel_tipoInput = {
    where: plataformaWhereUniqueInput
    update: XOR<plataformaUpdateWithoutPlataforma_papel_tipoInput, plataformaUncheckedUpdateWithoutPlataforma_papel_tipoInput>
    create: XOR<plataformaCreateWithoutPlataforma_papel_tipoInput, plataformaUncheckedCreateWithoutPlataforma_papel_tipoInput>
  }

  export type plataformaUpdateWithWhereUniqueWithoutPlataforma_papel_tipoInput = {
    where: plataformaWhereUniqueInput
    data: XOR<plataformaUpdateWithoutPlataforma_papel_tipoInput, plataformaUncheckedUpdateWithoutPlataforma_papel_tipoInput>
  }

  export type plataformaUpdateManyWithWhereWithoutPlataforma_papel_tipoInput = {
    where: plataformaScalarWhereInput
    data: XOR<plataformaUpdateManyMutationInput, plataformaUncheckedUpdateManyWithoutPlataformaInput>
  }

  export type plataformaScalarWhereInput = {
    AND?: Enumerable<plataformaScalarWhereInput>
    OR?: Enumerable<plataformaScalarWhereInput>
    NOT?: Enumerable<plataformaScalarWhereInput>
    id?: IntFilter | number
    nome?: StringNullableFilter | string | null
    plataforma_papel_tipo_id?: IntFilter | number
  }

  export type plataformaCreateWithoutPlataforma_x_regiao_atuacaoInput = {
    nome?: string | null
    plataforma_papel_tipo: plataforma_papel_tipoCreateNestedOneWithoutPlataformaInput
    plataforma_x_usuario?: plataforma_x_usuarioCreateNestedManyWithoutPlataformaInput
  }

  export type plataformaUncheckedCreateWithoutPlataforma_x_regiao_atuacaoInput = {
    id?: number
    nome?: string | null
    plataforma_papel_tipo_id: number
    plataforma_x_usuario?: plataforma_x_usuarioUncheckedCreateNestedManyWithoutPlataformaInput
  }

  export type plataformaCreateOrConnectWithoutPlataforma_x_regiao_atuacaoInput = {
    where: plataformaWhereUniqueInput
    create: XOR<plataformaCreateWithoutPlataforma_x_regiao_atuacaoInput, plataformaUncheckedCreateWithoutPlataforma_x_regiao_atuacaoInput>
  }

  export type regiao_atuacaoCreateWithoutPlataforma_x_regiao_atuacaoInput = {
    nome: string
    regiao_atuacao_tipo: regiao_atuacao_tipoCreateNestedOneWithoutRegiao_atuacaoInput
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoCreateNestedManyWithoutRegiao_atuacaoInput
  }

  export type regiao_atuacaoUncheckedCreateWithoutPlataforma_x_regiao_atuacaoInput = {
    id?: number
    nome: string
    regiao_atuacao_tipo_id: number
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUncheckedCreateNestedManyWithoutRegiao_atuacaoInput
  }

  export type regiao_atuacaoCreateOrConnectWithoutPlataforma_x_regiao_atuacaoInput = {
    where: regiao_atuacaoWhereUniqueInput
    create: XOR<regiao_atuacaoCreateWithoutPlataforma_x_regiao_atuacaoInput, regiao_atuacaoUncheckedCreateWithoutPlataforma_x_regiao_atuacaoInput>
  }

  export type plataformaUpsertWithoutPlataforma_x_regiao_atuacaoInput = {
    update: XOR<plataformaUpdateWithoutPlataforma_x_regiao_atuacaoInput, plataformaUncheckedUpdateWithoutPlataforma_x_regiao_atuacaoInput>
    create: XOR<plataformaCreateWithoutPlataforma_x_regiao_atuacaoInput, plataformaUncheckedCreateWithoutPlataforma_x_regiao_atuacaoInput>
  }

  export type plataformaUpdateWithoutPlataforma_x_regiao_atuacaoInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    plataforma_papel_tipo?: plataforma_papel_tipoUpdateOneRequiredWithoutPlataformaNestedInput
    plataforma_x_usuario?: plataforma_x_usuarioUpdateManyWithoutPlataformaNestedInput
  }

  export type plataformaUncheckedUpdateWithoutPlataforma_x_regiao_atuacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    plataforma_papel_tipo_id?: IntFieldUpdateOperationsInput | number
    plataforma_x_usuario?: plataforma_x_usuarioUncheckedUpdateManyWithoutPlataformaNestedInput
  }

  export type regiao_atuacaoUpsertWithoutPlataforma_x_regiao_atuacaoInput = {
    update: XOR<regiao_atuacaoUpdateWithoutPlataforma_x_regiao_atuacaoInput, regiao_atuacaoUncheckedUpdateWithoutPlataforma_x_regiao_atuacaoInput>
    create: XOR<regiao_atuacaoCreateWithoutPlataforma_x_regiao_atuacaoInput, regiao_atuacaoUncheckedCreateWithoutPlataforma_x_regiao_atuacaoInput>
  }

  export type regiao_atuacaoUpdateWithoutPlataforma_x_regiao_atuacaoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    regiao_atuacao_tipo?: regiao_atuacao_tipoUpdateOneRequiredWithoutRegiao_atuacaoNestedInput
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUpdateManyWithoutRegiao_atuacaoNestedInput
  }

  export type regiao_atuacaoUncheckedUpdateWithoutPlataforma_x_regiao_atuacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    regiao_atuacao_tipo_id?: IntFieldUpdateOperationsInput | number
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUncheckedUpdateManyWithoutRegiao_atuacaoNestedInput
  }

  export type regiao_atuacao_tipoCreateWithoutRegiao_atuacaoInput = {
    nome: string
  }

  export type regiao_atuacao_tipoUncheckedCreateWithoutRegiao_atuacaoInput = {
    id?: number
    nome: string
  }

  export type regiao_atuacao_tipoCreateOrConnectWithoutRegiao_atuacaoInput = {
    where: regiao_atuacao_tipoWhereUniqueInput
    create: XOR<regiao_atuacao_tipoCreateWithoutRegiao_atuacaoInput, regiao_atuacao_tipoUncheckedCreateWithoutRegiao_atuacaoInput>
  }

  export type organograma_x_regiao_atuacaoCreateWithoutRegiao_atuacaoInput = {
    organograma: organogramaCreateNestedOneWithoutOrganograma_x_regiao_atuacaoInput
  }

  export type organograma_x_regiao_atuacaoUncheckedCreateWithoutRegiao_atuacaoInput = {
    id?: number
    organograma_id: number
  }

  export type organograma_x_regiao_atuacaoCreateOrConnectWithoutRegiao_atuacaoInput = {
    where: organograma_x_regiao_atuacaoWhereUniqueInput
    create: XOR<organograma_x_regiao_atuacaoCreateWithoutRegiao_atuacaoInput, organograma_x_regiao_atuacaoUncheckedCreateWithoutRegiao_atuacaoInput>
  }

  export type organograma_x_regiao_atuacaoCreateManyRegiao_atuacaoInputEnvelope = {
    data: Enumerable<organograma_x_regiao_atuacaoCreateManyRegiao_atuacaoInput>
    skipDuplicates?: boolean
  }

  export type plataforma_x_regiao_atuacaoCreateWithoutRegiao_atuacaoInput = {
    plataforma: plataformaCreateNestedOneWithoutPlataforma_x_regiao_atuacaoInput
  }

  export type plataforma_x_regiao_atuacaoUncheckedCreateWithoutRegiao_atuacaoInput = {
    id?: number
    plataforma_id: number
  }

  export type plataforma_x_regiao_atuacaoCreateOrConnectWithoutRegiao_atuacaoInput = {
    where: plataforma_x_regiao_atuacaoWhereUniqueInput
    create: XOR<plataforma_x_regiao_atuacaoCreateWithoutRegiao_atuacaoInput, plataforma_x_regiao_atuacaoUncheckedCreateWithoutRegiao_atuacaoInput>
  }

  export type plataforma_x_regiao_atuacaoCreateManyRegiao_atuacaoInputEnvelope = {
    data: Enumerable<plataforma_x_regiao_atuacaoCreateManyRegiao_atuacaoInput>
    skipDuplicates?: boolean
  }

  export type regiao_atuacao_tipoUpsertWithoutRegiao_atuacaoInput = {
    update: XOR<regiao_atuacao_tipoUpdateWithoutRegiao_atuacaoInput, regiao_atuacao_tipoUncheckedUpdateWithoutRegiao_atuacaoInput>
    create: XOR<regiao_atuacao_tipoCreateWithoutRegiao_atuacaoInput, regiao_atuacao_tipoUncheckedCreateWithoutRegiao_atuacaoInput>
  }

  export type regiao_atuacao_tipoUpdateWithoutRegiao_atuacaoInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type regiao_atuacao_tipoUncheckedUpdateWithoutRegiao_atuacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type organograma_x_regiao_atuacaoUpsertWithWhereUniqueWithoutRegiao_atuacaoInput = {
    where: organograma_x_regiao_atuacaoWhereUniqueInput
    update: XOR<organograma_x_regiao_atuacaoUpdateWithoutRegiao_atuacaoInput, organograma_x_regiao_atuacaoUncheckedUpdateWithoutRegiao_atuacaoInput>
    create: XOR<organograma_x_regiao_atuacaoCreateWithoutRegiao_atuacaoInput, organograma_x_regiao_atuacaoUncheckedCreateWithoutRegiao_atuacaoInput>
  }

  export type organograma_x_regiao_atuacaoUpdateWithWhereUniqueWithoutRegiao_atuacaoInput = {
    where: organograma_x_regiao_atuacaoWhereUniqueInput
    data: XOR<organograma_x_regiao_atuacaoUpdateWithoutRegiao_atuacaoInput, organograma_x_regiao_atuacaoUncheckedUpdateWithoutRegiao_atuacaoInput>
  }

  export type organograma_x_regiao_atuacaoUpdateManyWithWhereWithoutRegiao_atuacaoInput = {
    where: organograma_x_regiao_atuacaoScalarWhereInput
    data: XOR<organograma_x_regiao_atuacaoUpdateManyMutationInput, organograma_x_regiao_atuacaoUncheckedUpdateManyWithoutOrganograma_x_regiao_atuacaoInput>
  }

  export type plataforma_x_regiao_atuacaoUpsertWithWhereUniqueWithoutRegiao_atuacaoInput = {
    where: plataforma_x_regiao_atuacaoWhereUniqueInput
    update: XOR<plataforma_x_regiao_atuacaoUpdateWithoutRegiao_atuacaoInput, plataforma_x_regiao_atuacaoUncheckedUpdateWithoutRegiao_atuacaoInput>
    create: XOR<plataforma_x_regiao_atuacaoCreateWithoutRegiao_atuacaoInput, plataforma_x_regiao_atuacaoUncheckedCreateWithoutRegiao_atuacaoInput>
  }

  export type plataforma_x_regiao_atuacaoUpdateWithWhereUniqueWithoutRegiao_atuacaoInput = {
    where: plataforma_x_regiao_atuacaoWhereUniqueInput
    data: XOR<plataforma_x_regiao_atuacaoUpdateWithoutRegiao_atuacaoInput, plataforma_x_regiao_atuacaoUncheckedUpdateWithoutRegiao_atuacaoInput>
  }

  export type plataforma_x_regiao_atuacaoUpdateManyWithWhereWithoutRegiao_atuacaoInput = {
    where: plataforma_x_regiao_atuacaoScalarWhereInput
    data: XOR<plataforma_x_regiao_atuacaoUpdateManyMutationInput, plataforma_x_regiao_atuacaoUncheckedUpdateManyWithoutPlataforma_x_regiao_atuacaoInput>
  }

  export type regiao_atuacaoCreateWithoutRegiao_atuacao_tipoInput = {
    nome: string
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoCreateNestedManyWithoutRegiao_atuacaoInput
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoCreateNestedManyWithoutRegiao_atuacaoInput
  }

  export type regiao_atuacaoUncheckedCreateWithoutRegiao_atuacao_tipoInput = {
    id?: number
    nome: string
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUncheckedCreateNestedManyWithoutRegiao_atuacaoInput
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUncheckedCreateNestedManyWithoutRegiao_atuacaoInput
  }

  export type regiao_atuacaoCreateOrConnectWithoutRegiao_atuacao_tipoInput = {
    where: regiao_atuacaoWhereUniqueInput
    create: XOR<regiao_atuacaoCreateWithoutRegiao_atuacao_tipoInput, regiao_atuacaoUncheckedCreateWithoutRegiao_atuacao_tipoInput>
  }

  export type regiao_atuacaoCreateManyRegiao_atuacao_tipoInputEnvelope = {
    data: Enumerable<regiao_atuacaoCreateManyRegiao_atuacao_tipoInput>
    skipDuplicates?: boolean
  }

  export type regiao_atuacaoUpsertWithWhereUniqueWithoutRegiao_atuacao_tipoInput = {
    where: regiao_atuacaoWhereUniqueInput
    update: XOR<regiao_atuacaoUpdateWithoutRegiao_atuacao_tipoInput, regiao_atuacaoUncheckedUpdateWithoutRegiao_atuacao_tipoInput>
    create: XOR<regiao_atuacaoCreateWithoutRegiao_atuacao_tipoInput, regiao_atuacaoUncheckedCreateWithoutRegiao_atuacao_tipoInput>
  }

  export type regiao_atuacaoUpdateWithWhereUniqueWithoutRegiao_atuacao_tipoInput = {
    where: regiao_atuacaoWhereUniqueInput
    data: XOR<regiao_atuacaoUpdateWithoutRegiao_atuacao_tipoInput, regiao_atuacaoUncheckedUpdateWithoutRegiao_atuacao_tipoInput>
  }

  export type regiao_atuacaoUpdateManyWithWhereWithoutRegiao_atuacao_tipoInput = {
    where: regiao_atuacaoScalarWhereInput
    data: XOR<regiao_atuacaoUpdateManyMutationInput, regiao_atuacaoUncheckedUpdateManyWithoutRegiao_atuacaoInput>
  }

  export type regiao_atuacaoScalarWhereInput = {
    AND?: Enumerable<regiao_atuacaoScalarWhereInput>
    OR?: Enumerable<regiao_atuacaoScalarWhereInput>
    NOT?: Enumerable<regiao_atuacaoScalarWhereInput>
    id?: IntFilter | number
    nome?: StringFilter | string
    regiao_atuacao_tipo_id?: IntFilter | number
  }

  export type cedente_n_sacadosCreateWithoutSacado_cedente_n_sacadosTosacadoInput = {
    cedente_cedenteTocedente_n_sacados?: cedenteCreateNestedOneWithoutCedente_n_sacadosInput
  }

  export type cedente_n_sacadosUncheckedCreateWithoutSacado_cedente_n_sacadosTosacadoInput = {
    id?: number
    cedente?: number | null
  }

  export type cedente_n_sacadosCreateOrConnectWithoutSacado_cedente_n_sacadosTosacadoInput = {
    where: cedente_n_sacadosWhereUniqueInput
    create: XOR<cedente_n_sacadosCreateWithoutSacado_cedente_n_sacadosTosacadoInput, cedente_n_sacadosUncheckedCreateWithoutSacado_cedente_n_sacadosTosacadoInput>
  }

  export type cedente_n_sacadosCreateManySacado_cedente_n_sacadosTosacadoInputEnvelope = {
    data: Enumerable<cedente_n_sacadosCreateManySacado_cedente_n_sacadosTosacadoInput>
    skipDuplicates?: boolean
  }

  export type cedente_n_sacadosUpsertWithWhereUniqueWithoutSacado_cedente_n_sacadosTosacadoInput = {
    where: cedente_n_sacadosWhereUniqueInput
    update: XOR<cedente_n_sacadosUpdateWithoutSacado_cedente_n_sacadosTosacadoInput, cedente_n_sacadosUncheckedUpdateWithoutSacado_cedente_n_sacadosTosacadoInput>
    create: XOR<cedente_n_sacadosCreateWithoutSacado_cedente_n_sacadosTosacadoInput, cedente_n_sacadosUncheckedCreateWithoutSacado_cedente_n_sacadosTosacadoInput>
  }

  export type cedente_n_sacadosUpdateWithWhereUniqueWithoutSacado_cedente_n_sacadosTosacadoInput = {
    where: cedente_n_sacadosWhereUniqueInput
    data: XOR<cedente_n_sacadosUpdateWithoutSacado_cedente_n_sacadosTosacadoInput, cedente_n_sacadosUncheckedUpdateWithoutSacado_cedente_n_sacadosTosacadoInput>
  }

  export type cedente_n_sacadosUpdateManyWithWhereWithoutSacado_cedente_n_sacadosTosacadoInput = {
    where: cedente_n_sacadosScalarWhereInput
    data: XOR<cedente_n_sacadosUpdateManyMutationInput, cedente_n_sacadosUncheckedUpdateManyWithoutCedente_n_sacadosInput>
  }

  export type titulo_tipoCreateWithoutTituloInput = {
    nome?: string | null
  }

  export type titulo_tipoUncheckedCreateWithoutTituloInput = {
    id?: number
    nome?: string | null
  }

  export type titulo_tipoCreateOrConnectWithoutTituloInput = {
    where: titulo_tipoWhereUniqueInput
    create: XOR<titulo_tipoCreateWithoutTituloInput, titulo_tipoUncheckedCreateWithoutTituloInput>
  }

  export type borderoCreateWithoutTituloInput = {
    carteira: carteiraCreateNestedOneWithoutBorderoInput
  }

  export type borderoUncheckedCreateWithoutTituloInput = {
    id?: number
    carteira_id: number
  }

  export type borderoCreateOrConnectWithoutTituloInput = {
    where: borderoWhereUniqueInput
    create: XOR<borderoCreateWithoutTituloInput, borderoUncheckedCreateWithoutTituloInput>
  }

  export type titulo_itensCreateWithoutTituloInput = {

  }

  export type titulo_itensUncheckedCreateWithoutTituloInput = {
    id?: number
  }

  export type titulo_itensCreateOrConnectWithoutTituloInput = {
    where: titulo_itensWhereUniqueInput
    create: XOR<titulo_itensCreateWithoutTituloInput, titulo_itensUncheckedCreateWithoutTituloInput>
  }

  export type titulo_itensCreateManyTituloInputEnvelope = {
    data: Enumerable<titulo_itensCreateManyTituloInput>
    skipDuplicates?: boolean
  }

  export type titulo_tipoUpsertWithoutTituloInput = {
    update: XOR<titulo_tipoUpdateWithoutTituloInput, titulo_tipoUncheckedUpdateWithoutTituloInput>
    create: XOR<titulo_tipoCreateWithoutTituloInput, titulo_tipoUncheckedCreateWithoutTituloInput>
  }

  export type titulo_tipoUpdateWithoutTituloInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type titulo_tipoUncheckedUpdateWithoutTituloInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type borderoUpsertWithoutTituloInput = {
    update: XOR<borderoUpdateWithoutTituloInput, borderoUncheckedUpdateWithoutTituloInput>
    create: XOR<borderoCreateWithoutTituloInput, borderoUncheckedCreateWithoutTituloInput>
  }

  export type borderoUpdateWithoutTituloInput = {
    carteira?: carteiraUpdateOneRequiredWithoutBorderoNestedInput
  }

  export type borderoUncheckedUpdateWithoutTituloInput = {
    id?: IntFieldUpdateOperationsInput | number
    carteira_id?: IntFieldUpdateOperationsInput | number
  }

  export type titulo_itensUpsertWithWhereUniqueWithoutTituloInput = {
    where: titulo_itensWhereUniqueInput
    update: XOR<titulo_itensUpdateWithoutTituloInput, titulo_itensUncheckedUpdateWithoutTituloInput>
    create: XOR<titulo_itensCreateWithoutTituloInput, titulo_itensUncheckedCreateWithoutTituloInput>
  }

  export type titulo_itensUpdateWithWhereUniqueWithoutTituloInput = {
    where: titulo_itensWhereUniqueInput
    data: XOR<titulo_itensUpdateWithoutTituloInput, titulo_itensUncheckedUpdateWithoutTituloInput>
  }

  export type titulo_itensUpdateManyWithWhereWithoutTituloInput = {
    where: titulo_itensScalarWhereInput
    data: XOR<titulo_itensUpdateManyMutationInput, titulo_itensUncheckedUpdateManyWithoutTitulo_itensInput>
  }

  export type titulo_itensScalarWhereInput = {
    AND?: Enumerable<titulo_itensScalarWhereInput>
    OR?: Enumerable<titulo_itensScalarWhereInput>
    NOT?: Enumerable<titulo_itensScalarWhereInput>
    id?: IntFilter | number
    titulo_id?: IntFilter | number
  }

  export type tituloCreateWithoutTitulo_tipoInput = {
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
    bordero: borderoCreateNestedOneWithoutTituloInput
    titulo_itens?: titulo_itensCreateNestedManyWithoutTituloInput
  }

  export type tituloUncheckedCreateWithoutTitulo_tipoInput = {
    id?: number
    bordero_id: number
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
    titulo_itens?: titulo_itensUncheckedCreateNestedManyWithoutTituloInput
  }

  export type tituloCreateOrConnectWithoutTitulo_tipoInput = {
    where: tituloWhereUniqueInput
    create: XOR<tituloCreateWithoutTitulo_tipoInput, tituloUncheckedCreateWithoutTitulo_tipoInput>
  }

  export type tituloCreateManyTitulo_tipoInputEnvelope = {
    data: Enumerable<tituloCreateManyTitulo_tipoInput>
    skipDuplicates?: boolean
  }

  export type tituloUpsertWithWhereUniqueWithoutTitulo_tipoInput = {
    where: tituloWhereUniqueInput
    update: XOR<tituloUpdateWithoutTitulo_tipoInput, tituloUncheckedUpdateWithoutTitulo_tipoInput>
    create: XOR<tituloCreateWithoutTitulo_tipoInput, tituloUncheckedCreateWithoutTitulo_tipoInput>
  }

  export type tituloUpdateWithWhereUniqueWithoutTitulo_tipoInput = {
    where: tituloWhereUniqueInput
    data: XOR<tituloUpdateWithoutTitulo_tipoInput, tituloUncheckedUpdateWithoutTitulo_tipoInput>
  }

  export type tituloUpdateManyWithWhereWithoutTitulo_tipoInput = {
    where: tituloScalarWhereInput
    data: XOR<tituloUpdateManyMutationInput, tituloUncheckedUpdateManyWithoutTituloInput>
  }

  export type pessoaCreateWithoutUsuarioInput = {
    nome: string
    sobrenome: string
    sexo?: string | null
    nascimento?: Date | string | null
    cpf?: string | null
    rg?: string | null
  }

  export type pessoaUncheckedCreateWithoutUsuarioInput = {
    id?: number
    nome: string
    sobrenome: string
    sexo?: string | null
    nascimento?: Date | string | null
    cpf?: string | null
    rg?: string | null
  }

  export type pessoaCreateOrConnectWithoutUsuarioInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutUsuarioInput, pessoaUncheckedCreateWithoutUsuarioInput>
  }

  export type pessoaUpsertWithoutUsuarioInput = {
    update: XOR<pessoaUpdateWithoutUsuarioInput, pessoaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<pessoaCreateWithoutUsuarioInput, pessoaUncheckedCreateWithoutUsuarioInput>
  }

  export type pessoaUpdateWithoutUsuarioInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pessoaUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    nascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    rg?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuario_perfilCreateWithoutUsuario_perfil_tipoInput = {
    senha: string
    usuario_id: number
  }

  export type usuario_perfilUncheckedCreateWithoutUsuario_perfil_tipoInput = {
    id?: number
    senha: string
    usuario_id: number
  }

  export type usuario_perfilCreateOrConnectWithoutUsuario_perfil_tipoInput = {
    where: usuario_perfilWhereUniqueInput
    create: XOR<usuario_perfilCreateWithoutUsuario_perfil_tipoInput, usuario_perfilUncheckedCreateWithoutUsuario_perfil_tipoInput>
  }

  export type usuario_perfilCreateManyUsuario_perfil_tipoInputEnvelope = {
    data: Enumerable<usuario_perfilCreateManyUsuario_perfil_tipoInput>
    skipDuplicates?: boolean
  }

  export type usuario_perfilUpsertWithWhereUniqueWithoutUsuario_perfil_tipoInput = {
    where: usuario_perfilWhereUniqueInput
    update: XOR<usuario_perfilUpdateWithoutUsuario_perfil_tipoInput, usuario_perfilUncheckedUpdateWithoutUsuario_perfil_tipoInput>
    create: XOR<usuario_perfilCreateWithoutUsuario_perfil_tipoInput, usuario_perfilUncheckedCreateWithoutUsuario_perfil_tipoInput>
  }

  export type usuario_perfilUpdateWithWhereUniqueWithoutUsuario_perfil_tipoInput = {
    where: usuario_perfilWhereUniqueInput
    data: XOR<usuario_perfilUpdateWithoutUsuario_perfil_tipoInput, usuario_perfilUncheckedUpdateWithoutUsuario_perfil_tipoInput>
  }

  export type usuario_perfilUpdateManyWithWhereWithoutUsuario_perfil_tipoInput = {
    where: usuario_perfilScalarWhereInput
    data: XOR<usuario_perfilUpdateManyMutationInput, usuario_perfilUncheckedUpdateManyWithoutUsuario_perfilInput>
  }

  export type usuario_perfilScalarWhereInput = {
    AND?: Enumerable<usuario_perfilScalarWhereInput>
    OR?: Enumerable<usuario_perfilScalarWhereInput>
    NOT?: Enumerable<usuario_perfilScalarWhereInput>
    id?: IntFilter | number
    senha?: StringFilter | string
    usuario_id?: IntFilter | number
    usuario_perfil_tipo_id?: IntFilter | number
  }

  export type carteiraCreateWithoutCarteira_n_cedentesInput = {
    fidic_fundo: fidic_fundoCreateNestedOneWithoutCarteiraInput
    bordero?: borderoCreateNestedManyWithoutCarteiraInput
  }

  export type carteiraUncheckedCreateWithoutCarteira_n_cedentesInput = {
    id?: number
    fiduc_fundo_id: number
    bordero?: borderoUncheckedCreateNestedManyWithoutCarteiraInput
  }

  export type carteiraCreateOrConnectWithoutCarteira_n_cedentesInput = {
    where: carteiraWhereUniqueInput
    create: XOR<carteiraCreateWithoutCarteira_n_cedentesInput, carteiraUncheckedCreateWithoutCarteira_n_cedentesInput>
  }

  export type cedenteCreateWithoutCarteira_n_cedentesInput = {
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    cedente_analise?: cedente_analiseCreateNestedManyWithoutCedente_cedenteTocedente_analiseInput
    cedente_n_sacados?: cedente_n_sacadosCreateNestedManyWithoutCedente_cedenteTocedente_n_sacadosInput
  }

  export type cedenteUncheckedCreateWithoutCarteira_n_cedentesInput = {
    id?: number
    pessoa_id: number
    razao_social: string
    nome_fantasia?: string | null
    abertura?: Date | string | null
    cnpj?: string | null
    endereco?: string | null
    numero?: string | null
    cep?: string | null
    bairro?: string | null
    cidade?: string | null
    uf?: string | null
    telefone?: string | null
    cedente_analise?: cedente_analiseUncheckedCreateNestedManyWithoutCedente_cedenteTocedente_analiseInput
    cedente_n_sacados?: cedente_n_sacadosUncheckedCreateNestedManyWithoutCedente_cedenteTocedente_n_sacadosInput
  }

  export type cedenteCreateOrConnectWithoutCarteira_n_cedentesInput = {
    where: cedenteWhereUniqueInput
    create: XOR<cedenteCreateWithoutCarteira_n_cedentesInput, cedenteUncheckedCreateWithoutCarteira_n_cedentesInput>
  }

  export type carteiraUpsertWithoutCarteira_n_cedentesInput = {
    update: XOR<carteiraUpdateWithoutCarteira_n_cedentesInput, carteiraUncheckedUpdateWithoutCarteira_n_cedentesInput>
    create: XOR<carteiraCreateWithoutCarteira_n_cedentesInput, carteiraUncheckedCreateWithoutCarteira_n_cedentesInput>
  }

  export type carteiraUpdateWithoutCarteira_n_cedentesInput = {
    fidic_fundo?: fidic_fundoUpdateOneRequiredWithoutCarteiraNestedInput
    bordero?: borderoUpdateManyWithoutCarteiraNestedInput
  }

  export type carteiraUncheckedUpdateWithoutCarteira_n_cedentesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fiduc_fundo_id?: IntFieldUpdateOperationsInput | number
    bordero?: borderoUncheckedUpdateManyWithoutCarteiraNestedInput
  }

  export type cedenteUpsertWithoutCarteira_n_cedentesInput = {
    update: XOR<cedenteUpdateWithoutCarteira_n_cedentesInput, cedenteUncheckedUpdateWithoutCarteira_n_cedentesInput>
    create: XOR<cedenteCreateWithoutCarteira_n_cedentesInput, cedenteUncheckedCreateWithoutCarteira_n_cedentesInput>
  }

  export type cedenteUpdateWithoutCarteira_n_cedentesInput = {
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cedente_analise?: cedente_analiseUpdateManyWithoutCedente_cedenteTocedente_analiseNestedInput
    cedente_n_sacados?: cedente_n_sacadosUpdateManyWithoutCedente_cedenteTocedente_n_sacadosNestedInput
  }

  export type cedenteUncheckedUpdateWithoutCarteira_n_cedentesInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoa_id?: IntFieldUpdateOperationsInput | number
    razao_social?: StringFieldUpdateOperationsInput | string
    nome_fantasia?: NullableStringFieldUpdateOperationsInput | string | null
    abertura?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cnpj?: NullableStringFieldUpdateOperationsInput | string | null
    endereco?: NullableStringFieldUpdateOperationsInput | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    cep?: NullableStringFieldUpdateOperationsInput | string | null
    bairro?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    uf?: NullableStringFieldUpdateOperationsInput | string | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cedente_analise?: cedente_analiseUncheckedUpdateManyWithoutCedente_cedenteTocedente_analiseNestedInput
    cedente_n_sacados?: cedente_n_sacadosUncheckedUpdateManyWithoutCedente_cedenteTocedente_n_sacadosNestedInput
  }

  export type organogramaCreateWithoutOrganograma_x_usuarioInput = {
    organograma_tipo: organograma_tipoCreateNestedOneWithoutOrganogramaInput
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoCreateNestedManyWithoutOrganogramaInput
  }

  export type organogramaUncheckedCreateWithoutOrganograma_x_usuarioInput = {
    id?: number
    organograma_id: number
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUncheckedCreateNestedManyWithoutOrganogramaInput
  }

  export type organogramaCreateOrConnectWithoutOrganograma_x_usuarioInput = {
    where: organogramaWhereUniqueInput
    create: XOR<organogramaCreateWithoutOrganograma_x_usuarioInput, organogramaUncheckedCreateWithoutOrganograma_x_usuarioInput>
  }

  export type organogramaUpsertWithoutOrganograma_x_usuarioInput = {
    update: XOR<organogramaUpdateWithoutOrganograma_x_usuarioInput, organogramaUncheckedUpdateWithoutOrganograma_x_usuarioInput>
    create: XOR<organogramaCreateWithoutOrganograma_x_usuarioInput, organogramaUncheckedCreateWithoutOrganograma_x_usuarioInput>
  }

  export type organogramaUpdateWithoutOrganograma_x_usuarioInput = {
    organograma_tipo?: organograma_tipoUpdateOneRequiredWithoutOrganogramaNestedInput
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUpdateManyWithoutOrganogramaNestedInput
  }

  export type organogramaUncheckedUpdateWithoutOrganograma_x_usuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    organograma_id?: IntFieldUpdateOperationsInput | number
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUncheckedUpdateManyWithoutOrganogramaNestedInput
  }

  export type plataformaCreateWithoutPlataforma_x_usuarioInput = {
    nome?: string | null
    plataforma_papel_tipo: plataforma_papel_tipoCreateNestedOneWithoutPlataformaInput
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoCreateNestedManyWithoutPlataformaInput
  }

  export type plataformaUncheckedCreateWithoutPlataforma_x_usuarioInput = {
    id?: number
    nome?: string | null
    plataforma_papel_tipo_id: number
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUncheckedCreateNestedManyWithoutPlataformaInput
  }

  export type plataformaCreateOrConnectWithoutPlataforma_x_usuarioInput = {
    where: plataformaWhereUniqueInput
    create: XOR<plataformaCreateWithoutPlataforma_x_usuarioInput, plataformaUncheckedCreateWithoutPlataforma_x_usuarioInput>
  }

  export type plataformaUpsertWithoutPlataforma_x_usuarioInput = {
    update: XOR<plataformaUpdateWithoutPlataforma_x_usuarioInput, plataformaUncheckedUpdateWithoutPlataforma_x_usuarioInput>
    create: XOR<plataformaCreateWithoutPlataforma_x_usuarioInput, plataformaUncheckedCreateWithoutPlataforma_x_usuarioInput>
  }

  export type plataformaUpdateWithoutPlataforma_x_usuarioInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    plataforma_papel_tipo?: plataforma_papel_tipoUpdateOneRequiredWithoutPlataformaNestedInput
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUpdateManyWithoutPlataformaNestedInput
  }

  export type plataformaUncheckedUpdateWithoutPlataforma_x_usuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    plataforma_papel_tipo_id?: IntFieldUpdateOperationsInput | number
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUncheckedUpdateManyWithoutPlataformaNestedInput
  }

  export type tituloCreateWithoutTitulo_itensInput = {
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
    titulo_tipo: titulo_tipoCreateNestedOneWithoutTituloInput
    bordero: borderoCreateNestedOneWithoutTituloInput
  }

  export type tituloUncheckedCreateWithoutTitulo_itensInput = {
    id?: number
    titulo_tipo_id: number
    bordero_id: number
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
  }

  export type tituloCreateOrConnectWithoutTitulo_itensInput = {
    where: tituloWhereUniqueInput
    create: XOR<tituloCreateWithoutTitulo_itensInput, tituloUncheckedCreateWithoutTitulo_itensInput>
  }

  export type tituloUpsertWithoutTitulo_itensInput = {
    update: XOR<tituloUpdateWithoutTitulo_itensInput, tituloUncheckedUpdateWithoutTitulo_itensInput>
    create: XOR<tituloCreateWithoutTitulo_itensInput, tituloUncheckedCreateWithoutTitulo_itensInput>
  }

  export type tituloUpdateWithoutTitulo_itensInput = {
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    titulo_tipo?: titulo_tipoUpdateOneRequiredWithoutTituloNestedInput
    bordero?: borderoUpdateOneRequiredWithoutTituloNestedInput
  }

  export type tituloUncheckedUpdateWithoutTitulo_itensInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo_tipo_id?: IntFieldUpdateOperationsInput | number
    bordero_id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usuario_perfil_tipoCreateWithoutUsuario_perfilInput = {
    nome: string
  }

  export type usuario_perfil_tipoUncheckedCreateWithoutUsuario_perfilInput = {
    id?: number
    nome: string
  }

  export type usuario_perfil_tipoCreateOrConnectWithoutUsuario_perfilInput = {
    where: usuario_perfil_tipoWhereUniqueInput
    create: XOR<usuario_perfil_tipoCreateWithoutUsuario_perfilInput, usuario_perfil_tipoUncheckedCreateWithoutUsuario_perfilInput>
  }

  export type usuario_perfil_tipoUpsertWithoutUsuario_perfilInput = {
    update: XOR<usuario_perfil_tipoUpdateWithoutUsuario_perfilInput, usuario_perfil_tipoUncheckedUpdateWithoutUsuario_perfilInput>
    create: XOR<usuario_perfil_tipoCreateWithoutUsuario_perfilInput, usuario_perfil_tipoUncheckedCreateWithoutUsuario_perfilInput>
  }

  export type usuario_perfil_tipoUpdateWithoutUsuario_perfilInput = {
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type usuario_perfil_tipoUncheckedUpdateWithoutUsuario_perfilInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type tituloCreateManyBorderoInput = {
    id?: number
    titulo_tipo_id: number
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
  }

  export type tituloUpdateWithoutBorderoInput = {
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    titulo_tipo?: titulo_tipoUpdateOneRequiredWithoutTituloNestedInput
    titulo_itens?: titulo_itensUpdateManyWithoutTituloNestedInput
  }

  export type tituloUncheckedUpdateWithoutBorderoInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo_tipo_id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    titulo_itens?: titulo_itensUncheckedUpdateManyWithoutTituloNestedInput
  }

  export type tituloUncheckedUpdateManyWithoutTituloInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo_tipo_id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type borderoCreateManyCarteiraInput = {
    id?: number
  }

  export type carteira_n_cedentesCreateManyCarteiraInput = {
    id?: number
    cedente_id: number
  }

  export type borderoUpdateWithoutCarteiraInput = {
    titulo?: tituloUpdateManyWithoutBorderoNestedInput
  }

  export type borderoUncheckedUpdateWithoutCarteiraInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: tituloUncheckedUpdateManyWithoutBorderoNestedInput
  }

  export type borderoUncheckedUpdateManyWithoutBorderoInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type carteira_n_cedentesUpdateWithoutCarteiraInput = {
    cedente?: cedenteUpdateOneRequiredWithoutCarteira_n_cedentesNestedInput
  }

  export type carteira_n_cedentesUncheckedUpdateWithoutCarteiraInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedente_id?: IntFieldUpdateOperationsInput | number
  }

  export type carteira_n_cedentesUncheckedUpdateManyWithoutCarteira_n_cedentesInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedente_id?: IntFieldUpdateOperationsInput | number
  }

  export type carteira_n_cedentesCreateManyCedenteInput = {
    id?: number
    carteira_id: number
  }

  export type cedente_analiseCreateManyCedente_cedenteTocedente_analiseInput = {
    id?: number
    status?: string | null
  }

  export type cedente_n_sacadosCreateManyCedente_cedenteTocedente_n_sacadosInput = {
    id?: number
    sacado?: number | null
  }

  export type carteira_n_cedentesUpdateWithoutCedenteInput = {
    carteira?: carteiraUpdateOneRequiredWithoutCarteira_n_cedentesNestedInput
  }

  export type carteira_n_cedentesUncheckedUpdateWithoutCedenteInput = {
    id?: IntFieldUpdateOperationsInput | number
    carteira_id?: IntFieldUpdateOperationsInput | number
  }

  export type cedente_analiseUpdateWithoutCedente_cedenteTocedente_analiseInput = {
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cedente_analiseUncheckedUpdateWithoutCedente_cedenteTocedente_analiseInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cedente_analiseUncheckedUpdateManyWithoutCedente_analiseInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cedente_n_sacadosUpdateWithoutCedente_cedenteTocedente_n_sacadosInput = {
    sacado_cedente_n_sacadosTosacado?: sacadoUpdateOneWithoutCedente_n_sacadosNestedInput
  }

  export type cedente_n_sacadosUncheckedUpdateWithoutCedente_cedenteTocedente_n_sacadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    sacado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cedente_n_sacadosUncheckedUpdateManyWithoutCedente_n_sacadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    sacado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type carteiraCreateManyFidic_fundoInput = {
    id?: number
  }

  export type fidic_fundo_x_usuarioCreateManyFidic_fundoInput = {
    id?: number
    usuario?: number | null
  }

  export type carteiraUpdateWithoutFidic_fundoInput = {
    bordero?: borderoUpdateManyWithoutCarteiraNestedInput
    carteira_n_cedentes?: carteira_n_cedentesUpdateManyWithoutCarteiraNestedInput
  }

  export type carteiraUncheckedUpdateWithoutFidic_fundoInput = {
    id?: IntFieldUpdateOperationsInput | number
    bordero?: borderoUncheckedUpdateManyWithoutCarteiraNestedInput
    carteira_n_cedentes?: carteira_n_cedentesUncheckedUpdateManyWithoutCarteiraNestedInput
  }

  export type carteiraUncheckedUpdateManyWithoutCarteiraInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type fidic_fundo_x_usuarioUpdateWithoutFidic_fundoInput = {
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type fidic_fundo_x_usuarioUncheckedUpdateWithoutFidic_fundoInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type fidic_fundo_x_usuarioUncheckedUpdateManyWithoutFidic_fundo_x_usuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type organograma_x_regiao_atuacaoCreateManyOrganogramaInput = {
    id?: number
    regiao_atuacao_id: number
  }

  export type organograma_x_usuarioCreateManyOrganogramaInput = {
    id?: number
    usuario_id: number
  }

  export type organograma_x_regiao_atuacaoUpdateWithoutOrganogramaInput = {
    regiao_atuacao?: regiao_atuacaoUpdateOneRequiredWithoutOrganograma_x_regiao_atuacaoNestedInput
  }

  export type organograma_x_regiao_atuacaoUncheckedUpdateWithoutOrganogramaInput = {
    id?: IntFieldUpdateOperationsInput | number
    regiao_atuacao_id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_x_regiao_atuacaoUncheckedUpdateManyWithoutOrganograma_x_regiao_atuacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    regiao_atuacao_id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_x_usuarioUpdateWithoutOrganogramaInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_x_usuarioUncheckedUpdateWithoutOrganogramaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type organograma_x_usuarioUncheckedUpdateManyWithoutOrganograma_x_usuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type organogramaCreateManyOrganograma_tipoInput = {
    id?: number
  }

  export type organogramaUpdateWithoutOrganograma_tipoInput = {
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUpdateManyWithoutOrganogramaNestedInput
    organograma_x_usuario?: organograma_x_usuarioUpdateManyWithoutOrganogramaNestedInput
  }

  export type organogramaUncheckedUpdateWithoutOrganograma_tipoInput = {
    id?: IntFieldUpdateOperationsInput | number
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUncheckedUpdateManyWithoutOrganogramaNestedInput
    organograma_x_usuario?: organograma_x_usuarioUncheckedUpdateManyWithoutOrganogramaNestedInput
  }

  export type organogramaUncheckedUpdateManyWithoutOrganogramaInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type usuarioCreateManyPessoaInput = {
    id?: number
    email: string
    senha: string
    status?: string | null
    primeiro_acesso?: boolean | null
    confirmou_cadastro?: boolean | null
    codigo_confirma_cadastro?: string | null
    codigo_reset_senha?: string | null
    codigo_data_expiracao?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type usuarioUpdateWithoutPessoaInput = {
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuarioUncheckedUpdateWithoutPessoaInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usuarioUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    primeiro_acesso?: NullableBoolFieldUpdateOperationsInput | boolean | null
    confirmou_cadastro?: NullableBoolFieldUpdateOperationsInput | boolean | null
    codigo_confirma_cadastro?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_reset_senha?: NullableStringFieldUpdateOperationsInput | string | null
    codigo_data_expiracao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type plataforma_x_regiao_atuacaoCreateManyPlataformaInput = {
    id?: number
    regiao_atuacao_id: number
  }

  export type plataforma_x_usuarioCreateManyPlataformaInput = {
    id?: number
    usuario_id: number
  }

  export type plataforma_x_regiao_atuacaoUpdateWithoutPlataformaInput = {
    regiao_atuacao?: regiao_atuacaoUpdateOneRequiredWithoutPlataforma_x_regiao_atuacaoNestedInput
  }

  export type plataforma_x_regiao_atuacaoUncheckedUpdateWithoutPlataformaInput = {
    id?: IntFieldUpdateOperationsInput | number
    regiao_atuacao_id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_x_regiao_atuacaoUncheckedUpdateManyWithoutPlataforma_x_regiao_atuacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    regiao_atuacao_id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_x_usuarioUpdateWithoutPlataformaInput = {
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_x_usuarioUncheckedUpdateWithoutPlataformaInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_x_usuarioUncheckedUpdateManyWithoutPlataforma_x_usuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type plataformaCreateManyPlataforma_papel_tipoInput = {
    id?: number
    nome?: string | null
  }

  export type plataformaUpdateWithoutPlataforma_papel_tipoInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUpdateManyWithoutPlataformaNestedInput
    plataforma_x_usuario?: plataforma_x_usuarioUpdateManyWithoutPlataformaNestedInput
  }

  export type plataformaUncheckedUpdateWithoutPlataforma_papel_tipoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUncheckedUpdateManyWithoutPlataformaNestedInput
    plataforma_x_usuario?: plataforma_x_usuarioUncheckedUpdateManyWithoutPlataformaNestedInput
  }

  export type plataformaUncheckedUpdateManyWithoutPlataformaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type organograma_x_regiao_atuacaoCreateManyRegiao_atuacaoInput = {
    id?: number
    organograma_id: number
  }

  export type plataforma_x_regiao_atuacaoCreateManyRegiao_atuacaoInput = {
    id?: number
    plataforma_id: number
  }

  export type organograma_x_regiao_atuacaoUpdateWithoutRegiao_atuacaoInput = {
    organograma?: organogramaUpdateOneRequiredWithoutOrganograma_x_regiao_atuacaoNestedInput
  }

  export type organograma_x_regiao_atuacaoUncheckedUpdateWithoutRegiao_atuacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    organograma_id?: IntFieldUpdateOperationsInput | number
  }

  export type plataforma_x_regiao_atuacaoUpdateWithoutRegiao_atuacaoInput = {
    plataforma?: plataformaUpdateOneRequiredWithoutPlataforma_x_regiao_atuacaoNestedInput
  }

  export type plataforma_x_regiao_atuacaoUncheckedUpdateWithoutRegiao_atuacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    plataforma_id?: IntFieldUpdateOperationsInput | number
  }

  export type regiao_atuacaoCreateManyRegiao_atuacao_tipoInput = {
    id?: number
    nome: string
  }

  export type regiao_atuacaoUpdateWithoutRegiao_atuacao_tipoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUpdateManyWithoutRegiao_atuacaoNestedInput
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUpdateManyWithoutRegiao_atuacaoNestedInput
  }

  export type regiao_atuacaoUncheckedUpdateWithoutRegiao_atuacao_tipoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    organograma_x_regiao_atuacao?: organograma_x_regiao_atuacaoUncheckedUpdateManyWithoutRegiao_atuacaoNestedInput
    plataforma_x_regiao_atuacao?: plataforma_x_regiao_atuacaoUncheckedUpdateManyWithoutRegiao_atuacaoNestedInput
  }

  export type regiao_atuacaoUncheckedUpdateManyWithoutRegiao_atuacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
  }

  export type cedente_n_sacadosCreateManySacado_cedente_n_sacadosTosacadoInput = {
    id?: number
    cedente?: number | null
  }

  export type cedente_n_sacadosUpdateWithoutSacado_cedente_n_sacadosTosacadoInput = {
    cedente_cedenteTocedente_n_sacados?: cedenteUpdateOneWithoutCedente_n_sacadosNestedInput
  }

  export type cedente_n_sacadosUncheckedUpdateWithoutSacado_cedente_n_sacadosTosacadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    cedente?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type titulo_itensCreateManyTituloInput = {
    id?: number
  }

  export type titulo_itensUpdateWithoutTituloInput = {

  }

  export type titulo_itensUncheckedUpdateWithoutTituloInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type titulo_itensUncheckedUpdateManyWithoutTitulo_itensInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type tituloCreateManyTitulo_tipoInput = {
    id?: number
    bordero_id: number
    nf?: string | null
    valor?: number | null
    vencimento?: Date | string | null
    numero?: string | null
    emissao?: Date | string | null
    parcela?: string | null
  }

  export type tituloUpdateWithoutTitulo_tipoInput = {
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    bordero?: borderoUpdateOneRequiredWithoutTituloNestedInput
    titulo_itens?: titulo_itensUpdateManyWithoutTituloNestedInput
  }

  export type tituloUncheckedUpdateWithoutTitulo_tipoInput = {
    id?: IntFieldUpdateOperationsInput | number
    bordero_id?: IntFieldUpdateOperationsInput | number
    nf?: NullableStringFieldUpdateOperationsInput | string | null
    valor?: NullableFloatFieldUpdateOperationsInput | number | null
    vencimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    numero?: NullableStringFieldUpdateOperationsInput | string | null
    emissao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parcela?: NullableStringFieldUpdateOperationsInput | string | null
    titulo_itens?: titulo_itensUncheckedUpdateManyWithoutTituloNestedInput
  }

  export type usuario_perfilCreateManyUsuario_perfil_tipoInput = {
    id?: number
    senha: string
    usuario_id: number
  }

  export type usuario_perfilUpdateWithoutUsuario_perfil_tipoInput = {
    senha?: StringFieldUpdateOperationsInput | string
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type usuario_perfilUncheckedUpdateWithoutUsuario_perfil_tipoInput = {
    id?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    usuario_id?: IntFieldUpdateOperationsInput | number
  }

  export type usuario_perfilUncheckedUpdateManyWithoutUsuario_perfilInput = {
    id?: IntFieldUpdateOperationsInput | number
    senha?: StringFieldUpdateOperationsInput | string
    usuario_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}